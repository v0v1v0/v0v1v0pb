<div class="container">

<table style="width: 100%;"><tr>
<td>fitSurface</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit response surface model and compute meanR and maxR statistics</h2>

<h3>Description</h3>

<p>This function computes predictions for off-axis dose combinations according
to the BIGL or HSA null model and, if required, computes appropriate meanR
and maxR statistics. Function requires as input dose-response dataframe and
output of <code>fitMarginals</code> containing estimates for the monotherapy
model. If transformation functions were used in monotherapy estimation, these
should also be provided.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fitSurface(
  data,
  fitResult,
  transforms = fitResult$transforms,
  null_model = c("loewe", "hsa", "bliss", "loewe2"),
  effect = "effect",
  d1 = "d1",
  d2 = "d2",
  statistic = c("none", "meanR", "maxR", "both"),
  CP = NULL,
  B.CP = 50,
  B.B = NULL,
  nested_bootstrap = FALSE,
  error = 4,
  sampling_errors = NULL,
  wild_bootstrap = FALSE,
  wild_bootType = "normal",
  control = "FWER",
  cutoff = 0.95,
  parallel = FALSE,
  progressBar = TRUE,
  method = c("equal", "model", "unequal"),
  confInt = TRUE,
  digits = 9,
  bootRS = TRUE,
  trans = "identity",
  rescaleResids = FALSE,
  invtrans = switch(trans, identity = "identity", log = "exp"),
  newtonRaphson = FALSE,
  asymptotes = 2,
  bootmethod = method
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Dose-response dataframe.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitResult</code></td>
<td>
<p>Monotherapy (on-axis) model fit, e.g. produced by
<code>fitMarginals</code>. It has to be a <code>"MarginalFit"</code> object or a
list containing <code>df</code>, <code>sigma</code>, <code>coef</code>,
<code>shared_asymptote</code> and <code>method</code> elements for, respectively,
marginal model degrees of freedom, residual standard deviation, named
vector of coefficient estimates, logical value of whether shared asymptote
is imposed and method for estimating marginal models during bootstrapping
(see <code>fitMarginals</code>). If biological and power transformations
were used in marginal model estimation, <code>fitResult</code> should contain
<code>transforms</code> elements with these transformations. Alternatively, these
can also be specified via <code>transforms</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transforms</code></td>
<td>
<p>Transformation functions. If non-null, <code>transforms</code> is
a list containing 5 elements, namely biological and power transformations
along with their inverse functions and <code>compositeArgs</code> which is a list
with argument values shared across the 4 functions. See vignette for more
information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>null_model</code></td>
<td>
<p>Specified null model for the expected response surface.
Currently, allowed options are <code>"loewe"</code> for generalized Loewe model,
<code>"hsa"</code> for Highest Single Agent model, <code>"bliss"</code> for Bliss additivity,
and <code>"loewe2"</code> for the alternative Loewe generalization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>effect</code></td>
<td>
<p>Name of the response column in the data ("effect")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d1</code></td>
<td>
<p>Name of the column with doses of the first compound ("d1")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d2</code></td>
<td>
<p>Name of the column with doses of the second compound ("d2")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>statistic</code></td>
<td>
<p>Which statistics should be computed. This argument can take
one of the values from <code>c("none", "meanR", "maxR", "both")</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CP</code></td>
<td>
<p>Prediction covariance matrix. If not specified, it will be estimated
by bootstrap using <code>B.CP</code> iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B.CP</code></td>
<td>
<p>Number of bootstrap iterations to use for CP matrix estimation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B.B</code></td>
<td>
<p>Number of iterations to use in bootstrapping null distribution for
either meanR or maxR statistics.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nested_bootstrap</code></td>
<td>
<p>When statistics are calculated, if
<code>nested_bootstrap = TRUE</code>, <code>CP</code> matrix is recalculated at each
bootstrap iteration of <code>B.B</code> using <code>B.CP</code> iterations. Using such
nested bootstrap may however significantly increase computational time. If
<code>nested_bootstrap = FALSE</code>, <code>CP</code> bootstrapped data reuses
<code>CP</code> matrix calculated from the original data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>error</code></td>
<td>
<p>Type of error for resampling in the bootstrapping procedure.
This argument will be passed to <code>generateData</code>. If <code>error
= 4</code> (default), the error terms for generating distribution of the null
will be resampled from the vector specified in <code>sampling_errors</code>. If
<code>error = 1</code>, normal errors are added. If <code>error = 2</code>, errors are
sampled from a mixture of two normal distributions. If <code>error = 3</code>,
errors are generated from a rescaled chi-square distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sampling_errors</code></td>
<td>
<p>Sampling vector to resample errors from. Used only if
<code>error</code> is 4 and is passed as argument to <code>generateData</code>.
If <code>sampling_errors = NULL</code> (default), mean residuals at off-axis
points between observed and predicted response are taken.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wild_bootstrap</code></td>
<td>
<p>Whether special bootstrap to correct for
heteroskedasticity should be used. If <code>wild_bootstrap = TRUE</code>, errors
are generated from <code>sampling_errors</code> multiplied by a random variable
following Rademacher distribution. Argument is used only if <code>error = 4</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wild_bootType</code></td>
<td>
<p>Type of distribution to be used for wild bootstrap. If <code>wild_bootstrap = TRUE</code>, 
errors are generated from "rademacher", "gamma", "normal" or "two-point" distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>If <code>control = "FCR"</code> then algorithm controls false coverage rate, if <code>control = "dFCR"</code> then 
algorithm controls directional false coverage rate, if <code>control = "FWER"</code> then 
algorithm controls family wise error rate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff</code></td>
<td>
<p>Cut-off to use in maxR procedure for declaring non-additivity
(default is 0.95).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>Whether parallel computing should be used for bootstrap. This
parameter can take either integer value to specify the number of threads to
be used or logical <code>TRUE/FALSE</code>. If <code>parallel = TRUE</code>, then
<code>max(1, detectCores()-1)</code> is set to be the number of threads. If
<code>parallel = FALSE</code>, then a single thread is used and cluster object
is not created.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progressBar</code></td>
<td>
<p>A boolean, should progress of bootstraps be shown?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>What assumption should be used for the variance of on- and 
off-axis points. This argument can take one of the values from 
<code>c("equal", "model", "unequal")</code>. With the value <code>"equal"</code> as the
default. <code>"equal"</code> assumes that both on- and off-axis points have the 
same variance, <code>"unequal"</code> estimates a different parameter for on- and 
off-axis points and <code>"model"</code> predicts variance based on the average 
effect of an off-axis point. If no transformations are used the 
<code>"model"</code> method is recommended. If transformations are used, only the
<code>"equal"</code> method can be chosen.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>confInt</code></td>
<td>
<p>a boolean, should confidence intervals be returned?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>Numeric value indicating the number of digits used for numeric values in confidence intervals</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bootRS</code></td>
<td>
<p>a boolean, should bootstrapped response surfaces be used in the
calculation of the confidence intervals?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trans, invtrans</code></td>
<td>
<p>the transformation function for the variance and its
inverse, possibly as strings</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rescaleResids</code></td>
<td>
<p>a boolean indicating whether to rescale residuals,
or else normality of the residuals is assumed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newtonRaphson</code></td>
<td>
<p>A boolean, should Newton-Raphson be used to find Loewe
response surfaces? May be faster but also less stable to switch on</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>asymptotes</code></td>
<td>
<p>Number of asymptotes. It can be either <code>1</code>
as in standard Loewe model or <code>2</code> as in generalized Loewe model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bootmethod</code></td>
<td>
<p>The resampling method to be used in the bootstraps. Defaults to the same as method</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Please see the example vignette <code>vignette("analysis", package = "BIGL")</code>
and the report "Lack of fit test for detecting synergy" included in the
<code>papers</code> folder for further details on the test statistics used:
<code>system.file("papers", "newStatistics.pdf", package = "BIGL")</code>
</p>


<h3>Value</h3>

<p>This function returns a <code>ResponseSurface</code> object with estimates
of the predicted surface. <code>ResponseSurface</code> object is essentially a
list with appropriately named elements.
</p>
<p>Elements of the list include input data, monotherapy model coefficients and
transformation functions, null model used to construct the surface as well
as estimated CP matrix, occupancy level at
each dose combination according to the generalized Loewe model and
<code>"offAxisTable"</code> element which contains observed and predicted effects
as well as estimated z-scores for each dose combination.
</p>
<p>If statistical testing was done, returned object contains <code>"meanR"</code>
and <code>"maxR"</code> elements with output from <code>meanR</code> and
<code>maxR</code> respectively.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
  data &lt;- subset(directAntivirals, experiment == 4)
  ## Data should contain d1, d2 and effect columns
  transforms &lt;- list("PowerT" = function(x, args) with(args, log(x)),
                     "InvPowerT" = function(y, args) with(args, exp(y)),
                     "BiolT" = function(x, args) with(args, N0 * exp(x * time.hours)),
                     "InvBiolT" = function(y, args) with(args, 1/time.hours * log(y/N0)),
                     "compositeArgs" = list(N0 = 1, time.hours = 72))
  fitResult &lt;- fitMarginals(data, transforms)
  surf &lt;- fitSurface(data, fitResult, statistic = "meanR")
  summary(surf)

## End(Not run)
</code></pre>


</div>