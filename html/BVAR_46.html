<div class="container">

<table style="width: 100%;"><tr>
<td>par_bvar</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Parallel hierarchical Bayesian vector autoregression</h2>

<h3>Description</h3>

<p>Wrapper for <code>bvar</code> to simplify parallel computation via
<code>parLapply</code>. Make sure to properly start and stop the
provided cluster.
</p>


<h3>Usage</h3>

<pre><code class="language-R">par_bvar(
  cl,
  n_runs = length(cl),
  data,
  lags,
  n_draw = 10000L,
  n_burn = 5000L,
  n_thin = 1L,
  priors = bv_priors(),
  mh = bv_mh(),
  fcast = NULL,
  irf = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>A <code>cluster</code> object obtained from
<code>makeCluster</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_runs</code></td>
<td>
<p>The number of parallel runs to calculate. Defaults to the
length of <em>cl</em>, i.e. the number of registered nodes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Numeric matrix or dataframe. Note that observations are expected
to be ordered from earliest to latest, and variables in the columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lags</code></td>
<td>
<p>Integer scalar. Lag order of the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_draw, n_burn</code></td>
<td>
<p>Integer scalar. The number of iterations to (a) cycle
through and (b) burn at the start.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_thin</code></td>
<td>
<p>Integer scalar. Every <em>n_thin</em>'th iteration is stored.
For a given memory requirement thinning reduces autocorrelation, while
increasing effective sample size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priors</code></td>
<td>
<p>Object from <code>bv_priors</code> with prior settings.
Used to adjust the Minnesota prior, add custom dummy priors, and choose
hyperparameters for hierarchical estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mh</code></td>
<td>
<p>Object from <code>bv_mh</code> with settings for the
Metropolis-Hastings step. Used to tune automatic adjustment of the
acceptance rate within the burn-in period, or manually adjust the proposal
variance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fcast</code></td>
<td>
<p>Object from <code>bv_fcast</code> with forecast settings.
Options include the horizon and settings for conditional forecasts i.e.
scenario analysis.
May also be calculated ex-post using <code>predict.bvar</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>irf</code></td>
<td>
<p>Object from <code>bv_irf</code> with settings for the calculation
of impulse responses and forecast error variance decompositions. Options
include the horizon and different identification schemes.
May also be calculated ex-post using <code>irf.bvar</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns a list of class <code>bvar_chain</code> with <code>bvar</code> objects.
</p>


<h3>See Also</h3>

<p><code>bvar</code>; <code>parLapply</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library("parallel")

cl &lt;- makeCluster(2L)

# Access a subset of the fred_qd dataset
data &lt;- fred_qd[, c("CPIAUCSL", "UNRATE", "FEDFUNDS")]
# Transform it to be stationary
data &lt;- fred_transform(data, codes = c(5, 5, 1), lag = 4)

# A singular run using one lag, default settings and very few draws
x &lt;- bvar(data, lags = 1, n_draw = 1000L, n_burn = 200L, verbose = FALSE)

# Two parallel runs
y &lt;- par_bvar(cl, n_runs = 2,
  data = data, lags = 1, n_draw = 1000L, n_burn = 200L)

stopCluster(cl)

# Plot lambda for all of the runs
## Not run: 
plot(x, type = "full", vars = "lambda", chains = y)

# Convert the hyperparameter lambda to a coda mcmc.list object
coda::as.mcmc(y, vars = "lambda")

## End(Not run)
</code></pre>


</div>