<div class="container">

<table style="width: 100%;"><tr>
<td>cable.ar.p.iter</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Bent-Cable Regression for Independent or AR Data, With Exception  </h2>

<h3>Description</h3>

<p>This function is the main engine for <code>bentcable.ar</code>. It performs
bent-cable (including broken-stick) regression to AR(p) time-series data
or independent data (time-series or otherwise). However, it 
<b>cannot fit broken sticks to independent data</b> (see
<code>stick.ar.0</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">cable.ar.p.iter(init, y.vect, t.vect = NULL, n = NA, tol,
	method0 = "css", method1 = "yw", stick = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p> A numeric vector of initial values, in the form of
<code>c(b0,b1,b2,tau,gamma,phi.1,...,phi.p)</code> when <code>stick=FALSE</code>, and
<code>c(b0,b1,b2,tau,phi.1,...,phi.p)</code> when <code>stick=TRUE</code>.
<code>phi</code> values correspond to AR(p) coefficients - if not included,
then independent data are assumed. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y.vect</code></td>
<td>
<p> A numeric vector of response data. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t.vect</code></td>
<td>
<p> A numeric vector of design points, which <b>MUST</b> be
equidistant with unit increments if AR(p) is assumed. They need not be
equidistant for independent data. Specifying <code>t.vect=NULL</code> is
equivalent to specifying the default time points <code>c(0,1,2,...)</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p> Length of response vector (optional). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p> Tolerance for determining convergence. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method0, method1</code></td>
<td>
<p> The fitting method when p&gt;0. <code>"css"</code> stands for
<em>conditional sum-of-squares</em> and corresponds to conditional maximum
likelihood. <code>"yw"</code> stands for <em>Yule-Walker</em>, and <code>"mle"</code>
for (full) <em>maximum likelihood estimation</em>. If <code>method0</code> fails
to converge, then <code>method1</code> is attempted. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stick</code></td>
<td>
<p> A logical value; if <code>TRUE</code>, a broken-stick regression is performed. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <em>bent cable</em> has the form
<code class="reqn">f(t) = b_0 + b_1 t + b_2 q(t)</code>, where <code class="reqn">q(t)</code> is
the <em>basic bent cable</em> 
</p>
<p style="text-align: center;"><code class="reqn">q(t)=\frac{(t-\tau+\gamma)^2}{4\gamma} I\{|t-\tau|\le\gamma\}
	+ (t-\tau) I\{t&gt;\tau+\gamma\}</code>
</p>

<p>for <code class="reqn">\gamma\ge 0</code>.
</p>
<p>For independent data (time series or otherwise), bent-cable
regression by maximum likelihood is performed via nonlinear
least-squares estimation of
<code class="reqn">\theta=(b_0,b_1,b_2,\tau,\gamma)</code> through the built-in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>
function <code>nls</code>. For AR(p) data, conditional maximum
likelihood (CML) estimation of <code class="reqn">(\theta,\phi)</code>
(conditioned on the first p data points) is performed through
the built-in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function <code>optim</code> with the <code>"BFGS"</code>
algorithm, where <code class="reqn">\phi=(\phi_1,\ldots,\phi_p)</code> are the AR
coefficients. In either case, the estimation relies on the
user-supplied initial values in <code>init</code>. A Gaussian model
is assumed, so that CML estimation is equivalent to minimizing
the conditional sum-of-squares error, specified as
<code>"css"</code> by default for <code>method0</code>. However,
<code>"css"</code> sometimes fails to converge, or the resulting
<code class="reqn">\phi</code> estimate sometimes corresponds to non-stationarity.
In this case, the alternative estimation approach specified
for <code>method1</code> is attempted. <code>"mle"</code> specifies the
<em>CML-ML hybrid</em> algorithm, and <code>"yw"</code> the
<em>CML-ML-MM hybrid</em> algorithm (<em>MM</em> stands for
<em>method of moments</em>; see <b>References</b>.) Both
<code>"yw"</code> and <code>"mle"</code> guarantee stationarity, but often
take much longer than <code>"css"</code> to converge.
</p>
<p>The bent-cable likelihood / deviance often has multiple peaks. Thus, the
user should be aware of different local maxima on which the optimization
algorithm can converge despite initial values for <code class="reqn">\theta</code> that
are very similar. The user is advised to combine several exploratory
analyses as well as model diagnoses before settling on a
<em>best</em> fit. See <b>Details</b> on the
<code>bentcable.ar</code> help page for a detailed description.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p> An <code>nls</code> object, returned if independent data are assumed. It is 
the maximum likelihood bent-cable fit. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimate</code></td>
<td>
<p> A numeric vector, returned if AR(p&gt;0) is assumed. It is the
estimated value of (<code class="reqn">\theta,\phi</code>). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ar.p.fit</code></td>
<td>
<p> Returned if AR(p&gt;0) is assumed. If <code>"css"</code> is used,
converges, and yields a <code class="reqn">\phi</code> estimate that corresponds to
stationarity, then <code>$ar.p.fit</code> is an <code>optim</code> object containing
the CML fit. If <code>"yw"</code> or <code>"mle"</code> is used and converges, then
<code>$ar.p.fit</code> is an <code>ar</code> object containing the CML-ML(-MM) fit. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y, t, n, p, stick</code></td>
<td>
<p> As supplied by the user; always returned. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p> A character string, returned if AR(p&gt;0) is assumed. It indicates
the method that yielded the returned fit. </p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>This function is intended for internal use by <code>bentcable.ar</code>.
</p>
<p>For several fits that assume a common p, their (conditional) likelihood
values should be compared to screen out those that result from local
maxima. Equivalently, the (conditional) sum-of-squares error (SSE) can
be compared and only the smallest kept. See <b>Examples</b> below.
Also see <b>Details</b> on the <code>bentcable.ar</code> help
page.
</p>


<h3>Author(s)</h3>

<p> Grace Chiu </p>


<h3>References</h3>

<p> See the <code>bentcableAR</code> package references. </p>


<h3>See Also</h3>

 <p><code>stick.ar.0</code>, <code>fullcable.t</code>, 
<code>bentcable.dev.plot</code>,
<code>nls</code>, <code>optim</code>,
<code>ar</code>. </p>


<h3>Examples</h3>

<pre><code class="language-R">data(stagnant)
data(sockeye)

# 'stagnant': independent data cable fit
fit0 &lt;- cable.ar.p.iter( c(.6,-.4,-.7,0,.5),
	stagnant$loght, stagnant$logflow )    # 'nls' fit
	# compare to this:
	# bentcable.ar( stagnant$loght, t.vect=stagnant$logflow,
	#	init.cable=c(.6,-.4,-.7,0,.5) )

fit0$fit   # 'fit0' SSE=0.005


# 'sockeye': AR(2) cable fit
fit1 &lt;- cable.ar.p.iter( c(13,.1,-.5,11,4,.5,-.5),
	sockeye$logReturns, tol=1e-4 )    # "css" successful
	# compare to this:
	# fit1 &lt;- bentcable.ar( sockeye$logReturns, 
	#	init.cable=c(13,.1,-.5,11,4), p=2 )

fit1$ar.p.fit$value     # 'fit1' SSE=4.9


# 'sockeye': AR(2) cable fit
fit2 &lt;- cable.ar.p.iter( c(10,0,0,5,.1,.5,-.5), sockeye$logReturns, 
	tol=1e-4 )    # "css" unsuccessful, switched to "yw"
	# compare to this:
	# fit2 &lt;- bentcable.ar(sockeye$logReturns, 
	#	init.cable=c(10,0,0,5,.1), p=2 )

cable.ar.p.iter( fit2$est, sockeye$logReturns, 
	tol=1e-4 )   # 'fit2' SSE=13.8 (from first line of screen output)


# 'sockeye': AR(4) stick fit
cable.ar.p.iter( c(13,.1,-.5,11,.5,-.5,.5,-.5),
	sockeye$logReturns, tol=1e-4, stick=TRUE )
	# compare to this:
	# bentcable.ar( sockeye$logReturns,
	#	init.cable=c(13,.1,-.5,11), p=4, stick=TRUE )
</code></pre>


</div>