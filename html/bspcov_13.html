<div class="container">

<table style="width: 100%;"><tr>
<td>thresPPP</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bayesian Estimation of a Sparse Covariance Matrix</h2>

<h3>Description</h3>

<p>Provides a post-processed posterior (PPP) for Bayesian inference of a sparse covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class="language-R">thresPPP(X, eps, thres = list(), prior = list(), nsample = 2000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>a n <code class="reqn">\times</code> p data matrix with column mean zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>a small positive number decreasing to <code class="reqn">0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thres</code></td>
<td>
<p>a list giving the information for thresholding PPP procedure.
The list includes the following parameters (with default values in parentheses):
<code>value (0.1)</code> giving the positive real number for the thresholding PPP procedure,
<code>fun ('hard')</code> giving the thresholding function ('hard' or 'soft') for the thresholding PPP procedure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>
<p>a list giving the prior information.
The list includes the following parameters (with default values in parentheses):
<code>A (I)</code> giving the positive definite scale matrix for the inverse-Wishart prior,
<code>nu (p + 1)</code> giving the degree of freedom of the inverse-Wishar prior.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsample</code></td>
<td>
<p>a scalar value giving the number of the post-processed posterior samples.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Lee and Lee (2023) proposed a two-step procedure generating samples from the post-processed posterior for Bayesian inference of a sparse covariance matrix:
</p>

<ul>
<li>
<p> Initial posterior computing step: Generate random samples from the following initial posterior obtained by using the inverse-Wishart prior <code class="reqn">IW_p(B_0, \nu_0)</code>
</p>
<p style="text-align: center;"><code class="reqn">
 \Sigma \mid X_1, \ldots, X_n \sim IW_p(B_0 + nS_n, \nu_0 + n),
 </code>
</p>

<p>where <code class="reqn">S_n = n^{-1}\sum_{i=1}^{n}X_iX_i^\top</code>.
</p>
</li>
<li>
<p> Post-processing step: Post-process the samples generated from the initial samples
</p>
<p style="text-align: center;"><code class="reqn">
 \Sigma_{(i)} := \left\{\begin{array}{ll}H_{\gamma_n}(\Sigma^{(i)}) + \left[\epsilon_n - \lambda_{\min}\{H_{\gamma_n}(\Sigma^{(i)})\}\right]I_p, &amp;
 \mbox{ if } \lambda_{\min}\{H_{\gamma_n}(\Sigma^{(i)})\} &lt; \epsilon_n, \\
 H_{\gamma_n}(\Sigma^{(i)}), &amp; \mbox{ otherwise },
 \end{array}\right.
 </code>
</p>

</li>
</ul>
<p>where <code class="reqn">\Sigma^{(1)}, \ldots, \Sigma^{(N)}</code> are the initial posterior samples,
<code class="reqn">\epsilon_n</code> is a positive real number, and <code class="reqn">H_{\gamma_n}(\Sigma)</code> denotes the generalized threshodling operator given as
</p>
<p style="text-align: center;"><code class="reqn">
(H_{\gamma_n}(\Sigma))_{ij} = \left\{\begin{array}{ll}\sigma_{ij}, &amp; \mbox{ if } i = j, \\
h_{\gamma_n}(\sigma_{ij}), &amp; \mbox{ if } i \neq j, \end{array}\right.
</code>
</p>

<p>where <code class="reqn">\sigma_{ij}</code> is the <code class="reqn">(i,j)</code> element of <code class="reqn">\Sigma</code> and <code class="reqn">h_{\gamma_n}(\cdot)</code> is a generalized thresholding function.
</p>
<p>For more details, see Lee and Lee (2023).
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Sigma</code></td>
<td>
<p>a nsample <code class="reqn">\times</code> p(p+1)/2 matrix including lower triangular elements of covariance matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>dimension of covariance matrix.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Kwangmin Lee
</p>


<h3>References</h3>

<p>Lee, K. and Lee, J. (2023), "Post-processes posteriors for sparse covariances", <em>Journal of Econometrics</em>.
</p>


<h3>See Also</h3>

<p>cv.thresPPP
</p>


<h3>Examples</h3>

<pre><code class="language-R">
n &lt;- 25
p &lt;- 50
Sigma0 &lt;- diag(1, p)
X &lt;- MASS::mvrnorm(n = n, mu = rep(0, p), Sigma = Sigma0)
res &lt;- bspcov::thresPPP(X, eps=0.01, thres=list(value=0.5,fun='hard'), nsample=100)
est &lt;- bspcov::estimate(res)

</code></pre>


</div>