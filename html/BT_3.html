<div class="container">

<table style="width: 100%;"><tr>
<td>BT</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>(Adaptive) Boosting Trees (ABT/BT) Algorithm.</h2>

<h3>Description</h3>

<p>Performs the (Adaptive) Boosting Trees algorithm. This code prepares the inputs and calls the function <code>BT_call</code>.
Each tree in the process is built thanks to the <code>rpart</code> function.
In case of cross-validation, this function prepares the folds and performs multiple calls to the fitting function <code>BT_call</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">BT(
  formula = formula(data),
  data = list(),
  tweedie.power = 1,
  ABT = TRUE,
  n.iter = 100,
  train.fraction = 1,
  interaction.depth = 4,
  shrinkage = 1,
  bag.fraction = 1,
  colsample.bytree = NULL,
  keep.data = TRUE,
  is.verbose = FALSE,
  cv.folds = 1,
  folds.id = NULL,
  n.cores = 1,
  tree.control = rpart.control(xval = 0, maxdepth = (if (!is.null(interaction.depth)) {
 
       interaction.depth
 } else {
     10
 }), cp = -Inf, minsplit = 2),
  weights = NULL,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a symbolic description of the model to be fit. Note that the offset isn't supported in this algorithm.
Instead, everything is performed with a log-link function and a direct relationship exist between response, offset and weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame containing the variables in the model. By default the variables are taken from <code>environment(formula)</code>, typically the environment from which
<code>BT</code> is called. If <code>keep.data=TRUE</code> in the initial call to <code>BT</code> then <code>BT</code> stores a copy with the object (up to the variables used).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tweedie.power</code></td>
<td>
<p>Experimental parameter currently not used - Set to 1 referring to Poisson distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ABT</code></td>
<td>
<p>a boolean parameter. If <code>ABT=TRUE</code> an adaptive boosting tree algorithm is built whereas if <code>ABT=FALSE</code> an usual boosting tree algorithm is run.
By default, it is set to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.iter</code></td>
<td>
<p>the total number of iterations to fit. This is equivalent to the number of trees and the number of basis functions in the additive expansion.
Please note that the initialization is not taken into account in the <code>n.iter</code>. More explicitly, a weighted average initializes the algorithm and then <code>n.iter</code> trees
are built. Moreover, note that the <code>bag.fraction</code>, <code>colsample.bytree</code>, ... are not used for this initializing phase.
By default, it is set to 100.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>train.fraction</code></td>
<td>
<p>the first <code>train.fraction * nrows(data)</code> observations are used to fit the <code>BT</code> and the remainder are used for
computing out-of-sample estimates (also known as validation error) of the loss function. By default, it is set to 1 meaning no out-of-sample estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interaction.depth</code></td>
<td>
<p>the maximum depth of variable interactions: 1 builds an additive model, 2 builds a model with up to two-way interactions, etc.
This parameter can also be interpreted as the maximum number of non-terminal nodes. By default, it is set to 4.
Please note that if this parameter is <code>NULL</code>, all the trees in the expansion are built based on the <code>tree.control</code> parameter only, independently
of the <code>ABT</code> value.
This option is devoted to advanced users only and allows them to benefit from the full flexibility of the implemented algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shrinkage</code></td>
<td>
<p>a shrinkage parameter (in the interval (0,1]) applied to each tree in the expansion. Also known as the learning rate or step-size reduction. By default, it is set to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bag.fraction</code></td>
<td>
<p>the fraction of independent training observations randomly selected to propose the next tree in the expansion.
This introduces randomness into the model fit. If <code>bag.fraction</code>&lt;1 then running the same model twice will result in similar but different fits.
Please note that if this parameter is used the <code>BTErrors$training.error</code> corresponds to the normalized in-bag error and the out-of-bag improvements
are computed and stored in <code>BTErrors$oob.improvement</code>. See <code>BTFit</code> for more details.
By default, it is set to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colsample.bytree</code></td>
<td>
<p>each tree will be trained on a random subset of <code>colsample.bytree</code> number of features. Each tree will consider a new
random subset of features from the formula, adding variability to the algorithm and reducing computation time. <code>colsample.bytree</code> will be bounded between
1 and the number of features considered in the formula. By default, it is set to <code>NULL</code> meaning no effect.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.data</code></td>
<td>
<p>a boolean variable indicating whether to keep the data frames. This is particularly useful if one wants to keep track of the initial data frames
and is further used for predicting in case any data frame is specified.
Note that in case of cross-validation, if <code>keep.data=TRUE</code> the initial data frames are saved whereas the cross-validation samples are not.
By default, it is set to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is.verbose</code></td>
<td>
<p>if <code>is.verbose=TRUE</code>, the <code>BT</code> will print out the algorithm progress. By default, it is set to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv.folds</code></td>
<td>
<p>a positive integer representing the number of cross-validation folds to perform. If <code>cv.folds</code>&gt;1 then <code>BT</code>, in addition to the usual fit,
will perform a cross-validation and calculate an estimate of generalization error returned in <code>BTErrors$cv.error</code>. By default, it is set to 1 meaning no cross-validation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>folds.id</code></td>
<td>
<p>an optional vector of values identifying what fold each observation is in. If supplied, this parameter prevails over <code>cv.folds</code>.
By default, <code>folds.id = NULL</code> meaning that no folds are defined.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.cores</code></td>
<td>
<p>the number of cores to use for parallelization. This parameter is used during the cross-validation.
This parameter is bounded between 1 and the maximum number of available cores.
By default, it is set to 1 leading to a sequential approach.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tree.control</code></td>
<td>
<p>for advanced user only. It allows to define additional tree parameters that will be used at each iteration.
See <code>rpart.control</code> for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>optional vector of weights used in the fitting process. These weights must be positive but do not need to be normalized.
By default, it is set to <code>NULL</code> which corresponds to an uniform weight of 1 for each observation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>optional number used as seed. Please note that if <code>cv.folds</code>&gt;1, the <code>parLapply</code> function is called.
Therefore, the seed (if defined) used inside each fold will be a multiple of the <code>seed</code> parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>not currently used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The NA values are currently dropped using <code>na.omit</code>.
</p>


<h3>Value</h3>

<p>a <code>BTFit</code> object.
</p>


<h3>Author(s)</h3>

<p>Gireg Willame <a href="mailto:gireg.willame@gmail.com">gireg.willame@gmail.com</a>
</p>
<p><em>This package is inspired by the <code>gbm3</code> package. For more details, see <a href="https://github.com/gbm-developers/gbm3/">https://github.com/gbm-developers/gbm3/</a></em>.
</p>


<h3>References</h3>

<p>M. Denuit, D. Hainaut and J. Trufin (2019). <strong>Effective Statistical Learning Methods for Actuaries |: GLMs and Extensions</strong>, <em>Springer Actuarial</em>.
</p>
<p>M. Denuit, D. Hainaut and J. Trufin (2019). <strong>Effective Statistical Learning Methods for Actuaries ||: Tree-Based Methods and Extensions</strong>, <em>Springer Actuarial</em>.
</p>
<p>M. Denuit, D. Hainaut and J. Trufin (2019). <strong>Effective Statistical Learning Methods for Actuaries |||: Neural Networks and Extensions</strong>, <em>Springer Actuarial</em>.
</p>
<p>M. Denuit, D. Hainaut and J. Trufin (2022). <strong>Response versus gradient boosting trees, GLMs and neural networks under Tweedie loss and log-link</strong>.
Accepted for publication in <em>Scandinavian Actuarial Journal</em>.
</p>
<p>M. Denuit, J. Huyghe and J. Trufin (2022). <strong>Boosting cost-complexity pruned trees on Tweedie responses: The ABT machine for insurance ratemaking</strong>.
Paper submitted for publication.
</p>
<p>M. Denuit, J. Trufin and T. Verdebout (2022). <strong>Boosting on the responses with Tweedie loss functions</strong>. Paper submitted for publication.
</p>


<h3>See Also</h3>

<p><code>BTFit</code>, <code>BTCVFit</code>, <code>BT_call</code>, <code>BT_perf</code>, <code>predict.BTFit</code>,
<code>summary.BTFit</code>, <code>print.BTFit</code>, <code>.BT_cv_errors</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Load dataset.
dataset &lt;- BT::BT_Simulated_Data

## Fit a Boosting Tree model.
BT_algo &lt;- BT(formula = Y_normalized ~ Age + Sport + Split + Gender, # formula
              data = dataset, # data
              ABT = FALSE, # Classical Boosting Tree
              n.iter = 200,
              train.fraction = 0.8,
              interaction.depth = 3,
              shrinkage = 0.01,
              bag.fraction = 0.5,
              colsample.bytree = 2, # 2 explanatory variable used at each iteration.
              keep.data = FALSE, # Do not keep a data copy.
              is.verbose = FALSE, # Do not print progress.
              cv.folds = 3, # 3-cv will be performed.
              folds.id = NULL ,
              n.cores = 1,
              weights = ExpoR, # &lt;=&gt; Poisson model on response Y with ExpoR in offset.
              seed = NULL)

## Determine the model performance and plot results.
best_iter_val &lt;- BT_perf(BT_algo, method='validation')
best_iter_oob &lt;- BT_perf(BT_algo, method='OOB', oobag.curve = TRUE)
best_iter_cv &lt;- BT_perf(BT_algo, method ='cv', oobag.curve = TRUE)

best_iter &lt;- best_iter_val

## Variable influence and plot results.
# Based on the first iteration.
variable_influence1 &lt;- summary(BT_algo, n.iter = 1)
# Using all iterations up to best_iter.
variable_influence_best_iter &lt;- summary(BT_algo, n.iter = best_iter)

##  Print results : call, best_iters and summarized relative influence.
print(BT_algo)

## Model predictions.
# Predict on the link scale, using only the best_iter tree.
pred_single_iter &lt;- predict(BT_algo, newdata = dataset,
                            n.iter = best_iter, type = 'link', single.iter = TRUE)
# Predict on the response scale, using the first best_iter.
pred_best_iter &lt;- predict(BT_algo, newdata = dataset,
                          n.iter = best_iter, type = 'response')


</code></pre>


</div>