<div class="container">

<table style="width: 100%;"><tr>
<td>Metropolis</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Creates a Metropolis-type MCMC with options for covariance adaptatin, delayed rejection, Metropolis-within-Gibbs, and tempering</h2>

<h3>Description</h3>

<p>Creates a Metropolis-type MCMC with options for covariance adaptatin, delayed rejection, Metropolis-within-Gibbs, and tempering
</p>


<h3>Usage</h3>

<pre><code class="language-R">Metropolis(
  bayesianSetup,
  settings = list(startValue = NULL, optimize = T, proposalGenerator = NULL,
    consoleUpdates = 100, burnin = 0, thin = 1, parallel = NULL, adapt = T,
    adaptationInterval = 500, adaptationNotBefore = 3000, DRlevels = 1, proposalScaling =
    NULL, adaptationDepth = NULL, temperingFunction = NULL, gibbsProbabilities = NULL,
    message = TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>bayesianSetup</code></td>
<td>
<p>either an object of class bayesianSetup created by <code>createBayesianSetup</code> (recommended), or a log target function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>settings</code></td>
<td>
<p>a list of settings - possible options follow below</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>startValue</code></td>
<td>
<p>startValue for the MCMC and optimization (if optimize = T). If not provided, the sampler will attempt to obtain the startValue from the bayesianSetup</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimize</code></td>
<td>
<p>logical, determines whether an optimization for start values and proposal function should be run before starting the sampling</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>proposalGenerator</code></td>
<td>
<p>optional proposalgenerator object (see <code>createProposalGenerator</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>proposalScaling</code></td>
<td>
<p>additional scaling parameter for the proposals that controls the different scales of the proposals after delayed rejection (typical, after a rejection, one would want to try a smaller scale). Needs to be as long as DRlevels. Defaults to 0.5^(- 0:(mcmcSampler$settings$DRlevels -1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>number of iterations treated as burn-in. These iterations are not recorded in the chain.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>thinning parameter. Determines the interval in which values are recorded.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>consoleUpdates</code></td>
<td>
<p>integer, determines the frequency with which sampler progress is printed to the console</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adapt</code></td>
<td>
<p>logical, determines wheter an adaptive algorithm should be implemented. Default is TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adaptationInterval</code></td>
<td>
<p>integer, determines the interval  of the adaption if adapt = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adaptationNotBefore</code></td>
<td>
<p>integer, determines the start value for the adaption if adapt = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DRlevels</code></td>
<td>
<p>integer, determines the number of levels for a delayed rejection sampler. Default is 1, which means no delayed rejection is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>temperingFunction</code></td>
<td>
<p>function to implement simulated tempering in the algorithm. The function describes how the acceptance rate will be influenced in the course of the iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gibbsProbabilities</code></td>
<td>
<p>vector that defines the relative probabilities of the number of parameters to be changes simultaniously.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>message</code></td>
<td>
<p>logical determines whether the sampler's progress should be printed</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The 'Metropolis' function is the main function for all Metropolis based samplers in this package. To call the derivatives from the basic Metropolis-Hastings MCMC, you can either use the corresponding function (e.g. <code>AM</code> for an adaptive Metropolis sampler) or use the parameters to adapt the basic Metropolis-Hastings. The advantage of the latter case is that you can easily combine different properties (e.g. adapive sampling and delayed rejection sampling) without changing the function.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>References</h3>

<p>Haario, H., E. Saksman, and J. Tamminen (2001). An adaptive metropolis algorithm. Bernoulli , 223-242.
</p>
<p>Haario, Heikki, et al. "DRAM: efficient adaptive MCMC." Statistics and Computing 16.4 (2006): 339-354.
</p>
<p>Hastings, W. K. (1970). Monte carlo sampling methods using markov chains and their applications. Biometrika 57 (1), 97-109.
</p>
<p>Green, Peter J., and Antonietta Mira. "Delayed rejection in reversible jump Metropolis-Hastings." Biometrika (2001): 1035-1053.
</p>
<p>Metropolis, N., A. W. Rosenbluth, M. N. Rosenbluth, A. H. Teller, and E. Teller (1953). Equation of state calculations by fast computing machines. The journal of chemical physics 21 (6), 1087 - 1092.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Running the metropolis via the runMCMC with a proposal covariance generated from the prior 
# (can be useful for complicated priors)

ll = function(x) sum(dnorm(x, log = TRUE))
setup = createBayesianSetup(ll, lower = c(-10,-10), upper = c(10,10))

samples = setup$prior$sampler(1000)

generator = createProposalGenerator(diag(1, setup$numPars))
generator = updateProposalGenerator(generator, samples, manualScaleAdjustment = 1, message = TRUE)

settings =  list(proposalGenerator = generator, optimize = FALSE, iterations = 500)  

out = runMCMC(bayesianSetup = setup, sampler = "Metropolis", settings = settings)
</code></pre>


</div>