<div class="container">

<table style="width: 100%;"><tr>
<td>predict.bigssg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Predicts for "bigssg" Objects
</h2>

<h3>Description</h3>

<p>Get fitted values and standard error estimates for generalized smoothing spline anova models. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'bigssg'
predict(object,newdata=NULL,se.lp=FALSE,include=object$tnames,
        effect=c("all","0","lin","non"),includeint=FALSE,
        design=FALSE,smoothMatrix=FALSE,intercept=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>Object of class "bigssg", which is output from <code>bigssg</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>

<p>Data frame or list containing the new data points for prediction. Variable names must match those used in the <code>formula</code> input of <code>bigssg</code>. See Details and Example. Default of <code>newdata=NULL</code> uses original data in <code>object</code> input.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.lp</code></td>
<td>

<p>Logical indicating if the standard errors of the linear predictors (<code class="reqn">\eta</code>) should be estimated. Default is <code>se.lp=FALSE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include</code></td>
<td>

<p>Which terms to include in the estimate. You can get fitted values for any combination of terms in the <code>tnames</code> element of an "bigssg" object.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>effect</code></td>
<td>

<p>Which effect to estimate: <code>effect="all"</code> gives <code class="reqn">\hat{y}</code> for given terms in <code>include</code>, <code>effect="lin"</code> gives linear portion of <code class="reqn">\hat{y}</code> for given terms in <code>include</code>, and <code>effect="non"</code> gives nonlinear portion of <code class="reqn">\hat{y}</code> for given terms in <code>include</code>. Use <code>effect="0"</code> to return the intercept.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>includeint</code></td>
<td>

<p>Logical indicating whether the intercept should be included in the prediction. If <code>include=object$tnames</code> and <code>effect="all"</code> (default), then this input is ignored and the intercept is automatically included in the prediction.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>design</code></td>
<td>

<p>Logical indicating whether the design matrix should be returned.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smoothMatrix</code></td>
<td>

<p>Logical indicating whether the smoothing matrix should be returned.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>

<p>Logical indicating whether the intercept should be included in the prediction. When used, this input overrides the <code>includeint</code> input.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Ignored.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Uses the coefficient and smoothing parameter estimates from a fit generalized smoothing spline anova (estimated by <code>bigssg</code>) to predict for new data.
</p>


<h3>Value</h3>

<p>Returns list with elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>fitted.values</code></td>
<td>
<p>Vector of fitted values (on data scale)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linear.predictors</code></td>
<td>
<p>Vector of fitted values (on link scale)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.lp</code></td>
<td>
<p>Vector of standard errors of linear predictors (if <code>se.lp=TRUE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Design matrix used to create linear predictors (if <code>design=TRUE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ix</code></td>
<td>
<p>Index vector such that <code>linear.predictors=X%*%object$modelspec$coef[ix]</code> (if <code>design=TRUE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>Smoothing matrix corresponding to fitted values (if <code>smoothMatrix=TRUE</code>)</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Gu, C. (2013). <em>Smoothing spline ANOVA models, 2nd edition</em>. New York: Springer.
</p>
<p>Gu, C. and Xiang, D. (2001). Cross-validating non-Gaussian data: Generalized approximate cross-validation revisited. <em>Journal of Computational and Graphical Statistics, 10</em>, 581-591.
</p>
<p>Helwig, N. E. (2017). <a href="http://dx.doi.org/10.3389/fams.2017.00015">Regression with ordered predictors via ordinal smoothing splines</a>. Frontiers in Applied Mathematics and Statistics, 3(15), 1-13.
</p>
<p>Helwig, N. E. and Ma, P. (2015). Fast and stable multiple smoothing parameter selection in smoothing spline analysis of variance models with large samples. <em>Journal of Computational and Graphical Statistics, 24</em>, 715-732.
</p>
<p>Helwig, N. E. and Ma, P. (2016). Smoothing spline ANOVA for super-large samples: Scalable computation via rounding parameters. <em>Statistics and Its Interface, 9</em>, 433-444.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
##########   EXAMPLE 1   ##########

# define univariate function and data
set.seed(1)
myfun &lt;- function(x){ sin(2*pi*x) }
ndpts &lt;- 1000
x &lt;- runif(ndpts)

# negative binomial response (unknown dispersion)
set.seed(773)
lp &lt;- myfun(x)
mu &lt;- exp(lp)
y &lt;- rnbinom(n=ndpts,size=2,mu=mu)

# fit cubic spline model
cubmod &lt;- bigssg(y~x,family="negbin",type="cub",nknots=20)
1/cubmod$dispersion   ## dispersion = 1/size
crossprod( lp - cubmod$linear.predictor )/length(lp)

# define new data for prediction
newdata &lt;- data.frame(x=seq(0,1,length.out=100))

# get fitted values and standard errors for new data
yc &lt;- predict(cubmod,newdata,se.lp=TRUE)

# plot results with 95% Bayesian confidence interval (link scale)
plot(newdata$x,yc$linear.predictor,type="l")
lines(newdata$x,yc$linear.predictor+qnorm(.975)*yc$se.lp,lty=3)
lines(newdata$x,yc$linear.predictor-qnorm(.975)*yc$se.lp,lty=3)

# plot results with 95% Bayesian confidence interval (data scale)
plot(newdata$x,yc$fitted,type="l")
lines(newdata$x,exp(yc$linear.predictor+qnorm(.975)*yc$se.lp),lty=3)
lines(newdata$x,exp(yc$linear.predictor-qnorm(.975)*yc$se.lp),lty=3)

# predict constant, linear, and nonlinear effects
yc0 &lt;- predict(cubmod,newdata,se.lp=TRUE,effect="0")
ycl &lt;- predict(cubmod,newdata,se.lp=TRUE,effect="lin")
ycn &lt;- predict(cubmod,newdata,se.lp=TRUE,effect="non")
crossprod( yc$linear - (yc0$linear + ycl$linear + ycn$linear) )

# plot results with 95% Bayesian confidence intervals (link scale)
par(mfrow=c(1,2))
plot(newdata$x,ycl$linear,type="l",main="Linear effect")
lines(newdata$x,ycl$linear+qnorm(.975)*ycl$se.lp,lty=3)
lines(newdata$x,ycl$linear-qnorm(.975)*ycl$se.lp,lty=3)
plot(newdata$x,ycn$linear,type="l",main="Nonlinear effect")
lines(newdata$x,ycn$linear+qnorm(.975)*ycn$se.lp,lty=3)
lines(newdata$x,ycn$linear-qnorm(.975)*ycn$se.lp,lty=3)
         
# plot results with 95% Bayesian confidence intervals (data scale)
par(mfrow=c(1,2))
plot(newdata$x,ycl$fitted,type="l",main="Linear effect")
lines(newdata$x,exp(ycl$linear+qnorm(.975)*ycl$se.lp),lty=3)
lines(newdata$x,exp(ycl$linear-qnorm(.975)*ycl$se.lp),lty=3)
plot(newdata$x,ycn$fitted,type="l",main="Nonlinear effect")
lines(newdata$x,exp(ycn$linear+qnorm(.975)*ycn$se.lp),lty=3)
lines(newdata$x,exp(ycn$linear-qnorm(.975)*ycn$se.lp),lty=3)

         
         
##########   EXAMPLE 2   ##########

# define bivariate function and data
set.seed(1)
myfun &lt;- function(x1v,x2v){
  sin(2*pi*x1v) + log(x2v+.1) + cos(pi*(x1v-x2v))
}
ndpts &lt;- 1000
x1v &lt;- runif(ndpts)
x2v &lt;- runif(ndpts)

# binomial response (with weights)
set.seed(773)
lp &lt;- myfun(x1v,x2v)
p &lt;- 1/(1+exp(-lp))
w &lt;- sample(c(10,20,30,40,50),length(p),replace=TRUE)
y &lt;- rbinom(n=ndpts,size=w,p=p)/w   ## y is proportion correct
cubmod &lt;- bigssg(y~x1v*x2v,family="binomial",type=list(x1v="cub",x2v="cub"),nknots=100,weights=w)
crossprod( lp - cubmod$linear.predictor )/length(lp)

# define new data for prediction
xnew &lt;- as.matrix(expand.grid(seq(0,1,length=50),seq(0,1,length=50)))
newdata &lt;- list(x1v=xnew[,1],x2v=xnew[,2])

# get fitted values for new data
yp &lt;- predict(cubmod,newdata)

# plot linear predictor and fitted values
par(mfrow=c(2,2))
imagebar(seq(0,1,l=50),seq(0,1,l=50),matrix(myfun(newdata$x1v,newdata$x2v),50,50),
         xlab=expression(italic(x)[1]),ylab=expression(italic(x)[2]),
         zlab=expression(hat(italic(y))),zlim=c(-4.5,1.5),main="True Linear Predictor")
imagebar(seq(0,1,l=50),seq(0,1,l=50),matrix(yp$linear.predictor,50,50),
         xlab=expression(italic(x)[1]),ylab=expression(italic(x)[2]),
         zlab=expression(hat(italic(y))),zlim=c(-4.5,1.5),main="Estimated Linear Predictor")
newprob &lt;- 1/(1+exp(-myfun(newdata$x1v,newdata$x2v)))
imagebar(seq(0,1,l=50),seq(0,1,l=50),matrix(newprob,50,50),
         xlab=expression(italic(x)[1]),ylab=expression(italic(x)[2]),
         zlab=expression(hat(italic(y))),zlim=c(0,0.8),main="True Probabilities")
imagebar(seq(0,1,l=50),seq(0,1,l=50),matrix(yp$fitted.values,50,50),
         xlab=expression(italic(x)[1]),ylab=expression(italic(x)[2]),
         zlab=expression(hat(italic(y))),zlim=c(0,0.8),main="Estimated Probabilities")         

# predict linear and nonlinear effects for x1v (link scale)
newdata &lt;- list(x1v=seq(0,1,length.out=100))
yl &lt;- predict(cubmod,newdata,include="x1v",effect="lin",se.lp=TRUE)
yn &lt;- predict(cubmod,newdata,include="x1v",effect="non",se.lp=TRUE)

# plot results with 95% Bayesian confidence intervals (link scale)
par(mfrow=c(1,2))
plot(newdata$x1v,yl$linear,type="l",main="Linear effect")
lines(newdata$x1v,yl$linear+qnorm(.975)*yl$se.lp,lty=3)
lines(newdata$x1v,yl$linear-qnorm(.975)*yl$se.lp,lty=3)
plot(newdata$x1v,yn$linear,type="l",main="Nonlinear effect")
lines(newdata$x1v,yn$linear+qnorm(.975)*yn$se.lp,lty=3)
lines(newdata$x1v,yn$linear-qnorm(.975)*yn$se.lp,lty=3)

</code></pre>


</div>