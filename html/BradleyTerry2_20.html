<div class="container">

<table style="width: 100%;"><tr>
<td>predict.BTm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Predict Method for Bradley-Terry Models</h2>

<h3>Description</h3>

<p>Obtain predictions and optionally standard errors of those predictions from
a fitted Bradley-Terry model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'BTm'
predict(
  object,
  newdata = NULL,
  level = ifelse(is.null(object$random), 0, 1),
  type = c("link", "response", "terms"),
  se.fit = FALSE,
  dispersion = NULL,
  terms = NULL,
  na.action = na.pass,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>a fitted object of class <code>"BTm"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>(optional) a data frame in which to look for variables with
which to predict.  If omitted, the fitted linear predictors are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>for models with random effects: an integer vector giving the
level(s) at which predictions are required. Level zero corresponds to
population-level predictions (fixed effects only), whilst level one
corresponds to the player-level predictions (full model) which are NA for
contests involving players not in the original data. By default, <code>level = 0</code>
for a fixed effects model, <code>1</code> otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>the type of prediction required.  The default is on the scale of
the linear predictors; the alternative <code>"response"</code> is on the scale of
the response variable. Thus for a default Bradley-Terry model the default
predictions are of log-odds (probabilities on logit scale) and
<code>type = "response"</code> gives the predicted probabilities. The <code>"terms"</code> option
returns a matrix giving the fitted values of each term in the model formula
on the linear predictor scale (fixed effects only).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.fit</code></td>
<td>
<p>logical switch indicating if standard errors are required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dispersion</code></td>
<td>
<p>a value for the dispersion, not used for models with
random effects. If omitted, that returned by <code>summary</code> applied to the
object is used, where applicable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terms</code></td>
<td>
<p>with <code>type ="terms"</code> by default all terms are returned.  A
character vector specifies which terms are to be returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>function determining what should be done with missing
values in <code>newdata</code>.  The default is to predict <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>newdata</code> is omitted the predictions are based on the data used for
the fit.  In that case how cases with missing values in the original fit are
treated is determined by the <code>na.action</code> argument of that fit.  If
<code>na.action = na.omit</code> omitted cases will not appear in the residuals,
whereas if <code>na.action = na.exclude</code> they will appear (in predictions
and standard errors), with residual value <code>NA</code>.  See also
<code>napredict</code>.
</p>


<h3>Value</h3>

<p>If <code>se.fit = FALSE</code>, a vector or matrix of predictions.  If
<code>se = TRUE</code>, a list with components </p>
<table>
<tr style="vertical-align: top;">
<td><code>fit </code></td>
<td>
<p>Predictions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.fit </code></td>
<td>
<p>Estimated standard errors</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Heather Turner
</p>


<h3>See Also</h3>

<p><code>predict.glm()</code>, <code>predict.glmmPQL()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## The final model in example(flatlizards)
result &lt;- rep(1, nrow(flatlizards$contests))
Whiting.model3 &lt;- BTm(1, winner, loser, ~ throat.PC1[..] + throat.PC3[..] +
                      head.length[..] + SVL[..] + (1|..),
                      family = binomial(link = "probit"),
                      data = flatlizards, trace = TRUE)

## `new' data for contests between four of the original lizards
## factor levels must correspond to original levels, but unused levels
## can be dropped - levels must match rows of predictors
newdata  &lt;- list(contests = data.frame(
                 winner = factor(c("lizard048", "lizard060"),
                 levels = c("lizard006", "lizard011", 
                            "lizard048", "lizard060")),
                 loser = factor(c("lizard006", "lizard011"),
                 levels = c("lizard006", "lizard011", 
                            "lizard048", "lizard060"))
                 ),
                 predictors = flatlizards$predictors[c(3, 6, 27, 33), ])

predict(Whiting.model3, level = 1, newdata = newdata)

## same as
predict(Whiting.model3, level = 1)[1:2]

## introducing a new lizard
newpred &lt;- rbind(flatlizards$predictors[c(3, 6, 27),
                     c("throat.PC1","throat.PC3", "SVL", "head.length")],
                 c(-5, 1.5, 1, 0.1))
rownames(newpred)[4] &lt;- "lizard059"

newdata  &lt;- list(contests = data.frame(
                 winner = factor(c("lizard048", "lizard059"),
                 levels = c("lizard006", "lizard011", 
                            "lizard048", "lizard059")),
                 loser = factor(c("lizard006", "lizard011"),
                 levels = c("lizard006", "lizard011", 
                            "lizard048", "lizard059"))
                 ),
                 predictors = newpred)

## can only predict at population level for contest with new lizard
predict(Whiting.model3, level = 0:1, se.fit = TRUE, newdata = newdata)

## predicting at specific levels of covariates

## consider a model from example(CEMS)
table6.model &lt;-  BTm(outcome = cbind(win1.adj, win2.adj),
                     player1 = school1, player2 = school2,
                     formula = ~ .. +
                         WOR[student] * Paris[..] +
                         WOR[student] * Milano[..] +
                         WOR[student] * Barcelona[..] +
                         DEG[student] * St.Gallen[..] +
                         STUD[student] * Paris[..] +
                         STUD[student] * St.Gallen[..] +
                         ENG[student] * St.Gallen[..] +
                         FRA[student] * London[..] +
                         FRA[student] * Paris[..] +
                         SPA[student] * Barcelona[..] +
                         ITA[student] * London[..] +
                         ITA[student] * Milano[..] +
                         SEX[student] * Milano[..],
                     refcat = "Stockholm",
                     data = CEMS)
                     
## estimate abilities for a combination not seen in the original data

## same schools
schools &lt;- levels(CEMS$preferences$school1)
## new student data
students &lt;- data.frame(STUD = "other", ENG = "good", FRA = "good", 
                       SPA = "good", ITA = "good", WOR = "yes", DEG = "no",
                       SEX = "female", stringsAsFactors = FALSE)
## set levels to be the same as original data    
for (i in seq_len(ncol(students))){
    students[,i] &lt;- factor(students[,i], levels(CEMS$students[,i]))
}
newdata &lt;- list(preferences = 
    data.frame(student = factor(500), # new id matching with `students[1,]`
               school1 = factor("London", levels = schools),
               school2 = factor("Paris", levels = schools)),
    students = students,
    schools = CEMS$schools)

## warning can be ignored as model specification was over-parameterized
predict(table6.model, newdata = newdata)

## if treatment contrasts are use (i.e. one player is set as the reference
## category), then predicting the outcome of contests against the reference
## is equivalent to estimating abilities with specific covariate values

## add student with all values at reference levels 
students &lt;- rbind(students,
    data.frame(STUD = "other", ENG = "good", FRA = "good", 
               SPA = "good", ITA = "good", WOR = "no", DEG = "no",
               SEX = "female", stringsAsFactors = FALSE))
## set levels to be the same as original data    
for (i in seq_len(ncol(students))){
    students[,i] &lt;- factor(students[,i], levels(CEMS$students[,i]))
}
newdata &lt;- list(preferences = 
    data.frame(student = factor(rep(c(500, 502), each = 6)), 
               school1 = factor(schools, levels = schools),
               school2 = factor("Stockholm", levels = schools)),
    students = students,
    schools = CEMS$schools)
    
predict(table6.model, newdata = newdata, se.fit = TRUE)

## the second set of predictions (elements 7-12) are equivalent to the output 
## of BTabilities; the first set are adjust for `WOR` being equal to "yes"
BTabilities(table6.model)

</code></pre>


</div>