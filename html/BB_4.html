<div class="container">

<table style="width: 100%;"><tr>
<td>BBsolve</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Solving Nonlinear System of Equations - A Wrapper for dfsane()</h2>

<h3>Description</h3>

<p>A strategy using different Barzilai-Borwein steplengths to 
solve a nonlinear system of equations.</p>


<h3>Usage</h3>

<pre><code class="language-R">  BBsolve(par, fn, method=c(2,3,1), 
	control=list(), quiet=FALSE, ...) 
  </code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p>A real vector argument to <code>fn</code>, indicating the initial guess
for the root of the nonliinear system of equations <code>fn</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fn</code></td>
<td>
<p>Nonlinear system of equation that is to be solved. 
A vector function that takes a real vector as argument and 
returns a real vector of the same length.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>A vector of integers specifying which Barzilai-Borwein 
steplengths should be used in a consecutive manner.  The methods will 
be used in the order specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>A list of parameters governing the algorithm behaviour.  
This list is the same as that for <code>dfsane</code> and <code>sane</code> (excepting 
the default for <code>trace</code>).  
See <code>details</code> for important special features of control parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quiet</code></td>
<td>
<p>logical indicating if messages about convergence success or
failure should be suppressed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed fn (via the optimization algorithm).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This wrapper is especially useful in problems where the algorithms
(<code>dfsane</code> or <code>sane</code>) are likely to experience difficulties in 
convergence.  When these algorithms with default parameters fail, i.e. 
when <code>convergence &gt; 0</code> is obtained, a user might attempt various 
strategies to find a root of the nonlinear system. The function <code>BBsolve</code> 
tries the following sequential strategy:
</p>

<ol>
<li>
<p> Try a different BB steplength.  Since the default is <code>method = 2</code> 
for <code>dfsane</code>, the BBsolve wrapper tries <code>method = c(2, 1, 3)</code>. 
</p>
</li>
<li>
<p> Try a different non-monotonicity parameter <code>M</code> for each method, 
i.e. BBsolve wrapper tries <code>M = c(50, 10)</code> for each BB steplength.
</p>
</li>
<li>
<p> Try with Nelder-Mead initialization.  Since the default for 
<code>dfsane</code> is <code>NM = FALSE</code>, BBsolve does <code>NM = c(TRUE, FALSE)</code>.
</p>
</li>
</ol>
<p>The argument <code>control</code> defaults to a list with values 
<code>maxit = 1500, M = c(50, 10), tol = 1e-07, trace = FALSE, 
        triter = 10, noimp = 100, NM = c(TRUE, FALSE)</code>. 
If <code>control</code> is specified as an argument, only values which are different
need to be given in the list. See <code>dfsane</code> for more details.
</p>


<h3>Value</h3>

<p>A list with the same elements as returned by <code>dfsane</code> 
or <code>sane</code>.  One additional element returned is <code>cpar</code> which 
contains the control parameter settings used to obtain successful 
convergence, or to obtain the best solution in case of failure. </p>


<h3>References</h3>

 
<p>R Varadhan and PD Gilbert (2009),  BB: An R Package for Solving a Large System of Nonlinear Equations and for Optimizing a High-Dimensional Nonlinear Objective Function, <em>J. Statistical Software</em>, 32:4, <a href="http://www.jstatsoft.org/v32/i04/">http://www.jstatsoft.org/v32/i04/</a>
</p>


<h3>See Also</h3>

<p><code>BBoptim</code>,
<code>dfsane</code>,
<code>sane</code>
<code>multiStart</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Use a preset seed so test values are reproducable. 
require("setRNG")
old.seed &lt;- setRNG(list(kind="Mersenne-Twister", normal.kind="Inversion",
    seed=1234))

broydt &lt;- function(x) {
n &lt;- length(x)
f &lt;- rep(NA, n)
h &lt;- 2
f[1] &lt;- ((3 - h*x[1]) * x[1]) - 2*x[2] + 1
tnm1 &lt;- 2:(n-1)
f[tnm1] &lt;- ((3 - h*x[tnm1]) * x[tnm1]) - x[tnm1-1] - 2*x[tnm1+1] + 1
f[n] &lt;- ((3 - h*x[n]) * x[n]) - x[n-1] + 1
f
}

p0 &lt;- rnorm(50)
BBsolve(par=p0, fn=broydt)  # this works 
dfsane(par=p0, fn=broydt) # but this is highly unliikely to work.

# this implements the 3 BB steplengths with M = 50, and without Nelder-Mead initialization
BBsolve(par=p0, fn=broydt, control=list(M=50, NM=FALSE))

# this implements BB steplength 1 with M = 50 and 10, and both with and 
#   without Nelder-Mead initialization  
BBsolve(par=p0, fn=broydt, method=1, control=list(M=c(50, 10))) 

# identical to dfsane() with defaults
BBsolve(par=p0, fn=broydt, method=2, control=list(M=10, NM=FALSE)) 
</code></pre>


</div>