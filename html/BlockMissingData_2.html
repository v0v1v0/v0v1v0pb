<div class="container">

<table style="width: 100%;"><tr>
<td>MBI</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Variable selection method with multiple block-wise imputation (MBI)</h2>

<h3>Description</h3>

<p>Fit a variable selection method with multiple block-wise imputation (MBI).
</p>


<h3>Usage</h3>

<pre><code class="language-R">MBI(
  X,
  y,
  cov_index,
  sub_index,
  miss_source,
  complete,
  lambda = NULL,
  eps1 = 0.001,
  eps2 = 1e-07,
  eps3 = 1e-08,
  max.iter = 1000,
  lambda.min = ifelse(n &gt; p, 0.001, 0.05),
  nlam = 100,
  beta0 = NULL,
  a = 3.7,
  gamma.ebic = 0.5,
  alpha1 = 0.5^(0:12),
  h1 = 2^(-(8:30)),
  ratio = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Design matrix for block-wise missing covariates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Response vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov_index</code></td>
<td>
<p>Starting indexes of covariates in data sources.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sub_index</code></td>
<td>
<p>Starting indexes of subjects in missing groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>miss_source</code></td>
<td>
<p>Indexes of missing data sources in missing groups, respectively ('NULL' represents no missing).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>complete</code></td>
<td>
<p>Logical indicator of whether there is a group of complete cases. If there is a group of complete cases,
it should be the first group. 'TRUE' represents that there is a group of complete cases.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A user supplied sequence of tuning parameter in penalty. If NULL, a sequence is automatically generated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps1</code></td>
<td>
<p>Convergence threshold at certain stage of the algorithm. Default is 1e-3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps2</code></td>
<td>
<p>Convergence threshold at certain stage of the algorithm. Default is 1e-7.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps3</code></td>
<td>
<p>Convergence threshold at certain stage of the algorithm. Default is 1e-8.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.iter</code></td>
<td>
<p>The maximum number of iterations allowed. Default is 1000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min</code></td>
<td>
<p>Smallest value for <code>lambda</code>, as a fraction of the maximum value in <code>lambda</code>. Default depends on the size of input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlam</code></td>
<td>
<p>The number of <code>lambda</code> values. Default is 100.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta0</code></td>
<td>
<p>Initial value for regression coefficients. If NULL, they are initialized automatically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>Tuning parameter in the SCAD penalty. Default is 3.7.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma.ebic</code></td>
<td>
<p>Parameter in the EBIC criterion. Default is 0.5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha1</code></td>
<td>
<p>A sequence of candidate values for the step size in the conjugate gradient algorithm. Default is 0.5^(0:12).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h1</code></td>
<td>
<p>A sequence of candidate values for the parameter in the numerical calculation of the first derivative of the objective function. Default is 2^(-(8:30)).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ratio</code></td>
<td>
<p>Parameter in the numerical calculation of the first derivative. Default is 1.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function uses the penalized generalized method of moments with multiple block-wise imputation to handle block-wise missing data, commonly found in multi-source datasets.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>Estimated coefficients matrix with <code>length(lambda)</code> rows and <code>dim(X)[2]</code> columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The actual sequence of <code>lambda</code> values used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bic1</code></td>
<td>
<p>BIC criterion values. '0' should be ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>notcon</code></td>
<td>
<p>Value indicating whether the algorithm is converged or not. '0' represents convergence; otherwise non-convergence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>Intercept sequence of length <code>length(lambda)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta0</code></td>
<td>
<p>Estimated coefficients matrix for standardized <code>X</code></p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Fei Xue and Annie Qu
</p>


<h3>References</h3>

<p>Xue, F., and Qu, A. (2021)
<em>Integrating Multisource Block-Wise Missing Data in Model Selection (2021), Journal of the American Statistical Association, Vol. 116(536), 1914-1927</em>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(MASS)

# Number of subjects
n &lt;- 30

# Number of total covariates
p &lt;- 4

# Number of missing groups of subjects
ngroup &lt;- 2

# Number of data sources
nsource &lt;- 2

# Starting indexes of covariates in data sources
cov_index=c(1, 3)

# Starting indexes of subjects in missing groups
sub_index=c(1, 16)

# Indexes of missing data sources in missing groups, respectively ('NULL' represents no missing)
miss_source=list(NULL, 1)

# Indicator of whether there is a group of complete cases. If there is a group of complete cases,
# it should be the first group.
complete=TRUE

# Create a block-wise missing design matrix X and response vector y
set.seed(1)
sigma=diag(1-0.4,p,p)+matrix(0.4,p,p)
X &lt;- mvrnorm(n,rep(0,p),sigma)
beta_true &lt;- c(2.5, 0, 3, 0)
y &lt;- rnorm(n) + X%*%beta_true

for (i in 1:ngroup) {
  if (!is.null(miss_source[[i]])) {
    if (i==ngroup) {
      if (miss_source[[i]]==nsource) {
        X[sub_index[i]:n, cov_index[miss_source[[i]]]:p] = NA
      } else {
        X[sub_index[i]:n, cov_index[miss_source[[i]]]:(cov_index[miss_source[[i]]+1]-1)] = NA
      }
    } else {
      if (miss_source[[i]]==nsource) {
        X[sub_index[i]:(sub_index[i+1]-1), cov_index[miss_source[[i]]]:p] = NA
      } else {
        X[sub_index[i]:(sub_index[i+1]-1), cov_index[miss_source[[i]]]:
        (cov_index[miss_source[[i]]+1]-1)] = NA
      }
    }
  }
}

# Now we can use the function with this simulated data
#start.time = proc.time()
result &lt;- MBI(X=X, y=y, cov_index=cov_index, sub_index=sub_index, miss_source=miss_source,
complete=complete, nlam = 15, eps2 = 1e-3, h1=2^(-(8:20)))
#time = proc.time() - start.time

theta=result$beta
bic1=result$bic1
best=which.min(bic1[bic1!=0])
beta_est=theta[best,]


</code></pre>


</div>