<div class="container">

<table style="width: 100%;"><tr>
<td>sfa</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Stochastic frontier estimation</h2>

<h3>Description</h3>

<p>Estimate a stochastic frontier production or cost function using a maximum 
likelihood method.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sfa(x, y, beta0 = NULL, lambda0 = 1, resfun = ebeta, 
    TRANSPOSE = FALSE, DEBUG=FALSE,
    control=list(), hessian=2)

sfa.cost(W, Y, COST, beta0 = NULL, lambda0 = 1, resfun = ebeta, 
    TRANSPOSE = FALSE, DEBUG=FALSE,
    control=list(), hessian=2)



te.sfa(object)
teBC.sfa(object)
teMode.sfa(object)
teJ.sfa(object)

te.add.sfa(object, ...)

sigma2u.sfa(object)
sigma2v.sfa(object)
sigma2.sfa(object)

lambda.sfa(object)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Input as a K x m matrix of observations on m inputs from K
firms; (firm x input); MUST be a matrix. No constant for the
intercept should be included in x as it is added by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Output; K times 1 matrix (one output)  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>Output; K times n matrix for m outputs; only to be used in cost function estimation.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p>Input prices as a K x m matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>COST</code></td>
<td>
<p>Cost as a K array for the K firms</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta0</code></td>
<td>
<p>Optional initial parameter values</p>
</td>
</tr>
</table>
<table>
<tr style="vertical-align: top;">
<td><code>lambda0</code></td>
<td>
<p>Optional initial ratio of variances</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resfun</code></td>
<td>
<p>Function to calculate the residuals, default is a
linear model with an intercept. Must be called as
<code>resfun(x,y,parm)</code> where <code>parm=c(beta,lambda)</code> or
<code>parm=c(beta)</code>, and return the residuals as an array of length
corresponding to the length of output <code>y</code>.</p>
</td>
</tr>
</table>
<table>
<tr style="vertical-align: top;">
<td><code>TRANSPOSE</code></td>
<td>
<p>If TRUE, data is transposed, i.e. input is now m x K matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DEBUG</code></td>
<td>
<p>Set to TRUE to get various debugging information written
on the console</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>List of control parameters to <code>ucminf</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessian</code></td>
<td>
<p>How the Hessian is delivered, see the ucminf
documentation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>Object of class ‘sfa’ as output from the
function <code>sfa</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments ... </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p> The optimization is done by the R method <code>ucminf</code> from
the package with the same name. The efficiency terms are assumed to
be half–normal distributed.
</p>
<p>Changing the maximum step length, the trust region, might be important,
and this can be done by the option 'control = list(stepmax=0.1)'. The
default value is 0.1 and that value is suitable for parameters
around 1; for smaller parameters a lower value should be used.
Notice that the step length is updated by the optimizing program and
thus, must be set for every call of the function sfa if it is to be
set.
</p>
<p>The generic functions <code>print.sfa</code>, <code>summary.sfa</code>,
<code>fitted.sfa</code>, <code>residuals.sfa</code>, <code>logLik.sfa</code>, and
<code>coef.sfa</code> all work as expected.
</p>
<p>The methods <code>te.sfa</code>, <code>teMode.sfa</code> etc. calculates the
efficiency corresponding to different methods
</p>


<h3>Value</h3>

<p>The values returned from <code>sfa</code> is the same as for <code>ucminf</code>,
i.e. a list with components plus some especially relevant for sfa:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p>The best set of parameters found <code>c(beta,lambda)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>The value of minus log-likelihood function corresponding to 'par'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>The parameters for the function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma2</code></td>
<td>
<p>The estimate of the total variance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The estimate of lambda</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>The number of observations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>The degrees of freedom for the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>The residuals as a K times 1 matrix/vector, 
can also be obtained by <br><code>residuals(sfa-object)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.values</code></td>
<td>
<p>Fitted values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov</code></td>
<td>
<p>The variance-covarians matrix for all estimated parameters
incl. lambda</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence</code></td>
<td>
<p>An integer code. '0' indicates successful
convergence.  Some of the error codes taken from
<code>ucminf</code> are
</p>
<p>'1' Stopped by small gradient (grtol). 
</p>
<p>'2' Stopped by small step (xtol). 
</p>
<p>'3' Stopped by function evaluation limit (maxeval). 
</p>
<p>'4' Stopped by zero step from line search 
</p>
<p>More codes are found in <code>ucminf</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>message</code></td>
<td>
<p>A character string giving any additional information
returned by the optimizer, or 'NULL'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>o</code></td>
<td>
<p>The object returned by <code>ucminf</code>, for further information
on this see <code>ucminf</code></p>
</td>
</tr>
</table>
<h3>Note</h3>

<p> Calculation of technical efficiencies for each unit can be done
by the method te.sfa as shown in the examples.
</p>
<p><code>te.sfa(sfaObject), teBC.sfa(sfaObject)</code>: Efficiencies estimated
by minimizing the mean square error; Eq. (7.21) in Bogetoft and
Otto (2011, 219) and Battese and Coelli (1988, 392)
</p>
<p><code>teMode.sfa(sfaObject), te1.sfa(sfaObject)</code>: Efficiencies
estimates using the conditional mode approach; Bogetoft and Otto
(2011, 219), Jondrow et al. (1982, 235).
</p>
<p><code>teJ.sfa(sfaObject), te2.sfa(sfaObject)</code>: Efficiencies estimates
using the conditional mean approach Jondrow et al. (1982, 235).
</p>
<p><code>te.add.sfa(sfaObject)</code> Efficiency in the additive model,
Bogetoft and Otto (2011, 219)
</p>
<p>The variance pf the distribution of efficiency can be calculated by
<code>sigma2u.sfa(sfaObject)</code>, the variance of the random
error by <code>sigma2v.sfa(sfaObject)</code>, and the total variance
(sum of variances of efficiency and random noise) by
<code>sigma2.sfa</code>.
</p>
<p>The ratio of variances of the efficiency and the random noise can be
found from the method <code>lambda.sfa</code>
</p>
<p>The generic method <code>summary</code> prints the parameters, standard
errors, t-values, and a few more statistics from the
optimization.
</p>


<h3>Author(s)</h3>

<p> Peter Bogetoft and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a></p>


<h3>References</h3>

<p>Bogetoft and Otto; <em>Benchmarking with DEA, SFA, and R</em>, Springer
2011; chapters 7 and 8.
</p>


<h3>See Also</h3>

<p> See the method <code>ucminf</code> for the possible optimization
methods and further options to use in the option <code>control</code>.
</p>
<p>The method <code>sfa</code> in the package <span class="pkg">frontier</span> gives another
way to estimate stochastic production functions.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Example from the book by Coelli et al.
# d &lt;- read.csv("c:/0work/rpack/front41Data.csv", header = TRUE, sep = ",")
# x &lt;- cbind(log(d$capital), log(d$labour))
# y &lt;- matrix(log(d$output))

n &lt;- 50
x1 &lt;- 1:50 + rnorm(n, 0, 10)
x2 &lt;- 100 + rnorm(n, 0, 10)
x &lt;- cbind(x1, x2)
y &lt;- 0.5 + 1.5*x1 + 2*x2 + rnorm(n, 0, 1) - pmax(0, rnorm(n, 0, 1))
sfa(x,y)
summary(sfa(x,y))


# Estimate efficiency for each unit
o &lt;- sfa(x,y)
eff(o)

te &lt;- te.sfa(o)
teM &lt;- teMode.sfa(o)
teJ &lt;- teJ.sfa(o)
cbind(eff(o),te,Mode=eff(o, type="Mode"),teM,teJ)[1:10,]


sigma2.sfa(o)       # Estimated varians
lambda.sfa(o)       # Estimated lambda
</code></pre>


</div>