<div class="container">

<table style="width: 100%;"><tr>
<td>modifications</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Additive Modifications to the Binomial Responses and Totals for
Use within ‘brglm.fit’</h2>

<h3>Description</h3>

<p>Get, test and set the functions that calculate the additive
modifications to the responses and totals in binomial-response GLMs,
for the application of bias-reduction either via modified scores or
via maximum penalized likelihood  (where penalization is by Jeffreys
invariant prior).
</p>


<h3>Usage</h3>

<pre><code class="language-R">modifications(family, pl = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>a family object of the form <code>binomial(link = "link")</code>, where
<code>"link"</code> can be one of <code>"logit"</code>, <code>"probit"</code>, <code>"cloglog"</code>
and <code>"cauchit"</code>. The usual ways of giving the family name are
supported (see <code>family</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pl</code></td>
<td>
<p>logical determining whether the function returned corresponds
to modifications for the penalized maximum likelihood approach or for
the modified-scores approach to bias-reduction. Default value is
<code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function returned from <code>modifications</code> accepts the argument <code>p</code>
which are the binomial probabilities and returns a list with
components <code>ar</code> and <code>at</code>, which are the link-dependent parts
of the additive modifications to the actual responses and totals,
respectively.
</p>
<p>Since the resulting function is used in <code>brglm.fit</code>, for
efficiency reasons no check is made for <code>p &gt;= 0 | p &lt;= 1</code>, for
<code>length(at) == length(p)</code> and for <code>length(ap) == length(p)</code>.
</p>


<h3>Construction of custom pseudo-data representations</h3>

<p> If
<code class="reqn">y^*</code> are the pseudo-responses (pseudo-counts) and
<code class="reqn">m^*</code> are the pseudo-totals then we call the pair <code class="reqn">(y^*,
  m^*)</code> a pseudo-data representation. Both the modified-scores
approach and the maximum penalized likelihood have a common property:
</p>
<p>there exists <code class="reqn">(y^*, m^*)</code> such that if we replace the actual data
<code class="reqn">(y, m)</code> with <code class="reqn">(y^*, m^*)</code> in the expression for the
ordinary scores (first derivatives of the likelihood) of a
binomial-response GLM, then we end-up either with the modified-scores
or with the derivatives of the penalized likelihood (see Kosmidis,
2007, Chapter 5).
</p>
<p>Let <code class="reqn">\mu</code> be the mean of the binomial response <code class="reqn">y</code>
(i.e. <code class="reqn">\mu=mp</code>, where <code class="reqn">p</code> is the binomial probability
corresponding to the count <code class="reqn">y</code>). Also, let <code class="reqn">d</code> and <code class="reqn">d'</code>
denote the first and the second derivatives, respectively, of
<code class="reqn">\mu</code> with respect to the linear predictor <code class="reqn">\eta</code> of the
model. All the above are viewed as functions of <code class="reqn">p</code>. The
pseudo-data representations have the generic form
</p>

<table>
<tr>
<td style="text-align: left;">
    pseudo-response : </td>
<td style="text-align: left;"> <code class="reqn">y^*=y + h a_r(p)</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    pseudo-totals : </td>
<td style="text-align: left;"> <code class="reqn">m^*=m + h a_t(p)</code>, </td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
</tr>
</table>
<p>where <code class="reqn">h</code> is the leverage corresponding to <code class="reqn">y</code>. The general
expressions for <code class="reqn">a_r(p)</code> ("r" for "response") and <code class="reqn">a_t(p)</code>
("t" for "totals") are:
</p>
<p><em>modified-scores approach</em>
</p>

<table>
<tr>
<td style="text-align: left;">
   <code class="reqn">a_r(p) = d'(p)/(2w(p))</code> </td>
</tr>
<tr>
<td style="text-align: left;">
   <code class="reqn">a_t(p) = 0</code>, </td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
</tr>
</table>
<p><em>maximum penalized likelihood approach</em>
</p>

<table>
<tr>
<td style="text-align: left;">
   <code class="reqn">a_r(p) = d'(p)/w(p) + p - 0.5</code> </td>
</tr>
<tr>
<td style="text-align: left;">
   <code class="reqn">a_t(p) = 0</code>. </td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
</tr>
</table>
<p>For supplying <code class="reqn">(y^*, m^*)</code> in <code>glm.fit</code> (as is
done by <code>brglm.fit</code>), an essential requirement for the
pseudo-data representation is that it should mimic the behaviour of the
original responses and totals, i.e. <code class="reqn">0 \le y^* \le m^*</code>. Since <code class="reqn">h \in [0, 1]</code>, the requirement translates to
<code class="reqn">0 \le a_r(p) \le  a_t(p)</code> for every <code class="reqn">p \in (0, 1)</code>. However,
the above definitions of <code class="reqn">a_r(p)</code> and <code class="reqn">a_t(p)</code> do not
necessarily respect this requirement.
</p>
<p>On the other hand, the pair <code class="reqn">(a_r(p), a_t(p))</code> is not unique in
the sense that for a given link function and once the link-specific
structure of the pair has been extrapolated, there is a class of
equivalent pairs that can be resulted following only the following two
rules:
</p>

<ul>
<li>
<p> add and subtract the same quantity from either <code class="reqn">a_r(p)</code>
or <code class="reqn">a_t(p)</code>.
</p>
</li>
<li>
<p> if a quantity is to be moved from <code class="reqn">a_r(p)</code> to <code class="reqn">a_t(p)</code> it
first has to be divided by <code class="reqn">-p</code>.
</p>
</li>
</ul>
<p>For example, in the case of penalized maximum likelihood, the pairs
<code class="reqn">(d'(p)/w(p) + p - 0.5 , 0)</code> and <code class="reqn">(d'(p)/w(p) + p , 0.5/p)</code> are
equivalent, in the sense that if the corresponding pseudo-data
representations are substituted in the ordinary scores both return the
same expression.
</p>
<p>So, in order to construct a pseudo-data representation that
corresponds to a user-specified link function and has the property
<code class="reqn">0 \le a_r(p) \le  a_t(p)</code> for every <code class="reqn">p \in (0, 1)</code>, one merely
has to pursue a simple algebraic calculation on the initial pair
<code class="reqn">(a_r(p), a_t(p))</code> using only the two aforementioned rules until
an appropriate pair is resulted. There is always a pair!
</p>
<p>Once the pair has been found the following steps should be followed.
</p>

<ol>
<li>
<p> For a user-specified link function the user has to write a
modification function with name "br.custom.family" or
"pml.custom.family" for <code>pl=FALSE</code> or <code>pl=TRUE</code>,
respectively. The function should take as argument the
probabilities <code>p</code> and return a list  of two vectors with
same length as <code>p</code> and  with names
<code>c("ar", "at")</code>. The result corresponds to the pair
<code class="reqn">(a_r(p), a_t(p))</code>.
</p>
</li>
<li>
<p> Check if the custom-made modifications function is
appropriate. This can be done via the function
<code>checkModifications</code> which has arguments
<code>fun</code> (the function to be tested) and <code>Length</code> with
default value <code>Length=100</code>. <code>Length</code> is to be used
when the user-specified link function takes as argument a
vector of values (e.g. the <code>logexp</code> link in
<code>?family</code>). Then the value of <code>Length</code> should be the
length of that vector.
</p>
</li>
<li>
<p> Put the function in the search patch so that
<code>modifications</code> can find it.
</p>
</li>
<li> <p><code>brglm</code> can now be used with the custom family as
<code>glm</code> would be used.
</p>
</li>
</ol>
<h3>Note</h3>

<p>The user could also deviate from modified-scores and maximum penalized
likelihood and experiment with implemented (or not) links, e.g. <code>probit</code>,
constructing his own pseudo-data representations of the aforementioned
general form. This could be done by changing the link name, e.g. by
</p>
<p><code>probitt &lt;-  make.link(probit) ;
    probitt$name &lt;- "probitt"</code>
</p>
<p>and then setting a custom <code>br.custom.family</code> that does
not necessarily depend on the <code>probit</code> link. Then, <code>brglm</code>
could be used with <code>pl=FALSE</code>.
</p>
<p>A further generalization would be to completely remove the hat value
<code class="reqn">h</code> in the generic expression of the pseudo-data representation
and have general additive modifications that depend on <code class="reqn">p</code>. To do
this divide both <code>ar</code> and <code>at</code> by
<code>pmax(get("hats",parent.frame()),.Machine\$double.eps)</code> within the
custom modification function (see also Examples).
</p>


<h3>Author(s)</h3>

<p>Ioannis Kosmidis, <a href="mailto:ioannis.kosmidis@warwick.ac.uk">ioannis.kosmidis@warwick.ac.uk</a></p>


<h3>References</h3>

<p>Kosmidis I. and Firth D. (2021). Jeffreys-prior penalty, finiteness
and shrinkage in binomial-response generalized linear
models. <em>Biometrika</em>, <b>108</b>, 71–82. 
</p>
<p>Kosmidis, I. (2007). Bias reduction in exponential family nonlinear
models. <em>PhD Thesis</em>, Department of Statistics, University of
Warwick.
</p>


<h3>See Also</h3>

<p><code>brglm</code>, <code>brglm.fit</code></p>


<h3>Examples</h3>

<pre><code class="language-R">## Begin Example 1
## logistic exposure model, following the Example in ?family. See,
## Shaffer, T.  2004. Auk 121(2): 526-540.
# Definition of the link function
logexp &lt;- function(days = 1) {
  linkfun &lt;- function(mu) qlogis(mu^(1/days))
  linkinv &lt;- function(eta) plogis(eta)^days
  mu.eta &lt;- function(eta) days * plogis(eta)^(days-1) *
        binomial()$mu.eta(eta)
  valideta &lt;- function(eta) TRUE
  link &lt;- paste("logexp(", days, ")", sep="")
  structure(list(linkfun = linkfun, linkinv = linkinv,
    mu.eta = mu.eta, valideta = valideta, name = link),
    class = "link-glm")
}
# Here d(p) = days * p * ( 1 - p^(1/days) )
#      d'(p) = (days - (days+1) * p^(1/days)) * d(p)
#      w(p) = days^2 * p * (1-p^(1/days))^2 / (1-p)
# Initial modifications, as given from the general expressions above:
br.custom.family &lt;- function(p) {
  etas &lt;- binomial(logexp(.days))$linkfun(p)
  # the link function argument `.days' will be detected by lexical
  # scoping. So, make sure that the link-function inputted arguments
  # have unusual names, like `.days' and that
  # the link function enters `brglm' as
  # `family=binomial(logexp(.days))'.
  list(ar = 0.5*(1-p)-0.5*(1-p)*exp(etas)/.days,
       at = 0*p/p) # so that to fix the length of at
}
.days &lt;-3
# `.days' could be a vector as well but then it should have the same
# length as the number of observations (`length(.days)' should be
# equal to `length(p)'). In this case, `checkModifications' should
# have argument `Length=length(.days)'.
#
# Check:
## Not run: checkModifications(br.custom.family)
# OOOPS error message... the condition is not satisfied
#
# After some trivial algebra using the two allowed operations, we
# get new modifications:
br.custom.family &lt;- function(p) {
  etas &lt;- binomial(logexp(.days))$linkfun(p)
  list(ar=0.5*p/p, # so that to fix the length of ar
       at=0.5+exp(etas)*(1-p)/(2*p*.days))
}
# Check:
checkModifications(br.custom.family)
# It is OK.
# Now,
modifications(binomial(logexp(.days)))
# works.
# Notice that for `.days &lt;- 1', `logexp(.days)' is the `logit' link
# model and `a_r=0.5', `a_t=1'.
# In action:
library(MASS)
example(birthwt)
m.glm &lt;- glm(formula = low ~ ., family = binomial, data = bwt)
.days &lt;- bwt$age
m.glm.logexp &lt;- update(m.glm,family=binomial(logexp(.days)))
m.brglm.logexp &lt;- brglm(formula = low ~ ., family =
binomial(logexp(.days)), data = bwt)
# The fit for the `logexp' link via maximum likelihood
m.glm.logexp
# and the fit for the `logexp' link via modified scores
m.brglm.logexp
## End Example
## Begin Example 2
## Another possible use of brglm.fit:
## Deviating from bias reducing modified-scores:
## Add 1/2 to the response of a probit model.
y &lt;- c(1,2,3,4)
totals &lt;- c(5,5,5,5)
x1 &lt;- c(1,0,1,0)
x2 &lt;- c(1,1,0,0)
my.probit &lt;- make.link("probit")
my.probit$name &lt;- "my.probit"
br.custom.family &lt;- function(p) {
   h &lt;- pmax(get("hats",parent.frame()),.Machine$double.eps)
   list(ar=0.5/h,at=1/h)
}
m1 &lt;- brglm(y/totals~x1+x2,weights=totals,family=binomial(my.probit))
m2 &lt;- glm((y+0.5)/(totals+1)~x1+x2,weights=totals+1,family=binomial(probit))
# m1 and m2 should be the same.
# End example
# Begin example 3: Maximum penalized likelihood for logistic regression, 
# with the penalty being a powerof the Jeffreys prior (`.const` below)
# Setup a custom logit link
mylogit &lt;- make.link("logit")
mylogit$name &lt;- "mylogit"
## Set-up the custom family
br.custom.family &lt;- function(p) {
     list(ar = .const * p/p, at = 2 * .const * p/p)
}
data("lizards")
## The reduced-bias fit is
.const &lt;- 1/2
brglm(cbind(grahami, opalinus) ~ height + diameter +
          light + time, family = binomial(mylogit), data=lizards)
## which is the same as what brglm does by default for logistic regression
brglm(cbind(grahami, opalinus) ~ height + diameter +
          light + time, family = binomial(logit), data=lizards)
## Stronger penalization (e.g. 5/2) can be achieved by 
.const &lt;- 5/2
brglm(cbind(grahami, opalinus) ~ height + diameter +
          light + time, family = binomial(mylogit), data=lizards)
# End example 
</code></pre>


</div>