<div class="container">

<table style="width: 100%;"><tr>
<td>bigtabulate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Extended Tabular Operations for Both matrix and big.matrix Objects</h2>

<h3>Description</h3>

<p>This package extends the <span class="pkg">bigmemory</span> package, but the 
functions may also be used with traditional <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> <code>matrix</code> and 
<code>data.frame</code> objects. The function <code>bigtabulate</code> is 
exposed, but we expect most users will prefer the higher-level functions 
<code>bigtable</code>, <code>bigtsummary</code>, and <code>bigsplit</code>. Each of these
functions provides functionality based on a specified conditional 
structure.  In other words, for every cell of a (possibly multidimensional) 
contingency table, they provide (or tabulate) some useful conditional 
behavior (or statistic(s)) of interest.  At the most basic level, this 
provides an extremely fast and memory-efficient alternative to 
<code>table</code> for matrices and data frames.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bigtabulate(
  x,
  ccols,
  breaks = vector("list", length = length(ccols)),
  table = TRUE,
  useNA = "no",
  summary.cols = NULL,
  summary.na.rm = FALSE,
  splitcol = NULL,
  splitret = "list"
)

bigsplit(
  x,
  ccols,
  breaks = vector("list", length = length(ccols)),
  useNA = "no",
  splitcol = NA,
  splitret = "list"
)

bigtable(
  x,
  ccols,
  breaks = vector("list", length = length(ccols)),
  useNA = "no"
)

bigtsummary(
  x,
  ccols,
  breaks = vector("list", length = length(ccols)),
  useNA = "no",
  cols,
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a <code>big.matrix</code> or a 
<code>data.frame</code> or a <code>matrix</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ccols</code></td>
<td>
<p>a vector of column indices or names specifying which 
columns should be used for conditioning (e.g. for building a contingency 
table or structure for tabulation).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>breaks</code></td>
<td>
<p>a vector or list of <code>length(ccols)</code>.  If a vector,
<code>NA</code> indicates that the associated column should be treated like a
factor (categorical variable), while an integer value indicates that the
range of the associated column should be broken into a specified number of
evenly-spaced bins (histogram-like).  If a list, <code>NA</code> triggers the
factor-like handling, a single number triggers bin-like behavior, while a
triplet (min,max,breaks) indicates that the bin-like behavior should be on
a restricted range rather than on the range of data for that column.  See
<code>binit</code> for similar specification of this option.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>table</code></td>
<td>
<p>if <code>TRUE</code>, a list of table counts will be returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useNA</code></td>
<td>
<p>whether to include extra '<code>NA</code>' levels in the table.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>summary.cols</code></td>
<td>
<p>column(s) for which table summaries will be calculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>summary.na.rm</code></td>
<td>
<p>if <code>TRUE</code>, <code>NA</code>s are removed from table
summary calculations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>splitcol</code></td>
<td>
<p>if <code>NA</code>, the indices which correspond to
table-levels are returned.  If numeric, the corresponding column
values will be returned in a list corresponding to table-levels.  If
<code>NULL</code>, then there is no splitting at all.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>splitret</code></td>
<td>
<p>if <code>"list"</code>, the <code>splitcol</code> value is returned
as a list.  When <code>splitcol</code> is <code>NA</code>, <code>splitret</code> may
be <code>"vector"</code>.  Finally, <code>"sparselist"</code> may be a useful option
when the full-blown splitting structure has many unrepresented "cells";
this is like using the <code>drop=TRUE</code> option to <code>split</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cols</code></td>
<td>
<p>with <code>bigtsummary</code>, which column(s) should be conditionally
summarized?  This (or these) will be passed on as <code>summary.cols</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>an obvious option for summaries.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This package concentrates on conditional stuctures and calculations,
much like <code>table</code>, <code>tapply</code>, and <code>split</code>.
The functions are juiced-up versions of the base <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> functions;
they work on both regular <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> matrices and data frames, but are specialized
for use with <span class="pkg">bigmemory</span> and (for more advanced usage) <span class="pkg">foreach</span>.
They are particularly fast and memory-efficient.  We have found that
<code>bigsplit</code> followed by <code>lapply</code> or <code>sapply</code>
can be particularly effective, when the subsets produced by the split
are of reasonable size.  For intensive calculations, subsequent use of
<code>foreach</code> can be helpful (think: parallel apply-like behavior).
</p>
<p>When <code>x</code> is a <code>matrix</code> or a <code>data.frame</code>, some additional
work may be required.  For example, a character column of a <code>data.frame</code>
will be converted to a <code>factor</code> and then coerced to numeric
values (factor level numberings).
</p>
<p>The conditional structure is specified via <code>ccols</code> and <code>breaks</code>.
This differs from the design of the base <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> functions but is at the root
of the gains in speed and memory-efficiency.  The <code>breaks</code> may seem
distracting, as most users will simply condition on categorical-like columns.
However, it provides the flexibility to “bin” “continuous”,
column(s) much like a histogram.  See <code>binit</code> for
another example
of this type of option, which can be particularly valuable with massive 
data sets.
</p>
<p>A word of caution: if a “continuous” variable is not “binned”,
it will be treated like a factor and the resulting conditional structure will
be large (perhaps immensely so).
The function uses left-closed intervals [a,b) for the "binning" behavior,
when specified, except in the right-most bin, where the interval is entirely
closed.
</p>
<p>Finally, <code>bigsplit</code> is somewhat more general than <code>split</code>.
The default behavior (<code>splitcol=NA</code>)
returns a split of <code>1:nrow(x)</code> as a list
based on the specified conditional structure.  However, it may also
return a vector of cell (or category) numbers.  And of course it may
conduct a split of <code>x[,splitcol]</code>.
</p>


<h3>Value</h3>

<p>array-like object(s), each similar to what is returned by
<code>tapply</code> and the associated <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> functions.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(iris)

# First, break up column 2 into 5 groups, and leave column 5 as a
# factor (which it is).  Note that iris is a data.frame, which is
# fine.  A matrix would also be fine.  A big.matrix would also be fine!
bigtable(iris, ccols=c(2, 5), breaks=list(5, NA))

iris[,2] &lt;- round(iris[,2]) # So columns 2 and 5 will be factor-like
                            # for convenience in these examples, below:

ans1 &lt;- bigtable(iris, c(2, 5))
ans1
# Same answer, but with nice factor labels from table(), because
# table() handles factors.  bigtable() uses the numeric factor
# levels only.
table(iris[,2], iris[,5])

# Here, our formulation is simpler than split's, and is faster and
# more memory-efficient:
ans2 &lt;- bigsplit(iris, c(2, 5), splitcol=1)
ans2[1:3]
split(iris[,1], list(col2=factor(iris[,2]), col5=iris[,5]))[1:3]
</code></pre>


</div>