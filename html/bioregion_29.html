<div class="container">

<table style="width: 100%;"><tr>
<td>nhclu_pam</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Non hierarchical clustering: partitioning around medoids</h2>

<h3>Description</h3>

<p>This function performs non hierarchical clustering on the basis of
dissimilarity with partitioning around medoids.
</p>


<h3>Usage</h3>

<pre><code class="language-R">nhclu_pam(
  dissimilarity,
  index = names(dissimilarity)[3],
  seed = NULL,
  n_clust = c(1, 2, 3),
  variant = "faster",
  nstart = 1,
  cluster_only = FALSE,
  algorithm_in_output = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dissimilarity</code></td>
<td>
<p>the output object from <code>dissimilarity()</code> or
<code>similarity_to_dissimilarity()</code>, or a <code>dist</code> object. If a <code>data.frame</code> is
used, the first two columns represent pairs of sites (or any pair of nodes),
and the next column(s) are the dissimilarity indices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p>name or number of the dissimilarity column to use. By default,
the third column name of <code>dissimilarity</code> is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>for the random number generator (NULL for random by default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_clust</code></td>
<td>
<p>an <code>integer</code> or an <code>integer</code> vector specifying the
requested number(s) of clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variant</code></td>
<td>
<p>a <code>character</code> string specifying the variant of pam to use,
by default <code>faster</code>. Available options are <code>original</code>, <code>o_1</code>, <code>o_2</code>, <code>f_3</code>,
<code>f_4</code>, <code>f_5</code> or <code>faster</code>. See pam for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nstart</code></td>
<td>
<p>an <code>integer</code> specifying the number of random start for the
pam algorithm. By default, 1 (for the <code>faster</code> variant).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster_only</code></td>
<td>
<p>a <code>boolean</code> specifying if only the clustering should be
returned from the pam function (more efficient).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm_in_output</code></td>
<td>
<p>a <code>boolean</code> indicating if the original output
of pam should be returned in the output (<code>TRUE</code> by
default, see Value).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>you can add here further arguments to be passed to <code>pam()</code>
(see pam)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This method partitions data into the chosen number of cluster on the basis
of the input dissimilarity matrix. It is more robust than k-means because it
minimizes the sum of dissimilarity between cluster centres and points
assigned to the cluster - whereas the k-means approach minimizes the sum of
squared euclidean distances (thus k-means cannot be applied directly on the
input dissimilarity matrix if the distances are not euclidean).
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five slots:
</p>

<ol>
<li>
<p><strong>name</strong>: <code>character</code> containing the name of the algorithm
</p>
</li>
<li>
<p><strong>args</strong>: <code>list</code> of input arguments as provided by the user
</p>
</li>
<li>
<p><strong>inputs</strong>: <code>list</code> of characteristics of the clustering process
</p>
</li>
<li>
<p><strong>algorithm</strong>: <code>list</code> of all objects associated with the
clustering procedure, such as original cluster objects
</p>
</li>
<li>
<p><strong>clusters</strong>: <code>data.frame</code> containing the clustering results</p>
</li>
</ol>
<p>In the <code>algorithm</code> slot, if <code>algorithm_in_output = TRUE</code>, users can
find the output of
pam.
</p>


<h3>Author(s)</h3>

<p>Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>),
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) and
Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>References</h3>

<p>Kaufman L, Rousseeuw PJ (2009).
“Finding groups in data: An introduction to cluster analysis.”
In &amp; Sons. JW (ed.), <em>Finding groups in data: An introduction to cluster analysis.</em>.
</p>


<h3>See Also</h3>

<p>nhclu_kmeans
</p>


<h3>Examples</h3>

<pre><code class="language-R">comat &lt;- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001),
20, 25)
rownames(comat) &lt;- paste0("Site",1:20)
colnames(comat) &lt;- paste0("Species",1:25)

comnet &lt;- mat_to_net(comat)
dissim &lt;- dissimilarity(comat, metric = "all")

clust1 &lt;- nhclu_pam(dissim, n_clust = 2:10, index = "Simpson")
clust2 &lt;- nhclu_pam(dissim, n_clust = 2:15, index = "Simpson")
partition_metrics(clust2, dissimilarity = dissim,
eval_metric = "pc_distance")
partition_metrics(clust2, net = comnet, species_col = "Node2",
                   site_col = "Node1", eval_metric = "avg_endemism")
   
</code></pre>


</div>