<div class="container">

<table style="width: 100%;"><tr>
<td>runMCMC</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Main wrapper function to start MCMCs, particle MCMCs and SMCs</h2>

<h3>Description</h3>

<p>Main wrapper function to start MCMCs, particle MCMCs and SMCs
</p>


<h3>Usage</h3>

<pre><code class="language-R">runMCMC(bayesianSetup, sampler = "DEzs", settings = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>bayesianSetup</code></td>
<td>
<p>either a BayesianSetup (see <code>createBayesianSetup</code>), a function, or a BayesianOutput created by runMCMC. The latter allows to continue a previous MCMC run. See details for how to restart a sampler.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sampler</code></td>
<td>
<p>sampling algorithm to be run. Default is DEzs. Options are "Metropolis", "AM", "DR", "DRAM", "DE", "DEzs", "DREAM", "DREAMzs", "SMC". For details see the help of the individual functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>settings</code></td>
<td>
<p>list with settings for each sampler. If a setting is not provided, defaults (see <code>applySettingsDefault</code>) will be used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The runMCMC function can be started with either one of
</p>

<ol>
<li>
<p> an object of class BayesianSetup with prior and likelihood function (created with <code>createBayesianSetup</code>). check if appropriate parallelization options are used - many samplers can make use of parallelization if this option is activated when the class is created.
</p>
</li>
<li>
<p> a log posterior or other target function,
</p>
</li>
<li>
<p> an object of class BayesianOutput created by runMCMC. The latter allows to continue a previous MCMC run.
</p>
</li>
</ol>
<p>Settings for the sampler are provides as a list. You can see the default values by running <code>applySettingsDefault</code> with the respective sampler name. The following settings can be used for all MCMCs:
</p>

<ul>
<li>
<p> startValue (no default) start values for the MCMC. Note that DE family samplers require a matrix of start values. If startvalues are not provided, they are sampled from the prior.
</p>
</li>
<li>
<p> iterations (10000) the MCMC iterations
</p>
</li>
<li>
<p> burnin (0) burnin
</p>
</li>
<li>
<p> thin (1) thinning while sampling
</p>
</li>
<li>
<p> consoleUpdates (100) update frequency for console updates
</p>
</li>
<li>
<p> parallel (NULL) whether parallelization is to be used
</p>
</li>
<li>
<p> message (TRUE) if progress messages are to be printed
</p>
</li>
<li>
<p> nrChains (1) the number of independent MCMC chains to be run. Note that this is not controlling the internal number of chains in population MCMCs such as DE, so if you run nrChains = 3 with a DEzs startValue that is a 4xparameter matrix (= 4 internal chains), you will run independent DEzs runs with 4 internal chains each.
</p>
</li>
</ul>
<p>The MCMC samplers will have a number of additional settings, which are described in the Vignette (run vignette("BayesianTools", package="BayesianTools") and in the help of the samplers. See <code>Metropolis</code> for Metropolis based samplers, <code>DE</code> and <code>DEzs</code> for standard differential evolution samplers, <code>DREAM</code> and <code>DREAMzs</code> for DREAM sampler, <code>Twalk</code> for the Twalk sampler, and <code>smcSampler</code> for rejection and Sequential Monte Carlo sampling. Note that the samplers "AM", "DR", and "DRAM" are special cases of the "Metropolis" sampler and are shortcuts for predefined settings ("AM": adapt=TRUE; "DR": DRlevels=2; "DRAM": adapt=True, DRlevels=2).
</p>
<p>Note that even if you specify parallel = T, this will only turn on internal parallelization of the samplers. The independent samplers controlled by nrChains are not evaluated in parallel, so if time is an issue it will be better to run the MCMCs individually and then combine them via <code>createMcmcSamplerList</code> into one joint object.
</p>
<p>Note that DE and DREAM variants as well as SMC and T-walk require a population to start, which should be provided as a matrix. Default (NULL) sets the population size for DE to 3 x dimensions of parameters, for DREAM to 2 x dimensions of parameters and for DEzs and DREAMzs to three, sampled from the prior. Note also that the zs variants of DE and DREAM require two populations, the current population and the z matrix (a kind of memory) - if you want to set both, provide a list with startvalue$X and startvalue$Z.
</p>
<p>setting startValue for sampling with nrChains &gt; 1 : if you want to provide different start values for the different chains, provide them as a list
</p>


<h3>Value</h3>

<p>The function returns an object of class mcmcSampler (if one chain is run) or mcmcSamplerList. Both have the superclass bayesianOutput. It is possible to extract the samples as a coda object or matrix with <code>getSample</code>.
It is also possible to summarize the posterior as a new prior via <code>createPriorDensity</code>.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><code>createBayesianSetup</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Generate a test likelihood function. 
ll &lt;- generateTestDensityMultiNormal(sigma = "no correlation")

## Create a BayesianSetup object from the likelihood 
## is the recommended way of using the runMCMC() function.
bayesianSetup &lt;- createBayesianSetup(likelihood = ll, lower = rep(-10, 3), upper = rep(10, 3))

## Finally we can run the sampler and have a look
settings = list(iterations = 1000, adapt = FALSE)
out &lt;- runMCMC(bayesianSetup = bayesianSetup, sampler = "Metropolis", settings = settings)

## out is of class bayesianOutput. There are various standard functions 
# implemented for this output

plot(out)
correlationPlot(out)
marginalPlot(out)
summary(out)

## additionally, you can return the sample as a coda object, and make use of the coda functions
# for plotting and analysis

codaObject = getSample(out, start = 500, coda = TRUE)
</code></pre>


</div>