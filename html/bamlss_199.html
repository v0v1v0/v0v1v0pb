<div class="container">

<table style="width: 100%;"><tr>
<td>sliceplot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Plot Slices of Bivariate Functions 
</h2>

<h3>Description</h3>

<p>This function plots slices from user defined values of bivariate surfaces.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sliceplot(x, y = NULL, z = NULL, view = 1, c.select = NULL,
  values = NULL, probs = c(0.1, 0.5, 0.9), grid = 100,
  legend = TRUE, pos = "topright", digits = 2, data = NULL,
  rawdata = FALSE, type = "mba", linear = FALSE,
  extrap = FALSE, k = 40, rug = TRUE, rug.col = NULL,
  jitter = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A matrix or data frame, containing the covariates for which the effect should be plotted 
in the first and second column and at least a third column containing the effect. Another
possibility is to specify the plot via a <code>formula</code>, 
e.g., for simple plotting of bivariate surfaces <code>z ~ x + y</code>, see the examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>If <code>x</code> is a vector the argument <code>y</code> and <code>z</code> must also be supplied as
vectors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>If <code>x</code> is a vector the argument <code>y</code> and <code>z</code> must also be supplied as
vectors, <code>z</code> defines the surface given by <code class="reqn">z = f(x, y)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>view</code></td>
<td>
<p>Which variable should be used for the x-axis of the plot, the other variable will be
used to compute the slices. May also be a <code>character</code> with the name of the corresponding
variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.select</code></td>
<td>
<p>Integer, selects the column that is used in the resulting matrix to be
used as the <code>z</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>values</code></td>
<td>
<p>The values of the <code>x</code> or <code>y</code> variable that should be used for computing
the slices, if set to <code>NULL</code>, slices will be constructed according to the quantiles, see
also argument <code>probs</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>probs</code></td>
<td>
<p>Numeric vector of probabilities with values in [0,1] to be used within function
<code>quantile</code> to compute the <code>values</code> for plotting the slices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>The grid size of the surface where the slices are generated from.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legend</code></td>
<td>
<p>If set to <code>TRUE</code>, a legend with the <code>values</code> that where used for slicing
will be added.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pos</code></td>
<td>
<p>The position of the legend, see also function <code>legend</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>The decimal place the legend values should be rounded.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>If <code>x</code> is a <code>formula</code>, a <code>data.frame</code> or <code>list</code>. By default the 
variables are taken from <code>environment(x)</code>: typically the environment from which 
<code>plot3d</code> is called.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rawdata</code></td>
<td>
<p>If set to <code>TRUE</code>, the data will not be interpolated, only raw data will be
used. This is useful when displaying data on a regular grid.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Character, which type of interpolation method should be used. The default is
<code>type = "akima"</code>, see function <code>interp</code>. The two other options are
<code>type = "mba"</code>, which calls function <code>mba.surf</code> of package <span class="pkg">MBA</span>, or
<code>type = "mgcv"</code>, which uses a spatial smoother withing package <span class="pkg">mgcv</span> for interpolation.
The last option is definitely the slowest, since a full regression model needs to be estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linear</code></td>
<td>
<p>Logical, should linear interpolation be used withing function
<code>interp</code>?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extrap</code></td>
<td>
<p>Logical, should interpolations be computed outside the observation area
(i.e., extrapolated)?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>Integer, the number of basis functions to be used to compute the interpolated surface
when <code>type = "mgcv"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rug</code></td>
<td>
<p>Add a <code>rug</code> to the plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jitter</code></td>
<td>
<p>If set to <code>TRUE</code> a <code>jitter</code>ed 
<code>rug</code> plot is added.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rug.col</code></td>
<td>
<p>Specify the color of the rug representation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Parameters passed to <code>matplot</code> and <code>legend</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Similar to function <code>plot3d</code>, this function first applies bivariate interpolation
on a regular <code>grid</code>, afterwards the slices are computed from the resulting surface. 
</p>


<h3>Note</h3>

<p>Function <code>sliceplot</code> can use the <span class="pkg">akima</span> package to construct smooth interpolated
surfaces, therefore, package <span class="pkg">akima</span> needs to be installed. The <span class="pkg">akima</span> package has an ACM
license that restricts applications to non-commercial usage, see
</p>
<p><a href="https://www.acm.org/publications/policies/software-copyright-notice">https://www.acm.org/publications/policies/software-copyright-notice</a>
</p>
<p>Function <code>sliceplot</code> prints a note referring to the ACM license. This note can be suppressed by
setting
</p>
<p><code>options("use.akima" = TRUE)</code> 
</p>


<h3>See Also</h3>

<p><code>plot2d</code>, <code>plot3d</code>,
<code>plotmap</code>, <code>plotblock</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Generate some data.
set.seed(111)
n &lt;- 500

## Regressors.
d &lt;- data.frame(z = runif(n, -3, 3), w = runif(n, 0, 6))

## Response.
d$y &lt;- with(d, 1.5 + cos(z) * sin(w) + rnorm(n, sd = 0.6))

## Not run: ## Estimate model.
b &lt;- bamlss(y ~ te(z, w), data = d)
summary(b)

## Plot estimated effect.
plot(b, term = "te(z,w)", sliceplot = TRUE)
plot(b, term = "te(z,w)", sliceplot = TRUE, view = 2)
plot(b, term = "te(z,w)", sliceplot = TRUE, view = "w")
plot(b, term = "te(z,w)", sliceplot = TRUE, probs = seq(0, 1, length = 10))

## End(Not run)

## Variations.
d$f1 &lt;- with(d, sin(z) * cos(w))
sliceplot(cbind(z = d$z, w = d$w, f1 = d$f1))

## Same with formula. 
sliceplot(sin(z) * cos(w) ~ z + w, ylab = "f(z)", data = d)

## Compare with plot3d().
plot3d(sin(z) * 1.5 * w ~ z + w, zlab = "f(z,w)", data = d)
sliceplot(sin(z) * 1.5 * w ~ z + w, ylab = "f(z)", data = d)
sliceplot(sin(z) * 1.5 * w ~ z + w, view = 2, ylab = "f(z)", data = d)
</code></pre>


</div>