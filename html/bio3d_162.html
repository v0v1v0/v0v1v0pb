<div class="container">

<table style="width: 100%;"><tr>
<td>nma.pdbs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Ensemble Normal Mode Analysis </h2>

<h3>Description</h3>

<p>Perform normal mode analysis (NMA) on an ensemble of aligned protein
structures.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'pdbs'
nma(pdbs, fit = TRUE, full = FALSE, subspace = NULL,
         rm.gaps = TRUE, varweight=FALSE, 
         outpath = NULL, ncore = 1, progress = NULL, ...)

## S3 method for class 'enma'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pdbs</code></td>
<td>
<p> a numeric matrix of aligned C-alpha xyz Cartesian
coordinates. For example an alignment data structure obtained with
<code>read.fasta.pdb</code> or <code>pdbaln</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p> logical, if TRUE coordinate superposition is performed
prior to normal mode calculations. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>full</code></td>
<td>
<p> logical, if TRUE return the complete, full structure, 
‘nma’ objects. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subspace</code></td>
<td>
<p> number of eigenvectors to store for further
analysis. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rm.gaps</code></td>
<td>
<p> logical, if TRUE obtain the hessian matrices for only
atoms in the aligned positions (non-gap positions in all aligned
structures). Thus, gap positions are removed from output. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varweight</code></td>
<td>
<p> logical, if TRUE perform weighing of the pair force
constants. Alternatively, provide a NxN matrix containing the
weights. See function <code>var.xyz</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outpath</code></td>
<td>
<p> character string specifing the output directory to
which the PDB structures should be written. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncore </code></td>
<td>
<p> number of CPU cores used to do the calculation.
<code>ncore&gt;1</code> requires package ‘parallel’ installed. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> an <code>enma</code> object obtained from <code>nma.pdbs</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress</code></td>
<td>
<p> progress bar for use with shiny web app. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> additional arguments to <code>nma</code>, <code>aa2mass</code>, and
<code>print</code>. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function performs normal mode analysis (NMA) on a set of aligned
protein structures obtained with function <code>read.fasta.pdb</code> or
<code>pdbaln</code>. The main purpose is to provide aligned atomic
fluctuations and mode vectors in an automated fashion. 
</p>
<p>The normal modes are calculated on the full structures as provided 
by object ‘pdbs’. With the input argument ‘full=TRUE’
the full ‘nma’ objects are returned together with output
‘U.subs’ providing the aligned mode vectors. When
‘rm.gaps=TRUE’ the unaligned atoms are ommited from
output. With default arguments ‘rmsip’ provides RMSIP
values for all pairwise structures.
</p>
<p>See examples for more details. 
</p>


<h3>Value</h3>

<p>Returns an ‘enma’ object with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>fluctuations </code></td>
<td>
<p> a numeric matrix containing aligned atomic
fluctuations with one row per input structure. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmsip</code></td>
<td>
<p> a numeric matrix of pair wise RMSIP values (only the ten
lowest frequency modes are included in the calculation). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>U.subspace </code></td>
<td>
<p> a three-dimensional array with aligned
eigenvectors  (corresponding to the subspace defined by the first N
non-trivial eigenvectors (‘U’) of the ‘nma’ object). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p> numeric matrix containing the raw eigenvalues with one row
per input structure. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xyz </code></td>
<td>
<p> an object of class ‘xyz’ containing the Cartesian
coordinates in which the calculation was performed. Coordinates are
superimposed to the first structure of the <code>pdbs</code> object when
‘fit=TRUE’. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>full.nma </code></td>
<td>
<p> a list with a <code>nma</code> object for each input
structure. </p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Skjaerven, L. et al. (2014) <em>BMC Bioinformatics</em> <b>15</b>, 399.
Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695–2696.
</p>


<h3>See Also</h3>

<p>For normal mode analysis on single structure PDB:
<code>nma.pdb</code>
</p>
<p>For the analysis of the resulting ‘eNMA’ object:
<code>mktrj.enma</code>, <code>dccm.enma</code>,
<code>plot.enma</code>, <code>cov.enma</code>.
</p>
<p>Similarity measures:
<code>sip</code>, <code>covsoverlap</code>,
<code>bhattacharyya</code>, <code>rmsip</code>.
</p>
<p>Related functionality:
<code>pdbaln</code>, <code>read.fasta.pdb</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Needs MUSCLE installed - testing excluded

if(check.utility("muscle")) {

## Fetch PDB files and split to chain A only PDB files
ids &lt;- c("1a70_A", "1czp_A", "1frd_A", "1fxi_A", "1iue_A", "1pfd_A")
files &lt;- get.pdb(ids, split = TRUE, path = tempdir())

## Sequence Alignement
pdbs &lt;- pdbaln(files, outfile = tempfile())

## Normal mode analysis on aligned data
modes &lt;- nma(pdbs, rm.gaps=FALSE)

## Plot fluctuation data
plot(modes, pdbs=pdbs)

## Cluster on Fluctuation similariy
sip &lt;- sip(modes)
hc &lt;- hclust(dist(sip))
col &lt;- cutree(hc, k=3)

## Plot fluctuation data
plot(modes, pdbs=pdbs, col=col)

## Remove gaps from output
modes &lt;- nma(pdbs, rm.gaps=TRUE)

## RMSIP is pre-calculated
heatmap(1-modes$rmsip)

## Bhattacharyya coefficient
bc &lt;- bhattacharyya(modes)
heatmap(1-bc)

}

</code></pre>


</div>