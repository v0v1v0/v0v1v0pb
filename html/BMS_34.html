<div class="container">

<table style="width: 100%;"><tr>
<td>pmp.bma</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Posterior Model Probabilities</h2>

<h3>Description</h3>

<p>Returns the posterior model probabilites for the best models encountered by
a 'bma' object
</p>


<h3>Usage</h3>

<pre><code class="language-R">pmp.bma(bmao, oldstyle = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>bmao</code></td>
<td>
<p>A bma object (see argument <code>nmodel</code> in <code>bms</code>),
alternatively an object of class <code>topmod</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>oldstyle</code></td>
<td>
<p>For normal use, leave this at <code>FALSE</code>. It is an
argument for compatibility with older BMS versions - see section 'Notes'</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A call to bms with an MCMC sampler (e.g.
<code>bms(datafls,mcmc="bd",nmodel=100)</code> uses a Metropolis-Hastings
algorithm to sample through the model space - and the frequency of how often
models are drawn converges to the distribution of their posterior marginal
likelihoods.  While sampling, each 'bma' object stores the best models
encountered by its sampling chain with their marginal likelihood and their
MCMC frequencies.
</p>
<p><code>pmp.bma</code> then allows for comparing the posterior model probabilities
(PMPs) for the two different methods, similar to <code>plotConv</code>.  It
calculates the PMPs based on marginal likelihoods (first column) and the
PMPs based on MCMC frequencies (second column) for the best x models stored
in the bma object.
</p>
<p>The correlation of the two columns is an indicator of how well the MCMC
sampler has converged to the actual PMP distribution - it is therefore also
given in the output of <code>summary.bma</code>.
</p>
<p>The second column is slightly different in case the <code>bms</code>
argument <code>mcmc</code> was set to <code>mcmc="enumeration"</code>: In this case, the
second column is also based on marginal likelihoods. The correlation between
the two columns is therefore one.
</p>


<h3>Value</h3>

<p>the result is a matrix, its row names describe the model binaries<br>
There are two columns in the matrix: </p>
<table>
<tr style="vertical-align: top;">
<td><code>PMP (Exact)</code></td>
<td>
<p>posterior model
probabilities based on the posterior likelihoods of the best models in
<code>bmao</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PMP (MCMC)</code></td>
<td>
<p>posterior model probabilities of the best
models in <code>bmao</code> based on their MCMC frequencies, relative to all
models encountered by <code>bmao</code> - see 'Details' </p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>The second column thus shows the PMPs of the best models relative to
all models the call to <code>bms</code> has sampled through (therefore
typically the second column adds up to less than one).  The first column
relates to the likelihoods of the best models, therefore it would add up to
1.  In order estimate for their marginal likelihoods with respect to the
other models (the ones not retained in the best models), these PMP aadding
up to one are multiplied with the sum of PMP of the best models accroding to
MCMC frequencies.  Therefore, the two columns have the same column sum.
</p>
<p>CAUTION: In package versions up to <code>BMS 0.2.5</code>, the first column was
indeed set always equal to one. This behaviour can still be mimicked by
setting <code>oldstyle=TRUE</code>.
</p>


<h3>See Also</h3>

<p><code>plotConv</code> for plotting <code>pmp.bma</code>,
<code>pmpmodel</code> to obtain the PMP for any individual model,
<code>bms</code> for sampling bma objects
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class="language-R">

## sample BMA for growth dataset, MCMC sampler
data(datafls)
mm=bms(datafls[,1:10],nmodel=20, mcmc="bd")

## mmodel likelihoods and MCMC frequencies of best 20 models
print(mm$topmod)

pmp.bma(mm)
#first column: posterior model prob based on model likelihoods,
#  relative to best models in 'mm'
#second column: posterior model prob based MCMC frequencies,
#  relative to all models encountered by 'mm'

#consequently, first column adds up to one
#second column shows how much of the sampled model space is
# contained in the best models
colSums(pmp.bma(mm))


#correlation betwwen the two shows how well the sampler converged
cor(pmp.bma(mm)[,1],pmp.bma(mm)[,2])

#is the same as given in summary.bma
summary(mm)["Corr PMP"]

#plot the two model probabilites
plotConv(mm)

#equivalent to the following chart
plot(pmp.bma(mm)[,2], type="s")
lines(pmp.bma(mm)[,1],col=2)


#moreover, note how the first column is constructed
liks=exp(mm$top$lik())
liks/sum(liks)
pmp.bma(mm)[,1] #these two are equivalent



#the example above does not converge well,
#too few iterations and best models
# this is already better, but also not good
mm=bms(datafls[,1:10],burn=2000,iter=5000,nmodel=200)


# in case the sampler has been 'enumeration' instead of MCMC,
# then both matrix columns are of course equivalent
mm=bms(datafls[,1:10],nmodel=512,mcmc="enumeration")
cor(pmp.bma(mm)[,1],pmp.bma(mm)[,2])
colSums(pmp.bma(mm))


</code></pre>


</div>