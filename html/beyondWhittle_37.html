<div class="container">

<table style="width: 100%;"><tr>
<td>gibbs_bdp_dw</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>BDP-DW method: performing posterior sampling and calculating statistics based on the posterior samples</h2>

<h3>Description</h3>

<p>BDP-DW method: performing posterior sampling and calculating statistics based on the posterior samples
</p>


<h3>Usage</h3>

<pre><code class="language-R">gibbs_bdp_dw(
  data,
  m,
  likelihood_thinning = 1,
  monitor = TRUE,
  print_interval = 100,
  unif_CR = FALSE,
  res_time,
  freq,
  Ntotal = 110000,
  burnin = 60000,
  thin = 10,
  adaptive.batchSize = 50,
  adaptive.targetAcceptanceRate = 0.44,
  M = 1,
  g0.alpha = 1,
  g0.beta = 1,
  k1.theta = 0.01,
  k2.theta = 0.01,
  tau.alpha = 0.001,
  tau.beta = 0.001,
  k1max = 100,
  k2max = 100,
  L = 20,
  bernstein1_l = 0.1,
  bernstein1_r = 0.9,
  bernstein2_l = 0.1,
  bernstein2_r = 0.9
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>time series that needs to be analyzed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>window size needed to calculate moving periodogram.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>likelihood_thinning</code></td>
<td>
<p>the thinning factor of the dynamic Whittle likelihood.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>monitor</code></td>
<td>
<p>a Boolean value (default TRUE) indicating whether to display the real-time status</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print_interval</code></td>
<td>
<p>If monitor = TRUE, then this value indicates number of iterations after which a status is printed to console;
If monitor = FALSE, it does not have any effect</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unif_CR</code></td>
<td>
<p>a Boolean value (default FALSE) indicating whether to calculate the uniform credible region</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>res_time, freq</code></td>
<td>
<p>a set of grid lines in <code class="reqn">[0,1]</code> and <code class="reqn">[0,\pi]</code>, respectively, specifying where to evaluate the estimated tv-PSD</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ntotal</code></td>
<td>
<p>total number of iterations to run the Markov chain</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>number of initial iterations to be discarded</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>thinning number (for post-processing of the posterior sample)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adaptive.batchSize</code></td>
<td>
<p>the batch size for the adaptive MCMC algorithm for sampling tau</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adaptive.targetAcceptanceRate</code></td>
<td>
<p>the target acceptance rate for the adaptive MCMC algorithm for sampling tau</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>DP base measure constant (&gt; 0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g0.alpha, g0.beta</code></td>
<td>
<p>parameters of Beta base measure of DP</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k1.theta</code></td>
<td>
<p>prior parameter for polynomial corresponding to rescaled time (propto exp(-k1.theta*k1*log(k1)))</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k2.theta</code></td>
<td>
<p>prior parameter for polynomial corresponding to rescaled frequency (propto exp(-k2.theta*k2*log(k2)))</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau.alpha, tau.beta</code></td>
<td>
<p>prior parameters for tau (inverse gamma)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k1max</code></td>
<td>
<p>upper bound of the degrees of Bernstein polynomial
corresponding to rescaled time (for pre-computation of basis functions)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k2max</code></td>
<td>
<p>upper bound of the degrees of Bernstein polynomial
corresponding to rescaled frequency (for pre-computation of basis functions)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p>truncation parameter of DP in stick breaking representation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bernstein1_l, bernstein1_r</code></td>
<td>
<p>left and right truncation of Bernstein polynomial basis functions
for rescaled time, 0&lt;=bernstein1_l&lt;bernstein1_r&lt;=1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bernstein2_l, bernstein2_r</code></td>
<td>
<p>left and right truncation of Bernstein polynomial basis functions
for rescaled frequency, 0&lt;=bernstein2_l&lt;bernstein2_r&lt;=1</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>list containing the following fields:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>k1,k2,tau,V,W1,W2</code></td>
<td>
<p>posterior traces of PSD parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lpost</code></td>
<td>
<p>traces log posterior</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tim</code></td>
<td>
<p>total run time</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bf_k1</code></td>
<td>
<p>Savage-Dickey estimate of Bayes factor of hypothesis k1=1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tvpsd.mean,tvpsd.median</code></td>
<td>
<p>posterior mean and pointwise posterior median (matrices of dimension length(rescaled_time) by length(freq))</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tvpsd.p05,tvpsd.p95</code></td>
<td>
<p>90 percent pointwise credibility interval</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tvpsd.u05,tvpsd.u95</code></td>
<td>
<p>90 percent uniform credibility interval if unif_CR = TRUE. Otherwise NA</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Tang et al. (2023)
<em>Bayesian nonparametric spectral analysis of locally stationary processes</em>
ArXiv preprint
&lt;arXiv:2303.11561&gt;
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

##
## Example: Applying BDP-DW method to a multi-peaked tvMA(1) process
##

# set seed
set.seed(200)
# set the length of time series
len_d &lt;- 1500
# generate data from DGP LS2c defined in Section 4.2.2 of Tang et al. (2023). 
# see also ?sim_tvarma12
sim_data &lt;- sim_tvarma12(len_d = 1500, dgp = "LS2", innov_distribution = "c")
# specify grid-points at which the tv-PSD is evaluated
res_time &lt;- seq(0, 1, by = 0.005); freq &lt;- pi * seq(0, 1, by = 0.01)
# calculate the true tv-PSD of DGP LS2c at the pre-specified grid
true_tvPSD &lt;- psd_tvarma12(rescaled_time = res_time, freq = freq, dgp = "LS2")
# plot the true tv-PSD
# type ?plot.bdp_dw_tv_psd for more info
plot(true_tvPSD)

# If you run the example be aware that this may take several minutes
print("This example may take some time to run")
result &lt;- gibbs_bdp_dw(data = sim_data, 
m = 50, 
likelihood_thinning = 2, 
rescaled_time = res_time,
 freq = freq)

# extract bayes factor and examine posterior summary
bayes_factor(result)
summary(result)

# compare estimate with true function
# type ?plot.bdp_dw_result for more info
par(mfrow = c(1,2))

plot(result, which = 1,
zlim = range(result$tvpsd.mean, true_tvPSD$tv_psd)
)
plot(true_tvPSD,
zlim = range(result$tvpsd.mean, true_tvPSD$tv_psd),
main = "true tv-PSD")

par(mfrow = c(1,1))


## End(Not run)
</code></pre>


</div>