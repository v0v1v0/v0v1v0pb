<div class="container">

<table style="width: 100%;"><tr>
<td>cvrisk.boostrq</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Crossvalidation for boostrq</h2>

<h3>Description</h3>

<p>Crossvalidation for boostrq
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'boostrq'
cvrisk(
  object,
  folds = mboost::cv(object$weights, type = "kfold"),
  grid = 0:mstop(object),
  papply = parallel::mclapply,
  mc.preschedule = FALSE,
  fun = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>a boostrq object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>folds</code></td>
<td>
<p>a matrix indicating the weights for the k resampling iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>a vetor of stopping parameters the empirical quantile risk is to be evaluated for.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>papply</code></td>
<td>
<p>(parallel) apply function, defaults to mclapply. To run sequentially
(i.e. not in parallel), one can use lapply.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mc.preschedule</code></td>
<td>
<p>preschedule tasks if are parallelized using mclapply (default: FALSE)?
For details see mclapply.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>if fun is NULL, the out-of-sample risk is returned. fun, as a function of object, may
extract any other characteristic of the cross-validated models. These are returned as is.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to callies</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Cross-validated Boosting regression quantiles
</p>


<h3>Examples</h3>

<pre><code class="language-R">boosted.rq &lt;-
boostrq(
 formula = mpg ~ brq(cyl * hp) + brq(am + wt),
 data = mtcars,
 mstop = 200,
 nu = 0.1,
 tau = 0.5
)

set.seed(101)

cvk.out &lt;-
cvrisk(
 boosted.rq,
 grid = 0:mstop(boosted.rq),
 folds = mboost::cv(boosted.rq$weights, type = "kfold", B = 5)
)

cvk.out

plot(cvk.out)

mstop(cvk.out)

boosted.rq[mstop(cvk.out)]

</code></pre>


</div>