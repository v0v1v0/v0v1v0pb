<div class="container">

<table style="width: 100%;"><tr>
<td>brm_model</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit an MMRM.</h2>

<h3>Description</h3>

<p>Fit an MMRM model using <code>brms</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">brm_model(
  data,
  formula,
  ...,
  prior = NULL,
  family = brms::brmsfamily(family = "gaussian"),
  imputed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A classed data frame from <code>brm_data()</code>, or an informative
prior archetype from a function like <code>brm_archetype_successive_cells()</code>.
Unless you supplied <code>model_missing_outcomes = TRUE</code> in <code>brm_formula()</code>,
<code>brm_model()</code> automatically rows with missing outcomes
just prior to fitting the model with <code>brms::brm()</code>.
The <code>brms.mmrm_data</code> attribute
in the output object is always the version of the data prior to
removing these rows. See the <code>data</code> element of the returned <code>brms</code>
object for the final data actually supplied to the model.
</p>
<p>If you supply a non-<code>NULL</code> value for the <code>imputed</code>
argument, then the <code>data</code> argument is ignored and the MMRM is fit
successively to each dataset in <code>imputed</code> using <code>brms::brm_multiple()</code>.
Posterior draws are combined automatically for downstream post-processing
unless you set <code>combine = FALSE</code> in <code>brm_model()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>An object of class <code>"brmsformula"</code> from <code>brm_formula()</code>
or <code>brms::brmsformula()</code>. Should include the full mapping
of the model, including fixed effects, residual correlation,
and heterogeneity in the discrete-time-specific residual variance
components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments to <code>brms::brm()</code> or <code>brms::brm_multiple()</code>
other than <code>data</code>, <code>formula</code>, <code>prior</code>, and <code>family</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>
<p>Either <code>NULL</code> for default priors
or a <code>"brmsprior"</code> object from <code>brms::prior()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>A <code>brms</code> family object generated by <code>brms::brmsfamily()</code>.
Must fit a continuous outcome variable and have the identity link.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>imputed</code></td>
<td>
<p>Either <code>NULL</code> (default), list of
datasets generated with multiple imputation, or a <code>"mids"</code> object
from the <code>mice</code> package. The <code>rbmi</code> package may offer a more appropriate
method for imputation for MMRMs than <code>mice</code>. It is your responsibility
to choose an imputation method appropriate for the data and model.
</p>
<p>If not <code>NULL</code>, then the MMRM is fit
successively to each dataset in <code>imputed</code> using <code>brms::brm_multiple()</code>.
Posterior draws are combined automatically for downstream post-processing
unless you set <code>combine = FALSE</code> in <code>brm_model()</code>, so everything at
the level of <code>brm_marginal_draws()</code> will be exactly the same as
a non-imputation workflow.
</p>
<p>Even if you supply <code>imputed</code>, please also supply the original
non-imputed dataset in the <code>data</code> argument to help with
downstream post-processing.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A fitted model object from <code>brms</code>, with new list elements
<code>brms.mmrm_data</code> and <code>brms.mmrm_formula</code> to capture the data
and formula supplied to <code>brm_model()</code>. See the explanation of the
<code>data</code> argument for how the data is handled and how it relates
to the data returned in the <code>brms.mmrm_data</code> attribute.
</p>


<h3>Parameterization</h3>

<p>For a formula on a <code>brm_data()</code> dataset,
the formula is not the only factor
that determines the fixed effect mapping.
The ordering of the categorical variables in the data,
as well as the <code>contrast</code> option in R, affect the
construction of the model matrix. To see the model
matrix that will ultimately be used in <code>brm_model()</code>,
run <code>brms::make_standata()</code> and examine the <code>X</code> element
of the returned list. See the examples below for a
demonstration.
</p>


<h3>See Also</h3>

<p>Other models: 
<code>brm_formula()</code>,
<code>brm_formula_sigma()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (identical(Sys.getenv("BRM_EXAMPLES", unset = ""), "true")) {
set.seed(0L)
data &lt;- brm_data(
  data = brm_simulate_simple()$data,
  outcome = "response",
  group = "group",
  time = "time",
  patient = "patient",
  reference_group = "group_1",
  reference_time = "time_1"
)
formula &lt;- brm_formula(
  data = data,
  baseline = FALSE,
  baseline_time = FALSE
)
# Optional: set the contrast option, which determines the model matrix.
options(contrasts = c(unordered = "contr.SAS", ordered = "contr.poly"))
# See the fixed effect mapping you get from the data:
head(brms::make_standata(formula = formula, data = data)$X)
# Specify a different contrast method to use an alternative
# mapping when fitting the model with brm_model():
options(
  contrasts = c(unordered = "contr.treatment", ordered = "contr.poly")
)
# different model matrix than before:
head(brms::make_standata(formula = formula, data = data)$X)
tmp &lt;- utils::capture.output(
  suppressMessages(
    suppressWarnings(
      model &lt;- brm_model(
        data = data,
        formula = formula,
        chains = 1,
        iter = 100,
        refresh = 0
      )
    )
  )
)
# The output is a brms model fit object with added list
# elements "brms.mmrm_data" and "brms.mmrm_formula" to track the dataset
# and formula used to fit the model.
model$brms.mmrm_data
model$brms.mmrm_formula
# Otherwise, the fitted model object acts exactly like a brms fitted model.
suppressWarnings(print(model))
brms::prior_summary(model)
}
</code></pre>


</div>