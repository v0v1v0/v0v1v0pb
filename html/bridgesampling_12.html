<div class="container">

<table style="width: 100%;"><tr>
<td>bridge_sampler</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Log Marginal Likelihood via Bridge Sampling</h2>

<h3>Description</h3>

<p>Computes log marginal likelihood via bridge sampling.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bridge_sampler(samples, ...)

## S3 method for class 'stanfit'
bridge_sampler(
  samples = NULL,
  stanfit_model = samples,
  repetitions = 1,
  method = "normal",
  cores = 1,
  use_neff = TRUE,
  maxiter = 1000,
  silent = FALSE,
  verbose = FALSE,
  ...
)

## S3 method for class 'mcmc.list'
bridge_sampler(
  samples = NULL,
  log_posterior = NULL,
  ...,
  data = NULL,
  lb = NULL,
  ub = NULL,
  repetitions = 1,
  param_types = rep("real", ncol(samples[[1]])),
  method = "normal",
  cores = 1,
  use_neff = TRUE,
  packages = NULL,
  varlist = NULL,
  envir = .GlobalEnv,
  rcppFile = NULL,
  maxiter = 1000,
  silent = FALSE,
  verbose = FALSE
)

## S3 method for class 'mcmc'
bridge_sampler(
  samples = NULL,
  log_posterior = NULL,
  ...,
  data = NULL,
  lb = NULL,
  ub = NULL,
  repetitions = 1,
  method = "normal",
  cores = 1,
  use_neff = TRUE,
  packages = NULL,
  varlist = NULL,
  envir = .GlobalEnv,
  rcppFile = NULL,
  maxiter = 1000,
  param_types = rep("real", ncol(samples)),
  silent = FALSE,
  verbose = FALSE
)

## S3 method for class 'matrix'
bridge_sampler(
  samples = NULL,
  log_posterior = NULL,
  ...,
  data = NULL,
  lb = NULL,
  ub = NULL,
  repetitions = 1,
  method = "normal",
  cores = 1,
  use_neff = TRUE,
  packages = NULL,
  varlist = NULL,
  envir = .GlobalEnv,
  rcppFile = NULL,
  maxiter = 1000,
  param_types = rep("real", ncol(samples)),
  silent = FALSE,
  verbose = FALSE
)

## S3 method for class 'stanreg'
bridge_sampler(
  samples,
  repetitions = 1,
  method = "normal",
  cores = 1,
  use_neff = TRUE,
  maxiter = 1000,
  silent = FALSE,
  verbose = FALSE,
  ...
)

## S3 method for class 'rjags'
bridge_sampler(
  samples = NULL,
  log_posterior = NULL,
  ...,
  data = NULL,
  lb = NULL,
  ub = NULL,
  repetitions = 1,
  method = "normal",
  cores = 1,
  use_neff = TRUE,
  packages = NULL,
  varlist = NULL,
  envir = .GlobalEnv,
  rcppFile = NULL,
  maxiter = 1000,
  silent = FALSE,
  verbose = FALSE
)

## S3 method for class 'runjags'
bridge_sampler(
  samples = NULL,
  log_posterior = NULL,
  ...,
  data = NULL,
  lb = NULL,
  ub = NULL,
  repetitions = 1,
  method = "normal",
  cores = 1,
  use_neff = TRUE,
  packages = NULL,
  varlist = NULL,
  envir = .GlobalEnv,
  rcppFile = NULL,
  maxiter = 1000,
  silent = FALSE,
  verbose = FALSE
)

## S3 method for class 'MCMC_refClass'
bridge_sampler(
  samples,
  repetitions = 1,
  method = "normal",
  cores = 1,
  use_neff = TRUE,
  maxiter = 1000,
  silent = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>samples</code></td>
<td>
<p>an <code>mcmc.list</code> object, a fitted <code>stanfit</code> object, a
<code>stanreg</code> object, an <code>rjags</code> object, a <code>runjags</code> object, or a
<code>matrix</code> with posterior samples (<code>colnames</code> need to correspond to
parameter names in <code>lb</code> and <code>ub</code>)  with posterior samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to <code>log_posterior</code>. Ignored for
the <code>stanfit</code> and <code>stanreg</code> methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stanfit_model</code></td>
<td>
<p>for the <code>stanfit</code> method, an additional object of
class <code>"stanfit"</code> with the same model as <code>samples</code>, which will be
used for evaluating the <code>log_posterior</code> (i.e., it does not need to
contain any samples). The default is to use <code>samples</code>. In case
<code>samples</code> was compiled in a different R session or on another computer
with a different OS or setup, the <code>samples</code> model usually cannot be
used for evaluation. In this case, one can compile the model on the current
computer with <code>iter = 0</code> and pass it here (this usually needs to be
done before <code>samples</code> is loaded).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>repetitions</code></td>
<td>
<p>number of repetitions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>either <code>"normal"</code> or <code>"warp3"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>number of cores used for evaluating <code>log_posterior</code>. On
unix-like systems (where <code>.Platform$OS.type == "unix"</code> evaluates to
<code>TRUE</code>; e.g., Linux and Mac OS) forking via <code>mclapply</code> is
used. Hence elements needed for evaluation should be in the
<code>.GlobalEnv</code>. For other systems (e.g., Windows)
<code>makeCluster</code> is used and further arguments specified below will
be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_neff</code></td>
<td>
<p>Boolean which determines whether the effective sample size is
used in the optimal bridge function. Default is TRUE. If FALSE, the number
of samples is used instead. If <code>samples</code> is a <code>matrix</code>, it is
assumed that the <code>matrix</code> contains the samples of one chain in order.
If <code>samples</code> come from more than one chain, we recommend to use an
<code>mcmc.list</code> object for optimal performance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>maximum number of iterations for the iterative updating scheme.
Default is 1,000 to avoid infinite loops.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>Boolean which determines whether to print the number of
iterations of the updating scheme to the console. Default is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Boolean. Should internal debug information be printed to
console? Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log_posterior</code></td>
<td>
<p>function or name of function that takes a parameter
vector and the <code>data</code> as input and returns the log of the unnormalized
posterior density (i.e., a scalar value). If the function name is passed,
the function should exist in the <code>.GlobalEnv</code>. For special behavior if
<code>cores &gt; 1</code> see <code>Details</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>data object which is used in <code>log_posterior</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lb</code></td>
<td>
<p>named vector with lower bounds for parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ub</code></td>
<td>
<p>named vector with upper bounds for parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param_types</code></td>
<td>
<p>character vector of length <code>ncol(samples)</code> with
<code>"real"</code>, <code>"simplex"</code> or <code>"circular"</code>. For all regular
bounded or unbounded continuous parameters, this should just be
<code>"real"</code>. However, if there are parameters which lie on a simplex or on
the circle, this should be noted here. Simplex parameters are parameters
which are bounded below by zero and collectively sum to one, such as weights
in a mixture model. For these, the stick-breaking transformation is
performed as described in the Stan reference manual. The circular variables
are given a numerical representation to which the normal distribution is
most likely a good fit. Only possible to use with
<code>bridge_sampler.matrix</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>packages</code></td>
<td>
<p>character vector with names of packages needed for evaluating
<code>log_posterior</code> in parallel (only relevant if <code>cores &gt; 1</code> and
<code>.Platform$OS.type != "unix"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varlist</code></td>
<td>
<p>character vector with names of variables needed for evaluating
<code>log_posterior</code> (only needed if <code>cores &gt; 1</code>  and
<code>.Platform$OS.type != "unix"</code> as these objects will be exported to the
nodes). These objects need to exist in <code>envir</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>envir</code></td>
<td>
<p>specifies the environment for <code>varlist</code> (only needed if
<code>cores &gt; 1</code>  and <code>.Platform$OS.type != "unix"</code> as these objects
will be exported to the nodes). Default is <code>.GlobalEnv</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rcppFile</code></td>
<td>
<p>in case <code>cores &gt; 1</code> and <code>log_posterior</code> is an
<code>Rcpp</code> function, <code>rcppFile</code> specifies the path to the cpp file
(will be compiled on all cores).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Bridge sampling is implemented as described in Meng and Wong (1996,
see equation 4.1) using the "optimal" bridge function. When <code>method =
 "normal"</code>, the proposal distribution is a multivariate normal distribution
with mean vector equal to the sample mean vector of <code>samples</code> and
covariance matrix equal to the sample covariance matrix of <code>samples</code>.
For a recent tutorial on bridge sampling, see Gronau et al. (in press).
</p>
<p>When <code>method = "warp3"</code>, the proposal distribution is a standard
multivariate normal distribution and the posterior distribution is "warped"
(Meng &amp; Schilling, 2002) so that it has the same mean vector, covariance
matrix, and skew as the samples. <code>method = "warp3"</code> takes approximately
twice as long as <code>method = "normal"</code>.
</p>
<p>Note that for the <code>matrix</code> method, the lower and upper bound of a
parameter cannot be a function of the bounds of another parameter.
Furthermore, constraints that depend on multiple parameters of the model are
not supported. This usually excludes, for example, parameters that
constitute a covariance matrix or sets of parameters that need to sum to
one.
</p>
<p>However, if the retransformations are part of the model itself and the
<code>log_posterior</code> accepts parameters on the real line and performs the
appropriate Jacobian adjustments, such as done for <code>stanfit</code> and
<code>stanreg</code> objects, such constraints are obviously possible (i.e., we
currently do not know of any parameter supported within Stan that does not
work with the current implementation through a <code>stanfit</code> object).
</p>


<h4>Parallel Computation</h4>

<p> On unix-like systems forking is used via
<code>mclapply</code>. Hence elements needed for evaluation of
<code>log_posterior</code> should be in the <code>.GlobalEnv</code>.
</p>
<p>On other OSes (e.g., Windows), things can get more complicated. For normal
parallel computation, the <code>log_posterior</code> function can be passed as
both function and function name. If the latter, it needs to exist in the
environment specified in the <code>envir</code> argument. For parallel computation
when using an <code>Rcpp</code> function, <code>log_posterior</code> can only be passed
as the function name (i.e., character). This function needs to result from
calling <code>sourceCpp</code> on the file specified in <code>rcppFile</code>.
</p>
<p>Due to the way <code>rstan</code> currently works, parallel computations with
<code>stanfit</code> and <code>stanreg</code> objects only work with forking (i.e., NOT
on Windows). </p>



<h3>Value</h3>

<p>if <code>repetitions = 1</code>, returns a list of class <code>"bridge"</code>
with components: </p>
 <ul>
<li> <p><code>logml</code>: estimate of log marginal
likelihood. </p>
</li>
<li> <p><code>niter</code>: number of iterations of the iterative
updating scheme. </p>
</li>
<li> <p><code>method</code>: bridge sampling method that was used
to obtain the estimate. </p>
</li>
<li> <p><code>q11</code>: log posterior evaluations for
posterior samples. </p>
</li>
<li> <p><code>q12</code>: log proposal evaluations for posterior
samples. </p>
</li>
<li> <p><code>q21</code>: log posterior evaluations for samples from
proposal. </p>
</li>
<li> <p><code>q22</code>: log proposal evaluations for samples from
proposal. </p>
</li>
</ul>
<p> if <code>repetitions &gt; 1</code>, returns a list of class
<code>"bridge_list"</code> with components: </p>
 <ul>
<li> <p><code>logml</code>: numeric
vector with estimates of log marginal likelihood. </p>
</li>
<li> <p><code>niter</code>:
numeric vector with number of iterations of the iterative updating scheme
for each repetition. </p>
</li>
<li> <p><code>method</code>: bridge sampling method that was
used to obtain the estimates. </p>
</li>
<li> <p><code>repetitions</code>: number of
repetitions. </p>
</li>
</ul>
<h3>Warning</h3>

<p>Note that the results depend strongly on the parameter
priors. Therefore, it is strongly advised to think carefully about the
priors before calculating marginal likelihoods. For example, the prior
choices implemented in <span class="pkg">rstanarm</span> or <span class="pkg">brms</span> might not be optimal
from a testing point of view. We recommend to use priors that have been
chosen from a testing and not a purely estimation perspective.
</p>
<p>Also note that for testing, the number of posterior samples usually needs to
be substantially larger than for estimation.
</p>


<h3>Note</h3>

<p>To be able to use a <code>stanreg</code> object for <code>samples</code>, the user
crucially needs to have specified the <code>diagnostic_file</code> when fitting
the model in <span class="pkg">rstanarm</span>.
</p>


<h3>Author(s)</h3>

<p>Quentin F. Gronau and Henrik Singmann. Parallel computing (i.e.,
<code>cores &gt; 1</code>) and the <code>stanfit</code> method use code from <code>rstan</code>
by Jiaqing Guo, Jonah Gabry, and Ben Goodrich. Ben Goodrich added the
<code>stanreg</code> method. Kees Mulder added methods for simplex and circular
variables.
</p>


<h3>References</h3>

<p>Gronau, Q. F., Singmann, H., &amp; Wagenmakers, E.-J. (2020). bridgesampling: An
R Package for Estimating Normalizing Constants. <em>Journal of Statistical
Software, 92</em>. doi: <a href="https://doi.org/10.18637/jss.v092.i10">10.18637/jss.v092.i10</a>
</p>
<p>Gronau, Q. F., Sarafoglou, A., Matzke, D., Ly, A., Boehm, U.,
Marsman, M., Leslie, D. S., Forster, J. J., Wagenmakers, E.-J., &amp;
Steingroever, H. (in press). A tutorial on bridge sampling. <em>Journal of
Mathematical Psychology</em>. <a href="https://arxiv.org/abs/1703.05984">https://arxiv.org/abs/1703.05984</a> <br><code>vignette("bridgesampling_tutorial")</code>
</p>
<p>Gronau, Q. F., Wagenmakers, E.-J., Heck, D. W., &amp; Matzke, D. (2017). <em>A
simple method for comparing complex models: Bayesian model comparison for
hierarchical multinomial processing tree models using Warp-III bridge
sampling</em>. Manuscript submitted for publication.
<a href="https://psyarxiv.com/yxhfm">https://psyarxiv.com/yxhfm</a>
</p>
<p>Meng, X.-L., &amp; Wong, W. H. (1996). Simulating ratios of normalizing
constants via a simple identity: A theoretical exploration. <em>Statistica
Sinica, 6</em>, 831-860.
<a href="http://www3.stat.sinica.edu.tw/statistica/j6n4/j6n43/j6n43.htm">http://www3.stat.sinica.edu.tw/statistica/j6n4/j6n43/j6n43.htm</a>
</p>
<p>Meng, X.-L., &amp; Schilling, S. (2002). Warp bridge sampling. <em>Journal of
Computational and Graphical Statistics, 11(3)</em>, 552-586.
doi: <a href="https://doi.org/10.1198/106186002457">10.1198/106186002457</a>
</p>
<p>Overstall, A. M., &amp; Forster, J. J. (2010). Default Bayesian model
determination methods for generalised linear mixed models.
<em>Computational Statistics &amp; Data Analysis, 54</em>, 3269-3288.
doi: <a href="https://doi.org/10.1016/j.csda.2010.03.008">10.1016/j.csda.2010.03.008</a>
</p>


<h3>See Also</h3>

<p><code>bf</code> allows the user to calculate Bayes factors and
<code>post_prob</code> allows the user to calculate posterior model
probabilities from bridge sampling estimates. <code>bridge-methods</code>
lists some additional methods that automatically invoke the
<code>error_measures</code> function.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## ------------------------------------------------------------------------
## Example 1: Estimating the Normalizing Constant of a Two-Dimensional
##            Standard Normal Distribution
## ------------------------------------------------------------------------

library(bridgesampling)
library(mvtnorm)

samples &lt;- rmvnorm(1e4, mean = rep(0, 2), sigma = diag(2))
colnames(samples) &lt;- c("x1", "x2")
log_density &lt;- function(samples.row, data) {
  -.5*t(samples.row) %*% samples.row
}

lb &lt;- rep(-Inf, 2)
ub &lt;- rep(Inf, 2)
names(lb) &lt;- names(ub) &lt;- colnames(samples)
bridge_result &lt;- bridge_sampler(samples = samples, log_posterior = log_density,
                                data = NULL, lb = lb, ub = ub, silent = TRUE)

# compare to analytical value
analytical &lt;- log(2*pi)
print(cbind(bridge_result$logml, analytical))

## Not run: 

## ------------------------------------------------------------------------
## Example 2: Hierarchical Normal Model
## ------------------------------------------------------------------------

# for a full description of the example, see
vignette("bridgesampling_example_jags")

library(R2jags)

### generate data ###

set.seed(12345)

mu &lt;- 0
tau2 &lt;- 0.5
sigma2 &lt;- 1

n &lt;- 20
theta &lt;- rnorm(n, mu, sqrt(tau2))
y &lt;- rnorm(n, theta, sqrt(sigma2))


### set prior parameters
alpha &lt;- 1
beta &lt;- 1
mu0 &lt;- 0
tau20 &lt;- 1

### functions to get posterior samples ###

### H0: mu = 0

getSamplesModelH0 &lt;- function(data, niter = 52000, nburnin = 2000, nchains = 3) {

  model &lt;- "
    model {
      for (i in 1:n) {
        theta[i] ~ dnorm(0, invTau2)
          y[i] ~ dnorm(theta[i], 1/sigma2)
      }
      invTau2 ~ dgamma(alpha, beta)
      tau2 &lt;- 1/invTau2
    }"

  s &lt;- jags(data, parameters.to.save = c("theta", "invTau2"),
            model.file = textConnection(model),
            n.chains = nchains, n.iter = niter,
            n.burnin = nburnin, n.thin = 1)

  return(s)

}

### H1: mu != 0

getSamplesModelH1 &lt;- function(data, niter = 52000, nburnin = 2000,
                              nchains = 3) {

  model &lt;- "
    model {
      for (i in 1:n) {
        theta[i] ~ dnorm(mu, invTau2)
        y[i] ~ dnorm(theta[i], 1/sigma2)
      }
      mu ~ dnorm(mu0, 1/tau20)
      invTau2 ~ dgamma(alpha, beta)
      tau2 &lt;- 1/invTau2
    }"

  s &lt;- jags(data, parameters.to.save = c("theta", "mu", "invTau2"),
            model.file = textConnection(model),
            n.chains = nchains, n.iter = niter,
            n.burnin = nburnin, n.thin = 1)

  return(s)

}

### get posterior samples ###

# create data lists for Jags
data_H0 &lt;- list(y = y, n = length(y), alpha = alpha, beta = beta, sigma2 = sigma2)
data_H1 &lt;- list(y = y, n = length(y), mu0 = mu0, tau20 = tau20, alpha = alpha,
                beta = beta, sigma2 = sigma2)

# fit models
samples_H0 &lt;- getSamplesModelH0(data_H0)
samples_H1 &lt;- getSamplesModelH1(data_H1)


### functions for evaluating the unnormalized posteriors on log scale ###
log_posterior_H0 &lt;- function(samples.row, data) {

  mu &lt;- 0
  invTau2 &lt;- samples.row[[ "invTau2" ]]
  theta &lt;- samples.row[ paste0("theta[", seq_along(data$y), "]") ]

  sum(dnorm(data$y, theta, data$sigma2, log = TRUE)) +
    sum(dnorm(theta, mu, 1/sqrt(invTau2), log = TRUE)) +
    dgamma(invTau2, data$alpha, data$beta, log = TRUE)

}

log_posterior_H1 &lt;- function(samples.row, data) {

  mu &lt;- samples.row[[ "mu" ]]
  invTau2 &lt;- samples.row[[ "invTau2" ]]
  theta &lt;- samples.row[ paste0("theta[", seq_along(data$y), "]") ]

  sum(dnorm(data$y, theta, data$sigma2, log = TRUE)) +
    sum(dnorm(theta, mu, 1/sqrt(invTau2), log = TRUE)) +
    dnorm(mu, data$mu0, sqrt(data$tau20), log = TRUE) +
    dgamma(invTau2, data$alpha, data$beta, log = TRUE)

}

# specify parameter bounds H0
cn &lt;- colnames(samples_H0$BUGSoutput$sims.matrix)
cn &lt;- cn[cn != "deviance"]
lb_H0 &lt;- rep(-Inf, length(cn))
ub_H0 &lt;- rep(Inf, length(cn))
names(lb_H0) &lt;- names(ub_H0) &lt;- cn
lb_H0[[ "invTau2" ]] &lt;- 0

# specify parameter bounds H1
cn &lt;- colnames(samples_H1$BUGSoutput$sims.matrix)
cn &lt;- cn[cn != "deviance"]
lb_H1 &lt;- rep(-Inf, length(cn))
ub_H1 &lt;- rep(Inf, length(cn))
names(lb_H1) &lt;- names(ub_H1) &lt;- cn
lb_H1[[ "invTau2" ]] &lt;- 0


# compute log marginal likelihood via bridge sampling for H0
H0.bridge &lt;- bridge_sampler(samples = samples_H0, data = data_H0,
                            log_posterior = log_posterior_H0, lb = lb_H0,
                            ub = ub_H0, silent = TRUE)
print(H0.bridge)

# compute log marginal likelihood via bridge sampling for H1
H1.bridge &lt;- bridge_sampler(samples = samples_H1, data = data_H1,
                            log_posterior = log_posterior_H1, lb = lb_H1,
                            ub = ub_H1, silent = TRUE)
print(H1.bridge)

# compute percentage error
print(error_measures(H0.bridge)$percentage)
print(error_measures(H1.bridge)$percentage)

# compute Bayes factor
BF01 &lt;- bf(H0.bridge, H1.bridge)
print(BF01)

# compute posterior model probabilities (assuming equal prior model probabilities)
post1 &lt;- post_prob(H0.bridge, H1.bridge)
print(post1)

# compute posterior model probabilities (using user-specified prior model probabilities)
post2 &lt;- post_prob(H0.bridge, H1.bridge, prior_prob = c(.6, .4))
print(post2)


## End(Not run)

## Not run: 

## ------------------------------------------------------------------------
## Example 3: rstanarm
## ------------------------------------------------------------------------
library(rstanarm)

# N.B.: remember to specify the diagnostic_file

fit_1 &lt;- stan_glm(mpg ~ wt + qsec + am, data = mtcars,
                  chains = 2, cores = 2, iter = 5000,
                  diagnostic_file = file.path(tempdir(), "df.csv"))
bridge_1 &lt;- bridge_sampler(fit_1)
fit_2 &lt;- update(fit_1, formula = . ~ . + cyl)
bridge_2 &lt;- bridge_sampler(fit_2, method = "warp3")
bf(bridge_1, bridge_2)


## End(Not run)

</code></pre>


</div>