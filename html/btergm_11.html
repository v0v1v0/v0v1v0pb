<div class="container">

<table style="width: 100%;"><tr>
<td>btergm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate a TERGM by MPLE with temporal bootstrapping</h2>

<h3>Description</h3>

<p>Estimate a TERGM by MPLE with temporal bootstrapping.
</p>


<h3>Usage</h3>

<pre><code class="language-R">btergm(
  formula,
  R = 500,
  offset = FALSE,
  returndata = FALSE,
  parallel = c("no", "multicore", "snow"),
  ncpus = 1,
  cl = NULL,
  control.ergm = NULL,
  usefastglm = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>Formula for the TERGM. Model construction works like in the
<span class="pkg">ergm</span> package with the same model terms etc. (for a list of terms, see
<code>help("ergm-terms")</code>). The networks to be modeled on the
left-hand side of the equation must be given either as a list of network
objects with more recent networks last (i.e., chronological order) or as a
list of matrices with more recent matrices at the end. <code>dyadcov</code> and
<code>edgecov</code> terms accept time-independent covariates (as <code>network</code>
or <code>matrix</code> objects) or time-varying covariates (as a list of networks
or matrices with the same length as the list of networks to be modeled).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>Number of bootstrap replications. The higher the number of
replications, the more accurate but also the slower is the estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>If <code>offset = TRUE</code> is set, a list of offset matrices
(one for each time step) with structural zeros is handed over to the
pseudolikelihood preparation routine. The offset matrices contain
structural zeros where either the dependent networks or any of the
covariates have missing nodes (if <code>auto.adjust = TRUE</code> is used). All
matrices and network objects are inflated to the dimensions of the largest
object, and the offset matrices inform the estimation preparation routine
which dyads are constrained to be absent. After MPLE data preparation, the
dyads with these structural zeros are removed before the GLM is estimated.
If <code>offset = FALSE</code> is set (the default behavior), all nodes that are
not present across all covariates and networks within a time step are
removed completely from the respective object(s) before estimation begins.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returndata</code></td>
<td>
<p>Return the processed input data instead of estimating and
returning the model? In the <code>btergm</code> case, this will return a data
frame with the dyads of the dependent variable/network and the change
statistics for all covariates. In the <code>mtergm</code> case, this will return
a list object with the blockdiagonal network object for the dependent
variable and blockdiagonal matrices for all dyadic covariates and the
offset matrix for the structural zeros.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>Use multiple cores in a computer or nodes in a cluster to
speed up bootstrapping computations. The default value <code>"no"</code> means
parallel computing is switched off. If <code>"multicore"</code> is used, the
<code>mclapply</code> function from the <span class="pkg">parallel</span> package (formerly in the
<span class="pkg">multicore</span> package) is used for parallelization. This should run on
any kind of system except MS Windows because it is based on forking. It is
usually the fastest type of parallelization. If <code>"snow"</code> is used, the
<code>parLapply</code> function from the <span class="pkg">parallel</span> package (formerly in the
<span class="pkg">snow</span> package) is used for parallelization. This should run on any
kind of system including cluster systems and including MS Windows. It is
slightly slower than the former alternative if the same number of cores is
used. However, <code>"snow"</code> provides support for MPI clusters with a large
amount of cores, which <span class="pkg">multicore</span> does not offer (see also the
<code>cl</code> argument). The backend for the bootstrapping procedure is the
<span class="pkg">boot</span> package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncpus</code></td>
<td>
<p>The number of CPU cores used for parallel computing (only if
<code>parallel</code> is activated). If the number of cores should be detected
automatically on the machine where the code is executed, one can set
<code>ncpus = detectCores()</code> after loading the <span class="pkg">parallel</span> package.
On some HPC clusters, the number of available cores is saved as an
environment variable; for example, if MOAB is used, the number of
available cores can sometimes be accessed using
<code>Sys.getenv("MOAB_PROCCOUNT")</code>, depending on the implementation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>An optional <span class="pkg">parallel</span> or <span class="pkg">snow</span> cluster for use if
<code>parallel = "snow"</code>. If not supplied, a PSOCK cluster is created
temporarily on the local machine.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control.ergm</code></td>
<td>
<p>ergm controls for <code>ergmMPLE</code> calls. See
<code>control.ergm</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>usefastglm</code></td>
<td>
<p>Controls whether to use the <code>fastglm</code>
estimation routine from the <span class="pkg">fastglm</span> package with <code>method = 3</code>.
Defaults to <code>FALSE</code> (and then uses
<code>speedglm.wfit</code> instead if available).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Print details about data preprocessing and estimation
settings.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments to be handed over to the
<code>boot</code> function.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>btergm</code> function computes temporal exponential random graph models
(TERGM) by bootstrapped pseudolikelihood, as described in Desmarais and
Cranmer (2012). It is faster than MCMC-MLE but only asymptotically unbiased
the longer the time series of networks because it uses temporal bootstrapping
to correct the standard errors.
</p>


<h3>Author(s)</h3>

<p>Philip Leifeld, Skyler J. Cranmer, Bruce A. Desmarais
</p>


<h3>References</h3>

<p>Cranmer, Skyler J., Tobias Heinrich and Bruce A. Desmarais
(2014): Reciprocity and the Structural Determinants of the International
Sanctions Network. <em>Social Networks</em> 36(1): 5-22.
<a href="https://doi.org/10.1016/j.socnet.2013.01.001">doi:10.1016/j.socnet.2013.01.001</a>.
</p>
<p>Desmarais, Bruce A. and Skyler J. Cranmer (2012): Statistical Mechanics of
Networks: Estimation and Uncertainty. <em>Physica A</em> 391: 1865â€“1876.
<a href="https://doi.org/10.1016/j.physa.2011.10.018">doi:10.1016/j.physa.2011.10.018</a>.
</p>
<p>Desmarais, Bruce A. and Skyler J. Cranmer (2010): Consistent Confidence
Intervals for Maximum Pseudolikelihood Estimators. <em>Neural Information
Processing Systems 2010 Workshop on Computational Social Science and the
Wisdom of Crowds</em>.
</p>
<p>Leifeld, Philip, Skyler J. Cranmer and Bruce A. Desmarais (2017):
Temporal Exponential Random Graph Models with btergm: Estimation and
Bootstrap Confidence Intervals. <em>Journal of Statistical Software</em>
83(6): 1-36. <a href="https://doi.org/10.18637/jss.v083.i06">doi:10.18637/jss.v083.i06</a>.
</p>


<h3>See Also</h3>

<p><code>mtergm</code> <code>tbergm</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(5)

networks &lt;- list()
for (i in 1:10) {              # create 10 random networks with 10 actors
  mat &lt;- matrix(rbinom(100, 1, .25), nrow = 10, ncol = 10)
  diag(mat) &lt;- 0               # loops are excluded
  nw &lt;- network::network(mat)  # create network object
  networks[[i]] &lt;- nw          # add network to the list
}

covariates &lt;- list()
for (i in 1:10) {              # create 10 matrices as covariate
  mat &lt;- matrix(rnorm(100), nrow = 10, ncol = 10)
  covariates[[i]] &lt;- mat       # add matrix to the list
}

fit &lt;- btergm(networks ~ edges + istar(2) + edgecov(covariates), R = 100)
summary(fit)                   # show estimation results

# For examples with real data, see help("knecht") or help("alliances").


# Examples for parallel processing:

# Some preliminaries:
# - "Forking" means running the code on multiple cores in the same
#   computer. It's fast but consumes a lot of memory because all
#   objects are copied for each node. It's also restricted to
#   cores within a physical computer, i.e. no distribution over a
#   network or cluster. Forking does not work on Windows systems.
# - "MPI" is a protocol for distributing computations over many
#   cores, often across multiple physical computers/nodes. MPI
#   is fast and can distribute the work across hundreds of nodes
#   (but remember that R can handle a maximum of 128 connections,
#   which includes file access and parallel connections). However,
#   it requires that the Rmpi package is installed and that an MPI
#   server is running (e.g., OpenMPI).
# - "PSOCK" is a TCP-based protocol. It can also distribute the
#   work to many cores across nodes (like MPI). The advantage of
#   PSOCK is that it can as well make use of multiple nodes within
#   the same node or desktop computer (as with forking) but without
#   consuming too much additional memory. However, the drawback is
#   that it is not as fast as MPI or forking.
# The following code provides examples for these three scenarios.

# btergm works with clusters via the parallel package. That is, the
# user can create a cluster object (of type "PSOCK", "MPI", or
# "FORK") and supply it to the 'cl' argument of the 'btergm'
# function. If no cluster object is provided, btergm will try to
# create a temporary PSOCK cluster (if parallel = "snow") or it
# will use forking (if parallel = "multicore").

## Not run: 
# To use a PSOCK cluster without providing an explicit cluster
# object:
require("parallel")
fit &lt;- btergm(networks ~ edges + istar(2) + edgecov(covariates),
              R = 100, parallel = "snow", ncpus = 25)

# Equivalently, a PSOCK cluster can be provided as follows:
require("parallel")
cores &lt;- 25
cl &lt;- makeCluster(cores, type = "PSOCK")
fit &lt;- btergm(networks ~ edges + istar(2) + edgecov(covariates),
              R = 100, parallel = "snow", ncpus = cores, cl = cl)
stopCluster(cl)

# Forking (without supplying a cluster object) can be used as
# follows.
require("parallel")
cores &lt;- 25
fit &lt;- btergm(networks ~ edges + istar(2) + edgecov(covariates),
              R = 100, parallel = "multicore", ncpus = cores)
stopCluster(cl)

# Forking (by providing a cluster object) works as follows:
require("parallel")
cores &lt;- 25
cl &lt;- makeCluster(cores, type = "FORK")
fit &lt;- btergm(networks ~ edges + istar(2) + edgecov(covariates),
              R = 100, parallel = "snow", ncpus = cores, cl = cl)
stopCluster(cl)

# To use MPI, a cluster object MUST be created beforehand. In
# this example, a MOAB HPC server is used. It stores the number of
# available cores as a system option:
require("parallel")
cores &lt;- as.numeric(Sys.getenv("MOAB_PROCCOUNT"))
cl &lt;- makeCluster(cores, type = "MPI")
fit &lt;- btergm(networks ~ edges + istar(2) + edgecov(covariates),
              R = 100, parallel = "snow", ncpus = cores, cl = cl)
stopCluster(cl)

# In the following example, the Rmpi package is used to create a
# cluster. This may not work on all systems; consult your local
# support staff or the help files on your HPC server to find out how
# to create a cluster object on your system.

# snow/Rmpi start-up
if (!is.loaded("mpi_initialize")) {
  library("Rmpi")
}
library(snow);

mpirank &lt;- mpi.comm.rank (0)
if (mpirank == 0) {
  invisible(makeMPIcluster())
} else {
  sink (file="/dev/null")
  invisible(slaveLoop (makeMPImaster()))
  mpi.finalize()
  q()
}
# End snow/Rmpi start-up

cl &lt;- getMPIcluster()

fit &lt;- btergm(networks ~ edges + istar(2) + edgecov(covariates),
              R = 100, parallel = "snow", ncpus = 25, cl = cl)

## End(Not run)

</code></pre>


</div>