<div class="container">

<table style="width: 100%;"><tr>
<td>get.thinned.tfr.mcmc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Creating and Accessing Thinned MCMCs
</h2>

<h3>Description</h3>

<p>The function <code>get.thinned.tfr.mcmc</code> accesses 
a thinned and burned version of the given Phase II MCMC set. <code>create.thinned.tfr.mcmc</code> creates or updates such a set.
</p>


<h3>Usage</h3>

<pre><code class="language-R">get.thinned.tfr.mcmc(mcmc.set, thin = 1, burnin = 0)

create.thinned.tfr.mcmc(mcmc.set, thin = 1, burnin = 0, 
    output.dir = NULL, verbose = TRUE, uncertainty = FALSE,
    update.with.countries = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mcmc.set</code></td>
<td>
<p>Object of class <code>bayesTFR.mcmc.set</code> of Phase II.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin, burnin</code></td>
<td>
<p>Thinning interval and burnin used for creating or identifying the thinned object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output.dir</code></td>
<td>
<p>Output directory. It is only used if the output goes to a non-standard directory.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uncertainty</code></td>
<td>
<p>If users want to save the thinned estimated TFR in the new mcmc object, this parameter should be set <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>update.with.countries</code></td>
<td>
<p>If an existing set is to be updated, this should be a vector of country indices for the update.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function <code>create.thinned.tfr.mcmc</code> is called from <code>tfr.predict</code> and thus, the resulting object contains exactly the same MCMCs used for generating projections. In addition, it can be also called from <code>tfr.diagnose</code> if desired, so that the projection process can re-use such a set that leads to a convergence. 
</p>
<p>The thinning is done as follows: The given <code>burnin</code> is removed from the beginning of each chain in the original MCMC set. Then each chain is thinned by <code>thin</code> using equal spacing and all chains are collapsed into one single chain per parameter. They are stored in the main simulation directory under the name ‘<span class="file">thinned_mcmc_<em>t</em>_<em>b</em></span>’ where <em>t</em> is the value  of <code>thin</code> and <em>b</em> the value of <code>burnin</code>.   
</p>
<p>If <code>uncertainty=TRUE</code>, the estimated TFR is thinned and saved as well.
</p>


<h3>Value</h3>

<p>Both functions return an object of class <code>bayesTFR.mcmc.set</code>. <code>get.thinned.tfr.mcmc</code> returns <code>NULL</code> if such object does not exist.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code>bayesTFR.mcmc.set</code>, <code>tfr.predict</code>, <code>tfr.diagnose</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
sim.dir &lt;- tempfile()
m &lt;- run.tfr.mcmc(nr.chains=2, iter=30, seed=1, output.dir=sim.dir, verbose=TRUE)
tfr.predict(m, burnin=15, use.tfr3=FALSE) # creates thinned MCMCs
mb &lt;- get.thinned.tfr.mcmc(m, thin=1, burnin=15)
summary(mb, meta.only=TRUE) # length 30 = 2chains x (30-15)iters.
unlink(sim.dir, recursive=TRUE)

## End(Not run)
</code></pre>


</div>