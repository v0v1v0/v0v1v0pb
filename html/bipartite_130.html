<div class="container">

<table style="width: 100%;"><tr>
<td>nest.smdm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Computes nestedness of a matrix as WNODA (and NODF and WNODF) </h2>

<h3>Description</h3>

<p>Calculates network nestedness, also within and between modules, i.e. separate nestednesses for nodes belonging to the same module and between nodes belonging to different modules. Three nestedness metrics are implemented in the function: NODF, WNODF and WNODA.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  nest.smdm(x, constraints=NULL, weighted=FALSE, decreasing="fill", sort=TRUE)
  module2constraints(mod)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an interaction matrix; typically with rows for lower and columns for higher level species;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constraints</code></td>
<td>
<p>a vector with modules for vertices of the matrix. The vector indicates first rows modules and then columns modules, following the sequence of input matrix x. If no constraints are provided, the function calculates nestedness for the entire matrix, not taking into account possible network modules.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weighted</code></td>
<td>
<p>Logical. Indicate whether to calculate binary or weighted version of the metrics. If set to FALSE for a weighted input matrix, the binary metric is calculated, but a warning is returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decreasing</code></td>
<td>
<p>The matrix has to be sorted before computation of (W)NODA. This can be done either by <span class="option">"fill"</span>, i.e. sum of cells with non-zero values, or <span class="option">"abund"</span>, i.e. sum of cell values. For a binary matrix decreasing needs to be <span class="option">"fill"</span> (as no abundances are available). For weighted matrices, the argument may be <span class="option">"fill"</span> (yielding WNODF) or <span class="option">"abundance"</span> (yielding WNODA).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sort</code></td>
<td>
<p>Logical. Should columns and rows of the matrix be sorted, in order to maximize nestedness index?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mod</code></td>
<td>
<p>Output of a <code>computeModules</code>-object. Returns a vector to be used as input for <span class="option">constraints</span>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Function returns a list with elements
</p>
<table>
<tr style="vertical-align: top;">
<td><code>WNODArow</code></td>
<td>
<p>Nestedness for rows</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>WNODAcol</code></td>
<td>
<p>Nestedness for columns</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>WNODAmatrix</code></td>
<td>
<p>Nestedness for entire matrix</p>
</td>
</tr>
</table>
<p>If constraints are provided, e.g. based on <code>computeModules</code>, output additionally includes:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>WNODA_SM_row</code></td>
<td>
<p>Nestedness for rows belonging to the same modules</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>WNODA_DM_row</code></td>
<td>
<p>Nestedness for rows belonging to different modules</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>WNODA_SM_col</code></td>
<td>
<p>Nestedness for columns belonging to the same modules</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>WNODA_DM_col</code></td>
<td>
<p>Nestedness for columns belonging to different modules</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>WNODA_SM_matrix</code></td>
<td>
<p>Nestedness for nodes (rows and columns) belonging to the same modules</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>WNODA_DM_matrix</code></td>
<td>
<p>Nestedness for nodes (rows and columns) belonging to different modules</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p> Rafael Barros Pereira Pinheiro <a href="mailto:rafael-bpp@hotmail.com">rafael-bpp@hotmail.com</a>, Gabriel Felix, Marco Mello, and the team of the Ecological Synthesis Lab, University of São Paulo </p>


<h3>References</h3>

<p>Almeida-Neto M, Guimaraes PR, Guimaraes PR Jr, Loyola RD, Ulrich W (2008) A consistent metric for nestedness analysis in ecological systems: reconciling concept and measurement. <em>Oikos</em> <b>117</b>: 1227–1239
</p>
<p>Almeida-Neto, M. &amp; Ulrich, W. (2011). A straightforward computational approach for measuring nestedness using quantitative matrices. <em>Environ. Model. Softw.</em> <b>26</b>: 173–178
</p>
<p>Felix, G.M., Pinheiro, R.B.P., Poulin, R., Krasnov, B.R. &amp; Mello, M.A.R. (2017). The compound topology of a continent-wide interaction network explained by an integrative hypothesis of specialization. <em>bioRxiv</em>
</p>
<p>Flores, C.O., Valverde, S. &amp; Weitz, J.S. (2013). Multi-scale structure and geographic drivers of cross-infection within marine bacteria and phages. <em>ISME J.</em> <b>7</b>: 520–532
</p>


<h3>See Also</h3>

<p><code>vegan::nestedNODF</code>, <code>computeModules</code></p>


<h3>Examples</h3>

<pre><code class="language-R">nest.smdm(Safariland)
nest.smdm(Safariland, weighted=TRUE)
nest.smdm(Safariland, weighted=TRUE, decreasing="abund")
nest.smdm(Safariland, weighted=TRUE, decreasing="abund", sort=FALSE)
# identify modules using computeModules:
mod &lt;- computeModules(Safariland)
const &lt;- module2constraints(mod)
nest.smdm(Safariland, constraint=const)
nest.smdm(Safariland, constraint=const, weighted=TRUE)
</code></pre>


</div>