<div class="container">

<table style="width: 100%;"><tr>
<td>fit_bayesPO</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit presence-only data using a Bayesian Poisson Process model</h2>

<h3>Description</h3>

<p>The model uses a data augmentation scheme to avoid performing approximations
on the likelihood function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fit_bayesPO(
  object,
  background,
  mcmc_setup = list(iter = 5000),
  verbose = TRUE,
  ...
)

## S4 method for signature 'bayesPO_model,matrix'
fit_bayesPO(
  object,
  background,
  mcmc_setup,
  verbose = TRUE,
  area = 1,
  cores = 1,
  ...
)

## S4 method for signature 'bayesPO_fit,matrix'
fit_bayesPO(
  object,
  background,
  mcmc_setup = list(iter = object$mcmc_setup$iter),
  verbose = TRUE,
  cores = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>Either a <code>bayesPO_model</code> or <code>bayesPO_fit</code> object. If
a model, then the model is fit according to specifications. If a fit,
then the model used to fit the model is recovered and used to continue
the MCMC calculations where the previous one left off.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>background</code></td>
<td>
<p>A matrix where the rows are the grid cells for the studied
region and the columns are the covariates. <code>NA</code>s must be removed. If
the function is being used on a <code>bayesPO_fit</code> object, the background
must be exactly the same as the one used in the original fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mcmc_setup</code></td>
<td>
<p>A list containing <code>iter</code> to inform the model how
many iterations are to be run. The list may optionally contain the objects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Set to <code>FALSE</code> to suppress all messages to console.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Parameters passed on to specific methods.
<code>burnin</code> and <code>thin</code> to inform these instructions as well.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>area</code></td>
<td>
<p>A positive number with the studied region's area.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>Currently unused.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The background is kept outside of the
</p>


<h3>Value</h3>

<p>An object of class <code>"bayesPO_fit"</code>.
</p>


<h3>See Also</h3>

<p><code>bayesPO_model</code> and <code>bayesPO_fit-class</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># This code is replicated from the vignette.
## Not run: 
beta &lt;- c(-1, 2) # Intercept = -1. Only one covariate
delta &lt;- c(3, 4) # Intercept = 3. Only one covariate
lambdaStar &lt;- 1000

total_points &lt;- rpois(1, lambdaStar)
random_points &lt;- cbind(runif(total_points), runif(total_points))
grid_size &lt;- 50

# Find covariate values to explain the species occurrence.
# We give them a Gaussian spatial structure.
reg_grid &lt;- as.matrix(expand.grid(seq(0, 1, len = grid_size), seq(0, 1, len = grid_size)))
Z &lt;- MASS::mvrnorm(1, rep(0, total_points + grid_size * grid_size),
  3 * exp(-as.matrix(dist(rbind(random_points, reg_grid))) / 0.2))
Z1 &lt;- Z[1:total_points]; Z2 &lt;- Z[-(1:total_points)]

# Thin the points by comparing the retaining probabilities with uniforms
# in the log scale to find the occurrences
occurrences &lt;- log(runif(total_points)) &lt;= -log1p(exp(-beta[1] - beta[2] * Z1))
n_occurrences &lt;- sum(occurrences)
occurrences_points &lt;- random_points[occurrences,]
occurrences_Z &lt;- Z1[occurrences]

# Find covariate values to explain the observation bias.
# Additionally create a regular grid to plot the covariate later.
W &lt;- MASS::mvrnorm(1, rep(0, n_occurrences + grid_size * grid_size),
  2 * exp(-as.matrix(dist(rbind(occurrences_points, reg_grid))) / 0.3))
W1 &lt;- W[1:n_occurrences]; W2 &lt;- W[-(1:n_occurrences)]

# Find the presence-only observations.
po_sightings &lt;- log(runif(n_occurrences)) &lt;= -log1p(exp(-delta[1] - delta[2] * W1))
n_po &lt;- sum(po_sightings)
po_points &lt;- occurrences_points[po_sightings, ]
po_Z &lt;- occurrences_Z[po_sightings]
po_W &lt;- W1[po_sightings]

jointPrior &lt;- prior(
  NormalPrior(rep(0, 2), 10 * diag(2)), # Beta
NormalPrior(rep(0, 2), 10 * diag(2)), # Delta
GammaPrior(0.00001, 0.00001) # LambdaStar
)

model &lt;- bayesPO_model(po = cbind(po_Z, po_W),
intensitySelection = 1, observabilitySelection = 2,
                    intensityLink = "logit", observabilityLink = "logit",
                    initial_values = 2, joint_prior = jointPrior)

bkg &lt;- cbind(Z2, W2) # Create background

fit &lt;- fit_bayesPO(model, bkg, area = 1, mcmc_setup = list(burnin = 1000, iter = 2000))

summary(fit)

# Rhat upper CI values are above 1.1. More iterations are needed, so...

fit2 &lt;- fit_bayesPO(fit, bkg, mcmc_setup = list(iter = 10000))

summary(fit2)
mcmc_trace(fit2)
mcmc_dens(fit2)

## End(Not run)
</code></pre>


</div>