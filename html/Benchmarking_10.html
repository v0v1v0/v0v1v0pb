<div class="container">

<table style="width: 100%;"><tr>
<td>dea.boot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Bootstrap DEA models </h2>

<h3>Description</h3>

<p> The function <code>dea.boot</code> bootstrap DEA models and
returns bootstrap of Farrell efficiencies. This function is slower than the 
<code>boot.sw89</code> from the package <span class="pkg">FEAR</span>. 
The faster function <code>boot.fear</code> is a wrapper for <code>boot.sw89</code> from 
the package <span class="pkg">FEAR</span> returning results directly as Farrell measures.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dea.boot(X, Y, NREP = 200, EFF = NULL, RTS = "vrs", ORIENTATION="in", 
         alpha = 0.05, XREF = NULL, YREF = NULL, FRONT.IDX=NULL, 
         EREF = NULL, DIRECT = NULL, TRANSPOSE = FALSE, 
         SHEPHARD.INPUT = TRUE, LP, CONTROL=NULL)

boot.fear(X, Y, NREP = 200, EFF = NULL, RTS = "vrs", ORIENTATION = "in", 
         alpha = 0.05, XREF = NULL, YREF = NULL, EREF = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Inputs of firms to be evaluated, a K x m matrix of
observations of K firms with m inputs (firm x input) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>Outputs of firms to be evaluated, a K x n matrix of
observations of K firms with n outputs (firm x input). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NREP</code></td>
<td>
<p>Number of bootstrap replications</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>EFF</code></td>
<td>
<p>Efficiencies for (X,Y) relative to the technology
generated from (XREF,YREF).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RTS</code></td>
<td>
<p>The returns to scale assumptions as in <code>dea</code>,
only works for "vrs", "drs", and "crs"; more to come.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ORIENTATION</code></td>
<td>
<p>Input efficiency "in" (1), output
efficiency "out" (2), and graph efficiency "graph" (3). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>One minus the size of the confidence interval for the
bias corrected efficiencies</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>XREF</code></td>
<td>
<p>Inputs of the firms determining the technology, defaults
to <code>X</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>YREF</code></td>
<td>
<p>Outputs of the firms determining the technology,
defaults to <code>Y</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FRONT.IDX</code></td>
<td>
<p>Index for firms determining the technology.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>EREF</code></td>
<td>
<p>Efficiencies for the firms in XREF, YREF.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DIRECT</code></td>
<td>
<p>Does not yet work and is therefore not used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>TRANSPOSE</code></td>
<td>
<p>Input and output matrices are K x m and K x n for
the default value <code>TRANSPOSE=FALSE</code>; this is standard in R
for statistical models.  When <code>TRANSPOSE=TRUE</code> data
matrices are m x K and n x K.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SHEPHARD.INPUT</code></td>
<td>
<p>The bootstrap of the Farrell input
efficiencies is done as a Shephard input distance function,
the inverse Farrell input efficiency. The option is only
relevant for input and graph directions. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LP</code></td>
<td>
<p>Only for debugging purposes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CONTROL</code></td>
<td>
<p>Possible controls to <span class="pkg">lpSolveAPI</span>, see the
documentation for that package. For examples of use see the
function <code>dea</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p> The details are lightly explained in Bogetoft and Otto
(2011) Chap. 6, and with more mathematical details in Dario and
Simar (2007) Sect. 3.4 and in Simar and Wilson (1998).
</p>
<p>The bootstrap at the moment does not work for any kind of
directional efficiency.  
</p>
<p>The returned confidence intervals are for the bias corrected
efficiencies; to get confidence intervals for the uncorrected
efficiencies add the biases to both upper and lower values for the
intervals.
</p>
<p>Under the default option <code>SHEPHARD.INPUT=TRUE</code> bias and bias
corrected efficiencies are calculated for Shephard input distance
function and then transformed to Farrell input efficiencies to
avoid possible negative biased corrected input efficiencies. If
this is not wanted use the option <code>SHEPHARD.INPUT=FALSE</code>. This
option is only relevant for input and graph oriented directions.</p>


<h3>Value</h3>

<p> The returned values from both functions are as follows:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>eff</code></td>
<td>
<p>Efficiencies</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eff.bc</code></td>
<td>
<p>Bias-corrected efficiencies</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bias</code></td>
<td>
<p>An array of bootstrap bias estimates for the K firms</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.int</code></td>
<td>
<p><code>K x 2</code> matrix with confidence interval for the
estimated efficiencies</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var</code></td>
<td>
<p>An array of bootstrap variance estimates for the K firms</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boot</code></td>
<td>
<p> The replica bootstrap estimates of the Farrell
efficiencies, a <code>K x NREP</code> matrix </p>
</td>
</tr>
</table>
<h3>Note</h3>

 





<p>The function <code>dea.boot</code> does not depend on the FEAR package
and can therefore be used on computers where the package FEAR is
not available. This, however, comes with a time penalty as it takes
around 4 times longer to run compared to using FEAR directly


</p>
<p>The returned bootstrap estimates from <code>FEAR::boot.sw98</code> 
of efficiencies are sorted for each firm individually. 

Unfortunately, this means that the component of replicas is not the efficiencies for
the same bootstrap replica, but could easily be from different
bootstrap replicas. This also means that this function can
<em>not</em> be used to bootstrap tests for statistical hypotheses
where the statistics involves summing of firm's efficiencies.
</p>
<p>If a numerical problem occurs, status=5, or if no solution can be found,
the best solution is often to scale the input <code>X</code> and output
<code>Y</code> yourself or use the option <code>CONTROL</code> to change scaling in
the program itself, as described in the notes for <code>dea</code>.
</p>


<h3>Author(s)</h3>

<p> Peter Bogetoft and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a></p>


<h3>References</h3>

<p> Peter Bogetoft and Lars Otto; <em>Benchmarking with
DEA, SFA, and R</em>; Springer 2011.
</p>
<p>Cinzia Dario and L. Simar; <em>Advanced Robust and Nonparametric
Methods in Efficiency Analysis</em>.  Methodology and Applications;
Springer 2007.
</p>
<p>Leopold Simar and Paul .W. Wilson (1998), “Sensitivity
analysis of efficiency scores: How to bootstrap in nonparametric
frontier models”, <em>Management Science</em> 44, 49–61.
</p>
<p>Paul W. Wilson (2008), “FEAR 1.0: A Software Package for
Frontier Efficiency Analysis with R,” <em>Socio-Economic Planning
Sciences</em> 42, 247–254
</p>


<h3>See Also</h3>

<p> The documentation for <code>boot.sw98</code> in the package
<span class="pkg">FEAR</span>. </p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- matrix(c(100,200,300,500,100,200,600),ncol=1)
y &lt;- matrix(c( 75,100,300,400, 25, 50,400),ncol=1)

e &lt;- dea(x,y)
eff(e)

dea.plot.frontier(x,y,txt=TRUE)

#  To bootstrap for real, NREP should be at least 2000. Run the
#  following lines a couple of times with nrep=100 and see how the
#  bootstrap frontier changes from one run to the next. Try the same
#  with NREP=2000 even though is does take a longer time to run,
#  especially for dea.boot.
nrep &lt;- 5
# nrep &lt;- 2000

# if ( "FEAR" %in% .packages(TRUE) )  {
##  The following only works if the package FEAR is installed; it does
##  not have to be loaded.
#  b &lt;- boot.fear(x,y, NREP=nrep)
# } else {
  b &lt;- dea.boot(x,y, NREP=nrep)
# }

#  bias corrected frontier
dea.plot.frontier(b$eff.bc*x, y, add=TRUE, lty="dashed")
#  outer 95% confidence interval frontier for uncorrected frontier
dea.plot.frontier((b$conf.int[,1]+b$bias)*x, y, add=TRUE, lty="dotted")


## Test of hypothesis in DEA model
# Null hypothesis is that technology is CRS and the alternative is VRS
# Bogetoft and Otto (2011) pages 183--185.
ec &lt;- dea(x,y, RTS="crs")
Ec &lt;- eff(ec)
ev &lt;- dea(x,y, RTS="vrs")
Ev &lt;- eff(ev)
# The test statistic; equation (6.1)
S &lt;- sum(Ec)/sum(Ev)

# To calculate CRS and VRS efficiencies in the same bootstrap replicas
# we reset the random number generator before each call of the
# function dea.boot.

# To get the an initial value for the random number generating process
# we save its state (seed)
save.seed &lt;- sample.int(1e9,1)

# The bootstrap and calculate CRS and VRS under the assumption that
# the true technology is CRS (the null hypothesis) and such that the
# results corresponds to the case where CRS and VRS are calculated for
# the same reference set of firms; to make this happen we set the
# random number generator to the same state before the calls.
set.seed(save.seed)
bc &lt;- dea.boot(x,y, nrep,, RTS="crs")
set.seed(save.seed)
bv &lt;- dea.boot(x,y, nrep,, RTS="vrs", XREF=x,YREF=y, EREF=ec$eff)

# Calculate the statistic for each bootstrap replica
bs &lt;- colSums(bc$boot)/colSums(bv$boot)
# The critical value for the test (default size \code{alpha} of test is 5%)
critValue(bs, alpha=.1)
S
# Accept the hypothesis at 10% level?
critValue(bs, alpha=.1) &lt;= S

# The probability of observing a smaller value of S when the
# hypothesis is true; the p--value.
typeIerror(S, bs)
# Accept the hypothesis at size level 10%?
typeIerror(S, bs) &gt;= .10
</code></pre>


</div>