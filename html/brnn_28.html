<div class="container">

<table style="width: 100%;"><tr>
<td>brnn</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>brnn</h2>

<h3>Description</h3>

<p>The brnn function
fits a two layer neural network as described in MacKay (1992) and Foresee and Hagan (1997). It uses the 
Nguyen and Widrow algorithm (1990) to assign initial weights and the Gauss-Newton algorithm to 
perform the optimization. This function implements the functionality of the function trainbr in Matlab 2010b.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  brnn(x, ...)
  
  ## S3 method for class 'formula'
brnn(formula, data, contrasts=NULL,...)

  ## Default S3 method:
brnn(x,y,neurons=2,normalize=TRUE,epochs=1000,mu=0.005,mu_dec=0.1, 
       mu_inc=10,mu_max=1e10,min_grad=1e-10,change = 0.001,cores=1,
       verbose=FALSE,Monte_Carlo = FALSE,tol = 1e-06, samples = 40,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>A formula of the form <code>y ~ x1 + x2 + ...</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Data frame from which variables specified in  <code>formula</code> are preferentially to be taken.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>(numeric, <code class="reqn">n \times p</code>) incidence matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>(numeric, <code class="reqn">n</code>) the response data-vector (NAs not  allowed).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neurons</code></td>
<td>
<p>positive integer that indicates the number of neurons.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p>logical, if TRUE will normalize inputs and output, the default value is TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epochs</code></td>
<td>
<p>positive integer, maximum number of epochs(iterations) to train, default 1000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>positive number that controls the behaviour of the Gauss-Newton optimization algorithm, default value 0.005.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu_dec</code></td>
<td>
<p>positive number, is the mu decrease ratio, default value 0.1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu_inc</code></td>
<td>
<p>positive number, is the mu increase ratio, default value 10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu_max</code></td>
<td>
<p>maximum mu before training is stopped, strict positive number, default value <code class="reqn">1\times 10^{10}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_grad</code></td>
<td>
<p>minimum gradient.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>change</code></td>
<td>
<p>The program  will stop if the maximum (in absolute value) of the differences of the F function in 3 consecutive iterations is less than this quantity.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>Number of cpu cores to use for calculations (only available in UNIX-like operating systems). The function detectCores in the R package 
parallel can be used to attempt to detect the number of CPUs in the machine that R is running, but not necessarily 
all the cores are available for the current user, because for example in multi-user 
systems it will depend on system policies. Further details can be found in the documentation for the parallel package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical, if TRUE will print iteration history.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Monte_Carlo</code></td>
<td>
<p>If TRUE it will estimate the trace of the inverse of the hessian using Monte Carlo procedures, see Bai et al. (1996) for 
more details. This routine calls the function estimate.trace() to perform the computations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>numeric tolerance, a tiny number useful for checking convergenge in the Bai's algorithm. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>samples</code></td>
<td>
<p>positive integer, number of Monte Carlo replicates to estimate the trace of the inverse, see Bai et al. (1996) for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts</code></td>
<td>
<p>an optional list of contrasts to be used for some or all of the factors appearing as variables in the model formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The software fits a two layer network as described in MacKay (1992) and Foresee and Hagan (1997). 
The model is given by:
</p>
<p><code class="reqn">y_i=g(\boldsymbol{x}_i)+e_i = \sum_{k=1}^s w_k g_k (b_k + \sum_{j=1}^p x_{ij} \beta_j^{[k]}) + e_i, i=1,...,n</code>
</p>
<p>where:
</p>

<ul>
<li>
<p><code class="reqn">e_i \sim N(0,\sigma_e^2)</code>.
</p>
</li>
<li>
<p><code class="reqn">s</code> is the number of neurons.
</p>
</li>
<li>
<p><code class="reqn">w_k</code> is the weight of the <code class="reqn">k</code>-th neuron, <code class="reqn">k=1,...,s</code>.
</p>
</li>
<li>
<p><code class="reqn">b_k</code> is a bias for the <code class="reqn">k</code>-th neuron, <code class="reqn">k=1,...,s</code>.
</p>
</li>
<li>
<p><code class="reqn">\beta_j^{[k]}</code> is the weight of the <code class="reqn">j</code>-th input to the net, <code class="reqn">j=1,...,p</code>.
</p>
</li>
<li>
<p><code class="reqn">g_k(\cdot)</code> is the activation function, in this implementation <code class="reqn">g_k(x)=\frac{\exp(2x)-1}{\exp(2x)+1}</code>.
</p>
</li>
</ul>
<p>The software will minimize 
</p>
<p style="text-align: center;"><code class="reqn">F=\beta E_D + \alpha E_W</code>
</p>

<p>where 
</p>

<ul>
<li>
<p><code class="reqn">E_D=\sum_{i=1}^n (y_i-\hat y_i)^2</code>, i.e. the error sum of squares.
</p>
</li>
<li>
<p><code class="reqn">E_W</code> is the sum of squares of network parameters (weights and biases).
</p>
</li>
<li>
<p><code class="reqn">\beta=\frac{1}{2\sigma^2_e}</code>.
</p>
</li>
<li>
<p><code class="reqn">\alpha=\frac{1}{2\sigma_\theta^2}</code>, <code class="reqn">\sigma_\theta^2</code> is a dispersion parameter for weights and biases.
</p>
</li>
</ul>
<h3>Value</h3>

<p>object of class <code>"brnn"</code> or <code>"brnn.formula"</code>. Mostly internal structure, but it is a list containing:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>$theta</code></td>
<td>
<p>A list containing weights and biases. The first <code class="reqn">s</code> components of the list contains vectors with the estimated parameters for
the <code class="reqn">k</code>-th neuron, i.e. <code class="reqn">(w_k, b_k, \beta_1^{[k]},...,\beta_p^{[k]})'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$message</code></td>
<td>
<p>String that indicates the stopping criteria for the training process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$alpha</code></td>
<td>
<p><code class="reqn">\alpha</code> parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$beta</code></td>
<td>
<p><code class="reqn">\beta</code> parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$gamma</code></td>
<td>
<p>effective number of parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$Ew</code></td>
<td>
<p>The sum of the squares of the bias and weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$Ed</code></td>
<td>
<p>The sum of the squares between observed and predicted values.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Bai, Z. J., M. Fahey and G. Golub. 1996. "Some large-scale matrix computation problems." 
<em>Journal of Computational and Applied Mathematics</em>  <b>74(1-2)</b>, 71-89.
</p>
<p>Foresee, F. D., and M. T. Hagan. 1997. "Gauss-Newton approximation to Bayesian regularization", 
<em>Proceedings of the 1997 International Joint Conference on Neural Networks</em>.
</p>
<p>Gianola, D. Okut, H., Weigel, K. and Rosa, G. 2011. "Predicting complex quantitative traits with Bayesian neural networks: a case study with Jersey cows and wheat". <em>BMC Genetics</em>, 
<b>12</b>,87.
</p>
<p>MacKay, D. J. C. 1992. "Bayesian interpolation", <em>Neural Computation</em>, 
<b>4(3)</b>, 415-447.
</p>
<p>Nguyen, D. and Widrow, B. 1990. "Improving the learning speed of 2-layer neural networks by choosing initial values of the adaptive weights", <em>Proceedings of the IJCNN</em>, <b>3</b>, 21-26.
</p>
<p>Paciorek, C. J. and Schervish, M. J. 2004. "Nonstationary Covariance Functions for
Gaussian Process Regression". In Thrun, S., Saul, L., and Scholkopf, B., editors, <em>Advances
in Neural Information Processing Systems 16</em>. MIT Press, Cambridge, MA.
</p>


<h3>See Also</h3>

<p><code>predict.brnn</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 

#Load the library
library(brnn)

###############################################################
#Example 1 
#Noise triangle wave function, similar to example 1 in Foresee and Hagan (1997)

#Generating the data
x1=seq(0,0.23,length.out=25)
y1=4*x1+rnorm(25,sd=0.1)
x2=seq(0.25,0.75,length.out=50)
y2=2-4*x2+rnorm(50,sd=0.1)
x3=seq(0.77,1,length.out=25)
y3=4*x3-4+rnorm(25,sd=0.1)
x=c(x1,x2,x3)
y=c(y1,y2,y3)


#With the formula interface
out=brnn(y~x,neurons=2)

#With the default S3 method the call is
#out=brnn(y=y,x=as.matrix(x),neurons=2)

plot(x,y,xlim=c(0,1),ylim=c(-1.5,1.5),
     main="Bayesian Regularization for ANN 1-2-1")
lines(x,predict(out),col="blue",lty=2)
legend("topright",legend="Fitted model",col="blue",lty=2,bty="n")

###############################################################
#Example 2
#sin wave function, example in the Matlab 2010b demo.

x = seq(-1,0.5,length.out=100)
y = sin(2*pi*x)+rnorm(length(x),sd=0.1)

#With the formula interface
out=brnn(y~x,neurons=3)

#With the default method the call is
#out=brnn(y=y,x=as.matrix(x),neurons=3)

plot(x,y)
lines(x,predict(out),col="blue",lty=2)

legend("bottomright",legend="Fitted model",col="blue",lty=2,bty="n")

###############################################################
#Example 3
#2 Inputs and 1 output
#the data used in Paciorek and
#Schervish (2004). The data is from a two input one output function with Gaussian noise
#with mean zero and standard deviation 0.25

data(twoinput)

#Formula interface
out=brnn(y~x1+x2,data=twoinput,neurons=10)

#With the default S3 method
#out=brnn(y=as.vector(twoinput$y),x=as.matrix(cbind(twoinput$x1,twoinput$x2)),neurons=10)

f=function(x1,x2) predict(out,cbind(x1,x2))
x1=seq(min(twoinput$x1),max(twoinput$x1),length.out=50)
x2=seq(min(twoinput$x2),max(twoinput$x2),length.out=50)
z=outer(x1,x2,f) # calculating the density values

transformation_matrix=persp(x1, x2, z,
                            main="Fitted model",
                            sub=expression(y==italic(g)~(bold(x))+e),
                            col="lightgreen",theta=30, phi=20,r=50, 
                            d=0.1,expand=0.5,ltheta=90, lphi=180,
                            shade=0.75, ticktype="detailed",nticks=5)
points(trans3d(twoinput$x1,twoinput$x2, f(twoinput$x1,twoinput$x2), 
               transformation_matrix), col = "red")

###############################################################
#Example 4
#Gianola et al. (2011).
#Warning, it will take a while

#Load the Jersey dataset
data(Jersey)

#Fit the model with the FULL DATA
#Formula interface
out=brnn(pheno$yield_devMilk~G,neurons=2,verbose=TRUE)

#Obtain predictions and plot them against fitted values
plot(pheno$yield_devMilk,predict(out))

#Predictive power of the model using the SECOND set for 10 fold CROSS-VALIDATION
data=pheno
data$X=G
data$partitions=partitions

#Fit the model for the TESTING DATA
out=brnn(yield_devMilk~X,
         data=subset(data,partitions!=2),neurons=2,verbose=TRUE)

#Plot the results
#Predicted vs observed values for the training set
par(mfrow=c(2,1))
plot(out$y,predict(out),xlab=expression(hat(y)),ylab="y")
cor(out$y,predict(out))

#Predicted vs observed values for the testing set
yhat_R_testing=predict(out,newdata=subset(data,partitions==2))
ytesting=pheno$yield_devMilk[partitions==2]
plot(ytesting,yhat_R_testing,xlab=expression(hat(y)),ylab="y")
cor(ytesting,yhat_R_testing)


## End(Not run)

</code></pre>


</div>