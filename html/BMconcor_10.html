<div class="container">

<table style="width: 100%;"><tr>
<td>svdbip</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>SVD for one bipartitioned matrix x</h2>

<h3>Description</h3>

<p>SVD for bipartitioned matrix x. r successive Solutions
</p>


<h3>Usage</h3>

<pre><code class="language-R">svdbip(x, K, H, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a <code>p</code> times <code>q</code> matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>is a row vector which contains the numbers pk, k=1,...,kx, of the partition of x with kx row blocks : <code>sum(pk)=p</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>H</code></td>
<td>
<p>is a row vector which contains the numbers qh, h=1,...,ky, of the partition of x with ky column blocks : sum(qh)=q</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>The number of wanted successive solutions</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The first solution calculates kx+ky normed vectors: kx vectors <code>uk[:,1]</code>
of <code class="reqn">R^{p_k}</code> associated to ky vectors <code>vh[:,1]</code>'s of <code class="reqn">R^{q_h}</code>, by
maximizing <code class="reqn">\sum_k \sum_h (u_k[:,1]^prime*x_{kh}*v_h[:,1])^2</code>, with kx+ky
norm constraints. A value <code class="reqn">(u_k[,1]^prime*x_{kh}*v_h[,1])^2</code> measures the
relative link between <code class="reqn">R^{p_k}</code> and <code class="reqn">R^{q_h}</code> associated to the block xkh.
The second solution is obtained from the same criterion, but after
replacing each xhk by xkh-xkh<em>vh</em>vh'-uk<em>uk'xkh+uk</em>uk'xkh<em>vh</em>vh'.  And
so on for the successive solutions 1,2,...,r .  The biggest number of
solutions may be r=inf(pk,qh), when the xkh's are supposed with full
rank; then <code>rmax=min([min(K),min(H)])</code>.
When K=p (or H=q, with t(x)), svdcp function is better.  When H=q and
K=p, it is the usual svd (with squared singular values).
Convergence of algorithm may be not global. So the below proposed
initialisation of the algorithm may be not very suitable for some data
sets.  Several different random initialisations with normed vectors
might be considered and the best result then choosen.
</p>


<h3>Value</h3>

<p>A <code>list</code> with following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p>a <code>p</code> times <code>r</code> matrix of kx row blocks uk (pk x r); uk'*uk = Identity.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>a <code>q</code> times <code>r</code> matrix of <code>ky</code> row blocks <code>vi (qi x r)</code> of axes in <code>Rqi</code> relative to <code>yi; vi^prime*vi = Identity</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>a <code>kx</code> times <code>ky</code> times <code>r</code> array; with r fixed, each matrix contains kxky values <code class="reqn">(u_h'*x_{kh}*v_k)^2</code>, the partial (squared) singular values relative to xkh.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Lafosse, R.
</p>


<h3>References</h3>

<p>Kissita G., Cazes P., Hanafi M. &amp; Lafosse (2004) Deux methodes d'analyse factorielle du lien entre deux tableaux de variables partitiones. Revue de Statistique Appliquee.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
x &lt;- matrix(runif(200),10,20)
s &lt;- svdbip(x,c(3,4,3),c(5,15),3)

</code></pre>


</div>