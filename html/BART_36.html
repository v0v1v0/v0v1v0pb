<div class="container">

<table style="width: 100%;"><tr>
<td>recur.bart</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>BART for recurrent events</h2>

<h3>Description</h3>

<p>Here we have implemented a simple and direct approach to utilize BART in
survival analysis that is very flexible, and is akin to discrete-time
survival analysis.  Following the capabilities of BART, we allow for
maximum flexibility in modeling the dependence of survival times on
covariates.  In particular, we do not impose proportional hazards.
</p>
<p>To elaborate, consider data in the usual form:
<code class="reqn">(t_i, \delta_i, {x}_i)</code> where <code class="reqn">t_i</code> is the event time,
<code class="reqn">\delta_i</code> is an indicator distinguishing events
(<code class="reqn">\delta=1</code>) from right-censoring
(<code class="reqn">\delta=0</code>), <code class="reqn">{x}_i</code> is a vector of covariates, and
<code class="reqn">i=1, ..., N</code>
indexes subjects.
</p>
<p>We denote the <code class="reqn">K</code> distinct event/censoring times by
<code class="reqn">0&lt;t_{(1)}&lt;...&lt;t_{(K)}&lt;\infty</code> thus
taking <code class="reqn">t_{(j)}</code> to be the <code class="reqn">j^{th}</code> order
statistic among distinct observation times and, for convenience,
<code class="reqn">t_{(0)}=0</code>. Now consider event indicators <code class="reqn">y_{ij}</code>
for each subject <code class="reqn">i</code> at each distinct time <code class="reqn">t_{(j)}</code>
up to and including the subject's observation time
<code class="reqn">t_i=t_{(n_i)}</code> with
<code class="reqn">n_i=\sum_j I[t_{(j)}\leq t_i]</code>.
This means <code class="reqn">y_{ij}=0</code> if <code class="reqn">j&lt;n_i</code> and
<code class="reqn">y_{in_i}=\delta_i</code>.
</p>
<p>We then denote by <code class="reqn">p_{ij}</code> the probability
of an event at time <code class="reqn">t_{(j)}</code> conditional on no previous event. We
now write the model for <code class="reqn">y_{ij}</code> as a nonparametric probit
regression of <code class="reqn">y_{ij}</code> on the time <code class="reqn">t_{(j)}</code> and the covariates
<code class="reqn">{x}_i</code>, and then utilize BART for binary responses.  Specifically,
<code class="reqn"> y_{ij}\ =\ \delta_i I[t_i=t_{(j)}],\ j=1, ..., n_i </code>; we have
<code class="reqn">p_{ij} = F(\mu_{ij}),\ \mu_{ij} = \mu_0+f(t_{(j)}, {x}_i)</code> where <code class="reqn">F</code> denotes the standard normal cdf (probit link).
As in the binary
response case, <code class="reqn">f</code> is the sum of many tree models.  </p>


<h3>Usage</h3>

<pre><code class="language-R">
recur.bart(x.train=matrix(0,0,0),
           y.train=NULL, times=NULL, delta=NULL,
           x.test=matrix(0,0,0), x.test.nogrid=FALSE,
           sparse=FALSE, theta=0, omega=1,
           a=0.5, b=1, augment=FALSE, rho=NULL,
           xinfo=matrix(0,0,0), usequants=FALSE,
           
           rm.const=TRUE, type='pbart',
           ntype=as.integer(
               factor(type, levels=c('wbart', 'pbart', 'lbart'))),
           k=2, power=2, base=0.95,
           offset=NULL, tau.num=c(NA, 3, 6)[ntype], 
           ntree=50, numcut = 100L, ndpost=1000, nskip=250,
           keepevery=10, 
           
           
           printevery = 100L, 
           keeptrainfits = TRUE,
           seed=99,    ## mc.recur.bart only
           mc.cores=2, ## mc.recur.bart only
           nice=19L    ## mc.recur.bart only
         )

mc.recur.bart(x.train=matrix(0,0,0),
              y.train=NULL, times=NULL, delta=NULL,
              x.test=matrix(0,0,0), x.test.nogrid=FALSE,
              sparse=FALSE, theta=0, omega=1,
              a=0.5, b=1, augment=FALSE, rho=NULL,
              xinfo=matrix(0,0,0), usequants=FALSE,
              
              rm.const=TRUE, type='pbart',
              ntype=as.integer(
                  factor(type, levels=c('wbart', 'pbart', 'lbart'))),
              k=2, power=2, base=0.95,
              offset=NULL, tau.num=c(NA, 3, 6)[ntype], 
              ntree=50, numcut = 100L, ndpost=1000, nskip=250,
              keepevery=10, 
              
              
              printevery = 100L, 
              keeptrainfits = TRUE,
              seed=99,    ## mc.recur.bart only
              mc.cores=2, ## mc.recur.bart only
              nice=19L    ## mc.recur.bart only
            )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x.train</code></td>
<td>
<p> Explanatory variables for training (in sample)
data.<br> Must be a matrix with (as usual) rows corresponding to
observations and columns to variables.<br><code>recur.bart</code> will generate
draws of <code class="reqn">f(t, x)</code> for each <code class="reqn">x</code> which is a row of x.train (note
that the definition of <code>x.train</code> is dependent on whether
<code>y.train</code> has been specified; see below).  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y.train</code></td>
<td>

<p>Binary response dependent variable for training (in sample) data.<br>
If <code>y.train</code> is <code>NULL</code>, then <code>y.train</code> (<code>x.train</code> and
<code>x.test</code>, if specified) are generated
by a call to <code>recur.pre.bart</code> (which require that <code>times</code> and <code>delta</code> be
provided: see below); otherwise, <code>y.train</code> (<code>x.train</code> and
<code>x.test</code>, if specified)
are utilized as given assuming that the data construction has already been performed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>

<p>The time of event or right-censoring.<br>
If <code>y.train</code> is <code>NULL</code>, then <code>times</code> (and <code>delta</code>)
must be provided.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>

<p>The event indicator: 1 is an event while 0 is censored.<br>
If <code>y.train</code> is <code>NULL</code>, then <code>delta</code> (and <code>times</code>)
must be provided.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.test</code></td>
<td>

<p>Explanatory variables for test (out of sample) data.<br>
Must be a matrix and have the same structure as x.train.<br><code>recur.bart</code> will generate draws of <code class="reqn">f(t, x)</code> for each <code class="reqn">x</code> which is a row of x.test.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.test.nogrid</code></td>
<td>

<p>Occasionally, you do not need the entire time grid for
<code>x.test</code>.  If so, then for performance reasons, you can set this argument to <code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sparse</code></td>
<td>
<p>Whether to perform variable selection based on a
sparse Dirichlet prior rather than simply uniform; see Linero 2016.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>Set <code class="reqn">theta</code> parameter; zero means random.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omega</code></td>
<td>
<p>Set <code class="reqn">omega</code> parameter; zero means random.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>Sparse parameter for <code class="reqn">Beta(a, b)</code> prior:
<code class="reqn">0.5&lt;=a&lt;=1</code> where lower values inducing more sparsity.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>Sparse parameter for <code class="reqn">Beta(a, b)</code> prior; typically,
<code class="reqn">b=1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>Sparse parameter: typically <code class="reqn">rho=p</code> where <code class="reqn">p</code> is the
number of covariates under consideration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>augment</code></td>
<td>
<p>Whether data augmentation is to be performed in sparse
variable selection.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xinfo</code></td>
<td>
<p> You can provide the cutpoints to BART or let BART
choose them for you.  To provide them, use the <code>xinfo</code>
argument to specify a list (matrix) where the items (rows) are the
covariates and the contents of the items (columns) are the
cutpoints.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>usequants</code></td>
<td>
<p> If <code>usequants=FALSE</code>, then the
cutpoints in <code>xinfo</code> are generated uniformly; otherwise,
if <code>TRUE</code>, uniform quantiles are used for the cutpoints. </p>
</td>
</tr>
</table>
<table>
<tr style="vertical-align: top;">
<td><code>rm.const</code></td>
<td>
<p> Whether or not to remove constant variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p> Whether to employ Albert-Chib, <code>'pbart'</code>, or
Holmes-Held, <code>'lbart'</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ntype</code></td>
<td>
<p> The integer equivalent of <code>type</code> where
<code>'wbart'</code> is 1, <code>'pbart'</code> is 2 and
<code>'lbart'</code> is 3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>

<p>k is the number of prior standard deviations <code class="reqn">f(t, x)</code> is away from +/-3.
The bigger k is, the more conservative the fitting will be.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>power</code></td>
<td>

<p>Power parameter for tree prior.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>base</code></td>
<td>

<p>Base parameter for tree prior.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p> With binary
BART, the centering is <code class="reqn">P(Y=1 | x) = F(f(x) + offset)</code> where
<code>offset</code> defaults to <code>F^{-1}(mean(y.train))</code>.  You can use
the <code>offset</code> parameter to over-ride these defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau.num</code></td>
<td>
<p> The numerator in the <code>tau</code> definition, i.e.,
<code>tau=tau.num/(k*sqrt(ntree))</code>. </p>
</td>
</tr>
</table>
<table>
<tr style="vertical-align: top;">
<td><code>ntree</code></td>
<td>

<p>The number of trees in the sum.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numcut</code></td>
<td>

<p>The number of possible values of c (see usequants).
If a single number if given, this is used for all variables.
Otherwise a vector with length equal to ncol(x.train) is required,
where the <code class="reqn">i^{th}</code> element gives the number of c used for
the <code class="reqn">i^{th}</code> variable in x.train.
If usequants is false, numcut equally spaced cutoffs
are used covering the range of values in the corresponding
column of x.train.  If usequants is true, then  min(numcut, the number of unique values in the
corresponding columns of x.train - 1) c values are used.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ndpost</code></td>
<td>

<p>The number of posterior draws returned.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nskip</code></td>
<td>

<p>Number of MCMC iterations to be treated as burn in.
</p>
</td>
</tr>
</table>
<table>
<tr style="vertical-align: top;">
<td><code>keepevery</code></td>
<td>

<p>Every keepevery draw is kept to be returned to the user.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>printevery</code></td>
<td>

<p>As the MCMC runs, a message is printed every printevery draws.
</p>
</td>
</tr>
</table>
<table><tr style="vertical-align: top;">
<td><code>keeptrainfits</code></td>
<td>

<p>Whether to keep <code>yhat.train</code> or not.
</p>
</td>
</tr></table>
<table>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>

<p><code>mc.recur.bart</code> only: seed required for reproducible MCMC.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mc.cores</code></td>
<td>

<p><code>mc.recur.bart</code> only: number of cores to employ in parallel.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nice</code></td>
<td>

<p><code>mc.recur.bart</code> only: set the job niceness.  The default
niceness is 19: niceness goes from 0 (highest) to 19 (lowest).
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>recur.bart</code> returns an object of type <code>recurbart</code> which is
essentially a list.  Besides the items listed
below, the list has a <code>binaryOffset</code> component giving the value
used, a <code>times</code> component giving the unique times, <code>K</code>
which is the number of unique times, <code>tx.train</code> and
<code>tx.test</code>, if any.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>yhat.train</code></td>
<td>

<p>A matrix with ndpost rows and nrow(x.train) columns.
Each row corresponds to a draw <code class="reqn">f^*</code> from the posterior of <code class="reqn">f</code>
and each column corresponds to a row of x.train.
The <code class="reqn">(i,j)</code> value is <code class="reqn">f^*(t, x)</code> for the <code class="reqn">i^{th}</code> kept draw of <code class="reqn">f</code>
and the <code class="reqn">j^{th}</code> row of x.train.<br>
Burn-in is dropped.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>haz.train</code></td>
<td>
<p>The hazard function, <code class="reqn">h(t|x)</code>, where x's are the
rows of the training data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cum.train</code></td>
<td>
<p>The cumulative hazard function, <code class="reqn">h(t|x)</code>, where x's are the
rows of the training data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yhat.test</code></td>
<td>
<p>Same as yhat.train but now the x's are the rows of the test data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>haz.test</code></td>
<td>
<p>The hazard function, <code class="reqn">h(t|x)</code>, where x's are the
rows of the test data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cum.test</code></td>
<td>
<p>The cumulative hazard function, <code class="reqn">h(t|x)</code>, where x's are the
rows of the test data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varcount</code></td>
<td>
<p>a matrix with ndpost rows and nrow(x.train) columns.
Each row is for a draw. For each variable (corresponding to the columns),
the total count of the number of times
that variable is used in a tree decision rule (over all trees) is given.</p>
</td>
</tr>
</table>
<p>Note that yhat.train and yhat.test are
<code class="reqn">f(t, x)</code> + <code>binaryOffset</code>.  If you want draws of the probability
<code class="reqn">P(Y=1 | t, x)</code> you need to apply the normal cdf (<code>pnorm</code>)
to these values.
</p>


<h3>See Also</h3>

<p><code>recur.pre.bart</code>, <code>predict.recurbart</code>,
<code>recur.pwbart</code>, <code>mc.recur.pwbart</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## load 20 percent random sample
data(xdm20.train)
data(xdm20.test)
data(ydm20.train)

##test BART with token run to ensure installation works
## with current technology even a token run will violate CRAN policy
## set.seed(99)
## post &lt;- recur.bart(x.train=xdm20.train, y.train=ydm20.train,
##                    nskip=1, ndpost=1, keepevery=1)

## Not run: 

## set.seed(99)
## post &lt;- recur.bart(x.train=xdm20.train, y.train=ydm20.train,
##                    keeptrainfits=TRUE)

## larger data sets can take some time so, if parallel processing
## is available, submit this statement instead
post &lt;- mc.recur.bart(x.train=xdm20.train, y.train=ydm20.train,
                      keeptrainfits=TRUE, mc.cores=8, seed=99)

require(rpart)
require(rpart.plot)

post$yhat.train.mean &lt;- apply(post$yhat.train, 2, mean)
dss &lt;- rpart(post$yhat.train.mean~xdm20.train)

rpart.plot(dss)
## for the 20 percent sample, notice that the top splits
## involve cci_pvd and n
## for the full data set, notice that all splits
## involve ca, cci_pud, cci_pvd, ins270 and n
## (except one at the bottom involving a small group)

## compare patients treated with insulin (ins270=1) vs
## not treated with insulin (ins270=0)
N &lt;- 50 ## 50 training patients and 50 validation patients
K &lt;- post$K ## 798 unique time points
NK &lt;- 50*K

## only testing set, i.e., remove training set
xdm20.test. &lt;- xdm20.test[NK+1:NK, post$rm.const]
xdm20.test. &lt;- rbind(xdm20.test., xdm20.test.)
xdm20.test.[ , 'ins270'] &lt;- rep(0:1, each=NK)

## multiple threads will be utilized if available
pred &lt;- predict(post, xdm20.test., mc.cores=8)

## create Friedman's partial dependence function for the
## relative intensity for ins270 by time
M &lt;- nrow(pred$haz.test) ## number of MCMC samples
RI &lt;- matrix(0, M, K)
for(j in 1:K) {
    h &lt;- seq(j, NK, by=K)
    RI[ , j] &lt;- apply(pred$haz.test[ , h+NK]/
                      pred$haz.test[ , h], 1, mean)
}

RI.lo &lt;- apply(RI, 2, quantile, probs=0.025)
RI.mu &lt;- apply(RI, 2, mean)
RI.hi &lt;- apply(RI, 2, quantile, probs=0.975)

plot(post$times, RI.hi, type='l', lty=2, log='y',
     ylim=c(min(RI.lo, 1/RI.hi), max(1/RI.lo, RI.hi)),
     xlab='t', ylab='RI(t, x)',
     sub='insulin(ins270=1) vs. no insulin(ins270=0)',
     main='Relative intensity of hospital admissions for diabetics')
lines(post$times, RI.mu)
lines(post$times, RI.lo, lty=2)
lines(post$times, rep(1, K), col='darkgray')

## RI for insulin therapy seems fairly constant with time
mean(RI.mu)


## End(Not run)
</code></pre>


</div>