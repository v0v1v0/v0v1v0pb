<div class="container">

<table style="width: 100%;"><tr>
<td>spg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Large-Scale Optimization</h2>

<h3>Description</h3>

<p>Spectral projected gradient method for large-scale optimization with simple constraints.</p>


<h3>Usage</h3>

<pre><code class="language-R">     spg(par, fn, gr=NULL, method=3, lower=-Inf, upper=Inf, 
           project=NULL, projectArgs=NULL, 
	   control=list(), quiet=FALSE, alertConvergence=TRUE, ...)
 </code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p>A real vector argument to <code>fn</code>, indicating the initial guess for the optimization of nonlinear 
objective function <code>fn</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fn</code></td>
<td>
<p>Nonlinear objective function that is to be optimized. 
A scalar function that takes a real vector as argument and 
returns a scalar that is the value of the function at that point 
(see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gr</code></td>
<td>
<p>The gradient of the objective function <code>fn</code> evaluated at the 
argument.  This is a vector-function that takes a real 
vector as argument and returns a real vector of the same length.  
It defaults to "NULL", which means that gradient is evaluated numerically.  
Computations are dramatically faster in high-dimensional problems when 
the exact gradient is provided.  See *Example*.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>An integer (1, 2, or 3) specifying which Barzilai-Borwein 
steplength to use.  The default is 3.  See *Details*.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p>An upper bound for box constraints.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>An lower bound for box constraints.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>project</code></td>
<td>
<p>A projection
function or character string indicating its name. The projection
function takes a point in <code class="reqn">R^n</code> and 
projects it onto a region that defines the constraints of the problem.  
This is a vector-function that takes a real vector as argument and 
returns a real vector of the same length. See *Details*. 
If a projection function is not supplied, arguments <code>lower</code> and
<code>upper</code> will cause the use of an internally defined function that
enforces the implied box constraints.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>projectArgs</code></td>
<td>
<p>A list with arguments to the <code>project</code>  
function. See *Details*. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>A list of control parameters. See *Details*.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quiet</code></td>
<td>
<p>A logical variable (TRUE/FALSE). If <code>TRUE</code> warnings 
and some additional information printing are suppressed.  
Default is <code>quiet = FALSE</code>
Note that <code>quiet</code> and the <code>control</code> variable <code>trace</code>  
affect different printing, so if <code>trace</code> is not set to <code>FALSE</code> 
there will be considerable printed output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alertConvergence</code></td>
<td>
<p>A logical variable. With the default <code>TRUE</code>
a warning is issued if convergence is not obtained. When set to <code>FALSE</code>
the warning is suppressed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed to <code>fn</code> and <code>gr</code>.
(Both must accept any specified arguments, either 
explicitly or by having a ... argument, but
they do not need to use them all.)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>R adaptation, with significant modifications, by Ravi Varadhan, Johns
Hopkins University (March 25, 2008), from the original FORTRAN code of
Birgin, Martinez, and Raydan (2001). The original is available at the 
TANGO project <a href="http://www.ime.usp.br/~egbirgin/tango/downloads.php">http://www.ime.usp.br/~egbirgin/tango/downloads.php</a>
</p>
<p>A major modification in our R adaptation of the original FORTRAN code is the 
availability of 3 different options for Barzilai-Borwein (BB) 
steplengths: <code>method = 1</code> is the BB 
steplength used in Birgin, Martinez and Raydan (2000);  <code>method = 2</code> is 
the other steplength proposed in Barzilai and Borwein's (1988) original paper.  
Finally, <code>method = 3</code>, is a new steplength, which was first proposed in 
Varadhan and Roland (2008) for accelerating the EM algorithm.  
In fact, Varadhan and Roland (2008) considered 3 similar steplength schemes in 
their EM acceleration work.  Here, we have chosen <code>method = 3</code> 
as the "default" method.  This method may be slightly slower than the 
other 2 BB steplength schemes, but it generally exhibited more reliable 
convergence to a better optimum in our experiments.  
We recommend that the user try the other steplength schemes if the default 
method does not perform well in their problem.  
</p>
<p>Box constraints can be imposed by vectors <code>lower</code> and <code>upper</code>. 
Scalar values for <code>lower</code> and <code>upper</code> are expanded to apply to 
all parameters. The default <code>lower</code> is <code>-Inf</code> and <code>upper</code> 
is <code>+Inf</code>, which imply no constraints.
</p>
<p>The <code>project</code> argument provides a way to implement more general constraints
to be imposed on the parameters in <code>spg</code>. <code>projectArgs</code> is passed
to the <code>project</code> function if one is specified.  The first argument of any <code>project</code> function should be <code>par</code> and any other arguments should be passed using its argument <code>projectArgs</code>.    
To avoid confusion it is suggested that user defined <code>project</code>
functions should not use arguments  <code>lower</code> and <code>upper</code>.
</p>
<p>The function <code>projectLinear</code> incorporates linear equalities and 
inequalities. This function also provides an example of how other projections
might be implemented.
</p>
<p>Argument <code>control</code> is a list specifing any changes to default values of 
algorithm control parameters.  Note that the names of these must be 
specified completely.  Partial matching will not work. 
The list items are as follows:
</p>

<dl>
<dt>M</dt>
<dd>
<p>A positive integer, typically between 5-20, that controls the monotonicity of the algorithm.  <code>M=1</code> would enforce strict monotonicity 
in the reduction of L2-norm of <code>fn</code>, whereas larger values allow for more non-monotonicity.  Global convergence under non-monotonicity is ensured by 
enforcing the Grippo-Lampariello-Lucidi condition (Grippo et al. 1986) in a non-monotone line-search algorithm.  Values of <code>M</code> 
between 5 to 20 are generally good.  The default is <code>M = 10</code>.</p>
</dd> 
<dt>maxit</dt>
<dd>
<p>The maximum number of iterations.  The default is <code>maxit = 1500</code>.</p>
</dd>
<dt>ftol</dt>
<dd>
<p>Convergence tolerance on the absolute change in objective function between successive iterations.  
Convergence is declared when the change is less than <code>ftol</code>.  Default is <code>ftol = 1.e-10</code>.</p>
</dd>
<dt>gtol</dt>
<dd>
<p>Convergence tolerance on the infinity-norm of projected gradient <code>gr</code> evaluated at the current parameter.  
Convergence is declared when the infinity-norm of projected gradient is less
than <code>gtol</code>.  Default is <code>gtol = 1.e-05</code>.</p>
</dd>
<dt>maxfeval</dt>
<dd>
<p>Maximum limit on the number of function evaluations.  Default is <code>maxfeval = 10000</code>.</p>
</dd>
<dt>maximize</dt>
<dd>
<p>A logical variable indicating whether the objective function is to be maximized.  Default is <code>maximize = FALSE</code> indicating
minimization.  For maximization (e.g. log-likelihood maximization in statistical modeling), this may be set to <code>TRUE</code>.</p>
</dd>
<dt>trace</dt>
<dd>
<p>A logical variable (TRUE/FALSE). If <code>TRUE</code>, information on 
the progress of optimization is printed.  Default is <code>trace = !quiet</code>.</p>
</dd>
<dt>triter</dt>
<dd>
<p>An integer that controls the frequency of tracing 
when <code>trace=TRUE</code>. Default is <code>triter=10</code>, which means that
the objective <code>fn</code> and the infinity-norm of its projected gradient are
printed at every 10-th iteration.</p>
</dd>   
<dt>eps</dt>
<dd>
<p>A small positive increment used in the finite-difference 
approximation of gradient.  Default is 1.e-07.</p>
</dd>
<dt>checkGrad</dt>
<dd>
<p><code>NULL</code> or a  logical variable <code>TRUE/FALSE</code> 
indicating whether to 
check the provided analytical gradient against a numerical approximation. 
With the default <code>NULL</code> the gradient is checked if it is estimated to take
less than about ten seconds. A warning will be issued in the case it takes 
longer. The default can be overridden by specifying <code>TRUE</code> or <code>FALSE</code>.
It is recommended that this be set to FALSE for high-dimensional problems, 
after making sure that the gradient is correctly specified, possibly by running
once with <code>TRUE</code> specified.</p>
</dd>
<dt>checkGrad.tol</dt>
<dd>
<p>A small positive value use to compare the maximum relative
difference between a user supplied gradient gr and the numerical approximation
calculated by grad from package <span class="pkg">numDeriv</span>. The default is 1.e-06.
If this value is exceeded then an error message is issued, as it is a 
reasonable indication of a problem with the user supplied gr. The user can
either fix the gr function, remove it so the finite-difference 
approximation is used, or increase the tolerance so the check passes.</p>
</dd>
</dl>
<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p>Parameters that optimize the nonlinear objective function, 
if convergence is successful.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>The value of the objective function at termination.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gradient</code></td>
<td>
<p>L-infinity norm of the projected gradient of the objective function at termination. If convergence is successful, this should be less than <code>gtol</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fn.reduction</code></td>
<td>
<p>Reduction in the value of the function from its initial value. This is negative in maximization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>Number of iterations taken by the algorithm. The gradient is evaluated once each iteration, so the number of gradient evaluations will also be equal to <code>iter</code>, plus any evaluations necessary for <code>checkGrad</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>feval</code></td>
<td>
<p>Number of times the objective <code>fn</code> was evaluated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence</code></td>
<td>
<p>An integer code indicating type of convergence.  <code>0</code> 
indicates successful convergence, in which case the projcted gradient is smaller 
than <code>pgtol</code> or the change in objective function is smaller than <code>ftol</code>.  Error codes are: <code>1</code> indicates that the maximum limit 
for iterations <code>maxit</code> has been reached.  <code>2</code> indicates that 
maximum limit on function evals has been exceeded.  <code>3</code> indicates 
failure due to error in function evaluation. <code>4</code> indicates failure due 
to error in gradient evaluation. <code>5</code> indicates failure due to error in 
projection.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>message</code></td>
<td>
<p>A text message explaining which termination criterion was used.</p>
</td>
</tr>
</table>
<h3>References</h3>

   
<p>Birgin EG, Martinez JM, and Raydan M (2000): Nonmonotone spectral projected gradient methods on convex sets, <em>SIAM J Optimization</em>, 10, 1196-1211.
</p>
<p>Birgin EG, Martinez JM, and Raydan M (2001): SPG: software for convex-constrained optimization, <em>ACM Transactions on Mathematical Software</em>.
</p>
<p>L Grippo, F Lampariello, and S Lucidi (1986),  A nonmonotone line search technique for Newton's method,  <em>SIAM J on Numerical Analysis</em>, 23, 707-716. 
</p>
<p>M Raydan (1997),  Barzilai-Borwein gradient method for large-scale unconstrained minimization problem, <em>SIAM J of Optimization</em>, 7, 26-33.
</p>
<p>R Varadhan and C Roland (2008), Simple and globally-convergent methods for accelerating the convergence of any EM algorithm,  <em>Scandinavian J Statistics</em>, doi: 10.1111/j.1467-9469.2007.00585.x.  
</p>
<p>R Varadhan and PD Gilbert (2009),  BB: An R Package for Solving a Large System of Nonlinear Equations and for Optimizing a High-Dimensional Nonlinear Objective Function, <em>J. Statistical Software</em>, 32:4, <a href="http://www.jstatsoft.org/v32/i04/">http://www.jstatsoft.org/v32/i04/</a>
</p>


<h3>See Also</h3>

<p><code>projectLinear</code>,
<code>BBoptim</code>,
<code>optim</code>,
<code>nlm</code>,
<code>sane</code>,
<code>dfsane</code>,
<code>grad</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">sc2.f &lt;- function(x){ sum((1:length(x)) * (exp(x) - x)) / 10}

sc2.g &lt;- function(x){ (1:length(x)) * (exp(x) - 1) / 10}

p0 &lt;- rnorm(50)
ans.spg1 &lt;- spg(par=p0, fn=sc2.f)  # Default is method=3
ans.spg2 &lt;- spg(par=p0, fn=sc2.f, method=1)
ans.spg3 &lt;- spg(par=p0, fn=sc2.f, method=2)
ans.cg &lt;- optim(par=p0, fn=sc2.f, method="CG")  #Uses conjugate-gradient method in "optim"
ans.lbfgs &lt;- optim(par=p0, fn=sc2.f, method="L-BFGS-B")  #Uses low-memory BFGS method in "optim"

# Now we use exact gradient.  
# Computation is much faster compared to when using numerical gradient.
ans.spg1 &lt;- spg(par=p0, fn=sc2.f, gr=sc2.g)

############
# Another example illustrating use of additional parameters to objective function 
valley.f &lt;- function(x, cons) {
  n &lt;- length(x)
  f &lt;- rep(NA, n)
  j &lt;- 3 * (1:(n/3))
  jm2 &lt;- j - 2
  jm1 &lt;- j - 1
  f[jm2] &lt;- (cons[2] * x[jm2]^3 + cons[1] * x[jm2]) * exp(-(x[jm2]^2)/100) - 1
  f[jm1] &lt;- 10 * (sin(x[jm2]) - x[jm1])
  f[j] &lt;- 10 * (cos(x[jm2]) - x[j])
  sum(f*f)
  }

k &lt;- c(1.003344481605351, -3.344481605351171e-03)
p0 &lt;- rnorm(30)  # number of parameters should be a multiple of 3 for this example
ans.spg2 &lt;- spg(par=p0, fn=valley.f, cons=k, method=2)  
ans.cg &lt;- optim(par=p0, fn=valley.f, cons=k, method="CG")  
ans.lbfgs &lt;- optim(par=p0, fn=valley.f, cons=k, method="L-BFGS-B")  

####################################################################
# Here is a statistical example illustrating log-likelihood maximization.

poissmix.loglik &lt;- function(p,y) {
  # Log-likelihood for a binary Poisson mixture
  i &lt;- 0:(length(y)-1)
  loglik &lt;- y*log(p[1]*exp(-p[2])*p[2]^i/exp(lgamma(i+1)) + 
        (1 - p[1])*exp(-p[3])*p[3]^i/exp(lgamma(i+1)))
  return (sum(loglik) )
  }

# Data from Hasselblad (JASA 1969)
poissmix.dat &lt;- data.frame(death=0:9, freq=c(162,267,271,185,111,61,27,8,3,1))
y &lt;- poissmix.dat$freq

# Lower and upper bounds on parameters
lo &lt;- c(0.001,0,0)  
hi &lt;- c(0.999, Inf, Inf)

p0 &lt;- runif(3,c(0.2,1,1),c(0.8,5,8))  # randomly generated starting values

ans.spg &lt;- spg(par=p0, fn=poissmix.loglik, y=y, lower=lo, upper=hi, 
     control=list(maximize=TRUE))

# how to compute hessian at the MLE
  require(numDeriv)
  hess &lt;- hessian(x=ans.spg$par, poissmix.loglik, y=y)
  se &lt;- sqrt(-diag(solve(hess)))  # approximate standard errors


</code></pre>


</div>