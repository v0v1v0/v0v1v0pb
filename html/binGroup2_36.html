<div class="container">

<table style="width: 100%;"><tr>
<td>OTC2</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Find the optimal testing configuration for group testing algorithms
that use a multiplex assay for two diseases</h2>

<h3>Description</h3>

<p>Find the optimal testing configuration (OTC) using
non-informative and informative hierarchical and array-based group testing
algorithms. Multiplex assays for two diseases are used at each stage of the
algorithms.
</p>


<h3>Usage</h3>

<pre><code class="language-R">OTC2(
  algorithm,
  p.vec = NULL,
  probabilities = NULL,
  alpha = NULL,
  Se,
  Sp,
  ordering = matrix(data = c(0, 1, 0, 1, 0, 0, 1, 1), nrow = 4, ncol = 2),
  group.sz,
  trace = TRUE,
  print.time = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>character string defining the group testing
algorithm to be used. Non-informative testing options include two-stage
hierarchical ("<kbd>D2</kbd>"), three-stage hierarchical ("<kbd>D3</kbd>"),
square array testing without master pooling ("<kbd>A2</kbd>"), and square array
testing with master pooling ("<kbd>A2M</kbd>"). Informative testing options
include two-stage hierarchical ("<kbd>ID2</kbd>") and three-stage hierarchical
("<kbd>ID3</kbd>") testing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.vec</code></td>
<td>
<p>vector of overall joint probabilities. The joint probabilities
are assumed to be equal for all individuals in the algorithm
(non-informative testing only). There are four joint probabilities to
consider: <code class="reqn">p_{00}</code>, the probability that an individual tests
negative for both diseases; <code class="reqn">p_{10}</code>, the probability that an
individual tests positive only for the first disease; <code class="reqn">p_{01}</code>,
the probability that an individual tests positive only for the second
disease; and <code class="reqn">p_{11}</code>, the probability that an individual tests
positive for both diseases. The joint probabilities must sum to 1. Only one
of <kbd>p.vec</kbd>, <kbd>probabilities</kbd>, or <kbd>alpha</kbd> should be specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>probabilities</code></td>
<td>
<p>matrix of joint probabilities for each individual,
where rows correspond to the four joint probabilities and columns correspond
to each individual in the algorithm. Only one of <kbd>p.vec</kbd>,
<kbd>probabilities</kbd>, or <kbd>alpha</kbd> should be specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>vector containing positive shape parameters of the Dirichlet
distribution (for informative testing only). The vector will be used to
generate a heterogeneous matrix of joint probabilities for each individual.
The vector must have length 4. Further details are given under 'Details'.
Only one of <kbd>p.vec</kbd>, <kbd>probabilities</kbd>, or <kbd>alpha</kbd> should be
specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Se</code></td>
<td>
<p>matrix of sensitivity values, where one value is given for each
disease (or infection) at each stage of testing. The rows of the matrix
correspond to each disease <code class="reqn">k=1,2</code>, and the columns of the matrix
correspond to each stage of testing <code class="reqn">s=1,...,S</code>. If a vector of 2
values is provided, the sensitivity values associated with disease <code class="reqn">k</code>
are assumed to be equal to the <code class="reqn">k</code>th value in the vector for all stages
of testing. Further details are given under 'Details'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sp</code></td>
<td>
<p>matrix of specificity values, where one value is given for each
disease (or infection) at each stage of testing. The rows of the matrix
correspond to each disease <code class="reqn">k=1,2</code>, and the columns of the matrix
correspond to each stage of testing <code class="reqn">s=1,...,S</code>. If a vector of 2
values is provided, the specificity values associated with disease <code class="reqn">k</code>
are assumed to be equal to the <code class="reqn">k</code>th value in the vector for all stages
of testing. Further details are given under 'Details'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ordering</code></td>
<td>
<p>matrix detailing the ordering for the binary responses of
the diseases. The columns of the matrix correspond to each disease and the
rows of the matrix correspond to each of the 4 sets of binary responses for
two diseases. This ordering is used with the joint probabilities. The
default ordering is (p_00, p_10, p_01, p_11).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group.sz</code></td>
<td>
<p>single group size or range of group sizes for which to
calculate operating characteristics and/or find the OTC. The details of
group size specification are given under 'Details'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>a logical value indicating whether the progress of
calculations should be printed for each initial group size provided by
the user. The default is <kbd>TRUE</kbd>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.time</code></td>
<td>
<p>a logical value indicating whether the length of time
for calculations should be printed. The default is <kbd>TRUE</kbd>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments to be passed to functions for hierarchical
testing with multiplex assays for two diseases.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function finds the OTC for standard group testing algorithms
with a multiplex assay that tests for two diseases and computes the
associated operating characteristics. Calculations for hierarchical group
testing algorithms are performed as described in Bilder et al. (2019) and
calculations for array-based group testing algorithms are performed as
described in Hou et al. (2019).
</p>
<p>Available algorithms include two- and three-stage hierarchical testing and
array testing with and without master pooling. Both non-informative and
informative group testing settings are allowed for hierarchical algorithms.
Only non-informative group testing settings are allowed for array testing
algorithms. Operating characteristics calculated are expected number of
tests, pooling sensitivity, pooling specificity, pooling positive
predictive value, and pooling negative predictive value for each individual.
</p>
<p>For informative algorithms where the <kbd>alpha</kbd> argument is specified, a
heterogeneous matrix of joint probabilities for each individual is generated
using the Dirichlet distribution. This is done using
<code>rBeta2009::rdirichlet</code> and requires the user to set a seed to
reproduce results. See Bilder et al. (2019) for additional details on the
use of the Dirichlet distribution for this purpose.
</p>
<p>The sensitivity/specificity values are allowed to vary across stages of
testing. For hierarchical testing, a different sensitivity/specificity value
may be used for each stage of testing. For array testing, a different
sensitivity/specificity value may be used for master pool testing (if
included), row/column testing, and individual testing. The values must be
specified in the order of the testing performed. For example, values are
specified as (stage 1, stage 2, stage 3) for three-stage hierarchical
testing or (master pool testing, row/column testing, individual testing)
for array testing with master pooling. A vector of 2
sensitivity/specificity values may be specified, and sensitivity/specificity
values for all stages of testing are assumed to be equal. The first value
in the vector will be used at each stage of testing for the first disease,
and the second value in the vector will be used at each stage of testing
for the second disease.
</p>
<p>The value(s) specified by <kbd>group.sz</kbd> represent the initial (stage 1)
group size for hierarchical testing and the row/column size for array
testing. If a single value is provided for <kbd>group.sz</kbd> with two-stage
hierarchical or array testing, operating characteristics will be calculated
and no optimization will be performed. If a single value is provided for
<kbd>group.sz</kbd> with three-stage hierarchical, the OTC will be found over all
possible configurations with this initial group size. If a range of group
sizes is specified, the OTC will be found over all group sizes.
</p>
<p>In addition to the OTC, operating characteristics for some of the other
configurations corresponding to each initial group size provided by the user
are displayed. For algorithms where there is only one configuration for each
initial group size (non-informative two-stage hierarchical and all array
testing algorithms), results for each initial group size are provided. For
algorithms where there is more than one possible configuration for each
initial group size (informative two-stage hierarchical and all three-stage
hierarchical algorithms), two sets of configurations are provided: 1) the
best configuration for each initial group size, and 2) the top 10
configurations for each initial group size provided by the user. If a single
value is provided for <kbd>group.sz</kbd> with array testing or non-informative
two-stage hierarchical testing, operating characteristics will not be
provided for configurations other than that specified by the user. Results
are sorted by the value of the objective function per individual,
<kbd>value</kbd>.
</p>
<p>The displayed overall pooling sensitivity, pooling specificity, pooling
positive predictive value, and pooling negative predictive value are
weighted averages of the corresponding individual accuracy measures for all
individuals within the initial group (or block) for a hierarchical
algorithm, or within the entire array for an array-based algorithm.
Expressions for these averages are provided in the Supplementary Material
for Hitt et al. (2019). These expressions are based on accuracy definitions
given by Altman and Bland (1994a, 1994b). Individual accuracy measures can
be calculated using the <code>operatingCharacteristics2</code>
(<code>opChar2</code>) function.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>the group testing algorithm used for calculations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prob.vec</code></td>
<td>
<p>the vector of joint probabilities provided by the user,
if applicable (for non-informative algorithms only).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>joint.p</code></td>
<td>
<p>the matrix of joint probabilities for each individual
provided by the user, if applicable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.vec</code></td>
<td>
<p>the alpha vector provided by the user, if applicable
(for informative algorithms only).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Se</code></td>
<td>
<p>the matrix of sensitivity values for each disease at each stage
of testing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sp</code></td>
<td>
<p>the matrix of specificity values for each disease at each stage
of testing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opt.ET</code></td>
<td>
<p>a list containing:
</p>

<dl>
<dt>OTC</dt>
<dd>
<p>a list specifying elements of the optimal testing configuration,
which may include:
</p>

<dl>
<dt>Stage1</dt>
<dd>
<p>group size for the first stage of hierarchical testing, if
applicable.</p>
</dd>
<dt>Stage2</dt>
<dd>
<p>group sizes for the second stage of hierarchical testing, if
applicable.</p>
</dd>
<dt>Block.sz</dt>
<dd>
<p>the block size/initial group size for informative Dorfman
testing, which is not tested.</p>
</dd>
<dt>pool.szs</dt>
<dd>
<p>group sizes for the first stage of testing for informative
Dorfman testing.</p>
</dd>
<dt>Array.dim</dt>
<dd>
<p>the row/column size for array testing.</p>
</dd>
<dt>Array.sz</dt>
<dd>
<p>the overall array size for array testing (the square of the
row/column size).</p>
</dd>
</dl>
</dd>
<dt>p.mat</dt>
<dd>
<p>the matrix of joint probabilities for each individual in the
algorithm. Each row corresponds to one of the four joint probabilities.
Each column corresponds to an individual in the testing algorithm.</p>
</dd>
<dt>ET</dt>
<dd>
<p>the expected testing expenditure for the OTC.</p>
</dd>
<dt>value</dt>
<dd>
<p>the value of the expected number of tests per individual.</p>
</dd>
<dt>Accuracy</dt>
<dd>
<p>the matrix of overall accuracy measures for the algorithm.
The rows correspond to each disease. The columns
correspond to the pooling sensitivity, pooling specificity, pooling positive
predictive value, and pooling negative predictive value for the overall
algorithm. Further details are given under 'Details'.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Configs</code></td>
<td>
<p>a data frame containing results for the best configuration
for each initial group size provided by the user. The columns correspond to
the initial group size, configuration (if applicable), overall array size
(if applicable), expected number of tests, value of the objective function
per individual, and accuracy measures for each disease. Accuracy measures
include the pooling sensitivity, pooling specificity, pooling positive
predictive value, and pooling negative predictive value. No results are
displayed if a single <kbd>group.sz</kbd> is provided. Further details are given
under 'Details'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Top.Configs</code></td>
<td>
<p>a data frame containing results for some of the top
configurations for each initial group size provided by the user. The
columns correspond to the initial group size, configuration,
expected number of tests, value of the objective function per individual,
and accuracy measures for each disease. Accuracy measures include the
pooling sensitivity, pooling specificity, pooling positive predictive
value, and pooling negative predictive value. No results are displayed for
non-informative two-stage hierarchical testing or for array testing
algorithms. Further details are given under 'Details'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group.sz</code></td>
<td>
<p>Initial group (or block) sizes examined to find the OTC.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>This function returns the pooling positive and negative
predictive values for all individuals even though these measures are
diagnostic specific; e.g., the pooling positive predictive value should
only be considered for those individuals who have tested positive.
</p>
<p>Additionally, only stage dependent sensitivity and specificity values are
allowed within the program (no group within stage dependent values are
allowed). See Bilder et al. (2019) for additional information.
</p>


<h3>Author(s)</h3>

<p>This function was written by Brianna D. Hitt. It calls
<kbd>ET.all.stages.new</kbd> and <kbd>PSePSpAllStages</kbd>, which were originally
written by Christopher Bilder for Bilder et al. (2019), and <kbd>ARRAY</kbd>,
which was originally written by Peijie Hou for Hou et al. (2020). The
functions <kbd>ET.all.stages.new</kbd>, <kbd>PSePSpAllStages</kbd>, and <kbd>ARRAY</kbd>
were obtained from <a href="http://chrisbilder.com/grouptesting/">http://chrisbilder.com/grouptesting/</a>. Minor
modifications were made to the functions for inclusion in the binGroup2
package.
</p>


<h3>References</h3>

<p>Altman, D., Bland, J. (1994).
“Diagnostic tests 1: Sensitivity and specificity.”
<em>BMJ</em>, <b>308</b>, 1552.
</p>
<p>Altman, D., Bland, J. (1994).
“Diagnostic tests 2: Predictive values.”
<em>BMJ</em>, <b>309</b>, 102.
</p>
<p>Bilder, C., Tebbs, J., McMahan, C. (2019).
“Informative group testing for multiplex assays.”
<em>Biometrics</em>, <b>75</b>, 278–288.
</p>
<p>Hitt, B., Bilder, C., Tebbs, J., McMahan, C. (2019).
“The objective function controversy for group testing: Much ado about nothing?”
<em>Statistics in Medicine</em>, <b>38</b>, 4912–4923.
</p>
<p>Hou, P., Tebbs, J., Wang, D., McMahan, C., Bilder, C. (2021).
“Array testing with multiplex assays.”
<em>Biostatistics</em>, <b>21</b>, 417–431.
</p>
<p>McMahan, C., Tebbs, J., Bilder, C. (2012a).
“Informative Dorfman Screening.”
<em>Biometrics</em>, <b>68</b>, 287–296.
</p>


<h3>See Also</h3>

<p>Other OTC functions: 
<code>OTC1()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Find the OTC for non-informative two-stage
#   hierarchical (Dorfman) testing
Se &lt;- matrix(data = c(0.95, 0.95, 0.99, 0.99), nrow = 2, ncol = 2,
             dimnames = list(Infection = 1:2, Stage = 1:2))
Sp &lt;- matrix(data = c(0.96, 0.96, 0.98, 0.98), nrow = 2, ncol = 2,
             dimnames = list(Infection = 1:2, Stage = 1:2))
OTC2(algorithm = "D2", p.vec = c(0.90, 0.04, 0.04, 0.02),
     Se = Se, Sp = Sp, group.sz = 2:10)

# Find the OTC over all possible testing configurations
#   for informative two-stage hierarchical (Dorfman)
#   testing with a specified group size.
# A matrix of joint probabilities for each individual is
#   generated using the Dirichlet distribution.
Se &lt;- matrix(data = rep(0.95, 4), nrow = 2, ncol = 2,
             dimnames = list(Infection = 1:2, Stage = 1:2))
Sp &lt;- matrix(data = rep(0.99, 4), nrow = 2, ncol = 2,
             dimnames = list(Infection = 1:2, Stage = 1:2))
set.seed(1002)
OTC2(algorithm = "ID2", alpha = c(18.25, 0.75, 0.75, 0.25),
     Se = Se, Sp = Sp, group.sz = 18:22)

# Find the OTC for non-informative three-stage
#   hierarchical testing.
Se &lt;- matrix(data = rep(0.95, 6), nrow = 2, ncol = 3,
             dimnames = list(Infection = 1:2, Stage = 1:3))
Sp &lt;- matrix(data = rep(0.99, 6), nrow = 2, ncol = 3,
             dimnames = list(Infection = 1:2, Stage = 1:3))
OTC2(algorithm = "D3", p.vec = c(0.91, 0.04, 0.04, 0.01),
     Se = Se, Sp = Sp, group.sz = 3:12)

# Find the OTC over all possible configurations
#   for informative three-stage hierarchical
#   testing with a specified group size
#   and a heterogeneous matrix of joint
#   probabilities for each individual.
set.seed(8791)
Se &lt;- matrix(data = rep(0.95, 6), nrow = 2, ncol = 3,
             dimnames = list(Infection = 1:2, Stage = 1:3))
Sp &lt;- matrix(data = rep(0.99, 6), nrow = 2, ncol = 3,
             dimnames = list(Infection = 1:2, Stage = 1:3))
p.unordered &lt;- t(rBeta2009::rdirichlet(n = 8,
                            shape = c(18.25, 0.75, 0.75, 0.25)))
p.ordered &lt;- p.unordered[, order(1 - p.unordered[1,])]
OTC2(algorithm = "ID3", probabilities = p.ordered,
         Se = Se, Sp = Sp, group.sz = 8,
         trace = FALSE, print.time = FALSE)

# Find the OTC for non-informative array testing
#   without master pooling.
Se &lt;- matrix(data = rep(0.95, 4), nrow = 2, ncol = 2,
             dimnames = list(Infection = 1:2, Stage = 1:2))
Sp &lt;- matrix(data = rep(0.99, 4), nrow = 2, ncol = 2,
             dimnames = list(Infection = 1:2, Stage = 1:2))
OTC2(algorithm = "A2", p.vec = c(0.90, 0.04, 0.04, 0.02),
     Se = Se, Sp = Sp, group.sz = 2:10)

# Find the OTC for non-informative array testing
#   with master pooling.
Se &lt;- matrix(data = rep(0.95, 6), nrow = 2, ncol = 3,
             dimnames = list(Infection = 1:2, Stage = 1:3))
Sp &lt;- matrix(data = rep(0.99, 6), nrow = 2, ncol = 3,
             dimnames = list(Infection = 1:2, Stage = 1:3))
OTC2(algorithm = "A2M", p.vec = c(0.90, 0.04, 0.04, 0.02),
     Se = Se, Sp = Sp, group.sz = 10,
     trace = FALSE, print.time = FALSE)
</code></pre>


</div>