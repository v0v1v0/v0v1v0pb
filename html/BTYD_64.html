<div class="container">

<table style="width: 100%;"><tr>
<td>dc.MergeCustomers</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Merge Customers</h2>

<h3>Description</h3>

<p>Takes two CBT or CBS matrices and ensures that the second one has the same
row names as the first.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dc.MergeCustomers(data.correct, data.to.correct)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data.correct</code></td>
<td>
<p>CBT or CBS with the correct customer IDs as row names.
Usually from the calibration period.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data.to.correct</code></td>
<td>
<p>CBT or CBS which needs to be fixed (customer IDs
inserted). Usually from the holdout period.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Care should be taken in using this function. It inserts zero values in all
rows that were not in the original holdout period data. This behavior does
not cause a problem if using CBT matrices, but will cause a problem if using
CBS matrices (for example, the output will report all customers with a
holdout period length of zero). However, this particular issue is easily
fixed (see examples) and should not cause problems.
</p>
<p>A work-around to avoid using this function is presented in the example for
<code>dc.BuildCBSFromCBTAndDates</code> - build the full CBT and only use the columns
applying to each particular time period to construct separate CBTs, and from
them, CBSs. That is a much cleaner and less error-prone method; however, on
occasion the data will not be available in event log format and you may not
be able to construct a CBT for both time periods together.
</p>


<h3>Value</h3>

<p>Updated holdout period CBT or CBS.
</p>


<h3>Examples</h3>

<pre><code class="language-R">elog &lt;- dc.ReadLines(system.file("data/cdnowElog.csv", package="BTYD"),2,3,5)
elog[,"date"] &lt;- as.Date(elog[,"date"], "%Y%m%d")
cutoff.date &lt;- as.Date("1997-09-30")
cal.elog &lt;- elog[which(elog[,"date"] &lt;= cutoff.date),]
holdout.elog &lt;- elog[which(elog[,"date"] &gt; cutoff.date),]

# Create calibration period CBT from cal.elog
cal.reach.cbt &lt;- dc.CreateReachCBT(cal.elog)
# Create holdout period CBT from holdout.elog
holdout.reach.cbt &lt;- dc.CreateReachCBT(holdout.elog)

# Note the difference:
nrow(cal.reach.cbt)            # 2357 customers
nrow(holdout.reach.cbt)        # 684 customers

# Create a "fixed" holdout period CBT, with the same number
# of customers in the same order as the calibration period CBT
fixed.holdout.reach.cbt &lt;- dc.MergeCustomers(cal.reach.cbt, holdout.reach.cbt)
nrow(fixed.holdout.reach.cbt)  # 2357 customers

# You can verify that the above is correct by turning these into a CBS
# (see \code{\link{dc.BuildCBSFromCBTAndDates}} and using
# \code{\link{pnbd.PlotFreqVsConditionalExpectedFrequency}}, for example

# Alternatively, we can fix the CBS, instead of the CBS:

cal.start.dates.indices &lt;- dc.GetFirstPurchasePeriodsFromCBT(cal.reach.cbt)
cal.start.dates &lt;- as.Date(colnames(cal.reach.cbt)[cal.start.dates.indices])
cal.end.dates.indices &lt;- dc.GetLastPurchasePeriodsFromCBT(cal.reach.cbt)
cal.end.dates &lt;- as.Date(colnames(cal.reach.cbt)[cal.end.dates.indices])
T.cal.total &lt;- rep(cutoff.date, nrow(cal.reach.cbt))
cal.dates &lt;- data.frame(cal.start.dates, cal.end.dates, T.cal.total)

# Create calibration period customer-by-sufficient-statistic data frame,
# using weeks as the unit of time.
cal.cbs &lt;- dc.BuildCBSFromCBTAndDates(cal.reach.cbt,
                                      cal.dates,
                                      per="week",
                                      cbt.is.during.cal.period=TRUE)

# Force the calibration period customer-by-sufficient-statistic to only
# 	contain repeat transactions (required by BG/BB and Pareto/NBD models)
cal.cbs[,"x"] &lt;- cal.cbs[,"x"] - 1

holdout.start &lt;- cutoff.date+1
holdout.end &lt;- as.Date(colnames(fixed.holdout.reach.cbt)[ncol(fixed.holdout.reach.cbt)])
holdout.dates &lt;- c(holdout.start, holdout.end)

# Create holdout period customer-by-sufficient-statistic data frame,
# using weeks as the unit of time.
holdout.cbs &lt;- dc.BuildCBSFromCBTAndDates(holdout.reach.cbt,
                                          holdout.dates,
                                          per="week",
                                          cbt.is.during.cal.period=FALSE)

# Note the difference:
nrow(cal.cbs)            # 2357 customers
nrow(holdout.cbs)        # 684 customers

# Create a "fixed" holdout period CBS, with the same number
# of customers in the same order as the calibration period CBS
fixed.holdout.cbs &lt;- dc.MergeCustomers(cal.cbs, holdout.cbs)
nrow(fixed.holdout.cbs)  # 2357 customers

# Furthermore, this function will assign a zero value to all fields
# that were not in the original holdout period CBS. Since T.star is the
# same for all customers in the holdout period, we should fix that:
fixed.holdout.cbs[,"T.star"] &lt;- rep(max(fixed.holdout.cbs[,"T.star"]),nrow(fixed.holdout.cbs))
</code></pre>


</div>