<div class="container">

<table style="width: 100%;"><tr>
<td>bifactorIndices</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>bifactorIndices</h2>

<h3>Description</h3>

<p>Computes all available bifactor indices for the input given.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bifactorIndices(
  Lambda,
  Theta = NULL,
  UniLambda = NULL,
  standardized = TRUE,
  Phi = NULL,
  Thresh = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Lambda</code></td>
<td>
<p>is a matrix of factor loadings or an object that can be converted to a
matrix of factor loadings by <code>getLambda</code>. Currently fitted <span class="pkg">lavaan</span>
objects and fitted <span class="pkg">mirt</span> objects are supported in addition to raw factor loading
matrix input. For <code>Mplus</code> output files, use <code>bifactorIndicesMplus</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Theta</code></td>
<td>
<p>is a vector of residual variances. If omitted, <code>Theta</code> will be computed from
input for <code>Lambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>UniLambda</code></td>
<td>
<p>is a matrix of factor loadings or an object that can be converted to
a matrix of factor loadings such as a fitted <span class="pkg">lavaan</span> objects or fitted <span class="pkg">mirt</span>
object. Defaults to <code>NULL</code>, as <code>UniLambda</code> is only required if you wish to
compute <code>ARPB</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardized</code></td>
<td>
<p>lets the function know whether to look for standardized or
unstandardized results from <span class="pkg">lavaan</span> and defaults to <code>TRUE</code>. If <code>Lambda</code> is not a
<span class="pkg">lavaan</span> object, then <code>standardized</code> will be ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Phi</code></td>
<td>
<p>is the correlation matrix of factors and defaults to <code>NULL</code>. User should generally ignore this
parameter. If not provided, <code>bifactorIndices</code> will try to determine <code>Phi</code> from <code>Lambda</code> when <code>Lambda</code>
is a fitted lavaan model or will assume it is the identity matrix otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Thresh</code></td>
<td>
<p>is a list of vectors of item thresholds, used only when items are categorical.<code>bifactorIndices</code>
will try to determine <code>Thresh</code> from <code>Lambda</code> when <code>Lambda</code>
is a fitted lavaan model and the indicators are categorical.
<code>Thresh</code> defaults to null, which indicates items are continuous.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Currently, factor loading matrices, fitted <span class="pkg">lavaan</span> objects, and fitted <span class="pkg">mirt</span>
objects are supported. For <code>Mplus</code> output, see <code>bifactorIndicesMplus</code>.
IRT parameters from <span class="pkg">mirt</span> are converted to standardized factor loadings via the
correspondence described in Kamata &amp; Bauer (2008). If you wish to use standardized
coefficients, item error variance will be computed directly from standardized factor
loadings. <code>ARPB</code> will only be computed if the factor loadings from a unidimensional model
are included, while <code>ECV_GS</code> and <code>ECV_SG</code> will only be computed for
models with a general factor, and <code>PUC</code> will only be conputed for a true bifactor
model. Note that if a correlated traits model is provided, the omega indices
will simply be the regular omega values for those factors. Interpretations for individual
indices as well as details about their computation can be found in the man page for the
individual indices.
</p>
<p>Formulas for all indices can be found in Rodriguez et al. (2016). When indicators are categorical,
the methodology of Green and Yang (2009) is used for computing Omega and OmegaH.
</p>


<h3>Value</h3>

<p>A list of bifactor indices, including three different ECV indices, IECV, PUC,
Omega, OmegaH, Factor Determinacy (FD), Construct Replicability (H) and ARPB.
Please note that many of these indices are interpretable even
when the model being used is not a bifactor model; some indices may be useful for
two-tier, trifactor, correlated traits, and even unidimensional models.
</p>


<h3>References</h3>

<p>Green, S. B., &amp; Yang, Y. (2009). Reliability of summed item scores using
structural equation modeling: An alternative to coefficient alpha.
<em>Psychometrika, 74</em>(1), 155-167 doi: <a href="https://doi.org/10.1007/s11336-008-9099-3">10.1007/s11336-008-9099-3</a>.
</p>
<p>Kamata, A., &amp; Bauer, D. J. (2008). A note on the relation between factor analytic and item
response theory models. <em>Structural Equation Modeling: A Multidisciplinary Journal, 15</em>
(1), 136-153.
</p>
<p>#' Rodriguez, A., Reise, S. P., &amp; Haviland, M. G. (2016). Evaluating bifactor models:
calculating and interpreting statistical indices. <em>Psychological Methods, 21</em>(2),
137 doi: <a href="https://doi.org/10.1037/met0000045">10.1037/met0000045</a>.
</p>


<h3>See Also</h3>

<p><code>bifactorIndicesMplus</code>,
<code>bifactorIndices_expl</code>,
<code>bifactorIndicesMplus_expl</code>,
<code>bifactorIndicesMplus_ESEM</code>,
<code>ECV_SS</code>,
<code>ECV_SG</code>,
<code>ECV_GS</code>,
<code>IECV</code>,
<code>PUC</code>,
<code>Omega_S</code>,
<code>Omega_H</code>,
<code>cat_Omega_S</code>,
<code>cat_Omega_H</code>,
<code>H</code>,
<code>FD</code>,
<code>ARPB</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Computing bifactor indices from fitted lavaan object
# (using mirt object is similar). Use of the unidimensional
# model is optional; it is only used to compute ARPB.


SRS_UnidimensionalModel &lt;-
  "SRS =~ SRS_1  + SRS_2  + SRS_3  + SRS_4  + SRS_5  +
          SRS_6  + SRS_7  + SRS_8  + SRS_9  + SRS_10 +
          SRS_11 + SRS_12 + SRS_13 + SRS_14 + SRS_15 +
          SRS_16 + SRS_17 + SRS_18 + SRS_19 + SRS_20"

SRS_Unidimensional &lt;- lavaan::cfa(SRS_UnidimensionalModel,
                                 SRS_data,
                                 ordered = paste0("SRS_", 1:20),
                                 orthogonal = TRUE)


SRS_BifactorModel &lt;-
"SRS =~ SRS_1  + SRS_2  + SRS_3  + SRS_4  + SRS_5  +
        SRS_6  + SRS_7  + SRS_8  + SRS_9  + SRS_10 +
        SRS_11 + SRS_12 + SRS_13 + SRS_14 + SRS_15 +
        SRS_16 + SRS_17 + SRS_18 + SRS_19 + SRS_20
 Function     =~ SRS_5  + SRS_9  + SRS_12 + SRS_15 + SRS_18
 Pain         =~ SRS_1  + SRS_2  + SRS_8  + SRS_11 + SRS_17
 SelfImage    =~ SRS_4  + SRS_6  + SRS_10 + SRS_14 + SRS_19
 MentalHealth =~ SRS_3  + SRS_7  + SRS_13 + SRS_16 + SRS_20"

SRS_bifactor &lt;- lavaan::cfa(SRS_BifactorModel,
                            SRS_data,
                            ordered = paste0("SRS_", 1:20),
                            orthogonal = TRUE)

bifactorIndices(SRS_bifactor, UniLambda = SRS_Unidimensional)



# Computing bifactor indices from standardized factor loading matrices
Lambda &lt;-  matrix(c(.82, .10,   0,   0,
                    .77, .35,   0,   0,
                    .79, .32,   0,   0,
                    .66, .39,   0,   0,
                    .51,   0, .71,   0,
                    .56,   0, .43,   0,
                    .68,   0, .13,   0,
                    .60,   0, .50,   0,
                    .83,   0,   0, .47,
                    .60,   0,   0, .27,
                    .78,   0,   0, .28,
                    .55,   0,   0, .75),
                    ncol = 4, byrow = TRUE)
colnames(Lambda) &lt;- c("General", "SF1", "SF2", "SF3")
bifactorIndices(Lambda)


# bifactorIndices can also be used on two-tier models
MTMM_model &lt;- "
Trait1  =~ T1M1_1 + T1M1_2 + T1M1_3 +
           T1M2_1 + T1M2_2 + T1M2_3 +
           T1M3_1 + T1M3_2 + T1M3_3
Trait2  =~ T2M1_1 + T2M1_2 + T2M1_3 +
           T2M2_1 + T2M2_2 + T2M2_3 +
           T2M3_1 + T2M3_2 + T2M3_3
Trait3  =~ T3M1_1 + T3M1_2 + T3M1_3 +
           T3M2_1 + T3M2_2 + T3M2_3 +
           T3M3_1 + T3M3_2 + T3M3_3

Method1  =~ T1M1_1 + T1M1_2 + T1M1_3 +
            T2M1_1 + T2M1_2 + T2M1_3 +
            T3M1_1 + T3M1_2 + T3M1_3
Method2  =~ T1M2_1 + T1M2_2 + T1M2_3 +
            T2M2_1 + T2M2_2 + T2M2_3 +
            T3M2_1 + T3M2_2 + T3M2_3
Method3  =~ T1M3_1 + T1M3_2 + T1M3_3 +
            T2M3_1 + T2M3_2 + T2M3_3 +
            T3M3_1 + T3M3_2 + T3M3_3

Trait1 ~~ 0*Method1
Trait1 ~~ 0*Method2
Trait1 ~~ 0*Method3
Trait2 ~~ 0*Method1
Trait2 ~~ 0*Method2
Trait2 ~~ 0*Method3
Trait3 ~~ 0*Method1
Trait3 ~~ 0*Method2
Trait3 ~~ 0*Method3

Method1 ~~ 0*Method2
Method1 ~~ 0*Method3
Method2 ~~ 0*Method3"

MTMM_fit &lt;- lavaan::cfa(MTMM_model, MTMM_data)
bifactorIndices(MTMM_fit)

</code></pre>


</div>