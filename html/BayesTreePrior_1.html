<div class="container">

<table style="width: 100%;"><tr>
<td>BayesTreePrior</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulation of the tree prior.</h2>

<h3>Description</h3>

<p>This is the main function to use for simulating from the prior. There are 4 cases : 
</p>

<ul>
<li>
<p>Case #1: Unrealistic case where we assume that the number of variables and possible splits are infinite (therefore <code class="reqn">P(T)</code> is not dependent on the design matrix X) and <code class="reqn">\beta=0</code>
</p>
</li>
<li>
<p>Case #2: Unrealistic case where we assume that the number of variables and possible splits are infinite (therefore <code class="reqn">P(T)</code> is not dependent on the design matrix X)
</p>
</li>
<li>
<p>Case #3: One variable with a finite number of observations (Seems to be equivalent to the multiple variables case when all variables are continuous)
</p>
</li>
<li>
<p>Case #4: General case
</p>
</li>
</ul>
<p>Case #1 will be used if no design matrix X or number of observations is given and <code class="reqn">\beta = 0</code>. Case #2 will be used if no design matrix X or number of observations is given and <code class="reqn">\beta \neq 0</code>. Case #3 will be used if no design matrix X is given but the number of observations is given. Case #4 will be used if the design matrix X is given. Note that case #4 is always slower, so if all your variables are continuous, it would be advisable to enter the number of uniques observations rather than the design matrix X, to be able to use case #3.
</p>


<h3>Usage</h3>

<pre><code class="language-R">BayesTreePrior(alpha, beta, X = NULL, n_obs = NULL, n_iter = 500,
  minpart = 1, package = NULL, pvars = NULL, MIA = FALSE,
  missingdummy = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>base parameter of the tree prior, <code class="reqn">\alpha \in [0,1)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>power parameter of the tree prior, <code class="reqn">\beta \geq 0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>data.frame of the design matrix (Required for case #4).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_obs</code></td>
<td>
<p>number of unique observations, <code class="reqn">n_{obs}&gt;1</code> (Required for case #3).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_iter</code></td>
<td>
<p>number of trees to generate, <code class="reqn">n_{iter}&gt;0</code> (Used for case #2, #3 or #4).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minpart</code></td>
<td>
<p>the minimum number of observations required in one of the child to be able to split, <code class="reqn">minpart&gt;0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>package</code></td>
<td>
<p>a optional string that can take the following values : "BayesTree", "tgp" or "bartMachine". It forces the algorithm to use the default paramameters used by the package specified (<code class="reqn">minpart=5</code> for BayesTree, <code class="reqn">minpart = max(c(10,dim(X)[2]+1))</code> for tgp and <code class="reqn">minpart=1</code> for bartMachine).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pvars</code></td>
<td>
<p>vector of probabilities for the choices of variables to split (Will automatically be normalized so that the sum equal to 1). It must be twice as large as the number of variables when <code class="reqn">missingdummy</code> is TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MIA</code></td>
<td>
<p>set to TRUE if you want Missing Incorporated in Attributes (MIA) imputation to be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missingdummy</code></td>
<td>
<p>set to TRUE if you want the NAs to be dummy coded.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>In case #1, it returns a list containing, in the following order: the expectation and the variance of the number of bottom nodes. In cases #2, #3 or #4, it returns a list containing, in the following order: the mean number of bottom nodes, the standard deviation of the number of bottom nodes, the mean of the depth, the standard deviation of the depth and a data.frame of vectors <code class="reqn">(b_i,d_i)</code>, where <code class="reqn">b_i</code> is the number of bottom nodes and <code class="reqn">d_i</code> is the depth of the <code class="reqn">i</code>th generated tree (<code class="reqn">i=1, \ldots ,n_{iter}</code>).
</p>


<h3>References</h3>

<p>Chipman, H. A., George, E. I., &amp; McCulloch, R. E. (1998). <em>Bayesian CART model search.</em> Journal of the American Statistical Association, 93(443), 935-948.
</p>
<p>Gramacy, R. B. (2007). tgp: <em>an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> package for Bayesian nonstationary, semiparametric nonlinear regression and design by treed Gaussian process models.</em> Journal of Statistical Software, 19(9), 6.
</p>
<p>Chipman, H. A., George, E. I., &amp; McCulloch, R. E. (2010). <em>BART: Bayesian additive regression trees.</em> The Annals of Applied Statistics, 266-298.
</p>
<p>Kapelner, A., &amp; Bleich, J. (2013). <em>bartMachine: A powerful tool for machine learning.</em> stat, 1050, 8.
</p>
<p>Twala, B. E. T. H., Jones, M. C., &amp; Hand, D. J. (2008). <em>Good methods for coping with missing data in decision trees.</em> Pattern Recognition Letters, 29(7), 950-956.
</p>
<p>Jolicoeur-Martineau, A. (expected 2016) <em>Etude d'une loi a priori pour les arbres binaires de regression</em> (<em>Study on the prior distribution of binary regression trees</em>) (Master thesis). UQAM university.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#Case 1 : Unrealistic case where we assume that the number of var/obs is infinite and beta=0
results1 = BayesTreePrior(.45,0)
#Case 2 : Unrealistic case where we assume that the number of var/obs is infinite
results2 = BayesTreePrior(.95,.5)
#Case 3 : One variable with a finite number of observations
results3 = BayesTreePrior(.95,.5,n_obs=150)
if (requireNamespace("MASS", quietly = TRUE)) {
    #Case 4 : General case, without missing data
    x1 = MASS::mcycle$times
    x2= MASS::mcycle$accel
    X = cbind(x1, x2)
    results4_nomiss = BayesTreePrior(.95,.5, data.frame(X), minpart=5, package="tgp")
    #Case 4 : General case, with missing data
    x1[sample(1:length(x1), 20)] &lt;- NA
    x2[sample(1:length(x2), 20)] &lt;- NA
    X = cbind(x1, x2)
    results4_miss = BayesTreePrior(.95,.5, data.frame(X), minpart=5, package="tgp", 
    MIA=TRUE, missingdummy=TRUE)
}
</code></pre>


</div>