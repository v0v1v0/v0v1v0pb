<div class="container">

<table style="width: 100%;"><tr>
<td>rhierBinLogit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>MCMC Algorithm for Hierarchical Binary Logit</h2>

<h3>Description</h3>

<p><b>This function has been deprecated. Please use <code>rhierMnlRwMixture</code> instead.</b>
</p>
<p><code>rhierBinLogit</code> implements an MCMC algorithm for hierarchical binary logits with a normal heterogeneity distribution. This is a hybrid sampler with a RW Metropolis step for unit-level logit parameters. 
</p>
<p><code>rhierBinLogit</code> is designed for use on choice-based conjoint data with partial profiles. The Design matrix is based on differences of characteristics between two alternatives. See Appendix A of <em>Bayesian Statistics and Marketing</em> for details.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rhierBinLogit(Data, Prior, Mcmc)</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Data </code></td>
<td>
<p>list(lgtdata, Z)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Prior</code></td>
<td>
<p>list(Deltabar, ADelta, nu, V)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Mcmc </code></td>
<td>
<p>list(R, keep, sbeta)</p>
</td>
</tr>
</table>
<h3>Details</h3>



<h4>Model and Priors</h4>

<p><code class="reqn">y_{hi} = 1</code> with <code class="reqn">Pr = exp(x_{hi}'\beta_h) / (1+exp(x_{hi}'\beta_h)</code> and <code class="reqn">\beta_h</code> is <code class="reqn">nvar x 1</code> <br><code class="reqn">h = 1, \ldots, length(lgtdata)</code> units (or "respondents" for survey data)
</p>
<p><code class="reqn">\beta_h</code> = ZDelta[h,] + <code class="reqn">u_h</code> <br>
Note: here ZDelta refers to <code>Z%*%Delta</code> with ZDelta[h,] the <code class="reqn">h</code>th row of this product<br>
Delta is an <code class="reqn">nz x nvar</code> array
</p>
<p><code class="reqn">u_h</code> <code class="reqn">\sim</code> <code class="reqn">N(0, V_{beta})</code>.  <br></p>
<p><code class="reqn">delta = vec(Delta)</code> <code class="reqn">\sim</code> <code class="reqn">N(vec(Deltabar), V_{beta}(x) ADelta^{-1})</code><br><code class="reqn">V_{beta}</code> <code class="reqn">\sim</code> <code class="reqn">IW(nu, V)</code>
</p>



<h4>Argument Details</h4>

<p><em><code>Data  = list(lgtdata, Z)</code> [<code>Z</code> optional]</em>
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>lgtdata:       </code> </td>
<td style="text-align: left;"> list of lists with each cross-section unit MNL data </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>lgtdata[[h]]$y:</code> </td>
<td style="text-align: left;"> <code class="reqn">n_h x 1</code> vector of binary outcomes (0,1) </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>lgtdata[[h]]$X:</code> </td>
<td style="text-align: left;"> <code class="reqn">n_h x nvar</code> design matrix for h'th unit </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Z:             </code> </td>
<td style="text-align: left;"> <code class="reqn">nreg x nz</code> mat of unit chars (def: vector of ones)
  </td>
</tr>
</table>
<p><em><code>Prior = list(Deltabar, ADelta, nu, V)</code> [optional]</em>
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>Deltabar:</code> </td>
<td style="text-align: left;"> <code class="reqn">nz x nvar</code> matrix of prior means (def: 0) </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>ADelta:  </code> </td>
<td style="text-align: left;"> prior precision matrix (def: 0.01I) </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>nu:      </code> </td>
<td style="text-align: left;"> d.f. parameter for IW prior on normal component Sigma (def: nvar+3) </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>V:       </code> </td>
<td style="text-align: left;"> pds location parm for IW prior on normal component Sigma (def: nuI)
  </td>
</tr>
</table>
<p><em><code>Mcmc  = list(R, keep, sbeta)</code> [only <code>R</code> required]</em>
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>R:       </code> </td>
<td style="text-align: left;"> number of MCMC draws </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>keep:    </code> </td>
<td style="text-align: left;"> MCMC thinning parm -- keep every <code>keep</code>th draw (def: 1) </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>sbeta:   </code> </td>
<td style="text-align: left;"> scaling parm for RW Metropolis (def: 0.2)
  </td>
</tr>
</table>
<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Deltadraw </code></td>
<td>
 <p><code class="reqn">R/keep x nz*nvar</code> matrix of draws of Delta</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>betadraw  </code></td>
<td>
 <p><code class="reqn">nlgt x nvar x R/keep</code> array of draws of betas</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Vbetadraw </code></td>
<td>
 <p><code class="reqn">R/keep x nvar*nvar</code> matrix of draws of Vbeta</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>llike     </code></td>
<td>
 <p><code class="reqn">R/keep x 1</code> vector of log-like values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reject    </code></td>
<td>
 <p><code class="reqn">R/keep x 1</code> vector of reject rates over nlgt units</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Some experimentation with the Metropolis scaling paramter (<code>sbeta</code>) may be required.</p>


<h3>Author(s)</h3>

<p>Peter Rossi, Anderson School, UCLA, <a href="mailto:perossichi@gmail.com">perossichi@gmail.com</a>.</p>


<h3>References</h3>

<p>For further discussion, see Chapter 5, <em>Bayesian Statistics and Marketing</em> by Rossi, Allenby, and McCulloch.</p>


<h3>See Also</h3>

 <p><code>rhierMnlRwMixture</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">if(nchar(Sys.getenv("LONG_TEST")) != 0) {R=10000} else {R=10}
set.seed(66)

nvar = 5              ## number of coefficients
nlgt = 1000           ## number of cross-sectional units
nobs = 10             ## number of observations per unit
nz = 2                ## number of regressors in mixing distribution

Z = matrix(c(rep(1,nlgt),runif(nlgt,min=-1,max=1)), nrow=nlgt, ncol=nz)
Delta = matrix(c(-2, -1, 0, 1, 2, -1, 1, -0.5, 0.5, 0), nrow=nz, ncol=nvar)
iota = matrix(1, nrow=nvar, ncol=1)
Vbeta = diag(nvar) + 0.5*iota%*%t(iota)

lgtdata=NULL
for (i in 1:nlgt) { 
  beta = t(Delta)%*%Z[i,] + as.vector(t(chol(Vbeta))%*%rnorm(nvar))
  X = matrix(runif(nobs*nvar), nrow=nobs, ncol=nvar)
  prob = exp(X%*%beta) / (1+exp(X%*%beta)) 
  unif = runif(nobs, 0, 1)
  y = ifelse(unif&lt;prob, 1, 0)
  lgtdata[[i]] = list(y=y, X=X, beta=beta)
}

Data1 = list(lgtdata=lgtdata, Z=Z)
Mcmc1 = list(R=R)

out = rhierBinLogit(Data=Data1, Mcmc=Mcmc1)

cat("Summary of Delta draws", fill=TRUE)
summary(out$Deltadraw, tvalues=as.vector(Delta))

cat("Summary of Vbeta draws", fill=TRUE)
summary(out$Vbetadraw, tvalues=as.vector(Vbeta[upper.tri(Vbeta,diag=TRUE)]))

if(0){
## plotting examples
plot(out$Deltadraw,tvalues=as.vector(Delta))
plot(out$betadraw)
plot(out$Vbetadraw,tvalues=as.vector(Vbeta[upper.tri(Vbeta,diag=TRUE)]))
}

</code></pre>


</div>