<div class="container">

<table style="width: 100%;"><tr>
<td>la</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Lasso Smooth Constructor</h2>

<h3>Description</h3>

<p>Smooth constructors and optimizer for Lasso penalization with <code>bamlss</code>. The
penalization is based on a Taylor series approximation of the Lasso penalty.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## Smooth constructor function.
la(formula, type = c("single", "multiple"), ...)

## Single Lasso smoothing parameter optimizer.
opt_lasso(x, y, start = NULL, adaptive = TRUE, lower = 0.001, upper = 1000,
  nlambda = 100, lambda = NULL,  multiple = FALSE, verbose = TRUE,
  digits = 4, flush = TRUE, nu = NULL, stop.nu = NULL,
  ridge = .Machine$double.eps^0.5, zeromodel = NULL, ...)

lasso(x, y, start = NULL, adaptive = TRUE, lower = 0.001, upper = 1000,
  nlambda = 100, lambda = NULL,  multiple = FALSE, verbose = TRUE,
  digits = 4, flush = TRUE, nu = NULL, stop.nu = NULL,
  ridge = .Machine$double.eps^0.5, zeromodel = NULL, ...)

## Lasso transformation function to set
## adaptive weights from an unpenalized model.
lasso_transform(x, zeromodel, nobs = NULL, ...)

## Plotting function for opt_lasso() optimizer.
lasso_plot(x, which = c("criterion", "parameters"),
  spar = TRUE, model = NULL, name = NULL, mstop = NULL,
  retrans = FALSE, color = NULL, show.lambda = TRUE,
  labels = NULL, digits = 2, ...)

## Extract optimum stopping iteration for opt_lasso() optimizer.
## Based on the minimum of the information criterion.
lasso_stop(x)

## Extract retransformed Lasso coefficients.
lasso_coef(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>A formula like <code>~ x1 + x2 + ... + xk</code> of variables which should be
penalized with Lasso.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Should one single penalty parameter be used or multiple parameters, one for each
covariate in <code>formula</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>For function <code>opt_lasso()</code> and <code>lasso_transform()</code> the <code>x</code> list, as returned
from function <code>bamlss.frame</code>, holding all model matrices and other information that
is used for fitting the model. For the plotting function and
<code>lasso_stop()</code>/<code>lasso_coef()</code> the
corresponding <code>bamlss</code> object fitted with the <code>opt_lasso()</code> optimizer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>The model response, as returned from function <code>bamlss.frame</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>A vector of starting values. Note, Lasso smoothing parameters will be dropped.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adaptive</code></td>
<td>
<p>Should adaptive weights be used for fused Lasso terms?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>Numeric. The minimum lambda value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p>Numeric. The maximum lambda value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda</code></td>
<td>
<p>Integer. The number of smoothing parameters for which coefficients should be
estimated, i.e., the vector of smoothing parameters is build up as a sequence from
<code>lower</code> to <code>upper</code> with length <code>nlambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Numeric. A sequence/vector of lambda parameters that should be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multiple</code></td>
<td>
<p>Logical. Should the lambda grid be exapnded to search for multiple lambdas, one for
each distributional parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Print information during runtime of the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>Set the digits for printing when <code>verbose = TRUE</code>. If the optimum lambda value
is plotted, the number of decimal decimal places to be used within <code>lasso_plot()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flush</code></td>
<td>
<p>use <code>flush.console</code> for displaying the current output in the console.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu</code></td>
<td>
<p>Numeric or logical. Defines the step length for parameter updating of a model term,
useful when the algorithm encounters convergence problems. If <code>nu = TRUE</code> the step length
parameter is optimized for each model term in each iteration of the backfitting algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stop.nu</code></td>
<td>
<p>Integer. Should step length reduction be stopped after <code>stop.nu</code> iterations
of the Lasso algorithm?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ridge</code></td>
<td>
<p>A ridge penalty parameter that should be used when finding adaptive weights, i.e.,
parameters from an unpenalized model. The ridge penalty is used to stabilize the estimation
in complex models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zeromodel</code></td>
<td>
<p>A model containing the unpenalized parameters, e.g., for each <code>la()</code>
terms one can place a simple ridge penalty with <code>la(x, ridge = TRUE, sp = 0.1)</code>. This
way it is possible to find the unpenalized parameters that can be used as adaptive
weights for fusion penalties.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs</code></td>
<td>
<p>Integer, number of observations of the data used for modeling. If not supplied
<code>nobs</code> is taken from the number of rows from the model term design matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which</code></td>
<td>
<p>Which of the two provided plots should be created, character or integer <code>1</code> and <code>2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spar</code></td>
<td>
<p>Should graphical parameters be set by the plotting function?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>Character selecting for which model the plot shpuld be created.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>Character, the name of the coefficient group that should be plotted. Note that
the string provided in <code>name</code> will be removed from the labels on the 4th axis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mstop</code></td>
<td>
<p>Integer vector, defines the path length to be plotted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>retrans</code></td>
<td>
<p>Logical, should coefficients be re-transformed before plotting?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>color</code></td>
<td>
<p>Colors or color function that creates colors for the group paths.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.lambda</code></td>
<td>
<p>Logical. Should the optimum value of the penalty parameter lambda be shown?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels</code></td>
<td>
<p>A character string of labels that should be used on the 4 axis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed to the subsequent smooth constructor function.
<code>lambda</code> controls the starting value of the penalty parameter, <code>const</code> the constant
that is added within the penalty approximation. Moreover, <code>fuse = 1</code> enforces nominal
fusion of categorical variables and <code>fuse = 2</code> ordered fusion within <code>la()</code> Note that
<code>la()</code> terms with and without fusion should not be mixed when using the <code>opt_lasso()</code>
optimizer function.
For the optimizer <code>opt_lasso()</code> arguments passed to function <code>bfit</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>For function <code>la()</code>, similar to function <code>s</code> a simple smooth
specification object.
</p>
<p>For function <code>opt_lasso()</code> a list containing the following objects:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>fitted.values</code></td>
<td>
<p>A named list of the fitted values based on the last lasso iteration
of the modeled parameters of the selected distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameters</code></td>
<td>
<p>A matrix, each row corresponds to the parameter values of one boosting iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lasso.stats</code></td>
<td>
<p>A matrix containing information about the log-likelihood, log-posterior
and the information criterion for each lambda.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Andreas Groll, Julien Hambuckers, Thomas Kneib, and Nikolaus Umlauf (2019). Lasso-type penalization in
the framework of generalized additive models for location, scale and shape.
<em>Computational Statistics &amp; Data Analysis</em>.
<a href="https://doi.org/10.1016/j.csda.2019.06.005">doi:10.1016/j.csda.2019.06.005</a>
</p>
<p>Oelker Margreth-Ruth and Tutz Gerhard (2015). A uniform framework for combination of
penalties in generalized structured models. <em>Adv Data Anal Classif</em>.
<a href="https://doi.org/10.1007/s11634-015-0205-y">doi:10.1007/s11634-015-0205-y</a>
</p>


<h3>See Also</h3>

<p><code>s</code>, <code>smooth.construct</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: ## Simulated fusion Lasso example.
bmu &lt;- c(0,0,0,2,2,2,4,4,4)
bsigma &lt;- c(0,0,0,-2,-2,-2,-1,-1,-1)
id &lt;- factor(sort(rep(1:length(bmu), length.out = 300)))

## Response.
set.seed(123)
y &lt;- bmu[id] + rnorm(length(id), sd = exp(bsigma[id]))

## Estimate model:
## fuse=1 -&gt; nominal fusion,
## fuse=2 -&gt; ordinal fusion,
## first, unpenalized model to be used for adaptive fusion weights.
f &lt;- list(y ~ la(id,fuse=2,fx=TRUE), sigma ~ la(id,fuse=1,fx=TRUE))
b0 &lt;- bamlss(f, sampler = FALSE)

## Model with single lambda parameter.
f &lt;- list(y ~ la(id,fuse=2), sigma ~ la(id,fuse=1))
b1 &lt;- bamlss(f, sampler = FALSE, optimizer = opt_lasso,
  criterion = "BIC", zeromodel = b0)

## Plot information criterion and coefficient paths.
lasso_plot(b1, which = 1)
lasso_plot(b1, which = 2)
lasso_plot(b1, which = 2, model = "mu", name = "mu.s.la(id).id")
lasso_plot(b1, which = 2, model = "sigma", name = "sigma.s.la(id).id")

## Extract coefficients for optimum Lasso parameter.
coef(b1, mstop = lasso_stop(b1))

## Predict with optimum Lasso parameter.
p1 &lt;- predict(b1, mstop = lasso_stop(b1))

## Full MCMC, needs lasso_transform() to assign the
## adaptive weights from unpenalized model b0.
b2 &lt;- bamlss(f, optimizer = FALSE, transform = lasso_transform,
  zeromodel = b0, nobs = length(y), start = coef(b1, mstop = lasso_stop(b1)),
  n.iter = 4000, burnin = 1000)
summary(b2)
plot(b2)

ci &lt;- confint(b2, model = "mu", pterms = FALSE, sterms = TRUE)
lasso_plot(b1, which = 2, model = "mu", name = "mu.s.la(id).id", spar = FALSE)
for(i in 1:8) {
  abline(h = ci[i, 1], lty = 2, col = "red")
  abline(h = ci[i, 2], lty = 2, col = "red")
}

## End(Not run)
</code></pre>


</div>