<div class="container">

<table style="width: 100%;"><tr>
<td>MixNRMI1</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Normalized Random Measures Mixture of Type I</h2>

<h3>Description</h3>

<p>Bayesian nonparametric estimation based on normalized measures driven
mixtures for locations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MixNRMI1(
  x,
  probs = c(0.025, 0.5, 0.975),
  Alpha = 1,
  Kappa = 0,
  Gama = 0.4,
  distr.k = "normal",
  distr.p0 = 1,
  asigma = 0.5,
  bsigma = 0.5,
  delta_S = 3,
  delta_U = 2,
  Meps = 0.01,
  Nx = 150,
  Nit = 1500,
  Pbi = 0.1,
  epsilon = NULL,
  printtime = TRUE,
  extras = TRUE,
  adaptive = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Numeric vector. Data set to which the density is fitted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>probs</code></td>
<td>
<p>Numeric vector. Desired quantiles of the density estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Alpha</code></td>
<td>
<p>Numeric constant. Total mass of the centering measure. See
details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Kappa</code></td>
<td>
<p>Numeric positive constant. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Gama</code></td>
<td>
<p>Numeric constant. <code class="reqn">0\leq \texttt{Gama} \leq 1</code>.  See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distr.k</code></td>
<td>
<p>The distribution name for the kernel. Allowed names are "normal", "gamma", "beta", "double exponential", "lognormal" or their common abbreviations "norm", "exp", or an integer number identifying the mixture kernel: 1 = Normal; 2 = Gamma; 3 = Beta; 4 = Double Exponential; 5 = Lognormal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distr.p0</code></td>
<td>
<p>The distribution name for the centering measure. Allowed names are "normal", "gamma", "beta", or their common abbreviations "norm", "exp", or an integer number identifying the centering measure: 1 = Normal; 2 = Gamma; 3 = Beta.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>asigma</code></td>
<td>
<p>Numeric positive constant. Shape parameter of the gamma prior
on the standard deviation of the mixture kernel <code>distr.k</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bsigma</code></td>
<td>
<p>Numeric positive constant. Rate parameter of the gamma prior
on the standard deviation of the mixture kernel <code>distr.k</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta_S</code></td>
<td>
<p>Numeric positive constant. Metropolis-Hastings proposal
variation coefficient for sampling sigma.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta_U</code></td>
<td>
<p>Numeric positive constant. Metropolis-Hastings proposal
variation coefficient for sampling the latent U.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Meps</code></td>
<td>
<p>Numeric constant. Relative error of the jump sizes in the
continuous component of the process. Smaller values imply larger number of
jumps.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nx</code></td>
<td>
<p>Integer constant. Number of grid points for the evaluation of the
density estimate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nit</code></td>
<td>
<p>Integer constant. Number of MCMC iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Pbi</code></td>
<td>
<p>Numeric constant. Burn-in period proportion of Nit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>Numeric constant. Extension to the evaluation grid range.
See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>printtime</code></td>
<td>
<p>Logical. If TRUE, prints out the execution time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extras</code></td>
<td>
<p>Logical. If TRUE, gives additional objects: means, weights and
Js.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adaptive</code></td>
<td>
<p>Logical. If TRUE, uses an adaptive MCMC strategy to sample the latent U (adaptive delta_U).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This generic function fits a normalized random measure (NRMI) mixture model
for density estimation (James et al. 2009). Specifically, the model assumes
a normalized generalized gamma (NGG) prior for the locations (means) of the
mixture kernel and a parametric prior for the common smoothing parameter
sigma, leading to a semiparametric mixture model.
</p>
<p>The details of the model are: </p>
<p style="text-align: center;"><code class="reqn">X_i|Y_i,\sigma \sim k(\cdot
|Y_i,\sigma)</code>
</p>
 <p style="text-align: center;"><code class="reqn">Y_i|P \sim P,\quad
i=1,\dots,n</code>
</p>
 <p style="text-align: center;"><code class="reqn">P \sim \textrm{NGG(\texttt{Alpha,
Kappa, Gama; P\_0})}</code>
</p>
 <p style="text-align: center;"><code class="reqn">\sigma \sim
\textrm{Gamma(asigma, bsigma)}</code>
</p>
<p> where
<code class="reqn">X_i</code>'s are the observed data, <code class="reqn">Y_i</code>'s are latent (location)
variables, <code>sigma</code> is the smoothing parameter, <code>k</code> is a parametric
kernel parameterized in terms of mean and standard deviation, <code>(Alpha,
Kappa, Gama; P_0)</code> are the parameters of the NGG prior with <code>P_0</code> being
the centering measure whose parameters are assigned vague hyper prior
distributions, and <code>(asigma,bsigma)</code> are the hyper-parameters of the
gamma prior on the smoothing parameter <code>sigma</code>. In particular:
<code>NGG(Alpha, 1, 0; P_0)</code> defines a Dirichlet process; <code>NGG(1,
Kappa, 1/2; P_0)</code> defines a Normalized inverse Gaussian process; and
<code>NGG(1, 0, Gama; P_0)</code> defines a normalized stable process.
</p>
<p>The evaluation grid ranges from <code>min(x) - epsilon</code> to <code>max(x) +
epsilon</code>. By default <code>epsilon=sd(x)/4</code>.
</p>


<h3>Value</h3>

<p>The function returns a MixNRMI1 object. It is based on a list with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>xx</code></td>
<td>
<p>Numeric vector. Evaluation grid.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qx</code></td>
<td>
<p>Numeric array. Matrix
of dimension <code class="reqn">\texttt{Nx} \times (\texttt{length(probs)} + 1)</code> with the posterior mean and the desired quantiles input
in <code>probs</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cpo</code></td>
<td>
<p>Numeric vector of <code>length(x)</code> with
conditional predictive ordinates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>Numeric vector of
<code>length(Nit*(1-Pbi))</code> with the number of mixtures components
(clusters).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>Numeric vector of <code>length(Nit*(1-Pbi))</code> with the
values of common standard deviation sigma.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>U</code></td>
<td>
<p>Numeric vector of
<code>length(Nit*(1-Pbi))</code> with the values of the latent variable U.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Allocs</code></td>
<td>
<p>List of <code>length(Nit*(1-Pbi))</code> with the clustering
allocations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>means</code></td>
<td>
<p>List of <code>length(Nit*(1-Pbi))</code> with the
cluster means (locations). Only if extras = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>List of
<code>length(Nit*(1-Pbi))</code> with the mixture weights. Only if extras = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Js</code></td>
<td>
<p>List of <code>length(Nit*(1-Pbi))</code> with the unnormalized weights
(jump sizes). Only if extras = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nm</code></td>
<td>
<p>Integer constant. Number of
jumps of the continuous component of the unnormalized process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nx</code></td>
<td>
<p>Integer constant. Number of grid points for the evaluation of the
density estimate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nit</code></td>
<td>
<p>Integer constant. Number of MCMC iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Pbi</code></td>
<td>
<p>Numeric constant. Burn-in period proportion of <code>Nit</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>procTime</code></td>
<td>
<p>Numeric vector with execution time provided by
<code>proc.time</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distr.k</code></td>
<td>
<p>Integer corresponding to the kernel chosen for the mixture</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Data used for the fit</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NRMI_params</code></td>
<td>
<p>A named list with the parameters of the NRMI process</p>
</td>
</tr>
</table>
<h3>Warning </h3>

<p>The function is computing intensive. Be patient.
</p>


<h3>Author(s)</h3>

<p>Barrios, E., Kon Kam King, G., Lijoi, A., Nieto-Barajas, L.E. and Prüenster, I.
</p>


<h3>References</h3>

<p>1.- Barrios, E., Lijoi, A., Nieto-Barajas, L. E. and Prünster,
I. (2013). Modeling with Normalized Random Measure Mixture Models.
Statistical Science. Vol. 28, No. 3, 313-334.
</p>
<p>2.- James, L.F., Lijoi, A. and Prünster, I. (2009). Posterior analysis for
normalized random measure with independent increments. Scand. J. Statist 36,
76-97.
</p>


<h3>See Also</h3>

<p><code>MixNRMI2</code>, <code>MixNRMI1cens</code>,
<code>MixNRMI2cens</code>, <code>multMixNRMI1</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
### Example 1
## Not run: 
# Data
data(acidity)
x &lt;- acidity
# Fitting the model under default specifications
out &lt;- MixNRMI1(x)
# Plotting density estimate + 95% credible interval
plot(out)
### Example 2
set.seed(150520)
data(enzyme)
x &lt;- enzyme
Enzyme1.out &lt;- MixNRMI1(x, Alpha = 1, Kappa = 0.007, Gama = 0.5,
                         distr.k = "gamma", distr.p0 = "gamma",
                         asigma = 1, bsigma = 1, Meps=0.005,
                         Nit = 5000, Pbi = 0.2)
attach(Enzyme1.out)
# Plotting density estimate + 95% credible interval
plot(Enzyme1.out)
# Plotting number of clusters
par(mfrow = c(2, 1))
plot(R, type = "l", main = "Trace of R")
hist(R, breaks = min(R - 0.5):max(R + 0.5), probability = TRUE)
# Plotting sigma
par(mfrow = c(2, 1))
plot(S, type = "l", main = "Trace of sigma")
hist(S, nclass = 20, probability = TRUE, main = "Histogram of sigma")
# Plotting u
par(mfrow = c(2, 1))
plot(U, type = "l", main = "Trace of U")
hist(U, nclass = 20, probability = TRUE, main = "Histogram of U")
# Plotting cpo
par(mfrow = c(2, 1))
plot(cpo, main = "Scatter plot of CPO's")
boxplot(cpo, horizontal = TRUE, main = "Boxplot of CPO's")
print(paste("Average log(CPO)=", round(mean(log(cpo)), 4)))
print(paste("Median log(CPO)=", round(median(log(cpo)), 4)))
detach()

## End(Not run)

### Example 3
## Do not run
# set.seed(150520)
# data(galaxy)
# x &lt;- galaxy
#  Galaxy1.out &lt;- MixNRMI1(x, Alpha = 1, Kappa = 0.015, Gama = 0.5,
#                          distr.k = "normal", distr.p0 = "gamma",
#                          asigma = 1, bsigma = 1, delta = 7, Meps=0.005,
#                          Nit = 5000, Pbi = 0.2)

# The output of this run is already loaded in the package
# To show results run the following
# Data
data(galaxy)
x &lt;- galaxy
data(Galaxy1.out)
attach(Galaxy1.out)
# Plotting density estimate + 95% credible interval
plot(Galaxy1.out)
# Plotting number of clusters
par(mfrow = c(2, 1))
plot(R, type = "l", main = "Trace of R")
hist(R, breaks = min(R - 0.5):max(R + 0.5), probability = TRUE)
# Plotting sigma
par(mfrow = c(2, 1))
plot(S, type = "l", main = "Trace of sigma")
hist(S, nclass = 20, probability = TRUE, main = "Histogram of sigma")
# Plotting u
par(mfrow = c(2, 1))
plot(U, type = "l", main = "Trace of U")
hist(U, nclass = 20, probability = TRUE, main = "Histogram of U")
# Plotting cpo
par(mfrow = c(2, 1))
plot(cpo, main = "Scatter plot of CPO's")
boxplot(cpo, horizontal = TRUE, main = "Boxplot of CPO's")
print(paste("Average log(CPO)=", round(mean(log(cpo)), 4)))
print(paste("Median log(CPO)=", round(median(log(cpo)), 4)))
detach()
</code></pre>


</div>