<div class="container">

<table style="width: 100%;"><tr>
<td>density.bma</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Coefficient Marginal Posterior Densities</h2>

<h3>Description</h3>

<p>Calculates the mixture marginal posterior densities for the coefficients
from a BMA object and plots them
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'bma'
density(
  x,
  reg = NULL,
  addons = "lemsz",
  std.coefs = FALSE,
  n = 300,
  plot = TRUE,
  hnbsteps = 30,
  addons.lwd = 1.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A bma object (see <code>bms</code>) or a <code>zlm</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reg</code></td>
<td>
<p>A scalar integer or character detailing which covariate's
coefficient should be plotted. If <code>reg=NULL</code> (default), then all
regressors are plotted one after the other, waiting for user interaction.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>addons</code></td>
<td>
<p>character. Specifies which additional information should be
added to the plot via low-level commands (see 'Details' below).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>std.coefs</code></td>
<td>
<p>logical. If <code>TRUE</code> then the posterior density is
estimated for standardized coefficients (representing the case where all
variables have mean zero and standard deviation 1) - default is
<code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>numeric. the number of equally spaced points at which the density
is to be estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>logical.  If <code>TRUE</code> (default), the density is plotted; if
<code>FALSE</code> then <code>density.bma</code> only returns the estimated posterior
densities without plotting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hnbsteps</code></td>
<td>
<p>even integer, default 30. The number of numerical
integration steps to be used in case of a hyper-g prior (cf. argument
<code>g</code> in <code>bms</code>). Increase this number to increase accuracy.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>addons.lwd</code></td>
<td>
<p>scalar, default 1.5. Line width to be used for the
low-level plotting commands specified by <code>addons</code>. Cf. argument
<code>lwd</code> in <code>par</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments for <code>plot.default</code> with
sensible defaults</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The argument <code>addons</code> specifies what additional information should be
added to the plot(s) via the low-level commands <code>lines</code> and
<code>legend</code>:<br><code>"e"</code> for the posterior expected value (EV) of
coefficients conditional on inclusion (see argument <code>exact=TRUE</code> in
<code>coef.bma</code>),<br><code>"s"</code> for 2 times posterior standard
deviation (SD) bounds,<br><code>"m"</code> for the posterior median,<br><code>"b"</code>
for posterior expected values of the individual models whom the density is
averaged over,<br><code>"E"</code> for posterior EV under MCMC frequencies (see
argument <code>exact=FALSE</code> in <code>coef.bma</code>),<br><code>"S"</code> for
the corresponding SD bounds (MCMC),<br><code>"p"</code> for plotting the Posterior
Inclusion Probability above the density plot,<br><code>"l"</code> for including a
<code>legend</code>, <code>"z"</code> for a zero line, <code>"g"</code> for adding a
<code>grid</code>
</p>
<p>Any combination of these letters will give the desired result. Use
<code>addons=""</code> for not using any of these.<br> In case of
<code>density.zlm</code>, only the letters <code>e</code>, <code>s</code>, <code>l</code>, <code>z</code>,
and <code>g</code> will have an effect.
</p>


<h3>Value</h3>

<p>The function returns a list containing objects of the class
<code>density</code> detailing the marginal posterior densities for each
coefficient provided in <code>reg</code>.<br> In case of <code>density.zlm</code>, simple
marginal posterior coefficient densities are computed, while
<code>density.bma</code> calculates there mixtures over models according to
posterior model probabilities.<br> These densities contain only the density
points apart from the origin. (see 'Note' below)
</p>
<p>As long as <code>plot=TRUE</code>, the densities are plotted too.  Note that (for
<code>density.bma</code>) if the posterior inclusion probability of a covariate is
zero, then it will not be plotted, and the returned density will be
<code>list(x=numeric(n),y=numeric(n))</code>.
</p>


<h3>Note</h3>

<p>The computed marginal posterior densities from <code>density.bma</code> are
a Bayesian Model Averaging mixture of the marginal posterior densities of
the individual models.  The accuracy of the result therefore depends on the
number of 'best' models contained in <code>x</code> (cf. argument <code>nmodel</code> in
<code>bms</code>).
</p>
<p>The marginal posterior density can be interpreted as 'conditional on
inclusion': If the posterior inclusion probability of a variable is smaller
than one, then some of its posterior density is Dirac at zero.  Therefore
the integral of the returned density vector adds up to the posterior
inclusion probability, i.e. the probability that the coefficient is not
zero.
</p>
<p>Correspondingly, the posterior EV and SD specified by <code>addons="es"</code> are
based on 'best' model likelihoods ('exact') and are conditional on
inclusion.  They correspond to the results from command
<code>coef.bma(x,exact=TRUE,condi.coef=TRUE,order.by.pip=FALSE)</code> (cf. the
example below).
</p>
<p>The low-level commands enacted by the argument <code>addons</code> rely on colors
of the <code>palette</code>: color 2 for <code>"e"</code> and <code>"s"</code>, color 3
for <code>"m"</code>, color 8 for <code>"b"</code>, color 4 for <code>"E"</code> and
<code>"S"</code>. The default colors may be changed by a call to
<code>palette</code>.
</p>
<p>Up to BMS version 0.3.0, <code>density.bma</code> may only cope with built-in
<code>gprior</code>s, not with any user-defined priors.
</p>


<h3>See Also</h3>

<p><code>quantile.coef.density</code> for extracting quantiles,
<code>coef.bma</code> for similar concepts, <code>bms</code> for creating
bma objects
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class="language-R">

 data(datafls)
 mm=bms(datafls)

 density(mm,reg="SubSahara")
 density(mm,reg=7,addons="lbz") 
 density(mm,1:9)
 density(mm,reg=2,addons="zgSE",addons.lwd=2,std.coefs=TRUE)

# plot the posterior density only for the very best model
 density(mm[1],reg=1,addons="esz")


#using the calculated density for other purposes...
 dd=density(mm,reg="SubSahara")
 plot(dd) 

 dd_list=density(mm,reg=1:3,plot=FALSE,n=400)
 plot(dd_list[[1]])


#Note that the shown density is only the part that is not zero
 dd=density(mm,reg="Abslat",addons="esl")
 pip_Abslat=sum(dd$y)*diff(dd$x)[1]

 #this pip and the EV conform to what is done by the follwing command
 coef(mm,exact=TRUE,condi.coef=TRUE)["Abslat",]

</code></pre>


</div>