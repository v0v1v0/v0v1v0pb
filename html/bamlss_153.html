<div class="container">

<table style="width: 100%;"><tr>
<td>plot3d</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Plot 3D Effects
</h2>

<h3>Description</h3>

<p>Function to plot 3D graphics or image and/or contour plots for bivariate effects/functions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">plot3d(x, residuals = FALSE, col.surface = NULL, 
  ncol = 99L, swap = FALSE, col.residuals = NULL, col.contour = NULL, 
  c.select = NULL, grid = 30L, image = FALSE, contour = FALSE, 
  legend = TRUE, cex.legend = 1, breaks = NULL, range = NULL, 
  digits = 2L, d.persp = 1L, r.persp = sqrt(3), outscale = 0,
  data = NULL, sep = "", shift = NULL, trans = NULL,
  type = "mba", linear = FALSE, extrap = FALSE,
  k = 40, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A matrix or data frame, containing the covariates for which the effect should be plotted 
in the first and second column and at least a third column containing the effect. Another
possibility is to specify the plot via a <code>formula</code>, 
e.g. for simple plotting of bivariate surfaces <code>z ~ x + y</code>, see the examples.
<code>x</code> may also be a character file path to the data to be used for plotting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>If set to <code>TRUE</code>, residuals may also be plotted if available. Residuals must
be supplied as an <code>attr</code>ibute named <code>"residuals"</code>, which
is a matrix or data frame where the first two columns are covariates and the third column
the residuals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.surface</code></td>
<td>
<p>The color of the surface, may also be a function, e.g. 
<code>col.surface = heat.colors</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncol</code></td>
<td>
<p>the number of different colors that should be generated, if <code>col.surface</code> is a 
function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>swap</code></td>
<td>
<p>If set to <code>TRUE</code> colors will be represented in reverse order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.residuals</code></td>
<td>
<p>The color of the partial residuals, or if <code>contour = TRUE</code> the color of the
contour lines.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.contour</code></td>
<td>
<p>The color of the contour lines.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.select</code></td>
<td>
<p>Integer vector of maximum length of columns of <code>x</code>, selects the 
columns of the resulting data matrix that should be used for plotting. E.g. if <code>x</code> has 5
columns, then <code>c.select = c(1, 2, 5)</code> will select column 1, 2 and 5 for plotting. 
If <code>c.select = 95</code> or <code>c.select = 80</code>, function <code>plot3d</code> will search for the
corresponding columns to plot a 95<code class="reqn">\%</code> or 80<code class="reqn">\%</code> confidence surfaces respectively. Note
that if e.g. <code>c.select = c(1, 2)</code>, <code>plot3d</code> will use columns 1 + 2 and 2 + 2 for 
plotting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>The grid size of the surface(s).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>image</code></td>
<td>
<p>If set to <code>TRUE</code>, an <code>image.plot</code> is drawn.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contour</code></td>
<td>
<p>If set to <code>TRUE</code>, a <code>contour</code> plot is drawn.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legend</code></td>
<td>
<p>If <code>image = TRUE</code> an additional legend may be added to the plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex.legend</code></td>
<td>
<p>The expansion factor for the legend text, see <code>text</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>breaks</code></td>
<td>
<p>A set of breakpoints for the colors: must give one more breakpoint than 
<code>ncol</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>range</code></td>
<td>
<p>Specifies a certain range values should be plotted for.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>Specifies the legend decimal places.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d.persp</code></td>
<td>
<p>See argument <code>d</code> in function <code>persp</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r.persp</code></td>
<td>
<p>See argument <code>r</code> in function <code>persp</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outscale</code></td>
<td>
<p>Scales the outer ranges of <code>x</code> and <code>z</code> limits used for interpolation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>If <code>x</code> is a <code>formula</code>, a <code>data.frame</code> or <code>list</code>. By default the 
variables are taken from <code>environment(x)</code>: typically the environment from which 
<code>plot3d</code> is called. Note that <code>data</code> may also be a character file path to the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sep</code></td>
<td>
<p>The field separator character when <code>x</code> or <code>data</code> is a character, see function
<code>read.table</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shift</code></td>
<td>
<p>Numeric constant to be added to the smooth before plotting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trans</code></td>
<td>
<p>Function to be applied to the smooth before plotting, e.g., to transform the
plot to the response scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Character, which type of interpolation method should be used. The default is
<code>type = "akima"</code>, see function <code>interp</code>. The two other options are
<code>type = "mba"</code>, which calls function <code>mba.surf</code> of package <span class="pkg">MBA</span>, or
<code>type = "mgcv"</code>, which uses a spatial smoother withing package <span class="pkg">mgcv</span> for interpolation.
The last option is definitely the slowest, since a full regression model needs to be estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linear</code></td>
<td>
<p>Logical, should linear interpolation be used withing function
<code>interp</code>?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extrap</code></td>
<td>
<p>Logical, should interpolations be computed outside the observation area
(i.e., extrapolated)?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>Integer, the number of basis functions to be used to compute the interpolated surface
when <code>type = "mgcv"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Parameters passed to <code>colorlegend</code> if an image plot with legend is drawn,
also other graphical parameters, please see the details.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For 3D plots the following graphical parameters may be specified additionally: 
</p>

<ul>
<li> <p><code>cex</code>: Specify the size of partial residuals,
</p>
</li>
<li> <p><code>col</code>: It is possible to specify the color for the surfaces if <code>se &gt; 0</code>, then 
e.g. <code>col = c("green", "black", "red")</code>,
</p>
</li>
<li> <p><code>pch</code>: The plotting character of the partial residuals,
</p>
</li>
<li> <p><code>...</code>: Other graphical parameters passed functions <code>persp</code>,
<code>image.plot</code> and <code>contour</code>.
</p>
</li>
</ul>
<h3>Note</h3>

<p>Function <code>plot3d</code> can use the <span class="pkg">akima</span> package to construct smooth interpolated
surfaces, therefore, package <span class="pkg">akima</span> needs to be installed. The <span class="pkg">akima</span> package has an ACM
license that restricts applications to non-commercial usage, see
</p>
<p><a href="https://www.acm.org/publications/policies/software-copyright-notice">https://www.acm.org/publications/policies/software-copyright-notice</a>
</p>
<p>Function <code>plot3d</code> prints a note referring to the ACM license. This note can be suppressed by
setting
</p>
<p><code>options("use.akima" = TRUE)</code> 
</p>


<h3>See Also</h3>

<p><code>colorlegend</code>, <code>plot2d</code>, <code>plotmap</code>,
<code>plotblock</code>, <code>sliceplot</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Generate some data.
set.seed(111)
n &lt;- 500

## Regressors.
d &lt;- data.frame(z = runif(n, -3, 3), w = runif(n, 0, 6))

## Response.
d$y &lt;- with(d, 1.5 + cos(z) * sin(w) + rnorm(n, sd = 0.6))

## Not run: ## Estimate model.
b &lt;- bamlss(y ~ s(z,w), data = d)
summary(b)

## Plot estimated effect.
plot(b, model = "mu", term = "s(z,w)")

## Extract fitted values.
f &lt;- fitted(b, model = "mu", term = "s(z,w)", intercept = FALSE)
f &lt;- cbind(d[, c("z", "w")], f)

## Now use plot3d().
plot3d(f)
plot3d(f, swap = TRUE)
plot3d(f, grid = 100, border = NA)

## Only works if columns are named with
## '2.5
plot3d(f, c.select = 95, border = c("red", NA, "green"),
  col.surface = c(1, NA, 1), resid = TRUE, cex.resid = 0.2)

## Now some image and contour.
# plot3d(f, image = TRUE, legend = FALSE)
# plot3d(f, image = TRUE, legend = TRUE)
# plot3d(f, image = TRUE, contour = TRUE)
# plot3d(f, image = TRUE, contour = TRUE, swap = TRUE)
# plot3d(f, image = TRUE, contour = TRUE, col.contour = "white")
# plot3d(f, contour = TRUE)
# plot3d(f, image = TRUE, contour = TRUE, c.select = 3)
# plot3d(f, image = TRUE, contour = TRUE, c.select = "Mean")
# plot3d(f, image = TRUE, contour = TRUE, c.select = "97.5

## End(Not run)

## Variations.
d$f1 &lt;- with(d, sin(z) * cos(w))
with(d, plot3d(cbind(z, w, f1)))

## Same with formula. 
plot3d(sin(z) * cos(w) ~ z + w, zlab = "f(z,w)", data = d)
plot3d(sin(z) * cos(w) ~ z + w, zlab = "f(z,w)", data = d, 
  ticktype = "detailed")

## Play with palettes.
plot3d(sin(z) * cos(w) ~ z + w, col.surface = heat.colors, data = d)
plot3d(sin(z) * cos(w) ~ z + w, col.surface = topo.colors, data = d)
plot3d(sin(z) * cos(w) ~ z + w, col.surface = cm.colors, data = d)
plot3d(sin(z) * cos(w) ~ z + w, col.surface = rainbow, data = d)
plot3d(sin(z) * cos(w) ~ z + w, col.surface = terrain.colors, data = d)

plot3d(sin(z) * cos(w) ~ z + w, col.surface = rainbow_hcl, data = d)
plot3d(sin(z) * cos(w) ~ z + w, col.surface = diverge_hcl, data = d)
plot3d(sin(z) * cos(w) ~ z + w, col.surface = sequential_hcl, data = d)

plot3d(sin(z) * cos(w) ~ z + w, 
  col.surface = rainbow_hcl(n = 99, c = 300, l = 80, start = 0, end = 100), 
  data = d)
# plot3d(sin(z) * cos(w) ~ z + w, 
#  col.surface = rainbow_hcl(n = 99, c = 300, l = 80, start = 0, end = 100), 
#  image = TRUE, grid = 200, data = d)
</code></pre>


</div>