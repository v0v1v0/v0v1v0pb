<div class="container">

<table style="width: 100%;"><tr>
<td>partial_application</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Convenience Functions for Partial Application</h2>

<h3>Description</h3>

<p>Convenience functions for using partial application with BioCro</p>


<h3>Usage</h3>

<pre><code class="language-R">partial_run_biocro(
    initial_values = list(),
    parameters = list(),
    drivers,
    direct_module_names = list(),
    differential_module_names = list(),
    ode_solver = BioCro::default_ode_solvers$homemade_euler,
    arg_names,
    verbose = FALSE
)

partial_evaluate_module(module_name, input_quantities, arg_names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>arg_names</code></td>
<td>

<p>A vector of strings specifying input quantities whose values should not be
fixed when using partial application.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial_values</code></td>
<td>

<p>Identical to the corresponding argument from <code>run_biocro</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameters</code></td>
<td>

<p>Identical to the corresponding argument from <code>run_biocro</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drivers</code></td>
<td>

<p>Identical to the corresponding argument from <code>run_biocro</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>direct_module_names</code></td>
<td>

<p>Identical to the corresponding argument from <code>run_biocro</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>differential_module_names</code></td>
<td>

<p>Identical to the corresponding argument from <code>run_biocro</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ode_solver</code></td>
<td>

<p>Identical to the corresponding argument from <code>run_biocro</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>Identical to the corresponding argument from <code>run_biocro</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>module_name</code></td>
<td>

<p>Identical to the corresponding argument from <code>evaluate_module</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>input_quantities</code></td>
<td>

<p>A list of named numeric elements representing any input quantities required
by the module that are not included in <code>arg_names</code>; any extraneous
quantities will be ignored by the module.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><em>Partial application</em> is the technique of fixing some of the input
arguments to a function, producing a new function with fewer inputs. In the
context of BioCro, partial application can often be useful while varying some
parameters, initial values, or drivers while performing optimization or
sensitivity analysis. Optimizers (such as <code>optim</code>)
typically require a function with a single input argument, so the partial
application tools provided here help to create such functions.
</p>
<p>Both <code>partial_run_biocro</code> and <code>partial_evaluate_module</code> accept the
same arguments as their "regular" counterparts (<code>run_biocro</code> and
<code>evaluate_module</code>) with the addition of <code>arg_names</code>, which
specifies the input quantities that should not be fixed.
</p>
<p>For <code>partial_run_biocro</code>, each element of <code>arg_names</code> must be the
name of a quantity that is one of the <code>initial_values</code>,
<code>parameters</code>, or <code>drivers</code>. For <code>partial_evaluate_module</code>, each
element of <code>arg_names</code> must be the name of one of the module's input
quantities.
</p>
<p>When using one of the pre-defined crop growth models, it may be helpful to
use the <code>with</code> command to pass arguments to <code>partial_run_biocro</code>;
see the documentation for <code>crop_model_definitions</code> for more
information.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>partial_run_biocro</code></td>
<td>

<p>A function that calls <code>run_biocro</code> with all of the inputs
(except those specified in <code>arg_names</code>) set to the values specified by
the original call to <code>partial_run_biocro</code>. The new function has one
input (<code>x</code>), which can be a vector or list specifying the values of the
quantities in <code>arg_names</code>. If <code>x</code> has no names, its elements must
be supplied in the same order as in the original <code>arg_names</code>. If
<code>x</code> has names, they must be identical to the elements of
<code>arg_names</code> but can be in any order. Elements of <code>x</code> corresponding
to drivers must be vectors having the same length as the other drivers; they
can be specified as a named element of a list or as sequential elements of
a vector without names. The return value of the new function is a data frame
as would be produced by <code>run_biocro</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>partial_evaluate_module</code></td>
<td>

<p>A function that calls <code>evaluate_module</code> with the input
quantities (except those specified in <code>arg_names</code>) set to the values
specified by the original call to <code>partial_evaluate_module</code>. The new
function has one input (<code>x</code>), which can be a vector or list specifying
the values of the quantities in <code>arg_names</code>. If <code>x</code> has no names,
its elements must be supplied in the same order as in the original
<code>arg_names</code>. If <code>x</code> has names, they must be identical to the
elements of <code>arg_names</code> but can be in any order. The return value of
the new function is a list with two elements (<code>inputs</code> and
<code>outputs</code>), each of which is a list of named numeric elements
representing the module's input and output values. (Note that this differs
from the output of <code>evaluate_module</code>, which only returns the outputs.)
</p>
</td>
</tr>
</table>
<h3>See Also</h3>


<ul>
<li> <p><code>run_biocro</code>
</p>
</li>
<li> <p><code>evaluate_module</code>
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R"># Specify weather data to use in these examples
ex_weather &lt;- get_growing_season_climate(weather$'2005')

# Example 1: varying the thermal time values at which senescence starts for
# different organs in a simulation; here we set them to the following values
# instead of the defaults:
#  - seneLeaf: 2000 degrees C * day
#  - seneStem: 2100 degrees C * day
#  - seneRoot: 2200 degrees C * day
#  - seneRhizome: 2300 degrees C * day
senescence_simulation &lt;- partial_run_biocro(
  miscanthus_x_giganteus$initial_values,
  miscanthus_x_giganteus$parameters,
  ex_weather,
  miscanthus_x_giganteus$direct_modules,
  miscanthus_x_giganteus$differential_modules,
  miscanthus_x_giganteus$ode_solver,
  c('seneLeaf', 'seneStem', 'seneRoot', 'seneRhizome')
)
senescence_result &lt;- senescence_simulation(c(2000, 2100, 2200, 2300))

# Example 2: a crude method for simulating the effects of climate change; here
# we increase the atmospheric CO2 concentration to 500 ppm and the temperature
# by 2 degrees C relative to 2005 temperatures. The commands below that call
# `temperature_simulation` all produce the same result.
temperature_simulation &lt;- partial_run_biocro(
  miscanthus_x_giganteus$initial_values,
  miscanthus_x_giganteus$parameters,
  ex_weather,
  miscanthus_x_giganteus$direct_modules,
  miscanthus_x_giganteus$differential_modules,
  miscanthus_x_giganteus$ode_solver,
  c("Catm", "temp")
)
hot_result_1 &lt;- temperature_simulation(c(500, ex_weather$temp + 2.0))
hot_result_2 &lt;- temperature_simulation(list(Catm = 500, temp = ex_weather$temp + 2.0))
hot_result_3 &lt;- temperature_simulation(list(temp = ex_weather$temp + 2.0, Catm = 500))

# Note that these commands will both produce errors:
# hot_result_4 &lt;- temperature_simulation(c(Catm = 500, temp = ex_weather$temp + 2.0))
# hot_result_5 &lt;- temperature_simulation(stats::setNames(
#   c(500, ex_weather$temp + 2.0),
#   c("Catm", rep("temp", length(ex_weather$temp)))
# ))

# Note that this command will produce a strange result where the first
# temperature value will be incorrectly interpreted as a `Catm` value, and the
# `Catm` value will be interpreted as the final temperature value.
# hot_result_6 &lt;- temperature_simulation(c(ex_weather$temp + 2.0, 500))

# Example 3: varying the base and air temperature inputs to the
# 'thermal_time_linear' module from the 'BioCro' module library. The commands
# below that call `thermal_time_rate` all produce the same result.
thermal_time_rate &lt;- partial_evaluate_module(
  'BioCro:thermal_time_linear',
  within(miscanthus_x_giganteus$parameters, {time = 1}),
  c("temp", "tbase")
)
rate_result_1 &lt;- thermal_time_rate(c(25, 10))
rate_result_2 &lt;- thermal_time_rate(c(temp = 25, tbase = 10))
rate_result_3 &lt;- thermal_time_rate(c(tbase = 10, temp = 25))
rate_result_4 &lt;- thermal_time_rate(list(temp = 25, tbase = 10))
rate_result_5 &lt;- thermal_time_rate(list(tbase = 10, temp = 25))
</code></pre>


</div>