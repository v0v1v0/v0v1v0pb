<div class="container">

<table style="width: 100%;"><tr>
<td>OPTIMIZE</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Optimal control of a BIMETS model
</h2>

<h3>Description</h3>

<p>The <code>OPTIMIZE</code> procedure provides a convenient method for performing optimal control exercises; the procedure maximizes an arbitrary objective-function under the constraints imposed by the econometric model and by user-specified constraints.
<br><br>
An approach to policy evaluation is via a so-called "social welfare function". This approach relaxes the assumptions of the instruments-targets framework, i.e. the <code>RENORM</code> procedure. Rather than assuming specific desired targets for some endogenous variables, it assumes the existence of a social welfare function determining a scalar measure of performance based on both endogenous and policy (exogenous) variables.
<br><br>
The social welfare function can incorporate information about tradeoffs in objectives that are not allowed by the <code>RENORM</code> instruments-targets approach.
<br><br>
BIMETS supplies the <code>OPTIMIZE</code> procedure in order to perform optimal control exercises on econometric models.
<br><br>
The optimization consists of maximizing a social welfare function, i.e. the objective-function, depending on exogenous and (simulated) endogenous variables, subject to user constraints plus the constraints imposed by the econometric model equations. Users are allowed to define constraints and objective-functions of any degree, and are allowed to provide different constraints and objective-functions in different optimization time periods.
<br><br>
The core of the <code>OPTIMIZE</code> procedure is based on a Monte Carlo method that takes advantage of the <code>STOCHSIMULATE</code> procedure. Policy variables, i.e. <code>INSTRUMENT</code>, are uniformly perturbed in the range defined by the user-provided boundaries, then the <code>INSTRUMENT</code> values that i) verify the user-provided constraints and ii) maximize the objective-functions are selected and stored into the <code>optimize</code> element of the output BIMETS model.
<br><br>
The following steps can describe the procedure implemented in <code>OPTIMIZE</code>:
<br><br>
1) check the correctness of input arguments;<br><br>
2) perform a <code>STOCHSIMULATE</code> by uniformly perturbing the <code>INSTRUMENT</code> variables inside the user-boundaries provided in the <code>OptimizeBounds</code> function argument;<br><br>
3) during the <code>STOCHSIMULATE</code>, for each period in the optimization <code>TSRANGE</code>: i) discard the stochastic realizations that do not verify the restrictions provided in the <code>OptimizeRestrictions</code> argument; ii) for all the remaining realizations, compute the current value of the objective-functions time series, as defined in the <code>OptimizeFunctions</code> argument, by using the exogenous and (simulated) endogenous stochastic time series;<br><br>
4) once the <code>STOCHSIMULATE</code> completes, select the stochastic realization that presents the higher value in the sum of the corresponding objective-function time series values, and return, among other data, the related optimal <code>INSTRUMENT</code> time series.<br><br></p>
<p>In the following figure, the scatter plot is populated with <code>2916</code> objective function stochastic realizations, computed by using the example code at the end of this section; the <code>210.58</code> local maximum  is highlighted<br>(i.e. <code>advancedKleinModel$optimize$optFunMax</code> in first example).<br><br> In this example:<br><br> 
i) The objective function definition is:<br><code class="reqn">f(y,cn,g) = (y-110)+(cn-90)*|cn-90|-\sqrt{g-20}</code> <br>
given <code class="reqn">y</code> as the simulated <em>Gross National Product</em>, <code class="reqn">cn</code> as the simulated <em>Consumption</em> and <code class="reqn">g</code> as the exogenous <em>Government Expenditure</em>: the basic idea is to maximize <em>Consumption</em>, and secondarily the <em>Gross National Product</em>, while reducing the <em>Government Expenditure</em>;<br><br> 
ii) The <code>INSTRUMENT</code> variables are the <code class="reqn">cn</code> <em>Consumption</em> "booster" (i.e. the add-factor, not to be confused with the simulated <em>Consumption</em> in the objective function) and the <code class="reqn">g</code> <em>Government Expenditure</em>, defined over the following domains: <code class="reqn"> cn \in (-5,5)</code>, <code class="reqn">g \in (15,25)</code>;<br><br>
iii) The following restrictions are applied to the <code>INSTRUMENT</code>: <code class="reqn">g + cn^2/2 &lt; 27  \wedge  g + cn &gt; 17</code>, given <code class="reqn">cn</code> as the <em>Consumption</em> "booster" (i.e. the add-factor) and <code class="reqn">g</code> as the <em>Government Expenditure</em>;
</p>
<p><img src="../help/figures/OptKlein.png" alt="OptKlein.png"><br><br></p>
<p>The figure clearly shows that non-linear restrictions have been applied, and that non-computable objective functions have been discarded, e.g. the stochastic realizations having <code class="reqn">g&lt;20</code> due to the square root operation in the objective function, given instrument <code class="reqn">g \in (15,25)</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">OPTIMIZE( model=NULL,
          simAlgo='GAUSS-SEIDEL',
          TSRANGE=NULL,
          simType='DYNAMIC',
          simConvergence=0.01,
          simIterLimit=100,
          ZeroErrorAC=FALSE,
          BackFill=0,
          Exogenize=NULL,
          ConstantAdjustment=NULL,
          verbose=FALSE,
          verboseSincePeriod=0,
          verboseVars=NULL,
          StochReplica=100,
          StochSeed=NULL,
          OptimizeBounds=NULL,
          OptimizeRestrictions=NULL,
          OptimizeFunctions=NULL,
          quietly=FALSE,
          RESCHECKeqList=NULL,
          JACOBIAN_SHOCK=1e-4,
          JacobianDrop=NULL,
          forceForwardLooking=FALSE,
          avoidCompliance=FALSE,
          ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>see <code>SIMULATE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simAlgo</code></td>
<td>
<p>see <code>SIMULATE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>TSRANGE</code></td>
<td>
<p>see <code>SIMULATE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simType</code></td>
<td>
<p>see <code>SIMULATE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simConvergence</code></td>
<td>
<p>see <code>SIMULATE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simIterLimit</code></td>
<td>
<p>see <code>SIMULATE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ZeroErrorAC</code></td>
<td>
<p>see <code>SIMULATE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BackFill</code></td>
<td>
<p>see <code>SIMULATE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Exogenize</code></td>
<td>
<p>see <code>SIMULATE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ConstantAdjustment</code></td>
<td>
<p>see <code>SIMULATE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>see <code>SIMULATE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verboseSincePeriod</code></td>
<td>
<p>see <code>SIMULATE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verboseVars</code></td>
<td>
<p>see <code>SIMULATE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>StochReplica</code></td>
<td>
<p>see <code>STOCHSIMULATE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>StochSeed</code></td>
<td>
<p>see <code>STOCHSIMULATE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>OptimizeBounds</code></td>
<td>
<p>the named <code>list()</code> that defines the search boundaries applied to <code>INSTRUMENT</code> exogenous variables. Each list element must have a name equal to an endogenous or an exogenous model variable.<br><br> 
The list names define the <code>INSTRUMENT</code>.<br><br>
If a list element name is equal to an exogenous variable, then the boundaries will be applied directly to the related exogenous stochastic time series values. If a list element name is equal to an endogenous variable, then the boundaries will be applied to the stochastic constant adjustment  (see <code>STOCHSIMULATE</code>) of the related endogenous variable. <br><br>
Each list element must be a named list built with the following two named variables: <br><br> 
- <code>TSRANGE</code>: the time range  wherein the search boundaries are active. The <code>TSRANGE</code> must be a 4 numerical array,<br> i.e. <code>TSRANGE=c(start_year, start_period, end_year, end_period)</code> or <code>TSRANGE=TRUE</code> in order to apply the provided boundaries to the whole <code>OPTIMIZE</code> <code>TSRANGE</code>. <br><br>  
- <code>BOUNDS</code>: the boundaries that are applied to the related instrument. These parameters must contain the lower and upper bound of the uniform distribution wherein the search for the objective-functions maximum is performed,<br> i.e. <code>BOUNDS=c(lower_bound,upper_bound)</code>. <br><br> 
See example in order to learn how to build a compliant boundaries structure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>OptimizeRestrictions</code></td>
<td>
<p>the named <code>list()</code> that defines the restrictions applied to <code>INSTRUMENT</code> exogenous variables. This list can be <code>NULL</code>.<br><br> 
Each list element must be a named list built with the following two named variables: <br><br> 
- <code>TSRANGE</code>: the time range  wherein the restriction is active. The <code>TSRANGE</code> must be a 4 numerical array,<br> i.e. <code>TSRANGE=c(start_year, start_period, end_year, end_period)</code> or <code>TSRANGE=TRUE</code> in order to apply the provided restriction to the whole <code>OPTIMIZE</code> <code>TSRANGE</code>. <br><br>  
- <code>INEQUALITY</code>: the inequality expression, i.e. a <code>character</code> variable, that defines the restriction. The <code>INEQUALITY</code> expression can contain exogenous and endogenous variable names, the standard arithmetic and logical operators, parentheses and the <code>MDL</code> functions described in the <code>EQ</code> section of the <code>MDL</code> help page. If in the <code>INEQUALITY</code> expression a variable name refers to an exogenous variable, then that variable will be evaluated by using the related exogenous time series stochastic values. If in the <code>INEQUALITY</code> expression a variable name refers to an endogenous variable, then that variable will be evaluated by using to the stochastic constant adjustment (see argument <code>StochStructure</code> of the <code>STOCHSIMULATE</code> help page) of the related endogenous variable. <br><br> 
Two different <code>OptimizeRestrictions</code> list element can not have overlapping <code>TSRANGE</code>. See example in order to learn how to build a compliant restrictions structure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>OptimizeFunctions</code></td>
<td>
<p>the named <code>list()</code> that defines the objective functions to be maximized.<br><br> 
Each list element must be a named list built with the following two named variables: <br><br> 
- <code>TSRANGE</code>: the time range  wherein the objective function is evaluated. The <code>TSRANGE</code> must be a 4 numerical array,<br> i.e. <code>TSRANGE=c(start_year, start_period, end_year, end_period)</code> or <code>TSRANGE=TRUE</code> in order to evaluate the objective function in each period of the <code>OPTIMIZE</code> <code>TSRANGE</code>. <br><br>  
- <code>FUNCTION</code>: the expression, i.e. a <code>character</code> variable, that defines the objective function. The <code>FUNCTION</code> expression can contain exogenous and endogenous variable names, the standard arithmetic and logical operators, parentheses and the <code>MDL</code> functions described in the <code>EQ</code> section of the <code>MDL</code> help page. If in the <code>FUNCTION</code> expression a variable name refers to an exogenous variable, then that variable will be evaluated by using the related exogenous time series stochastic values. If in the <code>FUNCTION</code> expression a variable name refers to an endogenous variable, then that variable will be evaluated by using the stochastic simulated time series (see <code>STOCHSIMULATE</code>) of the related endogenous variable. <br><br> 
Two different <code>OptimizeFunctions</code> list element can not have overlapping <code>TSRANGE</code>. See example in order to learn how to build a compliant objective functions structure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quietly</code></td>
<td>
<p>see <code>SIMULATE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RESCHECKeqList</code></td>
<td>
<p>see <code>SIMULATE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>JACOBIAN_SHOCK</code></td>
<td>
<p>see <code>SIMULATE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>JacobianDrop</code></td>
<td>
<p>see <code>SIMULATE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>forceForwardLooking</code></td>
<td>
<p>see <code>SIMULATE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>avoidCompliance</code></td>
<td>
<p>see <code>SIMULATE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>see <code>SIMULATE</code></p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>This function will add, into the output BIMETS model object, three new named elements, respectively <code>optimize</code>, <code>simulation_MM</code> and <code>INSTRUMENT_MM</code>.<br><br>
The <code>optimize</code> element is a named <code>list()</code> that contains the following elements:<br><br></p>
<p>- <code>INSTRUMENT</code>: a named list that contains the time series of the instrument exogenous variables that verify the <code>OptimizeRestrictions</code> and that allow the objective <code>OptimizeFunctions</code> to be maximized. This element is populated only if a finite solution exists. List names are equal to the names of the related exogenous variables. Users can also declare an endogenous variable as <code>INSTRUMENT</code> variable, by using the <code>OptimizeBounds</code> argument: in this case the constant adjustment (see <code>STOCHSIMULATE</code>) related to the provided endogenous variable will be used as instrument exogenous variable, and this output <code>INSTRUMENT</code> list will contains the constant adjustment time series that allow the objective <code>OptimizeFunction</code> to be maximized (see example);<br></p>
<p>- <code>optFunMax</code>: the scalar value (local maximum) obtained by evaluating the <code>OptimizeFunctions</code> while the model is fed by the optimized <code>INSTRUMENT</code> time series. This element is populated only if a finite solution exists;<br></p>
<p>- <code>optFunTS</code>: the time series obtained by evaluating the <code>OptimizeFunctions</code> during each period in the <code>OPTIMIZE</code> <code>TSRANGE</code> while the model is fed by the optimized <code>INSTRUMENT</code> time series. Thus, <code>optFunMax==sum(optFunTS)</code>. This element is populated only if a finite solution exists;<br></p>
<p>- <code>optFunAve</code>: the scalar value that is the mean of all the stochastic <code>OptimizeFunctions</code> realizations, filtered by the restrictions imposed by the <code>OptimizeRestrictions</code> argument. This element is populated only if a finite solution exists;<br></p>
<p>- <code>optFunSd</code>: the scalar value that is the standard deviation of all the stochastic <code>OptimizeFunctions</code> realizations, filtered by the restrictions imposed by the <code>OptimizeRestrictions</code> argument. This element is populated only if a finite solution exists;<br></p>
<p>- <code>realizationsToKeep</code>: a <code>1 x StochReplica</code> boolean row array. If the <code>i</code>-th element is <code>TRUE</code> than the related objective function realization is computable and verifies the restrictions imposed by the <code>OptimizeRestricions</code> argument. It can be useful along with <code>optFunResults</code> and <code>INSTRUMENT_MM</code> in order to verify and to refine results;<br></p>
<p>- <code>optFunResults</code>: the numerical array containing the evaluated <code>OptimizeFunctions</code> for all the (unfiltered) realizations;<br></p>
<p>- <code>modelData</code>: the whole model input dataset wherein the <code>INSTRUMENT</code> exogenous variables have been modified accordingly to the <code>OPTIMIZE</code> results. This data can be useful in order to verify or to refine results (see example);<br></p>
<p>- <code>ConstantAdjustment</code>: a modified constant adjustment input list wherein the constant adjustment time series related to a <code>INSTRUMENT</code> endogenous variables have been modified accordingly to the <code>OPTIMIZE</code> results. This data can be useful in order to verify or to refine results (see example);<br></p>
<p>The arguments passed to the function call during the latest <code>OPTIMIZE</code> run will be inserted into the <code>'__OPT_PARAMETERS__'</code> element of the model <code>optimize</code> list; this data can be helpful in order to replicate the optimization results.<br></p>
<p>The <code>simulation_MM</code> element is a named <code>list()</code>, having the endogenous variables as names. Each element will contain an <code>R x C</code> matrix, given <code>R</code> the number of observations in the optimization <code>TSRANGE</code> and <code>C=1+StochReplica</code>. The first column of each matrix contains the related endogenous variable's unperturbed simulated values; the remaining columns will contain all the <code>StochReplica</code> stochastic realizations for the related endogenous variable. <br></p>
<p>The <code>INSTRUMENT_MM</code> element is a named <code>list()</code>, having <code>INSTRUMENT</code> variables as names. Each element will contain an <code>R x C</code> matrix, given <code>R</code> the number of observations in the optimization <code>TSRANGE</code> and <code>C=1+StochReplica</code>. The first column of each matrix contains the related <code>INSTRUMENT</code> variable's unperturbed values; the remaining columns will contain all the <code>StochReplica</code> stochastic realizations for the related <code>INSTRUMENT</code> variable. <br><br></p>


<h3>See Also</h3>

<p><code>MDL</code><br><code>LOAD_MODEL</code><br><code>ESTIMATE</code><br><code>STOCHSIMULATE</code><br><code>MULTMATRIX</code><br><code>RENORM</code><br><code>TIMESERIES</code><br><code>BIMETS indexing</code><br><code>BIMETS configuration</code><br></p>


<h3>Examples</h3>

<pre><code class="language-R">

#define the advanced Klein model
advancedKleinModelDef &lt;- "
MODEL

COMMENT&gt; Modified Klein Model 1 of the U.S. Economy with PDL, 
COMMENT&gt; autocorrelation on errors, restrictions and conditional equation evaluations

COMMENT&gt; Consumption with autocorrelation on errors
BEHAVIORAL&gt; cn
TSRANGE 1923 1 1940 1
EQ&gt; cn =  a1 + a2*p + a3*TSLAG(p,1) + a4*(w1+w2) 
COEFF&gt; a1 a2 a3 a4
ERROR&gt; AUTO(2)

COMMENT&gt; Investment with restrictions
BEHAVIORAL&gt; i
TSRANGE 1923 1 1940 1
EQ&gt; i = b1 + b2*p + b3*TSLAG(p,1) + b4*TSLAG(k,1)
COEFF&gt; b1 b2 b3 b4
RESTRICT&gt; b2 + b3 = 1

COMMENT&gt; Demand for Labor with PDL
BEHAVIORAL&gt; w1 
TSRANGE 1923 1 1940 1
EQ&gt; w1 = c1 + c2*(y+t-w2) + c3*TSLAG(y+t-w2,1) + c4*time
COEFF&gt; c1 c2 c3 c4
PDL&gt; c3 1 2

COMMENT&gt; Gross National Product
IDENTITY&gt; y
EQ&gt; y = cn + i + g - t

COMMENT&gt; Profits
IDENTITY&gt; p
EQ&gt; p = y - (w1+w2)

COMMENT&gt; Capital Stock with IF switches
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1) + i
IF&gt; i &gt; 0
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1) 
IF&gt; i &lt;= 0

END
"

#load the model
advancedKleinModel &lt;- LOAD_MODEL(modelText = advancedKleinModelDef)


#define data
kleinModelData &lt;- list(  
    cn  =TIMESERIES(39.8,41.9,45,49.2,50.6,52.6,55.1,56.2,57.3,57.8,
                    55,50.9,45.6,46.5,48.7,51.3,57.7,58.7,57.5,61.6,65,69.7, 	
                    START=c(1920,1),FREQ=1),
    g   =TIMESERIES(4.6,6.6,6.1,5.7,6.6,6.5,6.6,7.6,7.9,8.1,9.4,10.7,
                    10.2,9.3,10,10.5,10.3,11,13,14.4,15.4,22.3,	
                    START=c(1920,1),FREQ=1),
    i   =TIMESERIES(2.7,-.2,1.9,5.2,3,5.1,5.6,4.2,3,5.1,1,-3.4,-6.2,
                    -5.1,-3,-1.3,2.1,2,-1.9,1.3,3.3,4.9,	
                    START=c(1920,1),FREQ=1),
    k   =TIMESERIES(182.8,182.6,184.5,189.7,192.7,197.8,203.4,207.6,
                    210.6,215.7,216.7,213.3,207.1,202,199,197.7,199.8,
                    201.8,199.9,201.2,204.5,209.4,	
                    START=c(1920,1),FREQ=1),
    p   =TIMESERIES(12.7,12.4,16.9,18.4,19.4,20.1,19.6,19.8,21.1,21.7,
                    15.6,11.4,7,11.2,12.3,14,17.6,17.3,15.3,19,21.1,23.5,	
                    START=c(1920,1),FREQ=1),
    w1  =TIMESERIES(28.8,25.5,29.3,34.1,33.9,35.4,37.4,37.9,39.2,41.3,
                    37.9,34.5,29,28.5,30.6,33.2,36.8,41,38.2,41.6,45,53.3,	
                    START=c(1920,1),FREQ=1),
    y   =TIMESERIES(43.7,40.6,49.1,55.4,56.4,58.7,60.3,61.3,64,67,57.7,
                    50.7,41.3,45.3,48.9,53.3,61.8,65,61.2,68.4,74.1,85.3,	
                    START=c(1920,1),FREQ=1),
    t   =TIMESERIES(3.4,7.7,3.9,4.7,3.8,5.5,7,6.7,4.2,4,7.7,7.5,8.3,5.4,
                    6.8,7.2,8.3,6.7,7.4,8.9,9.6,11.6,	
                    START=c(1920,1),FREQ=1),
    time=TIMESERIES(NA,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,
                    1,2,3,4,5,6,7,8,9,10,	
                    START=c(1920,1),FREQ=1),
    w2  =TIMESERIES(2.2,2.7,2.9,2.9,3.1,3.2,3.3,3.6,3.7,4,4.2,4.8,
                    5.3,5.6,6,6.1,7.4,6.7,7.7,7.8,8,8.5,	
                    START=c(1920,1),FREQ=1)
)

#load time series into the model object
advancedKleinModel &lt;- LOAD_MODEL_DATA(advancedKleinModel,kleinModelData)

#estimate the model
advancedKleinModel &lt;- ESTIMATE(advancedKleinModel, quietly=TRUE)

#we want to maximize the non-linear objective function:
#f()=(y-110)+(cn-90)*ABS(cn-90)-(g-20)^0.5
#in 1942 by using INSTRUMENT cn in range (-5,5) 
#(cn is endogenous so we use the add-factor)
#and g in range (15,25)
#we will also impose the following non-linear restriction:
#g+(cn^2)/2&lt;27 &amp; g+cn&gt;17

#we need to extend exogenous variables up to 1942
advancedKleinModel$modelData &lt;- within(advancedKleinModel$modelData,{
    w2    = TSEXTEND(w2,  UPTO=c(1942,1),EXTMODE='CONSTANT')
    t     = TSEXTEND(t,   UPTO=c(1942,1),EXTMODE='LINEAR')
    g     = TSEXTEND(g,   UPTO=c(1942,1),EXTMODE='CONSTANT')
    k     = TSEXTEND(k,   UPTO=c(1942,1),EXTMODE='LINEAR')
    time  = TSEXTEND(time,UPTO=c(1942,1),EXTMODE='LINEAR')
})

#define INSTRUMENT and boundaries
myOptimizeBounds &lt;- list(
    cn=list(TSRANGE=TRUE,
            BOUNDS=c(-5,5)),
    g=list(TSRANGE=TRUE,
           BOUNDS=c(15,25))
)

#define restrictions
myOptimizeRestrictions &lt;- list(
    myRes1=list(
        TSRANGE=TRUE,
        INEQUALITY='g+(cn^2)/2&lt;27 &amp; g+cn&gt;17')
)

#define objective function
myOptimizeFunctions &lt;- list(
    myFun1=list(
        TSRANGE=TRUE,
        FUNCTION='(y-110)+(cn-90)*ABS(cn-90)-(g-20)^0.5')
)

#Monte-Carlo optimization by using 10000 stochastic realizations
#and 1E-4 convergence criterion 
advancedKleinModel &lt;- OPTIMIZE(advancedKleinModel
                          ,simType = 'FORECAST'
                          ,TSRANGE=c(1942,1,1942,1)
                          ,simConvergence= 1E-4
                          ,simIterLimit  = 1000
                          ,StochReplica  = 10000
                          ,StochSeed = 123
                          ,OptimizeBounds = myOptimizeBounds
                          ,OptimizeRestrictions = myOptimizeRestrictions
                          ,OptimizeFunctions = myOptimizeFunctions)
                          
#OPTIMIZE(): optimization boundaries for the add-factor of endogenous 
#            variable "cn" are (-5,5) from year-period 1942-1 to 1942-1.
#OPTIMIZE(): optimization boundaries for the exogenous 
#            variable "g" are (15,25) from year-period 1942-1 to 1942-1.
#OPTIMIZE(): optimization restriction "myRes1" is active 
#            from year-period 1942-1 to 1942-1.
#OPTIMIZE(): optimization objective function "myFun1" is active 
#            from year-period 1942-1 to 1942-1.
#
#Optimize:     100.00 %
#OPTIMIZE(): 2916 out of 10000 objective function realizations (29%) 
#            are finite and verify the provided restrictions.
#...OPTIMIZE OK

#print local maximum
advancedKleinModel$optimize$optFunMax
#[1] 210.5755

#print INSTRUMENT that allow local maximum to be achieved
advancedKleinModel$optimize$INSTRUMENT
#$cn
#Time Series:
#Start = 1942 
#End = 1942 
#Frequency = 1 
#[1] 2.032203
#
#$g
#Time Series:
#Start = 1942 
#End = 1942 
#Frequency = 1 
#[1] 24.89773

#LET'S VERIFY RESULTS
#copy into modelData the computed INSTRUMENT 
#that allow to maximize the objective function 
advancedKleinModel$modelData &lt;- advancedKleinModel$optimize$modelData

#simulate the model by using the new INSTRUMENT
#note: we used cn add-factor as OPTIMIZE instrument, so we need 
#to pass the computed cn add-factor to the SIMULATE call
newConstantAdjustment &lt;- advancedKleinModel$optimize$ConstantAdjustment
advancedKleinModel &lt;- SIMULATE(advancedKleinModel
                  ,simType = 'FORECAST'
                  ,TSRANGE = c(1942,1,1942,1)
                  ,simConvergence = 1E-5
                  ,simIterLimit = 1000
                  ,ConstantAdjustment = newConstantAdjustment
)

#calculate objective function by using the SIMULATE output time series
#(y-110)+(cn-90)*ABS(cn-90)-(g-20)^0.5
y  &lt;- advancedKleinModel$simulation$y
cn &lt;- advancedKleinModel$simulation$cn
g  &lt;- advancedKleinModel$modelData$g
optFunTest &lt;- (y-110)+(cn-90)*abs(cn-90)-(g-20)^0.5

#verify computed max is equal to optimization max
#(in the following command TSPROJECT could be omitted because
#myFun1$TSRANGE = TRUE)
abs(sum(TSPROJECT(optFunTest
              ,TSRANGE=c(1942,1,1942,1)
              ,ARRAY = TRUE)
        ) - advancedKleinModel$optimize$optFunMax)  &lt; 1E-4
#[1] TRUE

#we can also check that the SIMULATE time series 
#are equal to the OPTIMIZE realizations that allow to maximize
#the objective function

#get realization index that maximizes the objective function
maximizingRealizationIdx &lt;- with(advancedKleinModel$optimize,
                              which.max(optFunResults[realizationsToKeep]))

#get stochastic realizations unfiltered
#(simulation_MM and INSTRUMENT_MM are populated during the OPTIMIZE call)
y_opt  &lt;- advancedKleinModel$simulation_MM$y
cn_opt &lt;- advancedKleinModel$simulation_MM$cn
g_opt  &lt;- advancedKleinModel$INSTRUMENT_MM$g

#filter by restrictions and by finite solutions
#(first column in all matrices is related to the un-perturbed model)
y_opt  &lt;- y_opt[ ,c(FALSE,advancedKleinModel$optimize$realizationsToKeep),drop=FALSE]
cn_opt &lt;- cn_opt[,c(FALSE,advancedKleinModel$optimize$realizationsToKeep),drop=FALSE]
g_opt  &lt;- g_opt[ ,c(FALSE,advancedKleinModel$optimize$realizationsToKeep),drop=FALSE]

#get maximizing realizations
y_opt  &lt;- y_opt[ ,maximizingRealizationIdx,drop=FALSE]
cn_opt &lt;- cn_opt[,maximizingRealizationIdx,drop=FALSE]
g_opt  &lt;- g_opt[ ,maximizingRealizationIdx,drop=FALSE]

#verify that these variables are equal to the SIMULATE time series
max(abs(y-y_opt))   &lt; 1E-4  
#[1] TRUE

max(abs(cn-cn_opt)) &lt; 1E-4  
#[1] TRUE

max(abs(g[[1942,1]]-g_opt)) &lt; 1E-4  
#[1] TRUE

 
############################################################
#MULTI RESTRICTIONS, MULTI OBJECTIVE FUNCTIONS EXAMPLE

#load the model (reset stuff)
advancedKleinModel &lt;- LOAD_MODEL(modelText = advancedKleinModelDef)

#load time series into the model object
advancedKleinModel &lt;- LOAD_MODEL_DATA(advancedKleinModel,kleinModelData)

#estimate the model
advancedKleinModel &lt;- ESTIMATE(advancedKleinModel, quietly=TRUE)

#we want to maximize the non-linear objective function:
#f1()=(y-110)+(cn-90)*ABS(cn-90)-(g-20)^0.5
#in 1942 by using INSTRUMENT cn in range (-5,5) 
#(cn is endogenous so we use the add-factor)
#and g in range (15,25)
#we want to maximize the non-linear objective function:
#f2()=(y-120)+(cn-100)*ABS(cn-100)-(g-20)^0.5-(w2-8)^0.5
#in 1943 by using INSTRUMENT cn in range (-5,5),
#g in range (15,25)
#and w2 in range (7.5,12.5)
#we will also impose the following non-linear restrictions:
#in 1942: g+(cn^2)/2&lt;27 &amp; g+cn&gt;17
#in 1943: (g^2)/10+(cn^2)/2+w2^2 &lt; 200

#we need to extend exogenous variables up to 1943
advancedKleinModel$modelData &lt;- within(advancedKleinModel$modelData,{
    w2    = TSEXTEND(w2,  UPTO=c(1943,1),EXTMODE='CONSTANT')
    t     = TSEXTEND(t,   UPTO=c(1943,1),EXTMODE='LINEAR')
    g     = TSEXTEND(g,   UPTO=c(1943,1),EXTMODE='CONSTANT')
    k     = TSEXTEND(k,   UPTO=c(1943,1),EXTMODE='LINEAR')
    time  = TSEXTEND(time,UPTO=c(1943,1),EXTMODE='LINEAR')
})

#define INSTRUMENT and boundaries
myOptimizeBounds &lt;- list(
    cn=list(TSRANGE=TRUE,
            BOUNDS=c(-5,5)),
    g=list(TSRANGE=TRUE,
           BOUNDS=c(15,25)),
    w2=list(TSRANGE=c(1943,1,1943,1),
            BOUNDS=c(7.5,12.5))
)

#define restrictions
myOptimizeRestrictions &lt;- list(
    myRes1=list(
        TSRANGE=c(1942,1,1942,1),
        INEQUALITY='g+(cn^2)/2 &lt; 27 &amp; g+cn &gt; 17'),
    myRes2=list(
        TSRANGE=c(1943,1,1943,1),
        INEQUALITY='(g^2)/10+(cn^2)/2+w2^2 &lt; 200')
)

#define objective functions
myOptimizeFunctions &lt;- list(
    myFun1=list(
        TSRANGE=c(1942,1,1942,1),
        FUNCTION='(y-110)+(cn-90)*ABS(cn-90)-(g-20)^0.5'),
    myFun2=list(
        TSRANGE=c(1943,1,1943,1),
        FUNCTION='(y-120)+(cn-100)*ABS(cn-100)-(g-20)^0.5-(w2-8)^0.5')
)

#Monte-Carlo optimization by using 1000 stochastic realizations
#and 1E-4 convergence
advancedKleinModel &lt;- OPTIMIZE(advancedKleinModel
                          ,simType = 'FORECAST'
                          ,TSRANGE=c(1942,1,1943,1)
                          ,simConvergence=1E-4
                          ,simIterLimit = 500
                          ,StochReplica = 1000
                          ,StochSeed = 123
                          ,OptimizeBounds = myOptimizeBounds
                          ,OptimizeRestrictions = myOptimizeRestrictions
                          ,OptimizeFunctions = myOptimizeFunctions)

#print INSTRUMENT that allow local maximum to be achieved
advancedKleinModel$optimize$INSTRUMENT

#LET'S VERIFY RESULTS
#copy into modelData the computed INSTRUMENT 
#that allow to maximize the objective function 
advancedKleinModel$modelData &lt;- advancedKleinModel$optimize$modelData

#simulate the model by using the new INSTRUMENT
newConstantAdjustment &lt;- advancedKleinModel$optimize$ConstantAdjustment
advancedKleinModel &lt;- SIMULATE(advancedKleinModel
                  ,simType = 'FORECAST'
                  ,TSRANGE = c(1942,1,1943,1)
                  ,simConvergence = 1E-5
                  ,simIterLimit = 100
                  ,ConstantAdjustment = newConstantAdjustment
)

#calculate objective functions by using the SIMULATE output time series
y  &lt;- advancedKleinModel$simulation$y
cn &lt;- advancedKleinModel$simulation$cn
g  &lt;- advancedKleinModel$modelData$g
w2 &lt;- advancedKleinModel$modelData$w2
optFunTest1 &lt;- (y-110)+(cn-90)*abs(cn-90)-(g-20)^0.5
optFunTest2 &lt;- (y-120)+(cn-100)*abs(cn-100)-(g-20)^0.5-(w2-8)^0.5

#verify computed max is equal to optimization max
abs(sum(TSPROJECT(optFunTest1
                  ,TSRANGE=c(1942,1,1942,1)
                  ,ARRAY = TRUE)+
        TSPROJECT(optFunTest2
                  ,TSRANGE=c(1943,1,1943,1)
                  ,ARRAY = TRUE)
        ) - advancedKleinModel$optimize$optFunMax)  &lt; 1E-2
#[1] TRUE
    
</code></pre>


</div>