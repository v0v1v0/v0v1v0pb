<div class="container">

<table style="width: 100%;"><tr>
<td>getPairScore</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Extract the Score of Each Pair</h2>

<h3>Description</h3>

<p>Extract the score of each pair.
</p>


<h3>Usage</h3>

<pre><code class="language-R">getPairScore(
  object,
  endpoint = NULL,
  strata = NULL,
  cumulative = FALSE,
  rm.withinStrata = TRUE,
  rm.strata = is.na(object@strata),
  rm.indexPair = TRUE,
  rm.weight = FALSE,
  rm.corrected = (object@correction.uninf == 0),
  unlist = TRUE,
  trace = 1
)

## S4 method for signature 'S4BuyseTest'
getPairScore(
  object,
  endpoint = NULL,
  strata = NULL,
  cumulative = FALSE,
  rm.withinStrata = TRUE,
  rm.strata = is.na(object@strata),
  rm.indexPair = TRUE,
  rm.weight = FALSE,
  rm.corrected = (object@correction.uninf == 0),
  unlist = TRUE,
  trace = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> object of class <code>S4BuyseTest</code>, i.e., output of <code>BuyseTest</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>endpoint</code></td>
<td>
<p>[integer/character vector] the endpoint for which the scores should be output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strata</code></td>
<td>
<p>[character vector] the strata relative to which the score should be output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cumulative</code></td>
<td>
<p>[logical] should the scores be cumulated over endpoints?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rm.withinStrata</code></td>
<td>
<p>[logical] should the columns indicating the position of each member of the pair
within each treatment group be removed?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rm.strata</code></td>
<td>
<p>[logical] should the column containing the level of the strata variable be removed from the output?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rm.indexPair</code></td>
<td>
<p>[logical] should the column containing the number associated to each pair be removed from the output?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rm.weight</code></td>
<td>
<p>[logical] should the column weight be removed from the output?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rm.corrected</code></td>
<td>
<p>[logical] should the columns corresponding to the scores after weighting be removed from the output?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unlist</code></td>
<td>
<p>[logical] should the structure of the output be simplified when possible?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>[logical] should a message be printed to explain what happened
when the function returned <code>NULL</code>?</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The maximal output (i.e. with all columns) contains for each endpoint, a data.table with:
</p>

<ul>
<li> <p><code>"strata"</code>: the name of the strata to which the pair belongs.
</p>
</li>
<li> <p><code>"index.T"</code>: the index of the treatment observation in the pair relative to the original dataset.
</p>
</li>
<li> <p><code>"index.C"</code>: the index of the control observation in the pair relative to the original dataset.
</p>
</li>
<li> <p><code>"indexWithinStrata.T"</code>: the index of the treatment observation in the pair relative to the treatment group and the strata.
</p>
</li>
<li> <p><code>"indexWithinStrata.C"</code>: the index of the control observation in the pair relative to the control group and the strata.
</p>
</li>
<li> <p><code>"favorable"</code>: the probability that the endpoint is better in the treatment arm vs. in the control arm.
</p>
</li>
<li> <p><code>"unfavorable"</code>: the probability that the endpoint is worse in the treatment arm vs. in the control arm.
</p>
</li>
<li> <p><code>"neutral"</code>: the probability that the endpoint is no different in the treatment arm vs. in the control arm.
</p>
</li>
<li> <p><code>"uninformative"</code>: the weight of the pair that cannot be attributed to favorable/unfavorable/neutral.
</p>
</li>
<li> <p><code>"weight"</code>: the residual weight of the pair to be analyzed at the current outcome. Each pair starts with a weight of 1.
</p>
</li>
<li> <p><code>"favorable.corrected"</code>: same as <code>"favorable"</code>  after weighting.
</p>
</li>
<li> <p><code>"unfavorable.corrected"</code>: same as <code>"favorable"</code> after weighting.
</p>
</li>
<li> <p><code>"neutral.corrected"</code>: same as <code>"favorable"</code> after weighting.
</p>
</li>
<li> <p><code>"uninformative.corrected"</code>: same as <code>"favorable"</code> after weighting.
</p>
</li>
</ul>
<p>Note that the <code>.T</code> and <code>.C</code> may change since they correspond of the label of the treatment and control arms.
The first weighting consists in multiplying the probability by the residual weight of the pair
(i.e. the weight of the pair that was not informative at the previous endpoint). This is always performed.
For time to event endpoint an additional weighting may be performed to avoid a possible bias in presence of censoring.
</p>


<h3>Author(s)</h3>

<p>Brice Ozenne
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(data.table)
library(prodlim)

## run BuyseTest
library(survival) ## import veteran

BT.keep &lt;- BuyseTest(trt ~ tte(time, threshold = 20, status = "status") + cont(karno),
                     data = veteran, keep.pairScore = TRUE, 
                     trace = 0, method.inference = "none")

## Extract scores
pScore &lt;- getPairScore(BT.keep, endpoint = 1)

## look at one pair
indexPair &lt;- intersect(which(pScore$index.1 == 22),
                       which(pScore$index.2 == 71))
pScore[indexPair]

## retrive pair in the original dataset
pVeteran &lt;- veteran[pScore[indexPair,c(index.1,index.2)],]
pVeteran

## the observation from the control group is censored at 97
## the observation from the treatment group has an event at 112
## since the threshold is 20, and (112-20)&lt;97
## we know that the pair is not in favor of the treatment

## the formula for probability in favor of the control is
## Sc(97)/Sc(112+20)
## where Sc(t) is the survival at time t in the control arm.

## we first estimate the survival in each arm
e.KM &lt;- prodlim(Hist(time,status)~trt, data = veteran)

## and compute the survival
iSurv &lt;- predict(e.KM, times =  c(97,112+20),
                 newdata = data.frame(trt = 1, stringsAsFactors = FALSE))[[1]]

## the probability in favor of the control is then
pUF &lt;- iSurv[2]/iSurv[1]
pUF
## and the complement to one of that is the probability of being neutral
pN &lt;- 1 - pUF
pN

if(require(testthat)){
   testthat::expect_equal(pUF, pScore[indexPair, unfavorable])
   testthat::expect_equal(pN, pScore[indexPair, neutral])
}
</code></pre>


</div>