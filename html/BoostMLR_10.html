<div class="container">

<table style="width: 100%;"><tr>
<td>updateBoostMLR</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Update boosting object with an additional boosting iterations
</h2>

<h3>Description</h3>

<p>Function allows to update boosting object with an additional boosting iterations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">updateBoostMLR(Object,
               M_Add,
               Verbose = TRUE,
               ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Object</code></td>
<td>
<p>Boosting object. This object is previously obtained using <code>BoostMLR</code> function or using <code>update</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M_Add</code></td>
<td>
<p>Number of additional boosting iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Verbose</code></td>
<td>
<p>Print the current stage of boosting iteration?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In boosting, <code>Mopt</code>, the number of boosting iterations
required to achive optimal result, is unknown. 
Typically, <code>Mopt</code> is estimated by specifying a large value
of <code>M</code> and then search for an optimal value that is less 
than <code>M</code> using the test data. 
Function <code>update</code> allows user to start with a small value of <code>M</code>, and keep increamenting boosting iterations, each time running through the test data, until an optimal boosting iteration is found. This can significantly reduce unnecessary computations, particularly when <code>Mopt</code> &lt;&lt; <code>M</code>.
The procedure can be replicated multiple times using the boosting object (see example below).
Results from <code>update</code> can be treated the same way we treat results
from <code>BoostMLR</code>.
</p>


<h3>Author(s)</h3>

<p>Amol Pande and Hemant Ishwaran
</p>


<h3>See Also</h3>

<p><code>BoostMLR</code>,
<code>predictBoostMLR</code>,
<code>simLong</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
##-----------------------------------------------------------------
## Univariate Longitudinal Response
##-----------------------------------------------------------------

# Simulate data involves 1 response and 4 covariates

dta &lt;- simLong(n = 100, N = 5, rho =.80, model = 2, q_x = 0, 
                                  q_y = 0,type = "corCompSym")$dtaL

# Boosting call: Raw values of covariates, B-spline for time, 
# no shrinkage, no estimate of rho and phi

boost.grow &lt;- BoostMLR(x = dta$features, tm = dta$time, id = dta$id, 
                          y = dta$y, M = 100, VarFlag = FALSE)
                          
# Update boosting object for the additional 100 iteration
boost.grow &lt;- updateBoostMLR(Object = boost.grow, M_Add = 100,Verbose = TRUE)

# Update boosting object for the additional 50 iteration
boost.grow &lt;- updateBoostMLR(Object = boost.grow, M_Add = 50,Verbose = TRUE)

</code></pre>


</div>