<div class="container">

<table style="width: 100%;"><tr>
<td>quantile.density</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Extract Quantiles from 'density' Objects</h2>

<h3>Description</h3>

<p>Quantiles for objects of class "density", "pred.density" or "coef.density"
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'density'
quantile(x, probs = seq(0.25, 0.75, 0.25), names = TRUE, normalize = TRUE, ...)

## S3 method for class 'coef.density'
quantile(x, probs = seq(0.25, 0.75, 0.25), names = TRUE, ...)

## S3 method for class 'pred.density'
quantile(x, probs = seq(0.25, 0.75, 0.25), names = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a object of class <code>pred.density</code>, <code>coef.density</code>,
<code>density</code>, or a list of densities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>probs</code></td>
<td>
<p>numeric vector of probabilities with values in [0,1] - elements
very close to the boundaries return <code>Inf</code> or <code>-Inf</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names</code></td>
<td>
<p>logical; if <code>TRUE</code>, the result has a <code>names</code>
attribute, resp. a <code>rownames</code> and <code>colnames</code> attributes. Set to
<code>FALSE</code> for speedup with many probs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p>logical; if <code>TRUE</code> then the values in <code>x$y</code> are
multiplied with a factor such that their integral is equal to one.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The methods <code>quantile.coef.density</code> and <code>quantile.pred.density</code>
both apply <code>quantile.density</code> to densities nested with object of class
<code>coef.density</code> or <code>pred.density</code>.<br> The function
<code>quantile.density</code> applies generically to the built-in class
<code>density</code> (as least for versions where there is no such method
in the pre-configured packages).<br> Note that <code>quantile.density</code> relies
on trapezoidal integration in order to compute the cumulative densities
necessary for the calculation of quantiles.
</p>


<h3>Value</h3>

<p>If <code>x</code> is of class <code>density</code> (or a list with exactly one
element), a vector with quantiles.<br> If <code>x</code> is a <code>list</code> of
densities with more than one element (e.g. as resulting from
<code>pred.density</code> or <code>coef.density</code>), then the output is a matrix of
quantiles, with each matrix row corresponding to the respective density.
</p>


<h3>Author(s)</h3>

<p>Stefan Zeugner
</p>


<h3>See Also</h3>

<p><code>quantile.default</code> for a comparable function,
<code>pred.density</code> and <code>density.bma</code> for the
BMA-specific objects.
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
 data(datafls)
 mm = bms(datafls[1:70,], user.int=FALSE)
 
 #predict last two observations with preceding 70 obs:
 pmm = pred.density(mm, newdata=datafls[71:72,], plot=FALSE) 
 #'standard error' quantiles
 quantile(pmm, c(.05, .95))
 
 #Posterior density for Coefficient of "GDP60"
 cmm = density(mm, reg="GDP60", plot=FALSE) 
 quantile(cmm, probs=c(.05, .95))
 
 
 #application to generic density:
 dd1 = density(rnorm(1000))
 quantile(dd1)
 
## Not run: 
 #application to list of densities:
 quantile.density( list(density(rnorm(1000)), density(rnorm(1000))) )

## End(Not run)

</code></pre>


</div>