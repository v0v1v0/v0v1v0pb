<div class="container">

<table style="width: 100%;"><tr>
<td>learn.structure</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>learn the structure of a network.</h2>

<h3>Description</h3>

<p>Learn the structure (the directed acyclic graph) of a <code>BN</code> object according to a <code>BNDataset</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">learn.structure(
  bn,
  dataset,
  algo = "mmhc",
  scoring.func = "BDeu",
  initial.network = NULL,
  alpha = 0.05,
  ess = 1,
  bootstrap = FALSE,
  layering = c(),
  max.fanin = num.variables(dataset),
  max.fanin.layers = NULL,
  max.parents = num.variables(dataset),
  max.parents.layers = NULL,
  layer.struct = NULL,
  cont.nodes = c(),
  use.imputed.data = FALSE,
  use.cpc = TRUE,
  mandatory.edges = NULL,
  ...
)

## S4 method for signature 'BN,BNDataset'
learn.structure(
  bn,
  dataset,
  algo = "mmhc",
  scoring.func = "BDeu",
  initial.network = NULL,
  alpha = 0.05,
  ess = 1,
  bootstrap = FALSE,
  layering = c(),
  max.fanin = num.variables(dataset) - 1,
  max.fanin.layers = NULL,
  max.parents = num.variables(dataset) - 1,
  max.parents.layers = NULL,
  layer.struct = NULL,
  cont.nodes = c(),
  use.imputed.data = FALSE,
  use.cpc = TRUE,
  mandatory.edges = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>bn</code></td>
<td>
<p>a <code>BN</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dataset</code></td>
<td>
<p>a <code>BNDataset</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algo</code></td>
<td>
<p>the algorithm to use. Currently, one among <code>sm</code> (Silander-Myllymaki), <code>mmpc</code>
(Max-Min Parent-and-Children), <code>mmhc</code> (Max-Min Hill Climbing, default), <code>hc</code>
(Hill Climbing) and <code>sem</code> (Structural Expectation Maximization).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scoring.func</code></td>
<td>
<p>the scoring function to use. Currently, one among <code>BDeu</code>, <code>AIC</code>, <code>BIC</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial.network</code></td>
<td>
<p>network srtructure to be used as starting point for structure search.
Can take different values:
a <code>BN</code> object, a matrix containing the adjacency matrix of the structure of the network,
or the string <code>random.chain</code> to sample a random chain as starting point.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>confidence threshold (only for <code>mmhc</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ess</code></td>
<td>
<p>Equivalent Sample Size value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bootstrap</code></td>
<td>
<p><code>TRUE</code> to use bootstrap samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>layering</code></td>
<td>
<p>vector containing the layers each node belongs to (only for <code>sm</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.fanin</code></td>
<td>
<p>maximum number of parents for each node (only for <code>hc</code>, <code>mmhc</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.fanin.layers</code></td>
<td>
<p>matrix of available parents in each layer (only for <code>sm</code> –
DEPRECATED, use <code>max.parents.layers</code> instead).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.parents</code></td>
<td>
<p>maximum number of parents for each node (for <code>sm</code>, <code>hc</code>, <code>mmhc</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.parents.layers</code></td>
<td>
<p>matrix of available parents in each layer (only for <code>sm</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>layer.struct</code></td>
<td>
<p><code>0/1</code> matrix for indicating which layers can contain parent nodes
for nodes in a layer (only for <code>mmhc</code>, <code>mmpc</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cont.nodes</code></td>
<td>
<p>vector containing the index of continuous variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.imputed.data</code></td>
<td>
<p><code>TRUE</code> to learn the structure from the imputed dataset
(if available, a check is performed). Default is to use raw dataset</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.cpc</code></td>
<td>
<p>(when using <code>mmhc</code>) compute Candidate Parent-and-Children sets instead of 
starting the Hill Climbing from an empty graph.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mandatory.edges</code></td>
<td>
<p>binary matrix, where a <code>1</code> in cell <code>[i,j]</code>
indicates that an edge from node <code>i</code> to node <code>j</code> must be present
in the final network.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>potential further arguments for method.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>We provide three algorithms in order to learn the structure of the network, that can be chosen with the <code>algo</code> parameter.
The first is the Silander-Myllym\"aki (<code>sm</code>)
exact search-and-score algorithm, that performs a complete evaluation of the search space in order to discover
the best network; this algorithm may take a very long time, and can be inapplicable when discovering networks
with more than 25–30 nodes. Even for small networks, users are strongly encouraged to provide
meaningful parameters such as the layering of the nodes, or the maximum number of parents – refer to the 
documentation in package manual for more details on the method parameters.
</p>
<p>The second method is the constraint-based Max-Min Parents-and-Children (<code>mmpc</code>), that returns the skeleton of the network.
Given the possible presence of loops, due to the non-directionality of the edges discovered, no parameter learning
is possible using this algorithm. Also note that in the case of a very dense network and lots of obsevations, the statistical evaluation
of the search space may take a long time. Also for this algorithm there are parameters that may need to be tuned,
mainly the confidence threshold of the statistical pruning. Please refer to the rest of this documentation for their explanation.
</p>
<p>The third algorithm is another heuristic, the Hill-Climbing (<code>hc</code>). It can start from the complete space of possibilities
(default) or from a reduced subset of possible edges, using the <code>cpc</code> argument.
</p>
<p>The fourth algorithm (and the default one) is the Max-Min Hill-Climbing heuristic (<code>mmhc</code>), that performs a statistical
sieving of the search space followed by a greedy evaluation, by combining the MMPC and the HC algorithms.
It is considerably faster than the complete method, at the cost of a (likely)
lower quality. As for MMPC, the computational time depends on the density of the network, the number of observations and
the tuning of the parameters.
</p>
<p>The fifth method is the Structural Expectation-Maximization (<code>sem</code>) algorithm,
for learning a network from a dataset with missing values. It iterates a sequence of Expectation-Maximization (in order to “fill in”
the holes in the dataset) and structure learning from the guessed dataset, until convergence. The structure learning used inside SEM,
due to computational reasons, is MMHC. Convergence of SEM can be controlled with the parameters <code>struct.threshold</code>
and <code>param.threshold</code>, for the structure and the parameter convergence, respectively.
for learning a network from a dataset with missing values. It iterates a sequence of Expectation-Maximization (in order to “fill in”
the holes in the dataset) and structure learning from the guessed dataset, until convergence. The structure learning used inside SEM,
due to computational reasons, is MMHC. Convergence of SEM can be controlled with the parameters <code>struct.threshold</code>
and <code>param.threshold</code>, for the structure and the parameter convergence, respectively.
</p>
<p>Search-and-score methods also need a scoring function to compute an estimated measure of each configuration of nodes.
We provide three of the most popular scoring functions, <code>BDeu</code> (Bayesian-Dirichlet equivalent uniform, default),
<code>AIC</code> (Akaike Information Criterion) and <code>BIC</code> (Bayesian Information Criterion). The scoring function
can be chosen using the <code>scoring.func</code> parameter.
</p>
<p>Structure learning sets the <code>dag</code> field of the <code>BN</code> under study, unless bootstrap or the <code>mmpc</code> algorithm
are employed. In these cases, given the possible presence of loops, the <code>wpdag</code> field is set.
</p>
<p>In case of missing data, the default behaviour (with no other indication from the user)
is to learn the structure using <code>mmhc</code> starting from the raw dataset.
</p>


<h3>Value</h3>

<p>new <code>BN</code> object with DAG.
</p>


<h3>See Also</h3>

<p>learn.network learn.dynamic.network
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
dataset &lt;- BNDataset("file.header", "file.data")
bn &lt;- BN(dataset)
# use MMHC
bn &lt;- learn.structure(bn, dataset, alpha=0.05, ess=1, bootstrap=FALSE)

# now use Silander-Myllymaki
layers &lt;- layering(bn)
mfl &lt;- as.matrix(read.table(header=F,
text='0 1 1 1 1 0 1 1 1 1 0 0 8 7 7 0 0 0 14 6 0 0 0 0 19'))
bn &lt;- learn.structure(bn, dataset, algo='sm', max.fanin=3, cont.nodes=c(),
                      layering=layers, max.fanin.layers=mfl, use.imputed.data=FALSE)

## End(Not run)

</code></pre>


</div>