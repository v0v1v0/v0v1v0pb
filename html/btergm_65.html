<div class="container">

<table style="width: 100%;"><tr>
<td>gof</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Goodness-of-fit diagnostics for ERGMs, TERGMs, SAOMs, and logit models</h2>

<h3>Description</h3>

<p>Assess goodness of fit of <code>btergm</code> and other network models.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gof(object, ...)

createGOF(
  simulations,
  target,
  statistics = c(dsp, esp, deg, ideg, geodesic, rocpr, walktrap.modularity),
  parallel = "no",
  ncpus = 1,
  cl = NULL,
  verbose = TRUE,
  ...
)

## S4 method for signature 'btergm'
gof(
  object,
  target = NULL,
  formula = getformula(object),
  nsim = 100,
  MCMC.interval = 1000,
  MCMC.burnin = 10000,
  parallel = c("no", "multicore", "snow"),
  ncpus = 1,
  cl = NULL,
  statistics = c(dsp, esp, deg, ideg, geodesic, rocpr, walktrap.modularity),
  verbose = TRUE,
  ...
)

## S4 method for signature 'ergm'
gof(
  object,
  target = NULL,
  formula = getformula(object),
  nsim = 100,
  MCMC.interval = 1000,
  MCMC.burnin = 10000,
  parallel = c("no", "multicore", "snow"),
  ncpus = 1,
  cl = NULL,
  statistics = c(dsp, esp, deg, ideg, geodesic, rocpr, walktrap.modularity),
  verbose = TRUE,
  ...
)

## S4 method for signature 'mtergm'
gof(
  object,
  target = NULL,
  formula = getformula(object),
  nsim = 100,
  MCMC.interval = 1000,
  MCMC.burnin = 10000,
  parallel = c("no", "multicore", "snow"),
  ncpus = 1,
  cl = NULL,
  statistics = c(dsp, esp, deg, ideg, geodesic, rocpr, walktrap.modularity),
  verbose = TRUE,
  ...
)

## S4 method for signature 'tbergm'
gof(
  object,
  target = NULL,
  formula = getformula(object),
  nsim = 100,
  MCMC.interval = 1000,
  MCMC.burnin = 10000,
  parallel = c("no", "multicore", "snow"),
  ncpus = 1,
  cl = NULL,
  statistics = c(dsp, esp, deg, ideg, geodesic, rocpr, walktrap.modularity),
  verbose = TRUE,
  ...
)

## S4 method for signature 'sienaFit'
gof(
  object,
  period = NULL,
  parallel = c("no", "multicore", "snow"),
  ncpus = 1,
  cl = NULL,
  structzero = 10,
  statistics = c(esp, deg, ideg, geodesic, rocpr, walktrap.modularity),
  groupName = object$f$groupNames[[1]],
  varName = NULL,
  outofsample = FALSE,
  sienaData = NULL,
  sienaEffects = NULL,
  nsim = NULL,
  verbose = TRUE,
  ...
)

## S4 method for signature 'network'
gof(
  object,
  covariates,
  coef,
  target = NULL,
  nsim = 100,
  mcmc = FALSE,
  MCMC.interval = 1000,
  MCMC.burnin = 10000,
  parallel = c("no", "multicore", "snow"),
  ncpus = 1,
  cl = NULL,
  statistics = c(dsp, esp, deg, ideg, geodesic, rocpr, walktrap.modularity),
  verbose = TRUE,
  ...
)

## S4 method for signature 'matrix'
gof(
  object,
  covariates,
  coef,
  target = NULL,
  nsim = 100,
  mcmc = FALSE,
  MCMC.interval = 1000,
  MCMC.burnin = 10000,
  parallel = c("no", "multicore", "snow"),
  ncpus = 1,
  cl = NULL,
  statistics = c(dsp, esp, deg, ideg, geodesic, rocpr, walktrap.modularity),
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A <code>btergm</code>, <code>ergm</code>, or <code>sienaFit</code> object (for
the <code>btergm</code>, <code>ergm</code>, and <code>sienaFit</code> methods, respectively).
Or a network object or matrix (for the <code>network</code> and <code>matrix</code>
methods, respectively).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arbitrary further arguments to be passed on to the statistics. See
also the help page for the gof-statistics.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simulations</code></td>
<td>
<p>A list of <code>network</code> objects or sparse matrices
(generated using the <span class="pkg">Matrix</span> package) representing simulated networks.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target</code></td>
<td>
<p>In the <code>gof</code> function: A network or list of networks to
which the simulations are compared. If left empty, the original networks
from the <code>btergm</code> object <code>x</code> are used as observed networks. In
the <code>createGOF</code> function: a list of sparse matrices (generated using
the <span class="pkg">Matrix</span> package) or a list of <code>network</code> objects (generated
using the <span class="pkg">network</span> package). The simulations are compared against
these target networks.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>statistics</code></td>
<td>
<p>A list of functions used for comparison of observed and
simulated networks. Note that the list should contain the actual functions,
not a character representation of them. See gof-statistics for
details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>Use multiple cores in a computer or nodes in a cluster to
speed up the simulations. The default value <code>"no"</code> means parallel
computing is switched off. If <code>"multicore"</code> is used (only available
for <code>sienaAlgorithm</code> and <code>sienaModel</code> objects), the
<code>mclapply</code> function from the <span class="pkg">parallel</span> package (formerly in the
<span class="pkg">multicore</span> package) is used for parallelization. This should run on
any kind of system except MS Windows because it is based on forking. It is
usually the fastest type of parallelization. If <code>"snow"</code> is used, the
<code>parLapply</code> function from the <span class="pkg">parallel</span> package (formerly in the
<span class="pkg">snow</span> package) is used for parallelization. This should run on any
kind of system including cluster systems and including MS Windows. It is
slightly slower than the former alternative if the same number of cores is
used. However, <code>"snow"</code> provides support for MPI clusters with a large
amount of cores, which <span class="pkg">multicore</span> does not offer (see also the
<code>cl</code> argument). Note that <code>"multicore"</code> will only work if all
cores are on the same node. For example, if there are three nodes with
eight cores each, a maximum of eight CPUs can be used. Parallel computing
is described in more detail on the help page of btergm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncpus</code></td>
<td>
<p>The number of CPU cores used for parallel GOF assessment (only
if <code>parallel</code> is activated). If the number of cores should be detected
automatically on the machine where the code is executed, one can try the
<code>detectCores()</code> function from the <span class="pkg">parallel</span> package. On some HPC
clusters, the number of available cores is saved as an environment
variable; for example, if MOAB is used, the number of available cores can
sometimes be accessed using <code>Sys.getenv("MOAB_PROCCOUNT")</code>, depending
on the implementation. Note that the maximum number of connections in a
single R session (i.e., to other cores or for opening files etc.) is 128,
so fewer than 128 cores should be used at a time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>An optional <span class="pkg">parallel</span> or <span class="pkg">snow</span> cluster for use if
<code>parallel = "snow"</code>. If not supplied, a cluster on the local machine
is created temporarily.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Print details?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>A model formula from which networks are simulated for
comparison. By default, the formula from the <code>btergm</code> object <code>x</code>
is used. It is possible to hand over a formula with only a single response
network and/or dyad or edge covariates or with lists of response networks
and/or covariates. It is also possible to use indices like
<code>networks[[4]]</code> or <code>networks[3:5]</code> inside the formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>
<p>The number of networks to be simulated at each time step.
Example: If there are six time steps in the <code>formula</code> and
<code>nsim = 100</code>, a total of 600 new networks is simulated. The
comparison between simulated and observed networks is only done within time
steps. For example, the first 100 simulations are compared with the first
observed network, simulations 101-200 with the second observed network etc.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MCMC.interval</code></td>
<td>
<p>Internally, this package uses the simulation facilities
of the <span class="pkg">ergm</span> package to create new networks against which to compare
the original network(s) for goodness-of-fit assessment. This argument sets
the MCMC interval to be passed over to the simulation command. The default
value is <code>1000</code>, which means that every 1000th simulation outcome from
the MCMC sequence is used. There is no general rule of thumb on the
selection of this parameter, but if the results look suspicious (e.g., when
the model fit is perfect), increasing this value may be helpful.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MCMC.burnin</code></td>
<td>
<p>Internally, this package uses the simulation facilities of
the <span class="pkg">ergm</span> package to create new networks against which to compare the
original network(s) for goodness-of-fit assessment. This argument sets the
MCMC burnin to be passed over to the simulation command. The default value
is <code>10000</code>. There is no general rule of thumb on the selection of this
parameter, but if the results look suspicious (e.g., when the model fit is
perfect), increasing this value may be helpful.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>period</code></td>
<td>
<p>Which transition between time periods should be used for GOF
assessment? By default, all transitions between all time periods are used.
For example, if there are three consecutive networks, this will extract
simulations from the transitions between 1 and 2 and between 2 and 3,
respectively, and these simulations will be compared to the networks at
time steps 2 and 3, respectively. The time period can be provided as a
numeric, e.g., <code>period = 4</code> for extracting the simulations between
time steps 4 and 5 (= the fourth transition) and predicting the fifth
network. Values lower than 1 or larger than the number of consecutive
networks minus 1 are therefore not permitted. This argument is only used if
out-of-sample prediction is switched off.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>structzero</code></td>
<td>
<p>Which value was used for structural zeros (usually nodes
that have dropped out of the network or have not yet joined the network) in
the dependent variable/network? These nodes are removed from the observed
network and the simulations before comparison. Usually, the value <code>10</code>
is used for structural zeros in Siena.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groupName</code></td>
<td>
<p>The group name used in the Siena model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varName</code></td>
<td>
<p>The variable name that denotes the dependent networks in the
Siena model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outofsample</code></td>
<td>
<p>Should out-of-sample prediction be attempted? If so, some
additional arguments must be provided: <code>sienaData</code>,
<code>sienaEffects</code>, and <code>nsim</code>. The <code>sienaData</code> object must
contain a base and a target network for out-of-sample prediction. The
<code>sienaEffects</code> must contain the effects to be used for the
simulations. The estimates will be taken from the estimated <code>object</code>,
and they will be injected into a new SAOM and fixed during the sampling
procedure. <code>nsim</code> determines how many simulations are used for the
out-of-sample comparison.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sienaData</code></td>
<td>
<p>An object of the class <code>siena</code>, which is usually
created using the <code>sienaDataCreate</code> function in the <span class="pkg">RSiena</span>
package. This argument is only used for out-of-sample prediction. The
object must be based on a <code>sienaDependent</code> object that contains two
networks: the base network from which to simulate forward, and the target
network which you want to predict out-of-sample. The object can contain
further objects for storing covariates etc. that are necessary for
estimating new networks. The best practice is to create an object that is
identical to the <code>siena</code> object used for estimating the model, except
that it contains the base and the target network instead of the dependent
variable/networks.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sienaEffects</code></td>
<td>
<p>An object of the class <code>sienaEffects</code>, which is
usually created using the <code>getEffects()</code> and the
<code>includeEffects()</code> functions in the <code>RSiena</code> package. The best
practice is to provide a <code>sienaEffects</code> object that is identical to
the object used to create the original model (that is, it should contain
the same effects), except that it should be based on the <code>siena</code>
object provided through the <code>sienaData</code> argument. In other words, the
<code>sienaEffects</code> object should be based on the base and target network
used for out-of-sample prediction, and it should contain the same effects
as those used for the original estimation. This argument is used only for
out-of-sample prediction.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariates</code></td>
<td>
<p>A list of matrices or network objects that serve as
covariates for the dependent network. The covariates in this list are
automatically added to the formula as <code>edgecov</code> terms.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coef</code></td>
<td>
<p>A vector of coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mcmc</code></td>
<td>
<p>Should statnet's MCMC methods be used for simulating new
networks? If <code>mcmc = FALSE</code>, new networks are simulated based on
predicted tie probabilities of the regression equation.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The generic <code>gof</code> function provides goodness-of-fit measures and
degeneracy checks for <code>btergm</code>, <code>mtergm</code>, <code>tbergm</code>,
<code>ergm</code>, <code>sienaFit</code>, and custom dyadic-independent models. The user
can provide a list of network statistics for comparing simulated networks
based on the estimated model with the observed network(s). See
<code>gof-statistics</code>. The objects created by these methods can be
displayed using various plot and print methods (see <code>gof-plot</code>).
</p>
<p>In-sample GOF assessment is the default, which means that the same time steps
are used for creating simulations and for comparison with the observed
network(s). It is possible to do out-of-sample prediction by specifying a
(list of) target network(s) using the <code>target</code> argument. If a formula is
provided, the simulations are based on the networks and covariates specified
in the formula. This is helpful in situations where complex out-of-sample
predictions have to be evaluated. A usage scenario could be to simulate from
a network at time <code>t</code> (provided through the <code>formula</code> argument) and
compare to an observed network at time <code>t + 1</code> (the <code>target</code>
argument). This can be done, for example, to assess predictive performance
between time steps of the original networks, or to check whether the model
performs well with regard to a newly measured network given the old data from
the previous time step.
</p>
<p>Predictive fit can also be assessed for stochastic actor-oriented models
(SAOM) as implemented in the <span class="pkg">RSiena</span> package. After compiling the usual
objects (model, data, effects), one of the time steps can be predicted based
on the previous time step and the SAOM using the <code>sienaFit</code> method of
the <code>gof</code> function. By default, however, within-sample fit is used for
SAOMs, just like for (T)ERGMs.
</p>
<p>The <code>gof</code> methods for networks and matrices serve to assess the goodness
of fit of a dyadic-independence model. To do this, the method requires a
vector of coefficients (one coefficient for the intercept or <code>edges</code>
term and one coefficient for each covariate), a list of covariates (in matrix
or network shape), and a dependent network or matrix. This is useful for
assessing the goodness of fit of QAP-adjusted logistic regression models (as
implemented in the <code>netlogit</code> function in the <span class="pkg">sna</span> package) or
other dyadic-independence models, such as models fitted using <code>glm</code>.
Note that this method only works with cross-sectional models and does not
accept lists of networks as input data.
</p>
<p>The <code>createGOF</code> function is used internally by the <code>gof</code> function
in order to create a <code>gof</code> object from a list of simulated networks and
a list of target networks to compare against. It can also be used directly by
the end user if the user wants to supply lists of simulated and target
networks from other sources.
</p>


<h3>References</h3>

<p>Leifeld, Philip, Skyler J. Cranmer and Bruce A. Desmarais (2018): Temporal
Exponential Random Graph Models with btergm: Estimation and Bootstrap
Confidence Intervals. <em>Journal of Statistical Software</em> 83(6): 1–36.
<a href="https://doi.org/10.18637/jss.v083.i06">doi:10.18637/jss.v083.i06</a>.
</p>
<p>Leifeld, Philip and Skyler J. Cranmer (2019): A Theoretical and Empirical
Comparison of the Temporal Exponential Random Graph Model and the Stochastic
Actor-Oriented Model. Network Science 7(1): 20–51.
<a href="https://doi.org/10.1017/nws.2018.26">doi:10.1017/nws.2018.26</a>.
</p>


</div>