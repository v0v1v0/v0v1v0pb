<div class="container">

<table style="width: 100%;"><tr>
<td>Attributes</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Set graph, vertex, and edge attributes common in MRI analyses</h2>

<h3>Description</h3>

<p><code>set_brainGraph_attr</code> is a convenience function that sets a number of
graph, vertex, and edge attributes for a given graph object. Specifically, it
calculates measures that are common in MRI analyses of brain networks.
</p>


<h3>Usage</h3>

<pre><code class="language-R">set_brainGraph_attr(g, type = c("observed", "random"),
  use.parallel = TRUE, A = NULL, xfm.type = c("1/w", "-log(w)",
  "1-w", "-log10(w/max(w))", "-log10(w/max(w)+1)"),
  clust.method = "louvain")

xfm.weights(g, xfm.type = c("1/w", "-log(w)", "1-w", "-log10(w/max(w))",
  "-log10(w/max(w)+1)"), invert = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p>A graph object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Character string indicating the type of graphs. Default:
<code>observed</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.parallel</code></td>
<td>
<p>Logical indicating whether to use <em>foreach</em>.
Default: <code>TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>Numeric matrix; the (weighted) adjacency matrix, which can be used
for faster calculation of local efficiency. Default: <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xfm.type</code></td>
<td>
<p>Character string specifying how to transform the weights.
Default: <code>1/w</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clust.method</code></td>
<td>
<p>Character string indicating which method to use for
community detection. Default: <code>'louvain'</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>invert</code></td>
<td>
<p>Logical indicating whether or not to invert the transformation.
Default: <code>FALSE</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Including <code>type='random'</code> in the function call will reduce the number of
attributes calculated. It will only add graph-level attributes for:
clustering coefficient, characteristic path length, rich club coefficient,
global efficiency, and modularity.
</p>


<h3>Value</h3>

<p>A graph object with the following attributes:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Graph-level</code></td>
<td>
<p>Density, connected component sizes, diameter, # of
triangles, transitivity, average path length, assortativity, global &amp;
local efficiency, modularity, vulnerability, hub score, rich-club
coefficient, # of hubs, edge asymmetry</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Vertex-level</code></td>
<td>
<p>Degree, strength; betweenness, eigenvector, and
leverage centralities; hubs; transitivity (local); k-core, s-core; local
&amp; nodal efficiency; color (community, lobe, component); membership
(community, lobe, component); gateway and participation coefficients,
within-module degree z-score; vulnerability; and coordinates (x, y, and
z)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Edge-level</code></td>
<td>
<p>Color (community, lobe, component), edge betweenness,
Euclidean distance (in mm), weight (if weighted)</p>
</td>
</tr>
</table>
<p><code>xfm.weights</code> returns the same graph object, with transformed
edge weights plus a graph attribute (<code>xfm.type</code>) recording the method
of transformation
</p>


<h3>Negative edge weights</h3>

<p>If there are any negative edge weights in the graph, several of the
distance-based metrics will <em>not</em> be calculated, because they can throw
errors which is undesirable when processing a large dataset. The metrics are:
local and nodal efficiency, diameter, characteristic path length, and
hubness.
</p>


<h3>Transforming edge weights</h3>

<p>For distance-based measures, it is important to transform the edge weights so
that the <em>strongest</em> connections are re-mapped to having the
<em>lowest</em> weights. Then you may calculate e.g., the <em>shortest path
length</em> which will include the strongest connections.
</p>
<p><code>xfm.type</code> allows you to choose from 5 options for transforming edge
weights when calculating distance-based metrics (e.g., shortest paths). There
is no “best-practice” for choosing one over the other, but the reciprocal is
probably most common.
</p>

<dl>
<dt><code>1/w</code></dt>
<dd>
<p>reciprocal (default)</p>
</dd>
<dt><code>-log(w)</code></dt>
<dd>
<p>the negative (natural) logarithm</p>
</dd>
<dt><code>1-w</code></dt>
<dd>
<p>subtract weights from 1</p>
</dd>
<dt><code>-log10(w/max(w))</code></dt>
<dd>
<p>negative (base-10) log of normalized
weights</p>
</dd>
<dt><code>-log10(w/max(w)+1)</code></dt>
<dd>
<p>same as above, but add 1 before taking
the log</p>
</dd>
</dl>
<p>To transform the weights back to original values, specify <code>invert=TRUE</code>.
</p>


<h3>Community detection</h3>

<p><code>clust.method</code> allows you to choose from any of the clustering
(community detection) functions available in <code>igraph</code>. These functions
begin with <code>cluster_</code>; the function argument should not include this
leading character string. There are a few possibilities, depending on the
value and the type of input graph:
</p>

<ol>
<li>
<p> By default, <code>louvain</code> is used, calling
<code>cluster_louvain</code>
</p>
</li>
<li>
<p> Uses <code>spinglass</code> if there are any negative edges and/or the
selected method is <code>spinglass</code>
</p>
</li>
<li>
<p> Uses <code>walktrap</code> if there are any negative edge weights and any
other method (besides <code>spinglass</code>) is selected
</p>
</li>
<li>
<p> Automatically transforms the edge weights if <code>edge_betweenness</code>
is selected and the graph is weighted, because the algorithm considers
edges as <em>distances</em>
</p>
</li>
</ol>
<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>See Also</h3>

<p><code>components</code>, <code>diameter</code>,
<code>centr_betw</code>, <code>betweenness</code>,
<code>centr_eigen</code>, <code>transitivity</code>,
<code>distances</code>, <code>assortativity</code>,
<code>coreness</code>, <code>communities</code>,
<code>knn</code>
</p>


</div>