<div class="container">

<table style="width: 100%;"><tr>
<td>bibit2</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The BiBit Algorithm with Noise Allowance</h2>

<h3>Description</h3>

<p>Same function as <code>bibit</code> with an additional new noise parameter which allows 0's in the discovered biclusters (See Details for more info).
</p>


<h3>Usage</h3>

<pre><code class="language-R">bibit2(matrix = NULL, minr = 2, minc = 2, noise = 0,
  arff_row_col = NULL, output_path = NULL, extend_columns = "none",
  extend_mincol = 1, extend_limitcol = 1, extend_noise = noise,
  extend_contained = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>matrix</code></td>
<td>
<p>The binary input matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minr</code></td>
<td>
<p>The minimum number of rows of the Biclusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minc</code></td>
<td>
<p>The minimum number of columns of the Biclusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noise</code></td>
<td>
<p>Noise parameter which determines the amount of zero's allowed in the bicluster (i.e. in the extra added rows to the starting row pair).
</p>

<ul>
<li> <p><code>noise=0</code>: No noise allowed. This gives the same result as using the <code>bibit</code> function. (default)
</p>
</li>
<li> <p><code>0&lt;noise&lt;1</code>: The <code>noise</code> parameter will be a noise percentage. The number of allowed 0's in a (extra) row in the bicluster will depend on the column size of the bicluster. 
More specifically <code>zeros_allowed = ceiling(noise * columnsize)</code>. For example for <code>noise=0.10</code> and a bicluster column size of <code>5</code>, the number of allowed 0's would be <code>1</code>.
</p>
</li>
<li> <p><code>noise&gt;=1</code>: The <code>noise</code> parameter will be the number of allowed 0's in a (extra) row in the bicluster independent from the column size of the bicluster. In this noise option, the noise parameter should be an integer.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arff_row_col</code></td>
<td>
<p>If you want to circumvent the internal R function to convert the matrix to <code>.arff</code> format, provide the pathname of this file here. Additionally, two <code>.csv</code> files should be provided containing 1 column of row and column names. These two files should not contain a header or quotes around the names, simply 1 column with the names.<br> 
(<em>Example</em>: <code>arff_row_col=c("...\\data\\matrix.arff","...\\data\\rownames.csv","...\\data\\colnames.csv")</code>)<br><em>Note:</em> These files can be generated with the <code>make_arff_row_col</code> function.
<br><strong>Warning:</strong> Should you use the <code>write.arff</code> function from the <code>foreign</code> package, remember to transpose the matrix first.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output_path</code></td>
<td>
<p>If as output, the original txt output of the Java code is desired, provide the outputh path here (without extension). In this case the <code>bibit</code> function will skip the transformation to a Biclust class object and simply return <code>NULL</code>.<br> 
(<em>Example</em>: <code>output_path="...\\out\\bibitresult"</code>)
<br>
(<em>Description Output</em>: The following information about every bicluster generated will be printed in the output file: number of rows, number of columns, name of rows and name of columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extend_columns</code></td>
<td>
<p><em>Column Extension Parameter</em><br> Can be one of the following: <code>"none"</code>, <code>"naive"</code>, <code>"recursive"</code> which will apply either a naive or recursive column extension procedure. (See Details Section for more information.)
<br> Based on the extension, additional biclusters will be created in the Biclust object which can be seen in the column and row names of the <code>RowxNumber</code> and <code>NumberxCol</code> slots (<code>"_Ext"</code> suffix).
<br> The <code>info</code> slot will also contain some additional information. Inside this slot, <code>BC.Extended</code> contains info on which original biclusters were extended, how many columns were added, and in how many extra extended biclusters this resulted.
<br><br><strong>Warning:</strong> Using a percentage-based <code>extend_noise</code> (or <code>noise</code> by default) in combination with the recursive procedure will result in a large amount of biclusters and increase the computation time a lot. Depending on the data when using recursive in combination with a noise percentage, it is advised to keep it reasonable small (e.g. 10%). Another remedy is to sufficiently increase the <code>extend_limitcol</code> either as a percentage or integer to limit the candidates of columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extend_mincol</code></td>
<td>
<p><em>Column Extension Parameter</em><br> A minimum number of columns that a bicluster should be able to be extended with before saving the result. (Default=1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extend_limitcol</code></td>
<td>
<p><em>Column Extension Parameter</em><br> The number (<code>extend_limitcol&gt;=1</code>) or percentage (<code>0&lt;extend_limitcol&lt;1</code>) of 1's that a column (subsetted on the BC rows) should at least contain for it to be a candidate to be added to the bicluster as an extension. (Default=1) (Increase this parameter if the recursive extension takes too long. Limiting the pool of candidates will decrease computation time, but restrict the results more.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extend_noise</code></td>
<td>
<p><em>Column Extension Parameter</em><br> The maximum allowed noise (in each row) when extending the columns of the bicluster. Can take the same as the <code>noise</code> parameter. By default this is the same value as <code>noise</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extend_contained</code></td>
<td>
<p><em>Column Extension Parameter</em><br> Logical value if extended results should be checked if they contain each other (and deleted if this is the case). Default = <code>FALSE</code>. This can be a lengthy procedure for a large amount of biclusters (&gt;1000).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A Biclust S4 Class object.
</p>


<h3>Details - General</h3>

<p><code>bibit2</code> follows the same steps as described in the Details section of <code>bibit</code>.<br>
Following the general steps of the BiBit algorithm, the allowance for noise in the biclusters is inserted in the original algorithm as such:
</p>

<ol>
<li>
<p> Binary data is encoded in bit words.
</p>
</li>
<li>
<p> Take a pair of rows as your starting point.
</p>
</li>
<li>
<p> Find the maximal overlap of 1's between these two rows and save this as a pattern/motif. You now have a bicluster of 2 rows and N columns in which N is the number of 1's in the motif.
</p>
</li>
<li>
<p> Check all remaining rows if they match this motif, <em>however</em> allow a specific amount of 0's in this matching as defined by the <code>noise</code> parameter. Those rows that match completely or those within the allowed noise range are added to bicluster.
</p>
</li>
<li>
<p> Go back to <em>Step 2</em> and repeat for all possible row pairs.
</p>
</li>
</ol>
<p><em>Note:</em> Biclusters are only saved if they satisfy the <code>minr</code> and <code>minc</code> parameter settings and if the bicluster is not already contained completely within another bicluster.<br><br>
What you will end up with are biclusters not only consisting out of 1's, but biclusters in which 2 rows (the starting pair) are all 1's and in which the other rows could contain 0's (= noise).<br><br><em>Note:</em> Because of the extra checks involved in the noise allowance, using noise might increase the computation time a little bit.
</p>


<h3>Details - Column Extension</h3>

<p>An optional procedure which can be applied <em>after</em> applying the BiBit algorithm (with noise) is called <em>Column Extension</em>. 
The procedure will add extra columns to a BiBit bicluster, keeping into account the allowed <code>extend_noise</code> level in each row.
The primary goal is to, after applying BiBit with noise, to also try and add some noise to the 2 initial 'perfect' rows.
Other parameters like <code>extend_mincol</code> and <code>extend_limitcol</code> can also further restrict which extensions should be discovered.
<br> This procedure can be done either <em>naively</em> (fast) or <em>recursively</em> (more slow and thorough) with the <code>extend_columns</code> parameter.
</p>

<dl>
<dt><code>"naive"</code></dt>
<dd>
<p>Subsetting on the bicluster rows, the column candidates are ordered based on the most 1's in a column. Afterwards, in this order, each column is sequentially checked and added when the resulted BC is still within row noise levels.
<br> This has 2 major consequences:
</p>

<ul>
<li>
<p>If 2 columns are identical, the first in the dataset is added, while the second isn't (depending on the noise level allowed per row).
</p>
</li>
<li>
<p>If 2 non-identical columns are viable to be added (correct row noise), the column with the most 1's is added. Afterwards the second column might not be viable anymore.
</p>
</li>
</ul>
<p>Note that using this method will always result in a maximum of 1 extended bicluster per original bicluster.
</p>
</dd>
<dt><code>"recursive"</code></dt>
<dd>
<p>Conditioning the group of candidates for the allowed row noise level, each possible/allowed combination of adding columns to the bicluster is checked. Only the resulted biclusters with the highest number of extra columns are saved.
Of course this could result in multiple extensions for 1 bicluster if there are multiple 'maximum added columns' results.
</p>
</dd>
</dl>
<p><em>Note:</em> These procedures are followed by a fast check if the extensions resulted in any duplicate biclusters. If so, these are deleted from the final result.
</p>


<h3>Author(s)</h3>

<p>Ewoud De Troyer
</p>


<h3>References</h3>

<p>Domingo S. Rodriguez-Baena, Antonia J. Perez-Pulido and Jesus S. Aguilar-Ruiz (2011), "A biclustering algorithm for extracting bit-patterns from binary datasets", <em>Bioinformatics</em>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
data &lt;- matrix(sample(c(0,1),100*100,replace=TRUE,prob=c(0.9,0.1)),nrow=100,ncol=100)
data[1:10,1:10] &lt;- 1 # BC1
data[11:20,11:20] &lt;- 1 # BC2
data[21:30,21:30] &lt;- 1 # BC3
data &lt;- data[sample(1:nrow(data),nrow(data)),sample(1:ncol(data),ncol(data))]

result1 &lt;- bibit2(data,minr=5,minc=5,noise=0.2)
result1
MaxBC(result1,top=1)

result2 &lt;- bibit2(data,minr=5,minc=5,noise=3)
result2
MaxBC(result2,top=2)

## End(Not run)
</code></pre>


</div>