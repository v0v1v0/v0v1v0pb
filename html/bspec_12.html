<div class="container">

<table style="width: 100%;"><tr>
<td>empiricalSpectrum</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute the "empirical" spectrum of a time series.</h2>

<h3>Description</h3>

<p>Computes the "empirical power" of a time series via a discrete Fourier
transform.
</p>


<h3>Usage</h3>

<pre><code class="language-R">empiricalSpectrum(x, two.sided=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a time series (<code>ts</code> object).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>two.sided</code></td>
<td>
<p>a <code>logical</code> flag indicating whether the output
is supposed to correspond to the <em>one-sided</em> (default) or
<em>two-sided</em> spectrum.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Performs a Fourier transform, and then derives (based on the
additional information on sampling rate etc. provided via the time
series' attributes) the spectral power as a function of frequency.
The result is simpler (in a way) than the <code>spectrum()</code>
function's output, see also the example below. What is returned is the
real-valued frequency series
</p>
<p style="text-align: center;"><code class="reqn">\kappa_j\frac{\Delta_t}{N}\bigl|\tilde{x}(f_j)\bigr|^2</code>
</p>

<p>where <code class="reqn">j=0,...,N/2+1</code>,
and <code class="reqn">f_j=\frac{j}{N \Delta_t}</code> are the
Fourier frequencies. <code class="reqn">\Delta_t</code> is the time series'
sampling interval and <code class="reqn">N</code> is its
length. <code class="reqn">\kappa_j</code> is =1 for zero and Nyquist
frequencies, and =2 otherwise, and denotes the number of (by
definition) non-zero Fourier coefficients. In case
<code>two.sided=TRUE</code>, the <code class="reqn">\kappa_j</code> prefactor is
omitted.
</p>
<p>For actual spectral estimation purposes, the use of a windowing
function (see e.g. the <code>tukeywindow()</code> function) is highly
recommended.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>frequency</code></td>
<td>
<p>the Fourier frequencies.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>power</code></td>
<td>
<p>the spectral power.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa</code></td>
<td>
<p>the number of (by definition) non-zero imaginary
components of the Fourier series.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>two.sided</code></td>
<td>
<p>a <code>logical</code> flag indicating one- or
two-sidedness.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Christian Roever, <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a></p>


<h3>References</h3>

<p>Roever, C., Meyer, R., Christensen, N.
Modelling coloured residual noise in gravitational-wave signal processing.
<em>Classical and Quantum Gravity</em>, <b>28</b>(1):015010, 2011.
doi: <a href="https://doi.org/10.1088/0264-9381/28/1/015010">10.1088/0264-9381/28/1/015010</a>.
See also <a href="https://arxiv.org/abs/0804.3853">arXiv preprint 0804.3853</a>.</p>


<h3>See Also</h3>

<p><code>fft</code>,
<code>spectrum</code>,
<code>tukeywindow</code>,
<code>welchPSD</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># load example data:
data(lh)

# compute spectrum:
spec1 &lt;- empiricalSpectrum(lh)
plot(spec1$frequency, spec1$power, log="y", type="b")

# plot "spectrum()" function's result in comparison:
spec2 &lt;- spectrum(lh, plot=FALSE)
lines(spec2$freq, spec2$spec, col="red")

# make both spectra match:
spec3 &lt;- empiricalSpectrum(lh, two.sided=TRUE)
spec4 &lt;- spectrum(lh, plot=FALSE, taper=0, fast=FALSE, detrend=FALSE)
plot(spec3$frequency, spec3$power, log="y", type="b")
lines(spec4$freq, spec4$spec, col="green")
</code></pre>


</div>