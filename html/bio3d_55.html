<div class="container">

<table style="width: 100%;"><tr>
<td>cmap</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Contact Map </h2>

<h3>Description</h3>

<p>Construct a Contact Map for Given Protein Structure(s).</p>


<h3>Usage</h3>

<pre><code class="language-R">cmap(...)

## Default S3 method:
cmap(...)

## S3 method for class 'xyz'
cmap(xyz, grpby = NULL, dcut = 4, scut = 3, pcut=1, binary=TRUE,
            mask.lower = TRUE, collapse=TRUE, gc.first=FALSE, ncore=1, nseg.scale=1, ...)

## S3 method for class 'pdb'
cmap(pdb, inds = NULL, verbose = FALSE, ...)

## S3 method for class 'pdbs'
cmap(pdbs, rm.gaps=FALSE, all.atom=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>xyz</code></td>
<td>
<p> numeric vector of xyz coordinates or a numeric matrix of
coordinates with a row per structure/frame. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grpby</code></td>
<td>
<p> a vector counting connective duplicated elements that
indicate the elements of <code>xyz</code> that should be considered as a group
(e.g. atoms from a particular residue). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dcut</code></td>
<td>
<p> a cutoff distance value below which atoms are considered
in contact. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scut</code></td>
<td>
<p> a cutoff neighbour value which has the effect of
excluding atoms that are sequentially within this value. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pcut</code></td>
<td>
<p> a cutoff probability of structures/frames showing a contact,
above which atoms are considered in contact with respect to the ensemble.
Ignored if <code>binary=FALSE</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>binary</code></td>
<td>
<p> logical, if FALSE the raw matrix containing fraction of frames that 
two residues are in contact is returned. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mask.lower</code></td>
<td>
<p> logical, if TRUE the lower matrix elements
(i.e. those below the diagonal) are returned as NA.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>collapse</code></td>
<td>
<p> logical, if FALSE an array of contact maps for all frames is returned. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gc.first</code></td>
<td>
<p> logical, if TRUE will call gc() first before calculation of 
distance matrix. This is to solve the memory overload problem when <code>ncore &gt; 1</code>
and <code>xyz</code> has many rows, with a bit sacrifice on speed. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncore </code></td>
<td>
<p> number of CPU cores used to do the calculation.
<code>ncore&gt;1</code> requires package ‘parallel’ installed. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nseg.scale </code></td>
<td>
<p> split input data into specified number of segments
prior to running multiple core calculation. See <code>fit.xyz</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pdb</code></td>
<td>
<p>  a structure object of class <code>"pdb"</code>, obtained from
<code>read.pdb</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inds</code></td>
<td>
<p> a list object of ATOM and XYZ indices as obtained from
<code>atom.select</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p> logical, if TRUE details of the selection are
printed. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pdbs</code></td>
<td>
<p> a ‘pdbs’ object as returned by <code>read.fasta.pdb</code>,
<code>read.all</code>, or <code>pdbaln</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rm.gaps</code></td>
<td>
<p> logical, if TRUE gapped positions are removed in the returned value. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all.atom</code></td>
<td>
<p> logical, if TRUE all-atom coordinates from <code>read.all</code>
are used. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> arguments passed to and from functions. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A contact map is a simplified distance matrix. See the distance matrix
function <code>dm</code> for further details.
</p>
<p>Function <code>"cmap.pdb"</code> is a wrapper for <code>"cmap.xyz"</code>
which selects all ‘notwater’ atoms and calculates the contact
matrix grouped by residue number.
</p>


<h3>Value</h3>

<p>Returns a N by N numeric matrix composed of zeros and ones, where
one indicates a contact between selected atoms.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695–2696.
</p>


<h3>See Also</h3>

 <p><code>dm</code>, <code>dccm</code>, <code>dist</code>,
<code>dist.xyz</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">
##- Read PDB file
pdb &lt;- read.pdb( system.file("examples/hivp.pdb", package="bio3d") )

## Atom Selection indices
inds &lt;- atom.select(pdb, "calpha")

## Reference contact map
ref.cont &lt;- cmap( pdb$xyz[inds$xyz], dcut=6, scut=3 )
plot.cmap(ref.cont)

## Not run: 
##- Read Traj file
trj &lt;- read.dcd( system.file("examples/hivp.dcd", package="bio3d") )
## For each frame of trajectory
sum.cont &lt;- NULL
for(i in 1:nrow(trj)) {

  ## Contact map for frame 'i'
  cont &lt;- cmap(trj[i,inds$xyz], dcut=6, scut=3)

  ## Product with reference
  prod.cont &lt;- ref.cont * cont
  sum.cont &lt;- c(sum.cont, sum(prod.cont,na.rm=TRUE))
}

plot(sum.cont, typ="l")

## End(Not run)
</code></pre>


</div>