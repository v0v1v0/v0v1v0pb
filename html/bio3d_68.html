<div class="container">

<table style="width: 100%;"><tr>
<td>community.aln</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Align communities from two or more networks</h2>

<h3>Description</h3>

<p>Find equivalent communities from two or more networks and re-assign colors
to them in a consistent way across networks. A ‘new.membership’ vector is
also generated for each network, which maps nodes to community IDs that are 
renumbered according to the community equivalency.
</p>


<h3>Usage</h3>

<pre><code class="language-R">community.aln(x, ..., aln = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x, ...</code></td>
<td>
<p>two or more objects of class <code>cna</code> (if the numbers of
nodes are different, an alignment ‘fasta’ object is required for 
the <code>aln</code> argument; See below) as obtained from function <code>cna</code>. 
Alternatively, a list of <code>cna</code> objects can be given to <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aln</code></td>
<td>
<p>alignment for comparing networks with different numbers of nodes.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function facilitates the inspection on the variance of the community
partition in a group of similar networks. The original community numbering
(and so the colors of communities in the output of <code>plot.cna</code> and 
<code>vmd.cna</code>) can be inconsistent across networks, i.e. equivalent 
communities may display different colors, impeding network comparison. 
The function calculates the dissimilarity between all communities and 
clusters communities with ‘hclust’ funciton. In each cluster, 0 or
1 community per network is included. The color attribute of communities is 
then re-assigned according to the clusters through all networks. In addition,
a ‘new.membership’ vector is generated for each network, which mapps 
nodes to new community IDs that are numbered consistently across networks.
</p>


<h3>Value</h3>

<p>Returns a list of updated <code>cna</code> objects.
</p>


<h3>See Also</h3>

<p><code>cna</code>, <code>plot.cna</code>, <code>vmd.cna</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
  # Needs MUSCLE installed - testing excluded
  if(check.utility("muscle")) {

    if (!requireNamespace("igraph", quietly = TRUE)) {
      message('Need igraph installed to run this example')
    } else {

    ## Fetch PDB files and split to chain A only PDB files
    ids &lt;- c("1tnd_A", "1tag_A")
    files &lt;- get.pdb(ids, split = TRUE, path = tempdir())
    
    ## Sequence Alignement
    pdbs &lt;- pdbaln(files, outfile = tempfile())
    
    ## Normal mode analysis on aligned data
    modes &lt;- nma(pdbs, rm.gaps=TRUE)
    
    ## Dynamic Cross Correlation Matrix
    cijs &lt;- dccm(modes)$all.dccm
 
    ## Correlation Network
    nets &lt;- cna(cijs, cutoff.cij=0.3)

    ## Align network communities
    nets.aln &lt;- community.aln(nets)

    ## plot all-residue and coarse-grained (community) networks
    pdb &lt;- pdbs2pdb(pdbs, inds=1, rm.gaps=TRUE)[[1]]
    op &lt;- par(no.readonly=TRUE)

    # before alignment
    par(mar=c(0.1, 0.1, 0.1, 0.1), mfrow=c(2,2))
    invisible( lapply(nets, function(x) 
       plot(x, layout=layout.cna(x, pdb=pdb, k=3, full=TRUE)[, 1:2], 
               full=TRUE)) )
    invisible( lapply(nets, function(x) 
       plot(x, layout=layout.cna(x, pdb=pdb, k=3)[, 1:2])) )

    # after alignment
    par(mar=c(0.1, 0.1, 0.1, 0.1), mfrow=c(2,2))
    invisible( lapply(nets.aln, function(x) 
       plot(x, layout=layout.cna(x, pdb=pdb, k=3, full=TRUE)[, 1:2], 
               full=TRUE)) )
    invisible( lapply(nets.aln, function(x) 
       plot(x, layout=layout.cna(x, pdb=pdb, k=3)[, 1:2])) )

    par(op)     

    }
  }

</code></pre>


</div>