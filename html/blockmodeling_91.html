<div class="container">

<table style="width: 100%;"><tr>
<td>sedist</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Computes distances in terms of Structural equivalence (Lorrain &amp; White, 1971)</h2>

<h3>Description</h3>

<p>The functions compute the distances in terms of Structural equivalence (Lorrain and White, 1971) between the units of a one-mode network.
Several options for treating the diagonal values are supported.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sedist(
  M,
  method = "default",
  fun = "default",
  fun.on.rows = "default",
  handle.interaction = "switch",
  use = "pairwise.complete.obs",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>A matrix representing the (usually valued) network. For now, only one-relational networks are supported. The network must be one-mode.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>The method used to compute distances - any of the methods allowed by functions dist, <code>"cor"</code> or <code>"cov"</code> (all <code>package::stats</code>) or just <code>"cor"</code> or <code>"cov"</code> (given as a character).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>Which function should be used to compute distances (given as a character).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun.on.rows</code></td>
<td>
<p>For non-standard function - does the function compute measure on rows (such as <code>"cor"</code>, <code>"cov"</code>,...) of the data matrix (as opposed to computing measure on columns (such as <code>dist</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>handle.interaction</code></td>
<td>
<p>How should the interaction between the vertices analysed be handled:<br><code>"switch"</code> (the default) - assumes that when comparing units i and j, M[i,i] should be compared with M[j,j] and M[i,j] with M[j,i]. These two comparisons are weighted by 2. This should be used with Euclidean distance to get the corrected Euclidean distance with p = 2.<br><code>"switch2"</code> - the same (alias)<br><code>"switch1"</code> - the same as above, only that the two comparisons are weighted by 1. This should be used with Euclidean distance to get the corrected Wuclidean distance with p = 1.<br><code>"ignore"</code> (diagonal) - Diagonal is ignored. This should be used with Euclidean distance to get the corrected Euclidean distance with p = 0.<br><code>"none"</code> - the matrix is used "as is"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use</code></td>
<td>
<p>For use with methods <code>"cor"</code> and <code>"cov"</code>, for other methods (the default option should be used if <code>handle.interaction == "ignore"</code>), <code>"pairwise.complete.obs"</code> are always used, if <code>stats.dist.cor.cov = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to <code>fun</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If both <code>method</code> and <code>fun</code> are <code>"default"</code>, the Euclidean distances are computed.
The <code>"default"</code> method for <code>fun = "dist"</code> is "euclidean" and for <code>fun  = "cor"</code> "pearson".
</p>


<h3>Value</h3>

<p>A matrix (usually of class dist) is returned.
</p>


<h3>Author(s)</h3>

<p>Aleš Žiberna
</p>


<h3>References</h3>

<p>Batagelj, V., Ferligoj, A., &amp; Doreian, P. (1992). Direct and indirect methods for structural equivalence. Social Networks, 14(1-2), 63-90. doi: 10.1016/0378-8733(92)90014-X
</p>
<p>Lorrain, F., &amp; White, H. C. (1971). Structural equivalence of individuals in social networks. Journal of Mathematical Sociology, 1(1), 49-80. doi: 10.1080/0022250X.1971.9989788
</p>


<h3>See Also</h3>

<p><code>dist</code>, <code>hclust</code>, <code>REGE</code>, <code>optParC</code>, <code>optParC</code>, <code>optRandomParC</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Generating a simple network corresponding to the simple Sum of squares
# Structural equivalence with blockmodel:
# null com
# null null
n &lt;- 20
net &lt;- matrix(NA, ncol = n, nrow = n)
clu &lt;- rep(1:2, times = c(5, 15))
tclu &lt;- table(clu)
net[clu == 1, clu == 1] &lt;- rnorm(n = tclu[1] * tclu[1], mean = 0, sd = 1)
net[clu == 1, clu == 2] &lt;- rnorm(n = tclu[1] * tclu[2], mean = 4, sd = 1)
net[clu == 2, clu == 1] &lt;- rnorm(n = tclu[2] * tclu[1], mean = 0, sd = 1)
net[clu == 2, clu == 2] &lt;- rnorm(n = tclu[2] * tclu[2], mean = 0, sd = 1)

D &lt;- sedist(M = net)
plot.mat(net, clu = cutree(hclust(d = D, method = "ward"), k = 2))

</code></pre>


</div>