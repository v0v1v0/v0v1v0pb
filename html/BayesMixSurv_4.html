<div class="container">

<table style="width: 100%;"><tr>
<td>bayesmixsurv.crossval</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Convenience functions for cross-validation-based selection of shrinkage parameter in the bayesmixsurv model.</h2>

<h3>Description</h3>

<p><code>bayesmixsurv.crossval</code> calculates cross-validation-based, out-of-sample log-likelihood of a bsgw model for a data set, given the supplied folds. <code>bayesmixsurv.crossval.wrapper</code> applies <code>bayesmixsurv.crossval</code> to a set of combinations of shrinkage parameters (<code>lambda1</code>,<code>lambda2</code>) and produces the resulting vector of log-likelihood values as well as the specific combination of shrinkage parameters associated with the maximum log-likelihood. <code>bayesmixsurv.generate.folds</code> generates random partitions, while <code>bayesmixsurv.generate.folds.eventbalanced</code> generates random partitions with events evenly distributed across partitions. The latter feature is useful for cross-valiation of small data sets with low event rates, since it prevents over-accumulation of events in one or two partitions, and lack of events altogether in other partitions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bayesmixsurv.generate.folds(ntot, nfold=5)
bayesmixsurv.generate.folds.eventbalanced(formula, data, nfold=5)
bayesmixsurv.crossval(data, folds, all=FALSE, print.level=1
  , control=bayesmixsurv.control(), ...)
bayesmixsurv.crossval.wrapper(data, folds, all=FALSE, print.level=1
  , control=bayesmixsurv.control(), lambda.min=0.01, lambda.max=100, nlambda=10
  , lambda1.vec=exp(seq(from=log(lambda.min), to=log(lambda.max), length.out = nlambda))
  , lambda2.vec=NULL
  , lambda12=if (is.null(lambda2.vec)) cbind(lambda1=lambda1.vec, lambda2=lambda1.vec)
    else as.matrix(expand.grid(lambda1=lambda1.vec, lambda2=lambda2.vec)), plot=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>ntot</code></td>
<td>
<p>Number of observations to create partitions for. It must typically be set to <code>nrow(data)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfold</code></td>
<td>
<p>Number of folds or partitions to generate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>Formula specifying the covariates to be used in component 1, and the time/status response variable in the survival model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Data frame containing the covariates and response, used in training and prediction.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>folds</code></td>
<td>
<p>An integer vector of length <code>nrow(data)</code>, defining fold/partition membership of each observation. For example, in 5-fold cross-validation for a data set of 200 observations, <code>folds</code> must be a 200-long vector with elements from the set <code>{1,2,3,4,5}</code>. Convenience functions <code>bayesmixsurv.generate.folds</code> and <code>bayesmixsurv.generate.folds.eventbalanced</code> can be used to generate the <code>folds</code> vector for a given survival data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all</code></td>
<td>
<p>If <code>TRUE</code>, estimation objects from each cross-validation task is collected and returned for diagnostics purposes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.level</code></td>
<td>
<p>Verbosity of progress report.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>List of control parameters, usually the output of bayesmixsurv.control.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min</code></td>
<td>
<p>Minimum value used to generate <code>lambda.vec</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.max</code></td>
<td>
<p>Maximum value used to generate <code>lambda.vec</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda</code></td>
<td>
<p>Length of <code>lambda.vec</code> vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda1.vec</code></td>
<td>
<p>Vector of shrinkage parameters to be tested for component-1 coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda2.vec</code></td>
<td>
<p>Vector of shrinkage parameters to be tested for component-2 coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda12</code></td>
<td>
<p>A data frame that enumerates all combinations of <code>lambda1</code> and <code>lambda2</code> to be tested. By default, it is constructed from forming all permutations of <code>lambda1.vec</code> and <code>lambda2.vec</code>. If <code>lambda2.vec=NULL</code>, it will only try equal values of the two parameters in each combination.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>If <code>TRUE</code>, and if the <code>lambda1</code> and <code>lambda2</code> entries in <code>lambda12</code> are identical, a plot of <code>loglike</code> as a function of either vector is produced.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to <code>bayesmixsurv</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Functions <code>bayesmixsurv.generate.folds</code> and <code>bayesmixsurv.generate.folds.eventbalanced</code> produce integer vectors of length <code>ntot</code> or <code>nrow(data)</code> respectively. The output of these functions can be directly passed to <code>bayesmixsurv.crossval</code> or <code>bayesmixsurv.crossval.wrapper</code>. Function <code>bayesmixsurv.crossval</code> returns the log-likelihood of data under the assumed bsgw model, calculated using a cross-validation scheme with the supplied <code>fold</code> parameter. If <code>all=TRUE</code>, the estimation objects for each of the <code>nfold</code> estimation jobs will be returned as the "estobjs" attribute of the returned value. Function <code>bayesmixsurv.crossval.wrapper</code> returns a list with elements <code>lambda1</code> and <code>lambda2</code>, the optimal shrinkage parameters for components 1 and 2, respectively. Additionally, the following attributes are attached:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>loglike.vec</code></td>
<td>
<p>Vector of log-likelihood values, one for each tested combination of <code>lambda1</code> and <code>lambda2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglike.opt</code></td>
<td>
<p>The maximum log-likelihood value from the <code>loglike.vec</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda12</code></td>
<td>
<p>Data frame with columns <code>lambda1</code> and <code>lambda2</code>. Each row of this data frame contains one combination of shrinkage parameters that are tested in the wrapper function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estobjs</code></td>
<td>
<p>If <code>all=TRUE</code>, a list of length <code>nrow(lambda12)</code> is returned, with each element being itself a list of <code>nfold</code> estimation objects associated with each call to the <code>bayesmixsurv</code> function. This object can be examined by the user for diagnostic purposes, e.g. by applying <code>plot</code> against each object.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Alireza S. Mahani, Mansour T.A. Sharabiani</p>


<h3>Examples</h3>

<pre><code class="language-R"># NOTE: to ensure convergence, typically more than 30 samples are needed
folds &lt;- bayesmixsurv.generate.folds.eventbalanced(Surv(futime, fustat) ~ 1, ovarian, 5)
cv &lt;- bayesmixsurv.crossval(ovarian, folds, formula1=Surv(futime, fustat) ~ ecog.ps + rx
  , control=bayesmixsurv.control(iter=30, nskip=10), print.level = 3)
cv2 &lt;- bayesmixsurv.crossval.wrapper(ovarian, folds, formula1=Surv(futime, fustat) ~ ecog.ps + rx
  , control=bayesmixsurv.control(iter=30, nskip=10)
  , lambda1.vec=exp(seq(from=log(0.1), to=log(1), length.out = 3)))
</code></pre>


</div>