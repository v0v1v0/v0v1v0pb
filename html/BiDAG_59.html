<div class="container">

<table style="width: 100%;"><tr>
<td>sampleBN</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bayesian network structure sampling from the posterior distribution</h2>

<h3>Description</h3>

<p>This function can be used for structure sampling using three different MCMC schemes. Order MCMC scheme (<code>algorithm="order"</code>) is the most computationally
efficient however it imposes a non-uniform prior in the space of DAGs. Partition MCMC (<code>algorithm="partition"</code>) is less computationally efficient and requires more iterations
to reach convergence, however it implements sampling using a uniform prior in the space of DAGs.
Due to the superexponential size of the search space as the number of nodes increases, the 
MCMC search is performed on a reduced search space. By default the search space is limited to the skeleton found through the PC algorithm by means of conditional independence tests 
(using the functions <code>skeleton</code> and <code>pc</code> from the ‘pcalg’ package [Kalisch et al, 2012]).
It is also possible to define an arbitrary search space by inputting an adjacency matrix, for example estimated by partial correlations or other network algorithms.
Also implemented is the possibility to expand the default or input search space, by allowing each node in the network to have one additional parent.  
This offers improvements in the learning and sampling of Bayesian networks. The iterative MCMC scheme (<code>algorithm="orderIter"</code>) allows for iterative expansions of the search space.
This is useful in cases when the initial search space is poor in a sense that it contains only a limited number of true positive edges. Iterative expansions of the search space
efficiently solve this issue. However this scheme requires longer runtimes due to the need of running multiple consecutive MCMC chains.  
This function is a wrapper for the three individual structure learning and sampling functions that implement each of the described algorithms; for details see <code>orderMCMC</code>,
<code>partitionMCMC</code>,<code>iterativeMCMC</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sampleBN(
  scorepar,
  algorithm = c("order", "orderIter", "partition"),
  chainout = TRUE,
  scoreout = FALSE,
  alpha = 0.05,
  moveprobs = NULL,
  iterations = NULL,
  stepsave = NULL,
  gamma = 1,
  verbose = FALSE,
  compress = TRUE,
  startspace = NULL,
  blacklist = NULL,
  scoretable = NULL,
  startpoint = NULL,
  plus1 = TRUE,
  cpdag = FALSE,
  hardlimit = 12,
  iterpar = list(posterior = 0.5, softlimit = 9, mergetype = "skeleton", accum = FALSE,
    plus1it = NULL, addspace = NULL, alphainit = NULL)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>scorepar</code></td>
<td>
<p>an object of class <code>scoreparameters</code>, containing the data and score parameters, see constructor function <code>scoreparameters</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>MCMC scheme to be used for sampling from posterior distribution; possible options are "order" (<code>orderMCMC</code>), "orderIter" (<code>iterativeMCMC</code>) or "partition" (<code>partitionMCMC</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chainout</code></td>
<td>
<p>logical, if TRUE the saved MCMC steps are returned, TRUE by default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scoreout</code></td>
<td>
<p>logical, if TRUE the search space and score tables are returned, FALSE by default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>numerical significance value in <code>{0,1}</code> for the conditional independence tests at the PC algorithm stage</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>moveprobs</code></td>
<td>
<p>a numerical vector of 4 (for "order" and "orderIter" algorithms) or 5 values (for "partition" algorithm) representing probabilities of the different moves in the space of
order and partitions accordingly. The moves are described in the corresponding algorithm specific functions <code>orderMCMC</code> and <code>partitionMCMC</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterations</code></td>
<td>
<p>integer, the number of MCMC steps, the default value is <code class="reqn">6n^{2}\log{n}</code> orderMCMC, <code class="reqn">20n^{2}\log{n}</code> for partitionMCMC and <code class="reqn">3.5n^{2}\log{n}</code> for iterativeMCMC; where n is the number of nodes in the Bayesian network</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stepsave</code></td>
<td>
<p>integer, thinning interval for the MCMC chain, indicating the number of steps between two output iterations, the default is <code>iterations/1000</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>tuning parameter which transforms the score by raising it to this power, 1 by default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical, if TRUE messages about the algorithm's progress will be printed, FALSE by default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compress</code></td>
<td>
<p>logical, if TRUE adjacency matrices representing sampled graphs will be stored as a sparse Matrix (recommended); TRUE by default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>startspace</code></td>
<td>
<p>(optional) a square sparse or ordinary matrix, of dimensions equal to the number of nodes, which defines the search space for the order MCMC in the form of an adjacency matrix. If NULL, the skeleton obtained from the PC-algorithm will be used. If <code>startspace[i,j]</code> equals to 1 (0) it means that the edge from node <code>i</code> to node <code>j</code> is included (excluded) from the search space. To include an edge in both directions, both <code>startspace[i,j]</code> and <code>startspace[j,i]</code> should be 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>blacklist</code></td>
<td>
<p>(optional) a square sparse or ordinary matrix, of dimensions equal to the number of nodes, which defines edges to exclude from the search space. If <code>blacklist[i,j]</code> equals to 1 it means that the edge from node <code>i</code> to node <code>j</code> is excluded from the search space.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scoretable</code></td>
<td>
<p>(optional) object of class <code>scorespace</code> containing list of score tables calculated for example by the last iteration of the function <code>iterativeMCMC</code>. When not NULL, parameter <code>startspace</code> is ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>startpoint</code></td>
<td>
<p>(optional) integer vector of length n (representing an order when <code>algorithm="order"</code> or <code>algorithm="orderIter"</code>) or an adjacency matrix or sparse adjacency matrix (representing a DAG when <code>algorithm="partition"</code>), which will be used as the starting point in the MCMC algorithm, the default starting point is random</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plus1</code></td>
<td>
<p>logical, if TRUE (default) the search is performed on the extended search space; only changable for orderMCMC; for other algorithms is fixed to TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cpdag</code></td>
<td>
<p>logical, if TRUE the CPDAG returned by the PC algorithm will be used as the search
space, if FALSE (default) the full undirected skeleton will be used as the search space</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hardlimit</code></td>
<td>
<p>integer, limit on the size of parent sets in the search space;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterpar</code></td>
<td>
<p>addition list of parameters for the MCMC scheme implemeting iterative expansions of the search space; for more details see <code>iterativeMCMC</code>; list(posterior = 0.5, softlimit = 9, mergetype = "skeleton", accum = FALSE, 
plus1it = NULL, addspace = NULL, alphainit = NULL)</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Depending on the value or the parameter <code>algorithm</code> returns an object of class <code>orderMCMC</code>, <code>partitionMCMC</code> or <code>iterativeMCMC</code> which contains log-score trace of sampled DAGs as well 
as adjacency matrix of the maximum scoring DAG(s), its score and the order or partition score. The output can optionally include DAGs sampled in MCMC iterations and the score tables. 
Optional output is regulated by the parameters <code>chainout</code> and <code>scoreout</code>. See <code>orderMCMC class</code>, <code>partitionMCMC class</code>, <code>iterativeMCMC class</code> for a detailed description of the classes' structures.
</p>


<h3>Note</h3>

<p>see also extractor functions <code>getDAG</code>, <code>getTrace</code>, <code>getSpace</code>, <code>getMCMCscore</code>.
</p>


<h3>Author(s)</h3>

<p>Polina Suter, Jack Kuipers, the code partly derived from the order MCMC implementation from Kuipers J, Moffa G (2017) &lt;doi:10.1080/01621459.2015.1133426&gt;
</p>


<h3>References</h3>

<p>P. Suter, J. Kuipers, G. Moffa, N.Beerenwinkel (2023) &lt;doi:10.18637/jss.v105.i09&gt;
</p>
<p>Friedman N and Koller D (2003). A Bayesian approach to structure discovery in bayesian networks. Machine Learning 50, 95-125.
</p>
<p>Kalisch M, Maechler M, Colombo D, Maathuis M and Buehlmann P (2012). Causal inference using graphical models with the R package pcalg. Journal of Statistical Software 47, 1-26.
</p>
<p>Geiger D and Heckerman D (2002). Parameter priors for directed acyclic graphical models and the characterization of several probability distributions. The Annals of Statistics 30, 1412-1440.
</p>
<p>Kuipers J, Moffa G and Heckerman D (2014). Addendum on the scoring of Gaussian acyclic graphical models. The Annals of Statistics 42, 1689-1691.
</p>
<p>Spirtes P, Glymour C and Scheines R (2000). Causation, Prediction, and Search, 2nd edition. The MIT Press.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
Asiascore &lt;- scoreparameters("bde", Asia)
iterativefit &lt;- learnBN(Asiascore, algorithm = "orderIter")
orderfit &lt;- sampleBN(Asiascore, scoretable = iterativefit)

myScore&lt;-scoreparameters("bge",Boston)
MCMCchains&lt;-list()
MCMCchains[[1]]&lt;-sampleBN(myScore,"partition")
MCMCchains[[2]]&lt;-sampleBN(myScore,"partition")
edge_posterior&lt;-lapply(MCMCchains,edgep,pdag=TRUE)
plotpcor(edge_posterior)

## End(Not run)
</code></pre>


</div>