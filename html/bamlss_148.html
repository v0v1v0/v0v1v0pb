<div class="container">

<table style="width: 100%;"><tr>
<td>residuals.bamlss</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Compute BAMLSS Residuals
</h2>

<h3>Description</h3>

<p>Function to compute quantile and response residuals.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'bamlss'
residuals(object, type = c("quantile", "response"),
  nsamps = NULL, ...)

## S3 method for class 'bamlss.residuals'
plot(x, which = c("hist-resid", "qq-resid", "wp"),
  spar = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An object of class <code>"bamlss"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>The type of residuals wanted, possible types are
<code>"quantile"</code> residuals and <code>"response"</code> residuals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsamps</code></td>
<td>
<p>If the fitted <code>bamlss</code> object contains samples of parameters,
computing residuals may take quite some time. Therefore, to get a first feeling it can
be useful to compute residuals only based on <code>nsamps</code> samples, i.e., <code>nsamps</code>
specifies the number of samples which are extracted on equidistant intervals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Object returned from function <code>residuals.bamlss()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which</code></td>
<td>
<p>Should a histogram with kernel density estimates be plotted, a qq-plot or a worm plot?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spar</code></td>
<td>
<p>Should graphical parameters be set by the plotting function?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>For function <code>residuals.bamlss()</code> arguments passed to possible
<code>$residuals()</code> functions that may be part of a <code>bamlss.family</code>. For function
<code>plot.bamlss.residuals()</code> arguments passed to function
<code>hist.default</code> and <code>qqnorm.default</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Response residuals are the raw residuals, i.e., the response data minus the fitted distributional
mean. If the <code>bamlss.family</code> object contains a function <code>$mu(par, ...)</code>, then
raw residuals are computed with <code>y - mu(par)</code> where <code>par</code> is the named list of fitted
values of distributional parameters. If <code>$mu(par, ...)</code> is missing, then the fitted values
of the first distributional parameter are used.
</p>
<p>Randomized quantile residuals are based on the cumulative distribution function of the
<code>bamlss.family</code> object, i.e., the <code>$p(y, par, ...)</code> function.
</p>


<h3>Value</h3>

<p>A vector of residuals.
</p>


<h3>References</h3>

<p>Dunn P. K., and Smyth G. K. (1996). Randomized Quantile Residuals.
<em>Journal of Computational and Graphical Statistics</em> <b>5</b>, 236–244.
</p>
<p>van Buuren S., and Fredriks M. (2001) Worm Plot: Simple Diagnostic Device for Modelling Growth
Reference Curves. <em>Statistics in Medicine</em>, <b>20</b>, 1259–1277
</p>


<h3>See Also</h3>

<p><code>bamlss</code>, <code>predict.bamlss</code>, <code>fitted.bamlss</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: ## Generate data.
d &lt;- GAMart()

## Estimate models.
b1 &lt;- bamlss(num ~ s(x1), data = d)
b2 &lt;- bamlss(num ~ s(x1) + s(x2) + s(x3), data = d)

## Extract quantile residuals.
e1 &lt;- residuals(b1, type = "quantile")
e2 &lt;- residuals(b2, type = "quantile")

## Plots.
plot(e1)
plot(e2)

## End(Not run)
</code></pre>


</div>