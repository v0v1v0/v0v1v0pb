<div class="container">

<table style="width: 100%;"><tr>
<td>betareg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Beta Regression for Rates and Proportions</h2>

<h3>Description</h3>

<p>Fit beta regression models for rates and proportions via maximum likelihood
using a parametrization with mean (depending through a link function on the
covariates) and precision parameter (called phi).
</p>


<h3>Usage</h3>

<pre><code class="language-R">betareg(formula, data, subset, na.action, weights, offset,
  link = c("logit", "probit", "cloglog", "cauchit", "log", "loglog"),
  link.phi = NULL, type = c("ML", "BC", "BR"), dist = NULL, nu = NULL,
  control = betareg.control(...), model = TRUE,
  y = TRUE, x = FALSE, ...)

betareg.fit(x, y, z = NULL, weights = NULL, offset = NULL,
  link = "logit", link.phi = "log", type = "ML", control = betareg.control(),
  dist = NULL, nu = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>symbolic description of the model, either of type <code>y ~ x</code>
(mean submodel, constant precision) or <code>y ~ x | z</code> (submodels for both
mean and precision); for details see below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data, subset, na.action</code></td>
<td>
<p>arguments controlling formula processing
via <code>model.frame</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>optional numeric vector of case weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>optional numeric vector with an a priori known component to be
included in the linear predictor for the mean. In <code>betareg.fit</code>,
<code>offset</code> may also be a list of two offsets for the mean and precision
equation, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link</code></td>
<td>
<p>character specification of the link function in
the mean model (mu). Currently, <code>"logit"</code>, <code>"probit"</code>,
<code>"cloglog"</code>, <code>"cauchit"</code>, <code>"log"</code>, <code>"loglog"</code> are supported.
Alternatively, an object of class <code>"link-glm"</code> can be supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link.phi</code></td>
<td>
<p>character specification of the link function in
the precision model (phi). Currently, <code>"identity"</code>,
<code>"log"</code>, <code>"sqrt"</code> are supported. The default is <code>"log"</code>
unless <code>formula</code> is of type <code>y ~ x</code> where the default is
<code>"identity"</code> (for backward compatibility).
Alternatively, an object of class <code>"link-glm"</code> can be supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>character specification of the type of estimator. Currently,
maximum likelihood (<code>"ML"</code>), ML with bias correction (<code>"BC"</code>),
and ML with bias reduction (<code>"BR"</code>) are supported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist</code></td>
<td>
<p>character specification of the response distribution.
Usually, this does not have to be set by the user because by default
the classical <code>"beta"</code> distribution is used when all observations
for the dependent variable are in (0, 1). In the presence of boundary
observations (0 or 1, which cannot be accomodated by <code>"beta"</code>) the
extended-support beta mixture distribution (<code>"xbetax"</code>) is used.
Additionally, <code>dist = "xbeta"</code> can be used with fixed exceedence
parameter <code>nu</code>, mostly for testing and debugging purposes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu</code></td>
<td>
<p>numeric. The fixed value of the expected exceedence parameter <code>nu</code> 
in case the extended-support beta mixture distribution is used. By default,
<code>nu</code> does not need to be specified and is estimated if needed. So
setting <code>nu</code> is mostly for profiling and debugging.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list of control arguments specified via
<code>betareg.control</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model, y, x</code></td>
<td>
<p>logicals. If <code>TRUE</code> the corresponding components
of the fit (model frame, response, model matrix) are returned.
For <code>betareg.fit</code>, <code>x</code> should be a numeric regressor matrix
and <code>y</code> should be the numeric response vector (with values in (0,1)).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>numeric matrix. Regressor matrix for the precision model, defaulting
to an intercept only.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed to <code>betareg.control</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Beta regression as suggested by Ferrari and Cribari-Neto (2004) and extended
by Simas, Barreto-Souza, and Rocha (2010) is implemented in <code>betareg</code>.
It is useful in situations where the dependent variable is continuous and restricted to
the unit interval (0, 1), e.g., resulting from rates or proportions. It is modeled to be
beta-distributed with parametrization using mean and precision parameter (called mu and
phi, respectively). The mean mu is linked, as in generalized linear models (GLMs), to the
explanatory variables through a link function and a linear predictor. Additionally, the
precision parameter phi can be linked to another (potentially overlapping) set of
regressors through a second link function, resulting in a model with variable dispersion
(see Cribari-Neto and Zeileis 2010).
Estimation is performed by default using maximum likelihood (ML) via <code>optim</code> with
analytical gradients and starting values from an auxiliary linear regression
of the transformed response. Subsequently, the <code>optim</code> result may be enhanced
by an additional Fisher scoring iteration using analytical gradients and expected information.
Alternative estimation methods are bias-corrected (BC) or bias-reduced (BR)
maximum likelihood (see Grün, Kosmidis, and Zeileis 2012). For ML and BC the Fisher
scoring is just a refinement to move the gradients even closer to zero and can be
disabled by setting <code>fsmaxit = 0</code> in the control arguments. For BR the Fisher scoring
is needed to solve the bias-adjusted estimating equations.
</p>
<p>In the beta regression as introduced by Ferrari and Cribari-Neto (2004), the mean of
the response is linked to a linear predictor described by <code>y ~ x1 + x2</code> using
a <code>link</code> function while the precision parameter phi is assumed to be
constant. Simas et al. (2009) suggest to extend this model by linking phi to an
additional set of regressors (<code>z1 + z2</code>, say): In <code>betareg</code> this can be
specified in a formula of type <code>y ~ x1 + x2 | z1 + z2</code> where the regressors
in the two parts can be overlapping. In the precision model (for phi), the link
function <code>link.phi</code> is used. The default is a <code>"log"</code> link unless no
precision model is specified. In the latter case (i.e., when the formula is of type
<code>y ~ x1 + x2</code>), the <code>"identity"</code> link is used by default for backward
compatibility.
</p>
<p>Kosmidis and Zeileis (2024) introduce a generalization of the classic beta regression
model with extended support [0, 1].
Specifically, the extended-support beta distribution (<code>"xbeta"</code>) leverages an underlying
symmetric four-parameter beta distribution with exceedence parameter nu
to obtain support [-nu, 1 + nu] that is subsequently censored to [0, 1] in order
to obtain point masses at the boundary values 0 and 1. The extended-support
beta mixture distribution (<code>"xbetax"</code>) is a continuous mixture of extended-support
beta distributions where the exceedence parameter follows an exponential distribution
with mean nu (rather than a fixed value of nu). The latter <code>"xbetax"</code>
specification is used by default in case of boundary observations at 0 and/or 1.
The <code>"xbeta"</code> specification with fixed nu is mostly for testing and
debugging purposes.
</p>
<p>A set of standard extractor functions for fitted model objects is available for
objects of class <code>"betareg"</code>, including methods to the generic functions
<code>print</code>, <code>summary</code>, <code>plot</code>, <code>coef</code>, 
<code>vcov</code>, <code>logLik</code>, <code>residuals</code>, 
<code>predict</code>, <code>terms</code>,
<code>model.frame</code>, <code>model.matrix</code>,
<code>cooks.distance</code> and <code>hatvalues</code> (see <code>influence.measures</code>),
<code>gleverage</code> (new generic), <code>estfun</code> and
<code>bread</code> (from the <span class="pkg">sandwich</span> package), and
<code>coeftest</code> (from the <span class="pkg">lmtest</span> package).
</p>
<p>See <code>predict.betareg</code>, <code>residuals.betareg</code>, <code>plot.betareg</code>,
and <code>summary.betareg</code> for more details on all methods.
</p>
<p>The main parameters of interest are the coefficients in the linear predictor of the mean
model. The additional parameters in the precision model (phi) can either
be treated as full model parameters (default) or as nuisance parameters. In the latter case
the estimation does not change, only the reported information in output from <code>print</code>,
<code>summary</code>, or <code>coef</code> (among others) will be different. See also <code>betareg.control</code>.
</p>
<p>The implemented algorithms for bias correction/reduction follow Kosmidis and Firth (2010).
Technical note: In case, either bias correction or reduction is requested,
the second derivative of the inverse link function is required for <code>link</code> and
<code>link.phi</code>. If the two links are specified by their names (as done by default
in <code>betareg</code>), then the <code>"link-glm"</code> objects are enhanced automatically
by the required additional <code>d2mu.deta</code> function. However, if a <code>"link-glm"</code>
object is supplied directly by the user, it needs to have the <code>d2mu.deta</code>
function or, for backward compatibility, <code>dmu.deta</code>.
</p>
<p>The original version of the package was written by Alexandre B. Simas and Andrea V. Rocha
(up to version 1.2). Starting from version 2.0-0 the code was rewritten by Achim Zeileis.
</p>


<h3>Value</h3>

<p><code>betareg</code> returns an object of class <code>"betareg"</code>, i.e., a list with components as follows.
For classic beta regressions (<code>dist = "beta"</code>) several elements are lists with the names <code>"mean"</code>
and <code>"precision"</code> for the information from the respective submodels. For extended-support
beta regressions (<code>dist = "xbetax"</code> or <code>"xbeta"</code>), the corresponding names are
<code>"mu"</code> and <code>"phi"</code> because they are not exactly the mean and precision due to the
censoring in the response variable.
</p>
<p><code>betareg.fit</code> returns an unclassed list with components up to <code>converged</code>.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>a list with elements <code>"mean"</code> (or <code>"mu"</code>) and <code>"precision"</code> (or <code>"phi"</code>)
containing the coefficients from the respective submodels and for extended-support beta regressions
an additional element <code>"nu"</code>,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>a vector of raw residuals (observed - fitted),</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.values</code></td>
<td>
<p>a vector of fitted means,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim</code></td>
<td>
<p>output from the <code>optim</code> call for maximizing the log-likelihood(s),</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>the method argument passed to the <code>optim</code> call,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>the control arguments passed to the <code>optim</code> call,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>the starting values for the parameters passed to the <code>optim</code> call,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>the weights used (if any),</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>a list of offset vectors used (if any),</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of observations,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs</code></td>
<td>
<p>number of observations with non-zero weights,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df.null</code></td>
<td>
<p>residual degrees of freedom in the null model (constant mean and dispersion),
i.e., <code>n - 2</code>,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df.residual</code></td>
<td>
<p>residual degrees of freedom in the fitted model,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi</code></td>
<td>
<p>logical indicating whether the precision (phi) coefficients will be
treated as full model parameters or nuisance parameters in subsequent calls to
<code>print</code>, <code>summary</code>, <code>coef</code> etc.,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglik</code></td>
<td>
<p>log-likelihood of the fitted model,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov</code></td>
<td>
<p>covariance matrix of all parameters in the model,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pseudo.r.squared</code></td>
<td>
<p>pseudo R-squared value (squared correlation of linear predictor
and link-transformed response),</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link</code></td>
<td>
<p>a list with elements <code>"mean"</code> (or <code>"mu"</code>) and <code>"precision"</code> (or <code>"phi"</code>)
containing the link objects for the respective submodels,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>converged</code></td>
<td>
<p>logical indicating successful convergence of <code>optim</code>,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the original function call,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>the original formula,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terms</code></td>
<td>
<p>a list with elements <code>"mean"</code> (or <code>"mu"</code>), <code>"precision"</code> (or <code>"phi"</code>) and
<code>"full"</code> containing the terms objects for the respective models,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>levels</code></td>
<td>
<p>a list with elements <code>"mean"</code> (or <code>"mu"</code>), <code>"precision"</code> (or <code>"phi"</code>) and
<code>"full"</code> containing the levels of the categorical regressors,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts</code></td>
<td>
<p>a list with elements <code>"mean"</code> (or <code>"mu"</code>) and <code>"precision"</code> (or <code>"phi"</code>)
containing the contrasts corresponding to <code>levels</code> from the
respective models,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>the full model frame (if <code>model = TRUE</code>),</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>the response proportion vector (if <code>y = TRUE</code>),</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a list with elements <code>"mean"</code> (or <code>"mu"</code>) and <code>"precision"</code> (or <code>"phi"</code>)
containing the model matrices from the respective models
(if <code>x = TRUE</code>).</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Cribari-Neto F, Zeileis A (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1–24.
<a href="https://doi.org/10.18637/jss.v034.i02">doi:10.18637/jss.v034.i02</a>
</p>
<p>Ferrari SLP, Cribari-Neto F (2004).
Beta Regression for Modeling Rates and Proportions.
<em>Journal of Applied Statistics</em>, <b>31</b>(7), 799–815.
</p>
<p>Grün B, Kosmidis I, Zeileis A (2012).
Extended Beta Regression in R: Shaken, Stirred, Mixed, and Partitioned.
<em>Journal of Statistical Software</em>, <b>48</b>(11), 1–25.
<a href="https://doi.org/10.18637/jss.v048.i11">doi:10.18637/jss.v048.i11</a>
</p>
<p>Kosmidis I, Firth D (2010).
A Generic Algorithm for Reducing Bias in Parametric Estimation.
<em>Electronic Journal of Statistics</em>, <b>4</b>, 1097–1112.
</p>
<p>Kosmidis I, Zeileis A (2024).
Extended-Support Beta Regression for [0, 1] Responses.
2409.07233, <em>arXiv.org E-Print Archive</em>.
<a href="https://doi.org/10.48550/arXiv.2409.07233">doi:10.48550/arXiv.2409.07233</a>
</p>
<p>Simas AB, Barreto-Souza W, Rocha AV (2010).
Improved Estimators for a General Class of Beta Regression Models.
<em>Computational Statistics &amp; Data Analysis</em>, <b>54</b>(2), 348–366.
</p>


<h3>See Also</h3>

<p><code>summary.betareg</code>, <code>predict.betareg</code>, <code>residuals.betareg</code>,
<code>Formula</code></p>


<h3>Examples</h3>

<pre><code class="language-R">options(digits = 4)

## Section 4 from Ferrari and Cribari-Neto (2004)
data("GasolineYield", package = "betareg")
data("FoodExpenditure", package = "betareg")

## Table 1
gy &lt;- betareg(yield ~ batch + temp, data = GasolineYield)
summary(gy)

## Table 2
fe_lin &lt;- lm(I(food/income) ~ income + persons, data = FoodExpenditure)
library("lmtest")
bptest(fe_lin)
fe_beta &lt;- betareg(I(food/income) ~ income + persons, data = FoodExpenditure)
summary(fe_beta)

## nested model comparisons via Wald and LR tests
fe_beta2 &lt;- betareg(I(food/income) ~ income, data = FoodExpenditure)
lrtest(fe_beta, fe_beta2)
waldtest(fe_beta, fe_beta2)


## Section 3 from online supplements to Simas et al. (2010)
## mean model as in gy above
## precision model with regressor temp
gy2 &lt;- betareg(yield ~ batch + temp | temp, data = GasolineYield)

## MLE column in Table 19
summary(gy2)

## LRT row in Table 18
lrtest(gy, gy2)
</code></pre>


</div>