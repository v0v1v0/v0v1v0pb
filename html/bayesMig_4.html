<div class="container">

<table style="width: 100%;"><tr>
<td>run.mig.mcmc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Run Markov chain Monte Carlo for parameters of net migration rate model</h2>

<h3>Description</h3>

<p>Runs MCMCs for simulating the net migration rate of all countries of the
world or for locations specified by users, using the Bayesian hierarchical model of Azose &amp; Raftery (2015).
</p>


<h3>Usage</h3>

<pre><code class="language-R">run.mig.mcmc(
  output.dir,
  nr.chains = 3,
  iter = 50000,
  thin = 1,
  replace.output = FALSE,
  annual = FALSE,
  start.year = 1950,
  present.year = 2020,
  wpp.year = 2019,
  my.mig.file = NULL,
  sigma.c.min = 1e-04,
  a.ini = NULL,
  a.half.width = NULL,
  mu.ini = NULL,
  exclude.from.world = NULL,
  pop.denom = 1,
  seed = NULL,
  parallel = FALSE,
  nr.nodes = nr.chains,
  buffer.size = 1000,
  verbose = TRUE,
  verbose.iter = 10,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>output.dir</code></td>
<td>
<p>A file path pointing to the directory in which to store results.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nr.chains</code></td>
<td>
<p>An integer number of independent Markov chains to run.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>The number of iterations to run per Markov chain.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>Thinning interval. A chain with 1000 iterations thinned by 20 will return a 
final count of 50 iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>replace.output</code></td>
<td>
<p>If the specified output directory already exists, should it be overwritten?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>annual</code></td>
<td>
<p>If <code>TRUE</code>, the model assumes the underlying data is on annual time scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start.year</code></td>
<td>
<p>Start year for using historical data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>present.year</code></td>
<td>
<p>End year for using historical data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wpp.year</code></td>
<td>
<p>Year for which WPP data is used if no user data is provided via <code>my.mig.file</code>. 
In such a case, the function loads a package called <span class="pkg">wpp</span><code class="reqn">x</code> where <code class="reqn">x</code> is the <code>wpp.year</code> and generates 
historical migration rates using the 
<code>migration</code> and <code>pop</code> datasets.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>my.mig.file</code></td>
<td>
<p>File name containing user-specified historical time series of migration rates 
for all locations that should be included in the simulation. It should be a tab-separated file.
For structure, see Details below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma.c.min, a.ini, mu.ini</code></td>
<td>
<p>Settings for the parameters
of the model (see Azose &amp; Raftery 2015), such as minimum value and initial values.
Initial values (*.ini) can be given as a vector of length <code>nr.chains</code>, giving one initial value per chain.
By default the initial values are equidistantly spread between their respective ranges.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a.half.width</code></td>
<td>
<p>Half width for Metropolis proposals of the a parameter. This argument can greatly influence 
the convergence and it is dependent on the scale of the data. By default it is set to 0.01 for 5-year data 
defined as rate per population; to 0.03 for 5-year data defined as per 1000; to 0.3 for 
annual data per population; to 0.5 for annual data per 1000. If the default does not 
yield satisfactory results, use the function <code>estimate.a.hw</code> to estimate 
an appropriate value, based on an existing simulation. Also it is important to set the <code>pop.denom</code>
argument correctly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude.from.world</code></td>
<td>
<p>Vector of location codes that should be excluded from estimating the hyperparameters. 
These would be for example small locations or locations with unusual patters. 
Note that location-specific parameters are generated for all locations, regardless of this setting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pop.denom</code></td>
<td>
<p>Denominator used to generate the input migration rates. It is used to derive an appropriate scaler 
for the priors and conditional distributions. Typically, this will be either 1 (default) if the rates are 
defined as per population, or 1000, if the rates are per 1000 population. 
Use this argument only if user-specified rates are supplied via the <code>my.mig.file</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Seed of the random number generator. If <code>NULL</code> no seed is set. It can be used to generate reproducible results.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>Whether to run code in parallel.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nr.nodes</code></td>
<td>
<p>Relevant only if <code>parallel</code> is <code>TRUE</code>. It gives the number of nodes for running the simulation in parallel. 
By default it equals to the number of chains.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>buffer.size</code></td>
<td>
<p>Buffer size (in number of iterations) for keeping data in the memory before flushing to disk.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Whether or not to print status updates to console window while the code is running.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose.iter</code></td>
<td>
<p>If verbose is TRUE, the number of iterations to wait between printing updates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional parameters to be passed to the function <code>performParallel</code>, if <code>parallel</code> is <code>TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function creates an object of class <code>bayesMig.mcmc.meta</code> and 
stores it in <code>output.dir</code>. It launches <code>nr.chains</code> MCMCs, either sequentially or 
in parallel. Parameter traces of each chain are stored as ASCII files in a subdirectory 
of <code>output.dir</code>, called <code>mc</code><em>x</em> where <em>x</em> is the identifier of that chain. 
There is one file per parameter, named after the parameter with the suffix “.txt”.
Location-specific parameters have the suffix <code>_country</code><em>c</em> where <em>c</em> is the location code.
In addition to the trace files, each <code>mc</code><em>x</em> directory contains the object 
<code>bayesMig.mcmc</code> in binary format.  
All chain-specific files  are written onto disk after the first, last and each 
<code class="reqn">i</code>-th (thinned) iteration, where <code class="reqn">i</code> is given by the argument <code>buffer.size</code>.
</p>
<p>By default (if no data is passed via the <code>my.mig.file</code> argument), the function 
loads observed data (further denoted as WPP dataset), from the <code>migration</code> 
and <code>pop</code> datasets in the <span class="pkg">wpp</span><code class="reqn">x</code> package where <code class="reqn">x</code> is 
the <code>wpp.year</code>. Net migration rates are computed as migration(<code class="reqn">t</code>) / (population(<code class="reqn">t_e</code>) - migration(<code class="reqn">t</code>)) 
where <code class="reqn">t_e</code> means the end of time period <code class="reqn">t</code>. For an annual simulation and 
<code>wpp.year</code> set to 2022, <code class="reqn">t = t_e</code> because the population in year <code class="reqn">t</code> 
is considered at the end of the year. If <code>wpp.year</code> is smaller than 2022 and <code>annual</code> is <code>TRUE</code>
the default dataset is interpolated from 5-year data.
</p>
<p>The argument <code>my.mig.file</code> can be used to overwrite the default data. It should be a tab-separated file.
If it is used, it should contain net migration rates for all locations to be used in the simulation, as no WPP data is used 
in such a case. The structure of the file has the same format as the <code>migration</code> dataset,
but the values should be rates (instead of counts). Use the argument <code>pop.denom</code> to define the scale of the 
denominator in these rates, i.e. if the rates are to be interpreted as per population (default) or some other scale. 
Each row in the <code>my.mig.file</code> file corresponds to a location. It does not have 
to be necessarily a country - it can be for example a subnational unit. It must contain columns 
“country_code” or “code” (unique identifier of the location), “name”, and columns representing 
5-year time intervals (if <code>annual</code> is <code>FALSE</code>), e.g., “1995-2000”, “2000-2005” etc., or single years
(if <code>annual</code> is <code>TRUE</code>). An example dataset of annual net migration rates for US states is included in the package, 
see example below. 
</p>
<p>Optionally, the <code>my.mig.file</code> can contain columns called “first.observed” and/or “last.observed”, containing 
for each location the year of the first and last observation, respectively. In such a case, any data 
before and after those time points will be ignored. Furthermore, the function <code>mig.predict</code> fills in the missing values 
after the last observation, using the median of the BHM procedure.
</p>
<p>If there are countries or locations that should be excluded from influencing the hyperparameters,
for example small countries or locations with unique migration patterns, their codes 
should be included in the argument <code>exclude.from.world</code>. These locations will still get 
their parameters simulated and thus, will be included in a projection. Alternatively 
if <code>my.mig.file</code> is used, these locations can be determined using an additional column, called 
“include_code”. Value 2 means the location is included in the BHM; value 1 means it's 
excluded but location-specific parameters are generated; value 0 means the location is ignored.
</p>


<h3>Value</h3>

<p>An object of class <code>bayesMig.mcmc.set</code> which is a list with two components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>meta</code></td>
<td>
<p>An object of class <code>bayesMig.mcmc.meta</code>. It contains information that is common to all chains.
Most items are the same as in <code>bayesTFR.mcmc.meta</code>. In addition, <code>mig.rates</code>
is a matrix of the observed migration rates with <code>NA</code>s in spots that were not used 
for estimation. <code>mig.rates.all</code> is a similar matrix but contains all data, regardless
if used for estimation or not. Item <code>user.data</code> is a logical indicating 
if the migration rates are given by the user (<code>TRUE</code>) or are taken from a <span class="pkg">wpp</span> package
(<code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mcmc.list</code></td>
<td>
<p>A list of objects of class <code>bayesMig.mcmc</code>, one for each MCMC. 
Information stored here is specific to each MCMC chain, similarly to <code>bayesTFR.mcmc</code>.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Azose, J. J., &amp; Raftery, A. E. (2015). 
Bayesian probabilistic projection of international migration. Demography, 52(5), 1627-1650.
</p>


<h3>See Also</h3>

<p><code>get.mig.mcmc</code>, <code>summary.bayesMig.mcmc.set</code>, <code>mig.partraces.plot</code>,
<code>mig.pardensity.plot</code>, <code>mig.predict</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Toy simulation for US states
us.mig.file &lt;- file.path(find.package("bayesMig"), "extdata", "USmigrates.txt")
sim.dir &lt;- tempfile()
m &lt;- run.mig.mcmc(nr.chains = 3, iter = 100, thin = 1, my.mig.file = us.mig.file, 
        annual = TRUE, output.dir = sim.dir)
summary(m)
summary(m, "Washington")

mig.partraces.plot(m)
mig.partraces.cs.plot("California", m)

# later one can access the object from disk
m &lt;- get.mig.mcmc(sim.dir)
 
unlink(sim.dir, recursive = TRUE)
# For a country-level simulation, see example in ?bayesMig. 

</code></pre>


</div>