<div class="container">

<table style="width: 100%;"><tr>
<td>TDAbiplot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Construct PCA biplots with translated calibrated density axes</h2>

<h3>Description</h3>

<p>Construct various rank-2 PCA biplots with translated axes based on a combination of the first three principal components.
</p>


<h3>Usage</h3>

<pre><code class="language-R">TDAbiplot(
  x,
  dist = NULL,
  inflate = 1,
  alpha = 0.95,
  alpha_Elip = NULL,
  swop = FALSE,
  density.args = NULL,
  color = NULL,
  symbol = "circle"
)

## S3 method for class 'bipl5'
TDAbiplot(
  x,
  dist = NULL,
  inflate = 1,
  alpha = 0.95,
  alpha_Elip = NULL,
  swop = FALSE,
  density.args = NULL,
  color = NULL,
  symbol = "circle"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An object of class <code>bipl5</code>. See <code>PCAbiplot</code> in this regard.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist</code></td>
<td>
<p>Minimum distance between each axis. Default is roughly 12.5% of the plot diameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inflate</code></td>
<td>
<p>Density inflation factor</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Argument passes to <code>alpha_Elip</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha_Elip</code></td>
<td>
<p>A function taking two arguments, Z and alpha. The output of the function should
be a two-column matrix of coordinates which will be used to construct an alpha-ellipse. See details below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>swop</code></td>
<td>
<p>Swop the direction which to which each axis is translated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>density.args</code></td>
<td>
<p>Arguments to be passed to the density function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>color</code></td>
<td>
<p>Colors to be utilized per class group</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>symbol</code></td>
<td>
<p>Plotting symbol to be used per class group</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function produces a PCA biplot with translated calibrated axes. The function
constructs this biplot in the <code>plot_ly</code> graphing library with reactivity
embedded on the display. The following features are available on the display:
</p>

<ul>
<li>
<p> A dropdown menu to change the principal components used to construct the display. Currently only the first three pairwise are supported.
</p>
</li>
<li>
<p> A button to give fit statistics of the biplot. Once clicked, a table is added to give the adequacy and predictivity of each axis for the display.
</p>
</li>
<li>
<p> A button that inserts a graph depicting the cumulative predictivity of each axis against the dimension of the biplot.
</p>
</li>
<li>
<p> Prediction lines are inserted onto the display if an observation is clicked. The prediction lines can be removed by clicking on the legend entry.
</p>
</li>
</ul>
<p>The <code>alpha_Elip</code> argument is used to subset the biplot plotting coordinates (Z) to remove the effect of outliers in the data.
A common suggestion is to use an alphabag or on Convex hull peeling algorithm to strip away extreme points. The alpha-ellipse
will be constructed around this data, and will impact the lengths of the calibrated axes.
</p>


<h3>Value</h3>

<p>A named list of class <code>bipl5</code>, see <code>PCAbiplot</code>, with the following attributes:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A data frame which is the original input data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z</code></td>
<td>
<p>A matrix of n x 2 representing the coordinates of each observation on the biplot</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rank</code></td>
<td>
<p>The rank of the approximated data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>Whether the data is standardized prior to performing dimension reduction</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>The grouping vector of the data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>The vector of column means of the input data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stddev</code></td>
<td>
<p>Vector of column standard deviations if the scale parameter is set to TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PCA</code></td>
<td>
<p>The singular value decomposition of the covariance/correlation matrix, see <code>svd</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>The plotly graph displaying the biplot, see <code>plot_ly</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Adequacy</code></td>
<td>
<p>The adequacy of each axis displayed for each set of principal components</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Predictivity</code></td>
<td>
<p>The predictivity of each axis displayed for each set of principal components</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p>PCAbiplot FMbiplot
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Simple illustration of a calibrated density axis biplot
x&lt;-PCAbiplot(iris[,-5],group=iris[,5])
TDAbiplot(x,dist=1,inflate=1)

## Change the plotting characters of class-groups:
y&lt;- x |&gt; TDAbiplot(dist=1,inflate=1,symbol=c("circle","diamond","square"))

## Custom kernel densities can be drawn on the axes:
density.args&lt;-list()
density.args$kernel &lt;- "optcosine"
density.args$bw &lt;- "sj"

y&lt;- x |&gt; TDAbiplot(dist=1,inflate=1,density.args=density.args)

## To lessen the effects of outliers, a smaller alpha-ellipse can be
## used to determine axis lengths. Define a function that strips away
## outliers, for example a convex hull peeling algorithm:

HullPeeling &lt;- function(x,alpha) {
  n&lt;-nrow(x)
  propinside&lt;-1
  target&lt;-1-alpha
  x2&lt;-x
  while (propinside&gt;target) {
    hull&lt;-grDevices::chull(x2)
    x2old&lt;-x2
    x2&lt;-x2[-hull,]
    propinside&lt;-nrow(x2)/n
  }
    return(x2[grDevices::chull(x2),])
}

y&lt;- x |&gt; TDAbiplot(dist=1,inflate=1, alpha_Elip=HullPeeling, alpha=0.4)
</code></pre>


</div>