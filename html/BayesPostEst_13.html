<div class="container">

<table style="width: 100%;"><tr>
<td>mcmcCoefPlot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Coefficient Plots for MCMC Output</h2>

<h3>Description</h3>

<p>Coefficient plots for MCMC output using <code>ggplot2</code>
</p>


<h3>Usage</h3>

<pre><code class="language-R">mcmcCoefPlot(
  mod,
  pars = NULL,
  pointest = "mean",
  ci = 0.95,
  hpdi = FALSE,
  sort = FALSE,
  plot = TRUE,
  regex = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mod</code></td>
<td>
<p>Bayesian model object generated by R2jags, rjags, R2WinBUGS, R2OpenBUGS, 
MCMCpack, rstan, rstanarm, and brms.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pars</code></td>
<td>
<p>a scalar or vector of the parameters you wish to include in the table.
By default, <code>mcmcCoefPlot</code> includes all parameters saved in a model object. If a
model has lots of samples and lots of saved parameters, not explicitly specifying
a limited number of parameters to include via <code>pars</code> may take a long time
or produce an unreadable plot. <code>pars</code> can either be a vector with the
specific parameters to be included in the table e.g. <code>pars = c("beta[1]",
"beta[2]", "beta[3]")</code>, or they can be partial names that will be matched using
regular expressions e.g. <code>pars = "beta"</code> if <code>regex = TRUE</code>. Both of
these will include <code>beta[1]</code>, <code>beta[2]</code>, and <code>beta[3]</code> in the
plot. If <code>pars</code> is left blank, <code>mcmcCoefPlot</code> will exclude auxiliary
parameters such as <code>deviance</code> from JAGS or <code>lp__</code> from Stan.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pointest</code></td>
<td>
<p>a character indicating whether to use the mean or median for
point estimates in the table.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci</code></td>
<td>
<p>a scalar indicating the confidence level of the uncertainty intervals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hpdi</code></td>
<td>
<p>a logical indicating whether to use highest posterior density intervals
or equal tailed credible intervals to capture uncertainty; default <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sort</code></td>
<td>
<p>logical indicating whether to sort the point estimates to produce
a caterpillar or dot plot; default <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>logical indicating whether to return a <code>ggplot</code> object or the
underlying tidy DataFrame; default <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regex</code></td>
<td>
<p>use regular expression matching with <code>pars</code>?</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a <code>ggplot</code> object or a tidy DataFrame.
</p>


<h3>Author(s)</h3>

<p>Rob Williams, <a href="mailto:jayrobwilliams@gmail.com">jayrobwilliams@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">

if (interactive()) {
## simulating data
set.seed(123456)
b0 &lt;- 0.2 # true value for the intercept
b1 &lt;- 0.5 # true value for first beta
b2 &lt;- 0.7 # true value for second beta
n &lt;- 500 # sample size
X1 &lt;- runif(n, -1, 1)
X2 &lt;- runif(n, -1, 1)
Z &lt;- b0 + b1 * X1 + b2 * X2
pr &lt;- 1 / (1 + exp(-Z)) # inv logit function
Y &lt;- rbinom(n, 1, pr)
df &lt;- data.frame(cbind(X1, X2, Y))

## formatting the data for jags
datjags &lt;- as.list(df)
datjags$N &lt;- length(datjags$Y)

## creating jags model
model &lt;- function()  {
  
  for(i in 1:N){
    Y[i] ~ dbern(p[i])  ## Bernoulli distribution of y_i
    logit(p[i]) &lt;- mu[i]    ## Logit link function
    mu[i] &lt;- b[1] +
      b[2] * X1[i] +
      b[3] * X2[i]
  }
  
  for(j in 1:3){
    b[j] ~ dnorm(0, 0.001) ## Use a coefficient vector for simplicity
  }
}

params &lt;- c("b")
inits1 &lt;- list("b" = rep(0, 3))
inits2 &lt;- list("b" = rep(0, 3))
inits &lt;- list(inits1, inits2)

## fitting the model with R2jags
set.seed(123)
fit &lt;- R2jags::jags(data = datjags, inits = inits,
                    parameters.to.save = params, n.chains = 2, n.iter = 2000,
                    n.burnin = 1000, model.file = model)

## generating coefficient plot with all non-auxiliary parameters
mcmcCoefPlot(fit)
}



</code></pre>


</div>