<div class="container">

<table style="width: 100%;"><tr>
<td>dea.dual</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Dual DEA models and assurance regions </h2>

<h3>Description</h3>

<p> Solution of dual DEA models, possibly with partial value
information given as restrictions on the ratios (assurance regions) </p>


<h3>Usage</h3>

<pre><code class="language-R">dea.dual(X, Y, RTS = "vrs", ORIENTATION = "in", 
         XREF = NULL, YREF = NULL, 
         FRONT.IDX = NULL, DUAL = NULL, DIRECT=NULL,
         TRANSPOSE = FALSE, LP = FALSE, CONTROL=NULL, LPK=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Inputs of firms to be evaluated, a K x m matrix of
observations of K firms with m inputs (firm x input).  In case
<code>TRANSPOSE=TRUE</code> the input matrix is transposed to input x
firm. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>Outputs of firms to be evaluated, a K x n matrix of
observations of K firms with n outputs (firm x input).  In case
<code>TRANSPOSE=TRUE</code> the output matrix is transposed to output x
firm. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RTS</code></td>
<td>
<p> A text string or a number defining the underlying DEA
technology / returns to scale assumption.
</p>

<table>
<tr>
<td style="text-align: right;">

1 </td>
<td style="text-align: left;"> vrs </td>
<td style="text-align: left;"> Variable returns to scale, convexity and free disposability </td>
</tr>
<tr>
<td style="text-align: right;">
2 </td>
<td style="text-align: left;"> drs </td>
<td style="text-align: left;"> Decreasing returns to scale, convexity, down-scaling and free disposability </td>
</tr>
<tr>
<td style="text-align: right;">
3 </td>
<td style="text-align: left;"> crs </td>
<td style="text-align: left;"> Constant returns to scale, convexity and free disposability </td>
</tr>
<tr>
<td style="text-align: right;">
4 </td>
<td style="text-align: left;"> irs </td>
<td style="text-align: left;"> Increasing returns to scale, (up-scaling, but not down-scaling), convexity and free disposability.
</td>
</tr>
</table>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ORIENTATION</code></td>
<td>
<p>Input efficiency "in" (1), output efficiency "out"
(2), and graph efficiency "graph" (3) (not yet implemented). For
use with <code>DIRECT</code> an additional option is "in-out" (0). In
this case, "graph" is not feasible</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>XREF</code></td>
<td>
<p>Input of the firms determining the technology, defaults to
<code>X</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>YREF</code></td>
<td>
<p>Output of the firms determining the technology, defaults
to <code>Y</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FRONT.IDX</code></td>
<td>
<p>Index for firms determining the technology</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DUAL</code></td>
<td>

<p>Matrix of order “number of inputs plus number of outputs minus
2” times 2.  The first column is the lower bound and the second column is
the upper bound for the restrictions on the multiplier ratios. The ratios are relative to the first input and the first
output, respectively. This implies that there is no restriction for neither the first
input nor the first output so that the number of restrictions is two less
than the total number of inputs and outputs.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DIRECT</code></td>
<td>
<p>Directional efficiency, <code>DIRECT</code> is either a
scalar, an array, or a matrix with non-negative elements.
</p>
<p>NB <em>Not yet implemented</em></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>TRANSPOSE</code></td>
<td>
<p>Input and output matrices are treated as firms
times goods for the default value <code>TRANSPOSE=FALSE</code>
corresponding to the standard in R for statistical models.  When
<code>TRUE</code> data matrices shall be transposed to good times firms
matrices as is normally used in LP formulation of the problem.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LP</code></td>
<td>
<p>Only for debugging. If <code>LP=TRUE</code> then input and
output for the LP program are written to standard output for
each unit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CONTROL</code></td>
<td>
<p>Possible controls to lpSolveAPI, see the documentation
for that package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LPK</code></td>
<td>
<p>When <code>LPK=k</code> then a mps file is written for firm
<code>k</code>; it can be used as input to an alternative LP solver just
to check the our results.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p> Solved as an LP program using the package lpSolveAPI. The
method <code>dea.dual.dea</code> calls the method <code>dea</code> with the option
<code>DUAL=TRUE</code>.  </p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>eff</code></td>
<td>
<p> The efficiencies </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>objval</code></td>
<td>
<p> The objective value as returned from the LP problem, normally the same as eff </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RTS</code></td>
<td>
<p>The return to scale assumption as in the option <code>RTS</code>
in the call</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ORIENTATION</code></td>
<td>
<p> The efficiency orientation as in the call </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>TRANSPOSE</code></td>
<td>
<p> As in the call </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p>Dual values, prices, for inputs </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>Dual values, prices, for outputs </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p> The values of gamma, the shadow price(s) for returns to
scale restriction </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sol</code></td>
<td>
<p>Solution of all variables as one component, sol=c(u,v,gamma).</p>
</td>
</tr>
</table>
<h3>Note</h3>

 
<p>Note that the dual values are not unique for extreme points in the
technology set. In this case the value of the calculated dual variable can
depend on the order of the complete efficient firms.
</p>
<p>If a numerical problem occurs, status=5, or if no solution can be found,
the best solution is often to scale the input <code>X</code> and output
<code>Y</code> yourself or use the option <code>CONTROL</code> to change scaling in
the program itself, as described in the notes for <code>dea</code>.
</p>


<h3>Author(s)</h3>

<p> Peter Bogetoft and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a></p>


<h3>References</h3>

<p> Bogetoft and Otto; <em>Benchmarking with DEA, SFA, and
R</em>; Springer 2011. Sect.  5.10: Partial value information </p>


<h3>See Also</h3>

<p><code>dea</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
x &lt;- matrix(c(2,5 , 1,2 , 2,2 , 3,2 , 3,1 , 4,1), ncol=2,byrow=TRUE)
y &lt;- matrix(1,nrow=dim(x)[1])
dea.plot.isoquant(x[,1],x[,2],txt=1:dim(x)[1])
segments(0,0, x[,1], x[,2], lty="dotted")


e &lt;- dea(x,y,RTS="crs",SLACK=TRUE)
ed &lt;- dea.dual(x,y,RTS="crs")
print(cbind("e"=e$eff,"ed"=ed$eff, peers(e), lambda(e), 
            e$sx, e$sy, ed$u, ed$v), digits=3)

dual &lt;- matrix(c(.5, 2.5), nrow=dim(x)[2]+dim(y)[2]-2, ncol=2, byrow=TRUE)
er &lt;- dea.dual(x,y,RTS="crs", DUAL=dual)
print(cbind("e"=e$eff,"ar"=er$eff, lambda(e), e$sx, e$sy, er$u, 
            "ratio"=er$u[,2]/er$u[,1],er$v),digits=3)


</code></pre>


</div>