<div class="container">

<table style="width: 100%;"><tr>
<td>cnapath</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Suboptimal Path Analysis for Correlation Networks </h2>

<h3>Description</h3>

<p>Find k shortest paths between a pair of nodes, source and sink, in a correlation 
network. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">cnapath(cna, from, to=NULL, k=10, collapse=TRUE, ncore=NULL, ...)
## S3 method for class 'cnapath'
summary(object, ..., pdb = NULL, label = NULL, col = NULL,
   plot = FALSE, concise = FALSE, cutoff = 0.1, normalize = TRUE, weight = FALSE)
## S3 method for class 'cnapath'
print(x, ...)
## S3 method for class 'cnapath'
plot(x, ...)
## S3 method for class 'ecnapath'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cna</code></td>
<td>
<p> A ‘cna’ object or a list of ‘cna’ objects obtained from 
<code>cna</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from</code></td>
<td>
<p> Integer vector or matrix indicating node id(s) of source. If is matrix
and <code>to</code> is NULL, the first column represents source and the second sink. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to</code></td>
<td>
<p> Integer vector indicating node id(s) of sink. All combinations of 
<code>from</code> and <code>to</code> values will be used as source/sink pairs. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p> Integer, number of suboptimal paths to identify. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>collapse</code></td>
<td>
<p> Logical, if TRUE results from all source/sink pairs are merged with
a single ‘cnapath’ object returned. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncore</code></td>
<td>
<p> Number of CPU cores used to do the calculation. 
By default (NULL), use all detected CPU cores. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p> A ‘cnapath’ class of object obtained from 
<code>cnapath</code>. Multiple ‘object’ input is allowed for 
comparing paths from different networks. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pdb</code></td>
<td>
<p> A ‘pdb’ class of object obtained from <code>read.pdb</code> 
and is used as the reference for node residue ids (in <code>summary.cnapath</code>) or 
for molecular visulaization with VMD (in <code>vmd.cnapath</code>). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label</code></td>
<td>
<p> Character, label for paths identified from different networks. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col</code></td>
<td>
<p> Colors for plotting statistical results for paths identified 
from different networks. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p> Logical, if TRUE path length distribution and node degeneracy will be plotted. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>concise</code></td>
<td>
<p> Logical, if TRUE only ‘on path’ residues will be displayed in the
node degeneracy plot. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff</code></td>
<td>
<p> Numeric, nodes with node degeneracy larger than <code>cutoff</code> are
shown in the output. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p> Logical, if TRUE node degeneracy is divided by the total 
(weighted) number of paths. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight</code></td>
<td>
<p> Logical, if TRUE each path is weighted by path length in calculating the
node degeneracty. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> A 'cnapath' class object, or a list of such objects, as obtained from function <code>cnapath</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> Additional arguments passed to igraph function 
<code>get.shortest.paths</code> (in 
the function <code>cnapath</code>), passed to <code>summary.cnapath</code> 
(in <code>print.cnapath</code>), as additional paths for 
comparison (in <code>summary.cnapath</code>). </p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The function <code>cnapath</code> returns a (or a list of) ‘cnapath’ 
class of list containing following three components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>path</code></td>
<td>
<p> a list object containing all identified suboptimal paths.  
Each entry of the list is a sequence of node ids for the path. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epath</code></td>
<td>
<p> a list object containing all identified suboptimal paths. 
Each entry of the list is a sequence of edge ids for the path. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist</code></td>
<td>
<p> a numeric vector of all path lengths. </p>
</td>
</tr>
</table>
<p>The function <code>summary.cnapath</code> returns a matrix of (normalized)
node degeneracy for ‘on path’ residues. 
</p>


<h3>Author(s)</h3>

<p> Xin-Qiu Yao </p>


<h3>References</h3>

<p>Yen, J.Y. (1971) <em>Management Science</em> <b>17</b>, 712–716.
</p>


<h3>See Also</h3>

<p><code>cna</code>, <code>cna.dccm</code>,
<code>vmd.cna</code>, <code>vmd.cnapath</code>, 
<code>get.shortest.paths</code>. </p>


<h3>Examples</h3>

<pre><code class="language-R">
# Redundant testing excluded

if (!requireNamespace("igraph", quietly = TRUE)) {
   message('Need igraph installed to run this example')
} else {

attach(transducin)
inds = match(c("1TND_A", "1TAG_A"), pdbs$id)

npdbs &lt;- trim(pdbs, row.inds=inds)
gaps.res &lt;- gap.inspect(npdbs$ali)

modes &lt;- nma(npdbs)
cij &lt;- dccm(modes)
net &lt;- cna(cij, cutoff.cij=0.3)

# get paths
pa1 &lt;- cnapath(net[[1]], from = 314, to=172, k=50)
pa2 &lt;- cnapath(net[[2]], from = 314, to=172, k=50)

# print the information of a path
pa1

# print two paths simultaneously
pas &lt;- list(pa1, pa2)
names(pas) &lt;- c("GTP", "GDP")
print.cnapath(pas)

# Or, for the same effect,
# summary(pa1, pa2, label=c("GTP", "GDP"))

# replace node numbers with residue name and residue number in the PDB file
pdb &lt;- read.pdb("1tnd")
pdb &lt;- trim.pdb(pdb, atom.select(pdb, chain="A", resno=npdbs$resno[1, gaps.res$f.inds]))
print.cnapath(pas, pdb=pdb)

# plot path length distribution and node degeneracy
print.cnapath(pas, pdb = pdb, col=c("red", "darkgreen"), plot=TRUE)

# View paths in 3D molecular graphic with VMD
#vmd.cnapath(pa1, pdb, launch = TRUE)
#vmd.cnapath(pa1, pdb, colors = 7, launch = TRUE)
#vmd.cnapath(pa1, pdb, spline=TRUE, colors=c("pink", "red"), launch = TRUE)
#pdb2 &lt;- read.pdb("1tag")
#pdb2 &lt;- trim.pdb(pdb2, atom.select(pdb2, chain="A", resno=npdbs$resno[2, gaps.res$f.inds]))
#vmd.cnapath(pa2, pdb2, launch = TRUE)

detach(transducin)

}

</code></pre>


</div>