<div class="container">

<table style="width: 100%;"><tr>
<td>biblioverlap</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Document-level matching of bibliographic datasets</h2>

<h3>Description</h3>

<p>This function identifies document overlap between bibliographic datasets and records it through the use of Universally Unique Identifiers (UUID).
</p>


<h3>Usage</h3>

<pre><code class="language-R">biblioverlap(
  db_list,
  matching_fields = default_matching_fields,
  n_threads = 1,
  ti_penalty = 0.1,
  ti_max = 0.6,
  so_penalty = 0.1,
  so_max = 0.3,
  au_penalty = 0.1,
  au_max = 0.3,
  py_max = 0.3,
  score_cutoff = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>db_list</code></td>
<td>

<ul><li>
<p> list of dataframes containing the sets of bibliographic data
</p>
</li></ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>matching_fields</code></td>
<td>

<ul><li>
<p> Five column names used in the matching. Should be universal across all datasets and provided as a named list with the following names: <strong>DI</strong> (unique identifier), <strong>TI</strong> (document title), <strong>PY</strong> (publication year), <strong>SO</strong> (publication source) and <strong>AU</strong> (Authors). Default values come from <a href="https://support.lens.org/knowledge-base/scholar-field-definition/">The Lens scholar field definition</a>.
</p>
</li></ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_threads</code></td>
<td>

<ul><li>
<p> number of (logical) cores used in the matching procedures. Default: 1
</p>
</li></ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ti_penalty</code></td>
<td>

<ul><li>
<p> penalty applied for each increment in Title's Levenshtein distance. Default: 0.1
</p>
</li></ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ti_max</code></td>
<td>

<ul><li>
<p> max score value for Title. Default: 0.6
</p>
</li></ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>so_penalty</code></td>
<td>

<ul><li>
<p> penalty applied for each increment in Source's Levenshtein distance. Default: 0.1
</p>
</li></ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>so_max</code></td>
<td>

<ul><li>
<p> max score value for Source. Default: 0.3
</p>
</li></ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>au_penalty</code></td>
<td>

<ul><li>
<p> penalty applied for each increment in Author's Levenshtein distance. Default: 0.1
</p>
</li></ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>au_max</code></td>
<td>

<ul><li>
<p> max  score value for Author. Default: 0.3
</p>
</li></ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>py_max</code></td>
<td>

<ul><li>
<p> max score value for Publication Year. Default: 0.3
</p>
</li></ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>score_cutoff</code></td>
<td>

<ul><li>
<p> minimum final score for a valid match between two documents. Default: 1
</p>
</li></ul>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In this procedure, any duplicates in the same dataset are removed. Then, Universally Unique Identifiers (UUID) are attributed to each record. If a match is found between two documents in a pairwise comparison, the UUID of the record from the first dataset is copied to the record on the second.
</p>
<p>All preprocessing and modifications to the dataset are performed in a copy of the original data, which is used internally by the program. After all pairwise comparisons are completed, the UUID data is added as a new column in the original data.
</p>
<p>Thus, the <code>db_list</code> returned by this function contains the same fields provided by the user plus the UUID column with the overlap information. This allows for further analysis using other fields (e.g. 'number of citations' or 'document type').
</p>


<h3>Value</h3>

<p>a list object containing:
</p>
<p>(i) <code>db_list</code>: a modified version of db_list where matching documents share the same UUID
</p>
<p>(ii) <code>summary</code>: a summary of the results of the matching procedure
</p>


<h3>Note</h3>

<p>In its internal data, the program will attempt to split the AU (Author) field to extract only the first author, for which it will calculate the Levenshtein distance.
</p>
<p>It assumes that the AU field is ";" (semicolon) separated. Thus, in order to correctly perform the matching procedure to when another separator is being applied to this field, the user can either: (i) change the separator to semicolon; or (ii) create a new column containing only the first author.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#Example list of input dataframes
lapply(ufrj_bio_0122, head, n=1)

#List of columns for matching (identical to biblioverlap()'s defaults)
matching_cols &lt;- list(DI = 'DOI',
                      TI = 'Title',
                      PY = 'Publication Year',
                      AU = 'Author/s',
                      SO = 'Source Title')

#Running document-level matching procedure (first two dataframes)
biblioverlap_results &lt;- biblioverlap(ufrj_bio_0122[1:2], matching_fields = matching_cols)

#Taking a look at the matched db_list
lapply(biblioverlap_results$db_list, head, n=1)

#Taking a look at the matching results summary
biblioverlap_results$summary

</code></pre>


</div>