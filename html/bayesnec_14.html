<div class="container">

<table style="width: 100%;"><tr>
<td>bayesnecformula</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Set up a model formula for use in
<code>bayesnec</code>
</h2>

<h3>Description</h3>

<p>Set up a model formula for use in the
<code>bayesnec</code> package, allowing linear
and non-linear (potentially multi-level) concentration-response
models to be defined.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bayesnecformula(formula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>Either a <code>character</code> string defining an
R formula or an actual <code>formula</code> object. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Unused.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See <code>methods(class = "bayesnecformula")</code> for an overview of
available methods.
</p>
<p><b>General formula syntax</b>
</p>
<p>The <code>formula</code> argument accepts formulas of the following syntax:
</p>
<p><code>response | aterms ~ crf(x, model) + glterms</code>
</p>
<p><b>The population-level term: <code>crf</code></b>
</p>
<p><code>bayesnec</code> uses a special internal
term called <code>crf</code>, which sets the concentration-response equation
to be evaluated based on some <code>x</code> predictor. The equation itself is
defined by the argument <code>"model"</code>: a <code>character</code>
vector containing a specific model, a concatenation of specific models,
or a single string defining a particular group of models
(or group of equations, see <code>models</code>). Internally
this argument is substituted by an actual <code>brmsformula</code>,
which is then passed onto <code>brm</code> for model fitting.
</p>
<p><b>Group-level terms: <code>glterms</code></b>
</p>
<p>The user has three options to define group-level effects in a
<code>bayesnecformula</code>: 1) a general "offset" group-level effect
defined by the term <code>ogl</code> (as in e.g. <code>ogl(group_variable)</code>). This
adds an additional population-level parameter <code>ogl</code> to the model defined
by <code>crf</code>, analogously to an intercept-only group-level effect
in a classic linear model. 2) A group-level effect applied to all
parameters in a model at once. This is done by the special term <code>pgl</code>,
(as in e.g. <code>pgl(group_variable)</code>), which comes in handy so the user
does not need to know the internal syntax and name of each parameter in the
model. 3) A more classic approach where the user can specify which
specific parameters — NB: that requires prior knowledge on the model
structure and parameter names — to vary according to a grouping variable
(as in e.g. <code>(bot | group_variable)</code>). <code>bayesnecformula</code>
will ignore this term should the parameter not exist in the specified model
or model suite. For example, the parameter <code>bot</code> exists in model
<code>"nec4param"</code> but not in <code>"nec3param"</code>, so if the user specifies
<code>model = "nec"</code> in <code>crf</code>, the term <code>(bot | group_variable)</code>
will be dropped in models where that parameter does not exist.
</p>
<p><b>Further brms terms (largely untested)</b>
</p>
<p>Currently <code>bayesnecformula</code> is quite agnostic about additional
terms that are valid for a <code>brmsformula</code>. These are
<code>aterms</code> and <code>pterms</code> (see <code>?brmsformula</code>).
The only capability that <code>bayesnecformula</code> does not allow is
the addition of <code>pterms</code> outside of the term <code>crf</code>. Although
<code>pterms</code> can be passed to predictor <code>x</code> within <code>crf</code>, we
strongly discourage their use because those functionalities have not
been tested yet. If this is extremely important to your work, please
raise an issue on bayesnec GitHub, and we will consider further testing and
development.
Currently, the only two <code>aterms</code> that have validated behaviour are:
</p>

<ol><li> <p><code>trials()</code>, which is essential in binomially-distributed data, e.g.
<code>y | trials(trials_variable)</code>, and 2) weights, e.g.
<code>y | weights(weights_variable)</code>, following <span class="pkg">brms</span> formula syntax.
Please note that <span class="pkg">brms</span> does not implement design weights as in other
standard <span class="pkg">base</span> functions. From their help page, <span class="pkg">brms</span> "takes the
weights literally, which means that an observation with weight 2 receives 2
times more weight than an observation with weight 1. It also means that
using a weight of 2 is equivalent to adding the corresponding observation
twice to the data frame". Other <code>aterms</code> might be added, though we
cannot attest to their functionality within
<code>bayesnec</code>, i.e. checks will
be done outside via <code>brm</code>.
</p>
</li></ol>
<p><strong>NB:</strong> <code>aterms</code> other than <code>trials()</code> and <code>weights()</code> are
currently omitted from <code>model.frame</code> output. If you need other
<code>aterms</code> as part of that output please raise an issue on our GitHub
page.
</p>
<p><b>Validation of formula</b>
Please note that the function only checks for the input nature of the
<code>formula</code> argument and adds a new class. This function <strong>does not</strong>
perform any validation on the model nor checks on its adequacy to work with
other functions in the package. For that please refer to the function
<code>check_formula</code> which requires the dataset associated with the
formula.
</p>


<h3>Value</h3>

<p>An object of class <code>bayesnecformula</code> and
<code>formula</code>.
</p>


<h3>See Also</h3>

<p><code>check_formula</code>,
<code>model.frame</code>,
<code>models</code>,
<code>show_params</code>,
<code>make_brmsformula</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(bayesnec)

bayesnecformula(y ~ crf(x, "nec3param"))
# or use shot alias bnf
bayesnecformula(y ~ crf(x, "nec3param")) == bnf(y ~ crf(x, "nec3param"))
bnf(y | trials(tr) ~ crf(sqrt(x), "nec3param"))
bnf(y | trials(tr) ~ crf(x, "nec3param") + ogl(group_1) + pgl(group_2))
bnf(y | trials(tr) ~ crf(x, "nec3param") + (nec + top | group_1))


# complex transformations are not advisable because
# they are passed directly to Stan via brms
# and are likely to fail -- transform your variable beforehand!
try(bnf(y | trials(tr) ~ crf(scale(x, scale = TRUE), "nec3param")))

</code></pre>


</div>