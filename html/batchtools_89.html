<div class="container">

<table style="width: 100%;"><tr>
<td>reduceResults</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Reduce Results</h2>

<h3>Description</h3>

<p>A version of <code>Reduce</code> for <code>Registry</code> objects
which iterates over finished jobs and aggregates them.
All jobs must have terminated, an error is raised otherwise.
</p>


<h3>Usage</h3>

<pre><code class="language-R">reduceResults(fun, ids = NULL, init, ..., reg = getDefaultRegistry())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>[<code>function</code>]<br>
A function to reduce the results. The result of previous iterations (or
the <code>init</code>) will be passed as first argument, the result of of the
i-th iteration as second. See <code>Reduce</code> for some
examples.
If the function has the formal argument “job”, the <code>Job</code>/<code>Experiment</code>
is also passed to the function (named).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ids</code></td>
<td>
<p>[<code>data.frame</code> or <code>integer</code>]<br>
A <code>data.frame</code> (or <code>data.table</code>)
with a column named “job.id”.
Alternatively, you may also pass a vector of integerish job ids.
If not set, defaults to the return value of <code>findDone</code>.
Invalid ids are ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>[<code>ANY</code>]<br>
Initial element, as used in <code>Reduce</code>.
If missing, the reduction uses the result of the first job as <code>init</code> and the reduction starts
with the second job.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>[<code>ANY</code>]<br>
Additional arguments passed to function <code>fun</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reg</code></td>
<td>
<p>[<code>Registry</code>]<br>
Registry. If not explicitly passed, uses the default registry (see <code>setDefaultRegistry</code>).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Aggregated results in the same order as provided ids.
Return type depends on the user function. If <code>ids</code>
is empty, <code>reduceResults</code> returns <code>init</code> (if available) or <code>NULL</code> otherwise.
</p>


<h3>Note</h3>

<p>If you have thousands of jobs, disabling the progress bar (<code>options(batchtools.progress = FALSE)</code>)
can significantly increase the performance.
</p>


<h3>See Also</h3>

<p>Other Results: 
<code>batchMapResults()</code>,
<code>loadResult()</code>,
<code>reduceResultsList()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
tmp = makeRegistry(file.dir = NA, make.default = FALSE)
batchMap(function(a, b) list(sum = a+b, prod = a*b), a = 1:3, b = 1:3, reg = tmp)
submitJobs(reg = tmp)
waitForJobs(reg = tmp)

# Extract element sum from each result
reduceResults(function(aggr, res) c(aggr, res$sum), init = list(), reg = tmp)

# Aggregate element sum via '+'
reduceResults(function(aggr, res) aggr + res$sum, init = 0, reg = tmp)

# Aggregate element prod via '*' where parameter b &lt; 3
reduce = function(aggr, res, job) {
  if (job$pars$b &gt;= 3)
    return(aggr)
  aggr * res$prod
}
reduceResults(reduce, init = 1, reg = tmp)

# Reduce to data.frame() (inefficient, use reduceResultsDataTable() instead)
reduceResults(rbind, init = data.frame(), reg = tmp)

# Reduce to data.frame by collecting results first, then utilize vectorization of rbind:
res = reduceResultsList(fun = as.data.frame, reg = tmp)
do.call(rbind, res)

# Reduce with custom combine function:
comb = function(x, y) list(sum = x$sum + y$sum, prod = x$prod * y$prod)
reduceResults(comb, reg = tmp)

# The same with neutral element NULL
comb = function(x, y) if (is.null(x)) y else list(sum = x$sum + y$sum, prod = x$prod * y$prod)
reduceResults(comb, init = NULL, reg = tmp)

# Alternative: Reduce in list, reduce manually in a 2nd step
res = reduceResultsList(reg = tmp)
Reduce(comb, res)
</code></pre>


</div>