<div class="container">

<table style="width: 100%;"><tr>
<td>sol.wbs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Solution path generation via the Wild Binary Segmentation method</h2>

<h3>Description</h3>

<p>This function arranges all possible change-in-mean features of the input vector in the order of importance, via the Wild Binary Segmentation (WBS) method.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sol.wbs(x, type = "const", M = 10000, systematic.intervals = TRUE, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A numeric vector containing the data to be processed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>The model type considered. Currently <code>type = "const"</code> is the only accepted value. This assumes that the mean of the input vector is piecewise-constant.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>The maximum number of all data sub-samples at the beginning of the algorithm. The default is
<code>M = 10000</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>systematic.intervals</code></td>
<td>
<p>When drawing the sub-intervals, whether to use a systematic (and fixed) or random scheme. The default is <code>systematic.intervals = TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>If a random scheme is used, a random seed can be provided so that every time the same sets of random sub-intervals would be drawn. The default is <code>seed = NULL</code>, which means that this option is not set</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The Wild Binary Segmentation algorithm is described in 
"Wild binary segmentation for multiple change-point detection", P. Fryzlewicz (2014), The Annals of Statistics, 42: 2243–2281.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>cptpath</code>, which contains the following fields: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>solutions.nested</code></td>
<td>
<p><code>TRUE</code>, i.e., the change-point outputs are nested</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solution.path</code></td>
<td>
<p>Locations of possible change-points in the mean of <code>x</code>, arranged in decreasing order of change-point importance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solution.set</code></td>
<td>
<p>Empty list</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Input vector <code>x</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>The input parameter <code>type</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>Input parameter <code>M</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cands</code></td>
<td>
<p>Matrix of dimensions length(<code>x</code>) - 1 by 4. The first two columns are (start, end)-points of the detection intervals of the corresponding possible change-point location in the third column. The fourth column is a measure of strength of the corresponding possible change-point. The order of the rows is the same as the order returned in <code>solution.path</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>The method used, which has value "wbs" here</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>P. Fryzlewicz (2014). Wild binary segmentation for multiple change-point detection. <em>The Annals of Statistics</em>, 42(6), 2243–2281.
</p>
<p>R. Baranowski, Y. Chen &amp; P. Fryzlewicz (2019). Narrowest-over-threshold detection of multiple change points and change-point-like features. <em>Journal of the Royal Statistical Society: Series B</em>, 81(3), 649–672.
</p>


<h3>See Also</h3>

<p><code>sol.idetect</code>, <code>sol.idetect_seq</code>, <code>sol.not</code>, <code>sol.tguh</code>, <code>sol.wbs2</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">r3 &lt;- rnorm(1000) + c(rep(0,300), rep(2,200), rep(-4,300), rep(0,200))
sol.wbs(r3)
</code></pre>


</div>