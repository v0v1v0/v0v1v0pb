<div class="container">

<table style="width: 100%;"><tr>
<td>jbd_Ctrans_chunker</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Wraps jbd_coordinates_transposed to identify  and fix transposed occurrences</h2>

<h3>Description</h3>

<p>Because the <code>jbd_coordinates_transposed()</code> function is very RAM-intensive, this wrapper
allows a user to specify chunk-sizes and only analyse a small portion of the occurrence data at a
time. The prefix jbd_ is used to highlight the difference between this function and the original
<code>bdc::bdc_coordinates_transposed()</code>.
This function will preferably use the countryCode column generated by
<code>bdc::bdc_country_standardized()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">jbd_Ctrans_chunker(
  data = NULL,
  lat = "decimalLatitude",
  lon = "decimalLongitude",
  idcol = "databse_id",
  country = "country_suggested",
  countryCode = "countryCode",
  sci_names = "scientificName",
  border_buffer = 0.2,
  save_outputs = TRUE,
  stepSize = 1e+06,
  chunkStart = 1,
  progressiveSave = TRUE,
  path = tempdir(),
  append = TRUE,
  scale = "large",
  mc.cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame or tibble. Occurrence records as input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lat</code></td>
<td>
<p>Character. The column with latitude in decimal degrees. Default = "decimalLatitude".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lon</code></td>
<td>
<p>Character. The column with longitude in decimal degrees. Default = "decimalLongitude".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>idcol</code></td>
<td>
<p>Character. The column name with a unique record identifier. Default = "database_id".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>country</code></td>
<td>
<p>Character. The name of the column containing country names. Default = "country".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>countryCode</code></td>
<td>
<p>Character. Identifies the column containing ISO-2 country codes
Default = "countryCode".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sci_names</code></td>
<td>
<p>Character. The column containing scientific names. Default = "scientificName".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>border_buffer</code></td>
<td>
<p>Numeric. The buffer, in decimal degrees, around points to help match them
to countries. Default = 0.2 (~22 km at equator).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>save_outputs</code></td>
<td>
<p>Logical. If TRUE, transposed occurrences will be saved to their own file.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stepSize</code></td>
<td>
<p>Numeric. The number of occurrences to process in each chunk. Default = 1000000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chunkStart</code></td>
<td>
<p>Numeric. The chunk number to start from. This can be &gt; 1 when you need to restart
the function from a certain chunk; for example if R failed unexpectedly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progressiveSave</code></td>
<td>
<p>Logical. If TRUE then the country output list will be saved between
each iteration so that <code>append</code> can be used if the function is stopped part way through.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>path</code></td>
<td>
<p>Character. The path to a file in which to save the 01_coordinates_transposed_
output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>append</code></td>
<td>
<p>Logical. If TRUE, the function will look to append an existing file.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>Passed to rnaturalearth's ne_countries().
Scale of map to return, one of 110, 50, 10 or 'small', 'medium', 'large'. Default = "large".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mc.cores</code></td>
<td>
<p>Numeric. If &gt; 1, the jbd_correct_coordinates function will run in parallel
using mclapply using the number of cores specified. If = 1 then it will be run using a serial
loop. NOTE: Windows machines must use a value of 1 (see ?parallel::mclapply). Additionally,
be aware that each thread can use large chunks of memory.
Default = 1.#'</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns the input data frame with a new column, coordinates_transposed, where FALSE = columns
that had coordinates transposed.
</p>


<h3>Examples</h3>

<pre><code class="language-R">if(requireNamespace("rnaturalearthdata")){
library(dplyr)
  # Import and prepare the data
data(beesFlagged)
beesFlagged &lt;- beesFlagged %&gt;% dplyr::select(!c(.val, .sea)) %&gt;%
  # Cut down the dataset to un example quicker
dplyr::filter(dplyr::row_number() %in% 1:20)
  # Run the function
beesFlagged_out &lt;- jbd_Ctrans_chunker(
# bdc_coordinates_transposed inputs
data = beesFlagged,
idcol = "database_id",
lat = "decimalLatitude",
lon = "decimalLongitude",
country = "country_suggested",
countryCode = "countryCode",
# in decimal degrees (~22 km at the equator)
border_buffer = 1, 
save_outputs = FALSE,
sci_names = "scientificName",
# chunker inputs
# How many rows to process at a time
stepSize = 1000000,  
# Start row
chunkStart = 1,  
# Progressively save the output between each iteration?
progressiveSave = FALSE,
path = tempdir(),
# If FALSE it may overwrite existing dataset
append = FALSE,
  # Users should select scale = "large" as it is more thoroughly tested
scale = "medium",
mc.cores = 1
) 
table(beesFlagged_out$coordinates_transposed, useNA = "always")
} # END if require

</code></pre>


</div>