<div class="container">

<table style="width: 100%;"><tr>
<td>plot2d</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Plot 2D Effects
</h2>

<h3>Description</h3>

<p>Function to plot simple 2D graphics for univariate effects/functions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">plot2d(x, residuals = FALSE, rug = FALSE, jitter = TRUE, 
  col.residuals = NULL, col.lines = NULL, col.polygons = NULL, 
  col.rug = NULL, c.select = NULL, fill.select = NULL, 
  data = NULL, sep = "", month = NULL, year = NULL,
  step = 12, shift = NULL, trans = NULL,
  scheme = 2, s2.col = NULL, grid = 50, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A matrix or data frame, containing the covariate for which the effect should be plotted 
in the first column and at least a second column containing the effect. Another possibility is
to specify the plot via a <code>formula</code>, e.g. <code>y ~ x</code>, see the examples.
<code>x</code> may also be a character file path to the data to be used for plotting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>If set to <code>TRUE</code>, residuals may also be plotted if available.
Residuals must be supplied as an <code>attr</code>ibute named <code>"residuals"</code>, which
is a matrix or data frame where the first column is the covariate and the second column
the residuals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rug</code></td>
<td>
<p>Add a <code>rug</code> to the plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jitter</code></td>
<td>
<p>If set to <code>TRUE</code> a <code>jitter</code>ed 
<code>rug</code> plot is added.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.residuals</code></td>
<td>
<p>The color of the partial residuals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.lines</code></td>
<td>
<p>The color of the lines.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.polygons</code></td>
<td>
<p>Specify the background color of polygons, if <code>x</code> has at least 3 columns, 
i.e. column 2 and 3 can form one polygon.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.rug</code></td>
<td>
<p>Specify the color of the rug representation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.select</code></td>
<td>
<p>Integer vector of maximum length of columns of <code>x</code>, selects the 
columns of the resulting data matrix that should be used for plotting. E.g. if <code>x</code> has 5
columns, then <code>c.select = c(1, 2, 5)</code> will select column 1, 2 and 5 for plotting. Note that
first element of <code>c.select</code> should always be the column that holds the variable for the
x-axis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill.select</code></td>
<td>
<p>Integer vector, select pairwise the columns of the resulting data matrix 
that should form one polygon with a certain background color specified in argument <code>col</code>. 
E.g. <code>x</code> has three columns, or is specified with formula <code>f1 + f2 ~ x</code>, then setting 
<code>fill.select = c(0, 1, 1)</code> will draw a polygon with <code>f1</code> and <code>f2</code> as boundaries. 
If <code>x</code> has five columns or the formula is e.g. <code>f1 + f2 + f3 + f4 ~ x</code>, then setting
<code>fill.select = c(0, 1, 1, 2, 2)</code>, the pairs <code>f1</code>, <code>f2</code> and <code>f3</code>, <code>f4</code>
are selected to form two polygons.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>If <code>x</code> is a formula, a <code>data.frame</code> or <code>list</code>. By default the variables 
are taken from <code>environment(x)</code>: typically the environment from which <code>plot2d</code> is 
called. Note that <code>data</code> may also be a character file path to the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sep</code></td>
<td>
<p>The field separator character when <code>x</code> or <code>data</code> is a character, see function
<code>read.table</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>month, year, step</code></td>
<td>
<p>Provide specific annotation for plotting estimation results for temporal
variables. <code>month</code> and <code>year</code> define the minimum time point whereas step specifies the
type of temporal data with <code>step = 4</code>, <code>step = 2</code> and <code>step = 1</code> corresponding to
quarterly, half yearly and yearly data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shift</code></td>
<td>
<p>Numeric constant to be added to the smooth before plotting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trans</code></td>
<td>
<p>Function to be applied to the smooth before plotting, e.g., to transform the
plot to the response scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scheme</code></td>
<td>
<p>Sets the plotting scheme for polygons, possible values are <code>1</code> and <code>2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s2.col</code></td>
<td>
<p>The color for the second plotting scheme.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>Integer, specifies the number of polygons for the second plotting scheme.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other graphical parameters, please see the details.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For 2D plots the following graphical parameters may be specified additionally: 
</p>

<ul>
<li> <p><code>cex</code>: Specify the size of partial residuals,
</p>
</li>
<li> <p><code>lty</code>: The line type for each column that is plotted, e.g. <code>lty = c(1, 2)</code>,
</p>
</li>
<li> <p><code>lwd</code>: The line width for each column that is plotted, e.g. <code>lwd = c(1, 2)</code>,
</p>
</li>
<li> <p><code>poly.lty</code>: The line type to be used for the polygons,
</p>
</li>
<li> <p><code>poly.lwd</code>: The line width to be used for the polygons,
</p>
</li>
<li> <p><code>density</code> <code>angle</code>, <code>border</code>: See <code>polygon</code>,
</p>
</li>
<li> <p><code>...</code>: Other graphical parameters, see function <code>plot</code>.
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>plot3d</code>, <code>plotmap</code>,
<code>plotblock</code>, <code>sliceplot</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Generate some data.
set.seed(111)
n &lt;- 500
## Regressor.
d &lt;- data.frame(x = runif(n, -3, 3))

## Response. 
d$y &lt;- with(d, 10 + sin(x) + rnorm(n, sd = 0.6))

## Not run: ## Estimate model.
b &lt;- bamlss(y ~ s(x), data = d)
summary(b)

## Plot estimated effect.
plot(b)
plot(b, rug = FALSE)

## Extract fitted values.
f &lt;- fitted(b, model = "mu", term = "s(x)")
f &lt;- cbind(d["x"], f)

## Now use plot2d.
plot2d(f)
plot2d(f, fill.select = c(0, 1, 0, 1))
plot2d(f, fill.select = c(0, 1, 0, 1), lty = c(2, 1, 2))
plot2d(f, fill.select = c(0, 1, 0, 1), lty = c(2, 1, 2),
  scheme = 2)

## Variations.
plot2d(sin(x) ~ x, data = d)
d$f &lt;- with(d, sin(d$x))
plot2d(f ~ x, data = d)
d$f1 &lt;- with(d, f + 0.1)
d$f2 &lt;- with(d, f - 0.1)
plot2d(f1 + f2 ~ x, data = d)
plot2d(f1 + f2 ~ x, data = d, fill.select = c(0, 1, 1), lty = 0)
plot2d(f1 + f2 ~ x, data = d, fill.select = c(0, 1, 1), lty = 0,
  density = 20, poly.lty = 1, poly.lwd = 2)
plot2d(f1 + f + f2 ~ x, data = d, fill.select = c(0, 1, 0, 1), 
  lty = c(0, 1, 0), density = 20, poly.lty = 1, poly.lwd = 2)

## End(Not run)</code></pre>


</div>