<div class="container">

<table style="width: 100%;"><tr>
<td>pop.trajectories</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Accessing Trajectories
</h2>

<h3>Description</h3>

<p>Obtain projection trajectories of population and vital events/rates. <code>get.pop</code> allows to access trajectories using a basic component of an expression. <code>get.pop.ex</code> and <code>get.pop.exba</code> returns results of an expression defined “by time” and “by age”, respectively. <code>get.trajectory.indices</code> creates a link to the probabilistic components of the projection by providing indices to the trajectories of TFR, e0 and migration. <code>extract.trajectories.eq</code> returns trajectories (of population or expression) and their indices that are closest to given values or a quantile. Similarly, functions <code>extract.trajectories.ge</code> and <code>extract.trajectories.le</code> return trajectories and their indices that are greater equal and less equal, respectively, to the given values or a quantile.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pop.trajectories(pop.pred, country, sex = c("both", "male", "female"), 
    age = "all", ...)

get.pop(object, pop.pred, aggregation = NULL, observed = FALSE, ...)

get.pop.ex(expression, pop.pred, observed = FALSE, as.dt = FALSE, ...)

get.pop.exba(expression, pop.pred, observed = FALSE, as.dt = FALSE, ...)

get.trajectory.indices(pop.pred, country, 
    what = c("TFR", "e0M", "e0F", "migM", "migF"))

extract.trajectories.eq(pop.pred, country = NULL, expression = NULL, 
    quant = 0.5, values = NULL, nr.traj = 1, ...)
    
extract.trajectories.ge(pop.pred, country = NULL, expression = NULL, 
    quant = 0.5, values = NULL, all = TRUE, ...)
    
extract.trajectories.le(pop.pred, country = NULL, expression = NULL, 
    quant = 0.5, values = NULL, all = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pop.pred</code></td>
<td>
<p>Object of class <code>bayesPop.prediction</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>country</code></td>
<td>
<p>Name or numerical code of a country.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sex</code></td>
<td>
<p>One of “both”  (default), “male” or “female”. By default the male and female projections are summed up.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>age</code></td>
<td>
<p>Either a character string “all” (default) or an integer vector of age indices. In a 5x5 simulation, value 1 corresponds to age 0-4, value 2 corresponds to age 5-9 etc. Last age goup <code class="reqn">130+</code> corresponds to index 27. In a 1x1 simulation, value 1 corresponds to age 0, value 2 to age 1 etc, up to 131 corresponding to the last age group. Results is summed over the given age categories.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>Character string giving a basic component of an expression (see pop.expressions).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aggregation</code></td>
<td>
<p>If the basic component is to be evaluated on an aggregated prediction object, this argument gives the name of the aggregation (corresponds argument <code>name</code> in <code>pop.aggregate</code>). By default, the function searches for available aggregations and gives priority to the one called “country”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>observed</code></td>
<td>
<p>Logical. Determines if the evaluation uses observed data (<code>TRUE</code>) or predictions (<code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expression</code></td>
<td>
<p>Expression defining the trajectories measure. For syntax see <code>pop.expressions</code>. It must be define by age (i.e. contain curly braces) if used in <code>get.pop.exba</code>, and the opposite applies to <code>get.pop.ex</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as.dt</code></td>
<td>
<p>Logical indicating if the result should be returned as a <code>data.table</code> object in long format. This can be useful especially if results for all countries are requested.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>what</code></td>
<td>
<p>A character string that defines to which component should the indices link to. Allowable options are “TFR”, “e0M” (male life expectancy), “e0F” (female life expectancy), “migM” (male migration), “migF” (female migration).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quant</code></td>
<td>
<p>Quantile used to select the closest trajectories to.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>values</code></td>
<td>
<p>Vector of values used to select the closest trajectories to. If it is not of length 1, it has to be of the same length as the number of projected time periods. If it is not given, <code>quant</code> is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nr.traj</code></td>
<td>
<p>Number of trajectories to return. This argument can be passed to any of the functions that contains ....</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all</code></td>
<td>
<p>Logical indicating if the corresponding condition should apply to all time periods of a trajectory. If it is <code>FALSE</code>, a trajectory is extracted if the condition is fulfilled in at least one time period.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional argument passed to the underlying functions. In case of <code>get.pop</code>, <code>get.pop.ex</code> and  <code>get.pop.exba</code>, this is only used for <code>observed=FALSE</code>. It can be either <code>nr.traj</code> giving the number of trajectories or logical <code>typical.trajectory</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Function <code>pop.trajectories</code> returns an array of population trajectories for given sex and age. 
</p>
<p>Function <code>get.pop</code> evaluates a basic component of an expression and results in a four-dimensional array. Internally, this function is used for evaluation after an expression is decomposed into basic components. It can be useful for example for debugging purposes, to obtain results from parts of an expression. In addition, while  <code>pop.trajectories</code> works only for population counts, <code>get.pop</code> can be used for obtaining trajectories of vital events and rates. Note that the wildcard “XXX” in the expression cannot be used in <code>get.pop</code>; use <code>get.pop.ex</code> or <code>get.pop.exba</code> instead.
</p>
<p>Functions <code>get.pop.ex</code> and <code>get.pop.exba</code> evaluate a whole expression and the dimensions of the resulting array is collapsed depending on the specific expression. Use <code>get.pop.ex</code> if the expected result of the expression does not contain the age dimension, i.e. it uses no brackets or square brackets. If it is not the case, i.e. the expression is defined using curly braces in order to include the age dimension, the  <code>get.pop.exba</code> function is to be used. Argument <code>nr.traj</code> can be used to restrict the number of trajectories returned. Use one of those functions if results for all countries (i.e. if using “XXX”) is desired. 
</p>
<p>Function <code>get.trajectory.indices</code> returns an array of indices that link back to the given probabilistic component. It is of the same length as number of trajectories in the prediction object. For example, an array of <code>c(10, 15, 20)</code> (for a prediction with three trajectories) obtained with <code>what="TFR"</code> means that the 1st, 2nd and 3rd population trajectory, respectively, were generated with the 10th, 15th and 20th TFR trajectory, respectively. If the input TFR and e0 were generated using <code>bayesTFR</code> and <code>bayesLife</code>, functions <code>get.tfr.trajectories</code> and <code>get.e0.trajectories</code> can be used to extract the corresponding TFR and e0 trajectories.
</p>
<p>Function <code>extract.trajectories.eq</code> can be used to select a given number of trajectories of any population quantity, including vital events, that are close to either specific values or to a given quantile. For example the default seting with <code>quant=0.5</code> and <code>nr.traj=1</code> returns the one trajectory that is “closest” to the median projection. As a measure of “closeness” the sum of absolute differences (across all time periods) is used. 
</p>
<p>Similarly, function <code>extract.trajectories.ge</code> (<code>extract.trajectories.le</code>) selects all trajectories that are greater (less) equal to the specific values or a given quantile. The argument <code>all</code> specifies, if the greater/less condition should be valid for all time periods of the selected trajectories or at least one time period. 
</p>


<h3>Value</h3>

<p>Function <code>pop.trajectories</code> returns a two-dimensional array (time x trajectory).
</p>
<p>Function <code>get.pop</code> returns an array of four dimensions (country x age x time x trajectory). See pop.expressions for more details.
</p>
<p>Functions <code>get.pop.ex</code> and <code>get.pop.exba</code> return an array of trajectories. Its dimensions depend on the expression and whether it is evaluated on observed data or projections. If <code>as.dt</code> is <code>TRUE</code> these functions return <code>data.table</code> objects in long format.
</p>
<p>Function <code>get.trajectory.indices</code> returns a 1-d array of indices. If the given component is deterministic, it returns <code>NULL</code>. 
</p>
<p>Functions <code>extract.trajectories.eq</code>, <code>extract.trajectories.ge</code>, <code>extract.trajectories.le</code> return a list with two components. <code>trajectories</code>: 2-d array of trajectories; <code>index</code>: indices of the selected trajectories relative to the whole set of available trajectories.  
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p>pop.expressions
</p>


<h3>Examples</h3>

<pre><code class="language-R">sim.dir &lt;- file.path(find.package("bayesPop"), "ex-data", "Pop")
pred &lt;- get.pop.prediction(sim.dir, write.to.cache=FALSE)

# observed female of Netherlands by age; 1x21x15x1 array
popFNL &lt;- get.pop("PNL_F{}", pred, observed=TRUE)

# observed population for all countries in the prediction object,
# here 2 countries; 2x1x15x1 array
popAll &lt;- get.pop("PXXX", pred, observed=TRUE)

# future migration for all countries in the prediction object,
# here 2 countries; 2x17 array
migAll &lt;- get.pop.ex("GXXX", pred)

# projection population for Ecuador with 3 trajectories; 
# 1x1x17x3 array
popEcu &lt;- get.pop("P218", pred, observed=FALSE)

# the above is equivalent to 
popEcu2 &lt;- pop.trajectories(pred, "Ecuador")

# Expression "PNL_F{} / PNL_M{}" evaluated on projections
# is internally replaced by
FtoM &lt;- get.pop("PNL_F{}", pred) / get.pop("PNL_M{}", pred)
# should return the same result as
FtoMa &lt;- get.pop.exba("PNL_F{} / PNL_M{}", pred)

# the same expression by time (summed over ages) 
FtoMt &lt;- get.pop.ex("PNL_F / PNL_M", pred)

# the example simulation was generated with 3 TFR trajectories ...
get.trajectory.indices(pred, "Netherlands", what="TFR")
# ... and 1 e0 trajectory 
get.trajectory.indices(pred, "Netherlands", what="e0M")

# The three trajectories of the population ratio of Ecuador to Netherlands
get.pop.ex("PEC/PNL", pred)
# Returns the trajectory closest to the upper 80% bound, including the corresponding index
extract.trajectories.eq(pred, expression="PEC/PNL", quant=0.9)
# Returns the median trajectory and the high variant, including the corresponding index
extract.trajectories.ge(pred, expression="PEC/PNL", quant=0.45)
</code></pre>


</div>