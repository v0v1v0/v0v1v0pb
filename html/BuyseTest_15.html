<div class="container">

<table style="width: 100%;"><tr>
<td>auc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimation of the Area Under the ROC Curve (EXPERIMENTAL)</h2>

<h3>Description</h3>

<p>Estimation of the Area Under the ROC curve, possibly after cross validation,
to assess the discriminant ability of a biomarker regarding a disease status.
</p>


<h3>Usage</h3>

<pre><code class="language-R">auc(
  labels,
  predictions,
  fold = NULL,
  observation = NULL,
  direction = "&gt;",
  add.halfNeutral = TRUE,
  null = 0.5,
  conf.level = 0.95,
  transformation = TRUE,
  order.Hprojection = 2,
  pooling = "mean"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>labels</code></td>
<td>
<p>[integer/character vector] the disease status (should only take two different values).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predictions</code></td>
<td>
<p>[numeric vector] A vector with the same length as <code>labels</code> containing the biomarker values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fold</code></td>
<td>
<p>[character/integer vector] If using cross validation, the index of the fold. 
Should have the same length as <code>labels</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>observation</code></td>
<td>
<p>[integer vector] If using cross validation, the index of the corresponding observation in the original dataset.
Necessary to compute the standard error when using cross validation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>direction</code></td>
<td>
<p>[character] <code>"&gt;"</code> lead to estimate P[Y&gt;X],
<code>"&lt;"</code> to estimate P[Y&lt;X],
and <code>"auto"</code> to estimate max(P[Y&gt;X],P[Y&lt;X]).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add.halfNeutral</code></td>
<td>
<p>[logical] should half of the neutral score be added to the favorable and unfavorable scores?
Useful to match the usual definition of the AUC in presence of ties.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>null</code></td>
<td>
<p>[numeric, 0-1] the value against which the AUC should be compared when computing the p-value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.level</code></td>
<td>
<p>[numeric, 0-1] the confidence level of the confidence intervals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transformation</code></td>
<td>
<p>[logical] should a log-log transformation be used when computing the confidence intervals and the p-value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order.Hprojection</code></td>
<td>
<p>[1,2] the order of the H-projection used to linear the statistic when computing the standard error.
2 is involves more calculations but is more accurate in small samples. Only active when the <code>fold</code> argument is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pooling</code></td>
<td>
<p>[character] method used to compute the global AUC from the fold-specific AUC: either an empirical average <code>"mean"</code>
or a weighted average with weights proportional to the number of pairs of observations in each fold <code>"pairs"</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The iid decomposition of the AUC is based on a first order decomposition.
So its squared value will not exactly match the square of the standard error estimated with a second order H-projection.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>BuyseTestAUC</code> that inherits from data.frame.
The last line of the object contains the global AUC value with its standard error.
</p>


<h3>References</h3>

<p>Erin LeDell, Maya Petersen, and Mark van der Laan (2015). <b>Computationally efficient confidence intervals for cross-validated area under the ROC curve estimates</b>. <em>Electron J Stat.</em> 9(1):1583â€“1607. <br></p>


<h3>Examples</h3>

<pre><code class="language-R">library(data.table)

n &lt;- 200
set.seed(10)
X &lt;- rnorm(n)
dt &lt;- data.table(Y = as.factor(rbinom(n, size = 1, prob = 1/(1+exp(1/2-X)))),
                 X = X,
                 fold = unlist(lapply(1:10,function(iL){rep(iL,n/10)})))

## compute auc
auc(labels = dt$Y, predictions = dt$X, direction = "&gt;")

## compute auc after 10-fold cross-validation
auc(labels = dt$Y, prediction = dt$X, fold = dt$fold, observation = 1:NROW(dt))

</code></pre>


</div>