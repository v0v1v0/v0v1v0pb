<div class="container">

<table style="width: 100%;"><tr>
<td>bess</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Best subset selection</h2>

<h3>Description</h3>

<p>Best subset selection for generalized linear model and Cox's proportional model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bess(x, y, family = c("gaussian", "binomial", "cox"),
     method = "gsection", s.min = 1,
     s.max,
     s.list,
     K.max = 20,
     max.steps = 15,
     glm.max = 1e6,
     cox.max = 20,
	 factor = NULL,
     epsilon = 1e-4,
	 weights=rep(1,nrow(x)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Input matrix,of dimension n x p; each row is an observation vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Response variable,of length n. For family="binomial" should be a factor with two levels.
For family="cox", y should be a two-column matrix with columns named 'time' and 'status'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>One of the GLM or Cox models. Either "gaussian", "binomial", or "cox", depending on the response.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Methods tobe used to select the optimal model size. For method = "<code>sequential</code>", we solve the best subset selection problem for each <code class="reqn">s</code> in <code class="reqn">1,2,\dots,s_{max}</code>. At each model size <code class="reqn">s</code>, we run the <code>bess</code> function with a warm start from the last solution with model size <code class="reqn">s-1</code>. For method = "<code>gsection</code>", we solve the best subset selection problem with a range non-coninuous model sizes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s.min</code></td>
<td>
<p>The minimum value of model sizes. Only used for method = "<code>gsection</code>". Default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s.max</code></td>
<td>
<p>The maximum value of model sizes. Only used for method = "<code>gsection</code>". Default is <code class="reqn">\min{p, n/\log(n)}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s.list</code></td>
<td>
<p>A list of sequential value representing the model sizes. Only used for method = "<code>sequential</code>".Default is <code class="reqn">(1,\min{p, n/\log(n)})</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K.max</code></td>
<td>
<p>The maximum iterations used for method = "<code>gsection</code>"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.steps</code></td>
<td>
<p>The maximum number of iterations in <code>bess</code> function. In linear regression, only a few steps can gurantee the convergence. Default is 15.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>glm.max</code></td>
<td>
<p>The maximum number of iterations for solving the maximum likelihood problem on the active set at each step in the primal dual active set algorithm.Only used in the logistic regression for family="binomial". Default is 1e6.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cox.max</code></td>
<td>
<p>The maximum number of iterations for solving the maximum partial likelihood problem on the active set at each step in the primal dual active set algorithm. Only used in Cox's model for family="cox". Default is 20.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>factor</code></td>
<td>
<p>Which variable to be factored. Should be NULL or a numeric vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>The tolerance for an early stoping rule in the method "sequential". The early stopping rule is defined as <code class="reqn">\|Y-X\beta\|/n \leq \epsilon</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Observation weights. Default is 1 for each observation</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The best subset selection problem with model size <code class="reqn">s</code> is
</p>
<p style="text-align: center;"><code class="reqn">\min_\beta -2 logL(\beta) \;\;{\rm s.t.}\;\; \|\beta\|_0 \leq s.</code>
</p>

<p>In the GLM case, <code class="reqn">logL(\beta)</code> is the log-likelihood function; In the Cox model, <code class="reqn">logL(\beta)</code> is the log parital likelihood function.
</p>
<p>For each candiate model size, the best subset selection problem is solved by the primal dual active set(PDAS) algorithm, see Wen et al(2017) for details. This algorithm utilizes an active set updating strategy via primal and dual vairables and fits the sub-model by exploiting the fact that their support set are non-overlap and complementary. For the case of method = "sequential", we run the PDAS algorithm for a list of sequential model sizes and use the estimate from last iteration as a warm start. For the case of method = "<code>gsection</code>", a golden section search technique is adopted to efficiently determine the optimal model size.
</p>


<h3>Value</h3>

<p>A list with class attribute 'bess' and named components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>Types of the model: "<code>bess_gaussian</code>" for linear model,"<code>bess_binomial</code>" for logistic model and "<code>bess_cox</code>" for Cox model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>The best fitting coefficients of size <code class="reqn">s=0,1,\dots,p</code> with the smallest loss function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The lambda value in the Lagrangian form of the best subset selection problem with model size of <code class="reqn">s</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bestmodel</code></td>
<td>
<p>The best fitted model, the class of which is "lm", "glm" or "coxph"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deviance</code></td>
<td>
<p>The value of <code class="reqn">-2\times logL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nulldeviance</code></td>
<td>
<p>The value of <code class="reqn">-2\times logL</code> for null model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>AIC</code></td>
<td>
<p>The value of <code class="reqn">-2\times logL + 2 \|\beta\|_0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BIC</code></td>
<td>
<p>The value of <code class="reqn">-2\times logL+ log(n) \|\beta\|_0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>EBIC</code></td>
<td>
<p>The value of <code class="reqn">-2\times logL+ (log(n)+2\times log(p)) \|\beta\|_0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>factor</code></td>
<td>
<p>Which variable to be factored. Should be NULL or a numeric vector.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Canhong Wen, Aijun Zhang, Shijie Quan, and Xueqin Wang.
</p>


<h3>References</h3>

<p>Wen, C., Zhang, A., Quan, S. and Wang, X. (2020). BeSS: An R Package for Best Subset Selection in Linear, Logistic and Cox Proportional Hazards Models, <em>Journal of Statistical Software</em>, Vol. 94(4).  doi:10.18637/jss.v094.i04.
</p>


<h3>See Also</h3>

<p><code>bess.one</code>, <code>plot.bess</code>,
<code>predict.bess</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#--------------linear model--------------#
# Generate simulated data
n &lt;- 500
p &lt;- 20
K &lt;-10
sigma &lt;- 1
rho &lt;- 0.2
data &lt;- gen.data(n, p, family = "gaussian", K, rho, sigma)

# Best subset selection
fit1 &lt;- bess(data$x, data$y, family = "gaussian")
print(fit1)
#coef(fit1, sparse=TRUE)  # The estimated coefficients
bestmodel &lt;- fit1$bestmodel
#summary(bestmodel)

# Plot solution path and the loss function
plot(fit1, type = "both", breaks = TRUE)

## Not run:
#--------------logistic model--------------#

# Generate simulated data
data &lt;- gen.data(n, p, family="binomial", 5, rho, sigma)

# Best subset selection
fit2 &lt;- bess(data$x, data$y, s.list = 1:10, method = "sequential",
             family = "binomial", epsilon = 0)
print(fit2)
#coef(fit2, sparse = TRUE)
bestmodel &lt;- fit2$bestmodel
#summary(bestmodel)

# Plot solution path and the loss function
plot(fit2, type = "both", breaks = TRUE, K = 5)

#--------------cox model--------------#

# Generate simulated data
data &lt;- gen.data(n, p, 5, rho, sigma, c = 10, family = "cox", scal = 10)

# Best subset selection
fit3 &lt;- bess(data$x, data$y, s.list = 1:10, method = "sequential",
             family = "cox")
print(fit3)
#coef(fit3, sparse = TRUE)
bestmodel &lt;- fit3$bestmodel
#summary(bestmodel)

# Plot solution path and the loss function
plot(fit3, type = "both", breaks = TRUE, K = 5)


#----------------------High dimensional linear models--------------------#

p &lt;- 1000
data &lt;- gen.data(n, p, family = "gaussian", K, rho, sigma)

# Best subset selection
fit &lt;- bess(data$x, data$y, method="sequential", family = "gaussian", epsilon = 1e-12)

# Plot solution path
plot(fit, type = "both", breaks = TRUE, K = 10)


data("prostate")
x = prostate[,-9]
y = prostate[,9]

fit.group = bess(x, y, s.list = 1:ncol(x), factor = c("gleason"))


#---------------SAheart---------------#
data("SAheart")
y = SAheart[,5]
x = SAheart[,-5]
x$ldl[x$ldl&lt;5] = 1
x$ldl[x$ldl&gt;=5&amp;x$ldl&lt;10] = 2
x$ldl[x$ldl&gt;=10] = 3

fit.group = bess(x, y, s.list = 1:ncol(x), factor = c("ldl"), family = "binomial")
## End(Not run)
</code></pre>


</div>