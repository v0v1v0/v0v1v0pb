<div class="container">

<table style="width: 100%;"><tr>
<td>dc.BuildCBSFromCBTAndDates</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Build CBS matrix from CBT matrix</h2>

<h3>Description</h3>

<p>Given a customer-by-time matrix, yields the resulting
customer-by-sufficient-statistic matrix.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dc.BuildCBSFromCBTAndDates(cbt, dates, per, cbt.is.during.cal.period = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cbt</code></td>
<td>
<p>customer-by-time matrix. This is a matrix consisting of a row per
customer and a column per time period. It should contain numeric
information about a customer's transactions in every time period - either
the number of transactions in that time period (frequency), a 1 to indicate
that at least 1 transaction occurred (reach), or the average/total amount
spent in that time period.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dates</code></td>
<td>
<p>if cbt.is.during.cal.period is TRUE, then dates is a data
frame with three columns: 1. the dates when customers made their first
purchases 2. the dates when customers made their last purchases 3. the date
of the end of the calibration period. if cbt.is.during.cal.period is FALSE,
then dates is a vector with two elements: 1. the date of the beginning of
the holdout period 2. the date of the end of the holdout period.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>per</code></td>
<td>
<p>interval of time for customer-by-sufficient-statistic matrix.
May be "day", "week", "month", "quarter", or "year".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cbt.is.during.cal.period</code></td>
<td>
<p>if TRUE, indicates the customer-by-time
matrix is from the calibration period. If FALSE, indicates the
customer-by-time matrix is from the holdout period.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The customer-by-sufficient statistic matrix will contain the sum of the
statistic included in the customer-by-time matrix (see the cbt parameter),
the customer's last transaction date, and the total time period for which the
customer was observed.
</p>


<h3>Value</h3>

<p>Customer-by-sufficient-statistic matrix, with three columns:
frequency("x"), recency("t.x") and total time observed("T.cal"). See
details. Frequency is total transactions, not repeat transactions.
</p>


<h3>Examples</h3>

<pre><code class="language-R">elog &lt;- dc.ReadLines(system.file("data/cdnowElog.csv", package="BTYD"),2,3,5)
elog[,"date"] &lt;- as.Date(elog[,"date"], "%Y%m%d")

# Transaction-flow models are about interpurchase times. Since we
# only know purchase times to the day, we merge all transaction on
# the same day. This example uses dc.MergeTransactionsOnSameDate
# to illustrate this; however, we could have simply used dc.CreateReachCBT
# instead of dc.CreateFreqCBT to obtain the same result.
merged.elog &lt;- dc.MergeTransactionsOnSameDate(elog)
cutoff.date &lt;- as.Date("1997-09-30")
freq.cbt &lt;- dc.CreateFreqCBT(merged.elog)
cal.freq.cbt &lt;- freq.cbt[,as.Date(colnames(freq.cbt)) &lt;= cutoff.date]
holdout.freq.cbt &lt;- freq.cbt[,as.Date(colnames(freq.cbt)) &gt; cutoff.date]

cal.start.dates.indices &lt;- dc.GetFirstPurchasePeriodsFromCBT(cal.freq.cbt)
cal.start.dates &lt;- as.Date(colnames(cal.freq.cbt)[cal.start.dates.indices])
cal.end.dates.indices &lt;- dc.GetLastPurchasePeriodsFromCBT(cal.freq.cbt)
cal.end.dates &lt;- as.Date(colnames(cal.freq.cbt)[cal.end.dates.indices])
T.cal.total &lt;- rep(cutoff.date, nrow(cal.freq.cbt))
cal.dates &lt;- data.frame(cal.start.dates, 
                        cal.end.dates, 
                        T.cal.total)

# Create calibration period customer-by-sufficient-statistic data frame,
# using weeks as the unit of time.
cal.cbs &lt;- dc.BuildCBSFromCBTAndDates(cal.freq.cbt, 
                                      cal.dates,
                                      per="week", 
                                      cbt.is.during.cal.period=TRUE)
# Force the calibration period customer-by-sufficient-statistic to only contain
# repeat transactions (required by BG/BB and Pareto/NBD models)
cal.cbs[,"x"] &lt;- cal.cbs[,"x"] - 1

holdout.start &lt;- cutoff.date+1
holdout.end &lt;- as.Date(colnames(holdout.freq.cbt)[ncol(holdout.freq.cbt)])
holdout.dates &lt;- c(holdout.start, holdout.end)

# Create holdout period customer-by-sufficient-statistic data frame, using weeks
# as the unit of time.
holdout.cbs &lt;- dc.BuildCBSFromCBTAndDates(holdout.freq.cbt, 
                                          holdout.dates,
                                          per="week", 
                                          cbt.is.during.cal.period=FALSE)                        
</code></pre>


</div>