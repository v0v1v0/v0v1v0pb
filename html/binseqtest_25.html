<div class="container">

<table style="width: 100%;"><tr>
<td>designOBF</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Design Sequential Binary Boundary
</h2>

<h3>Description</h3>

<p>There are several functions that create binary sequential boundaries. The function <code>designAb</code> allows great flexibility in creating 
user defined boundaries. The functions <code>designOBF</code> and <code>designOBFpower</code> create boudaries of the O-Brien-Fleming type, extending those 
boundaries to allow looks after every observation. The former (<code>designOBF</code>) uses a user defined maximum number of observations (Nmax), while 
the latter  (<code>designOBFpower</code>) uses the power argument to try to find a design with a smaller maximum that achieves the desired power. 
The functions <code>designFixed</code> and <code>designFixedpower</code> are analogous for fixed sample designs. The function <code>designSimon</code> uses the <code>ph2simon</code>
from the <span class="pkg">clinfun</span> package to create boundaries using Simon's (1989) two-stage design.
</p>


<h3>Usage</h3>

<pre><code class="language-R">
designAb(Nk, a = NULL, b = NULL, theta0 = NULL, 
    tsalpha = NULL, alternative = "two.sided", 
    conf.level = 0.95, binding = "both")

designOBF(Nmax,theta0 = 0.5,  k = Inf,  tsalpha = NULL,
    alternative = "two.sided", conf.level = 0.95, 
    binding = "both")
designOBFpower(theta0 = 0.5, theta1=.6,  k=Inf,
    power=.9, tsalpha = NULL, alternative = "two.sided",
    conf.level = 0.95, binding = "both", allNgreater=FALSE,
    checkmax=10, maxNmax=2*ss)

designFixed(Nmax, theta0 = 0.5, tsalpha = NULL, 
    alternative = "two.sided", conf.level = 0.95)
designFixedpower(theta0 = 0.5, theta1 = 0.6, power = 0.8,
    maxNmax = Inf, tsalpha = NULL, alternative = NULL,
    conf.level = 0.95, allNgreater = FALSE)

designSimon(theta0, theta1, alpha = 0.05, beta = 0.2, 
    type = c("optimal", "minimax"), nmax=100)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Nk</code></td>
<td>
<p>vector of unique N values where there is stopping</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>numeric vector with length(a)=length(Nk)-1, stop if number of successes out of Nk[i] is less than or equal to a[i] (see details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>numeric vector with length(a)=length(Nk)-1, stop if number of successes out of Nk[i] is greater than or equal to b[i] (see details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nmax</code></td>
<td>
<p>maximum number of observations for the design</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxNmax</code></td>
<td>
<p>maximum number for Nmax (see details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>number of looks at the data, Inf denotes looking after each observation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta0</code></td>
<td>
<p>probability of success under the null</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tsalpha</code></td>
<td>
<p>vector of length 2 with nominal significance levels for each side, if not NULL overrides <code>conf.level</code> and <code>alternative</code> 
(see <code>getTSalpha</code>)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.level</code></td>
<td>
<p>confidence level, ignored if tsalpha is not NULL</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alternative</code></td>
<td>
<p>character, alternative hypothesis, either 'less', 'greater' or 'two.sided' </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>binding</code></td>
<td>
<p>character, which sides are binding: 'both', 'upper', or 'lower'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta1</code></td>
<td>
<p>probability of success under alternative for power calculations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>power</code></td>
<td>
<p>nominal power, boundary strives to have power under the alternative at least equal to power</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allNgreater</code></td>
<td>
<p>logical, if TRUE max(N) will be at least as large as the fixed sample size for which all greater N have power&gt;power</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>checkmax</code></td>
<td>
<p>integer, on the iteration  checkmax, check that Nmax has power at least power</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>one sided alpha level for test theta&gt;theta0</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>1-power, for theta1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>character, type of 2-stage design, either 'optimal' or 'minimax'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nmax</code></td>
<td>
<p>maximum total sample size, cannot be higher than 1000</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>tsalpha</code>, <code>alternative</code>, and <code>conf.level</code> are input into the <code>getTSalpha</code> function to output a <code>tsalpha</code> vector. The <code>tsalpha</code> 
vector allows the nominal error to be different on each side. For details see <code>getTSalpha</code>.
</p>
<p>For <code>designAb</code>, when you do not want to stop on the lower or upper boundary at any value of Nk, the associated value of a (lower) or b (upper) should be NA. 
</p>
<p>The <code>designOBF</code> function calculates a boundary that stops whenever the B-value (Lan and Wittes, 1988) is larger than one cutoff value or smaller than a different cutoff value. 
The cutoff values are chosen so that the probability of spending alpha on the appropriate side 
is almost all spent while still rejecting at at least one end value of the boundary. 
</p>
<p>The function <code>designOBFpower</code> repeatedly calls <code>designOBF</code> and finds the design that 
gives sufficient power under a given alternative. Specifically, by setting  
Nmax to Nmaxi in <code>designOBF</code>, where Nmaxi is increased by 1 at each iteration. The initial Nmaxi is either 
the first N that gives a large enough power in the fixed sample size design (allNgreater==FALSE) or the first N such that all larger N will give enough power for fixed samples (allNgreater==TRUE). 
On the <code>(checkmax)</code>th iteration, check that the power will be large enough when Nmaxi equals Nmax (from designOBFpower call). 
So if you set <code>checkmax</code>=1 then you will
check the largest value of Nmax first, but this may be inefficient since larger values of Nmax in the <code>obf</code> call are slower.  
</p>
<p>See Kirk and Fay (2014) for an introductory paper about exact binary sequential tests using the binseqtest package.
</p>


<h3>Value</h3>

<p>a object of class <code>boundEst</code>
</p>


<h3>References</h3>

<p>Kirk, J, and Fay, MP (2014). An Introduction to Practical Sequential Inferences via Single Arm Binary Response Studies Using the binseqtest R Package. (to appear in American Statistician).
</p>
<p>Lan, KKG, and Wittes, J (1988). The B-Value: A Tool for Monitoring Data. Biometrics 44:579-585.
</p>
<p>Simon R. (1989). Optimal Two-Stage Designs for Phase II Clinical Trials. Controlled Clinical Trials 10, 1-10. 
</p>


</div>