<div class="container">

<table style="width: 100%;"><tr>
<td>%%COMPUTE%%</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multivariate computation.</h2>

<h3>Description</h3>

<p>Easily compute multivariate sum, mean, and other scores.
Reverse scoring can also be easily implemented without saving extra variables.
<code>Alpha</code> function uses a similar method to deal with reverse scoring.
</p>
<p>Three ways to specify variables:
</p>

<ol>
<li> <p><strong><code>var + items</code></strong>: common and unique parts of variable names (suggested).
</p>
</li>
<li> <p><strong><code>vars</code></strong>: a character vector of variable names (suggested).
</p>
</li>
<li> <p><strong><code>varrange</code></strong>: starting and stopping positions of variables (NOT suggested).
</p>
</li>
</ol>
<h3>Usage</h3>

<pre><code class="language-R">COUNT(data, var = NULL, items = NULL, vars = NULL, varrange = NULL, value = NA)

MODE(data, var = NULL, items = NULL, vars = NULL, varrange = NULL)

SUM(
  data,
  var = NULL,
  items = NULL,
  vars = NULL,
  varrange = NULL,
  rev = NULL,
  range = likert,
  likert = NULL,
  na.rm = TRUE
)

.sum(
  var = NULL,
  items = NULL,
  vars = NULL,
  varrange = NULL,
  rev = NULL,
  range = likert,
  likert = NULL,
  na.rm = TRUE
)

MEAN(
  data,
  var = NULL,
  items = NULL,
  vars = NULL,
  varrange = NULL,
  rev = NULL,
  range = likert,
  likert = NULL,
  na.rm = TRUE
)

.mean(
  var = NULL,
  items = NULL,
  vars = NULL,
  varrange = NULL,
  rev = NULL,
  range = likert,
  likert = NULL,
  na.rm = TRUE
)

STD(
  data,
  var = NULL,
  items = NULL,
  vars = NULL,
  varrange = NULL,
  rev = NULL,
  range = likert,
  likert = NULL,
  na.rm = TRUE
)

CONSEC(
  data,
  var = NULL,
  items = NULL,
  vars = NULL,
  varrange = NULL,
  values = 0:9
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var</code></td>
<td>
<p><strong>[Option 1]</strong>
Common part across variables: e.g., <code>"RSES"</code>, <code>"XX.{i}.pre"</code>
(if <code>var</code> string has any placeholder in braces <code>{...}</code>,
then <code>items</code> will be pasted into the braces, see examples)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>items</code></td>
<td>
<p><strong>[Option 1]</strong>
Unique part across variables: e.g., <code>1:10</code>, <code>c("a", "b", "c")</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vars</code></td>
<td>
<p><strong>[Option 2]</strong>
Character vector specifying variables: e.g., <code>c("X1", "X2", "X3", "X4", "X5")</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varrange</code></td>
<td>
<p><strong>[Option 3]</strong>
Character string specifying positions ("start:stop") of variables: e.g., <code>"A1:E5"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>[Only for <code>COUNT</code>] The value to be counted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rev</code></td>
<td>
<p>[Optional] Variables that need to be reversed. It can be
(1) a character vector specifying the reverse-scoring variables (recommended), or
(2) a numeric vector specifying the item number of reverse-scoring variables (not recommended).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>range, likert</code></td>
<td>
<p>[Optional] Range of likert scale: e.g., <code>1:5</code>, <code>c(1, 5)</code>.
If not provided, it will be automatically estimated from the given data (BUT you should use this carefully).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>Ignore missing values. Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>values</code></td>
<td>
<p>[Only for <code>CONSEC</code>] Values to be counted as consecutive identical values. Defaults to all numbers (<code>0:9</code>).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A vector of computed values.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>COUNT()</code>: <strong>Count</strong> a certain value across variables.
</p>
</li>
<li> <p><code>MODE()</code>: Compute <strong>mode</strong> across variables.
</p>
</li>
<li> <p><code>SUM()</code>: Compute <strong>sum</strong> across variables.
</p>
</li>
<li> <p><code>.sum()</code>: Tidy version of <code>SUM</code>,
only can be used in <code>add()/added()</code>
</p>
</li>
<li> <p><code>MEAN()</code>: Compute <strong>mean</strong> across variables.
</p>
</li>
<li> <p><code>.mean()</code>: Tidy version of <code>MEAN</code>,
only can be used in <code>add()/added()</code>
</p>
</li>
<li> <p><code>STD()</code>: Compute <strong>standard deviation</strong> across variables.
</p>
</li>
<li> <p><code>CONSEC()</code>: Compute <strong>consecutive identical digits</strong> across variables (especially useful in detecting careless responding).
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">d = data.table(
  x1 = 1:5,
  x4 = c(2,2,5,4,5),
  x3 = c(3,2,NA,NA,5),
  x2 = c(4,4,NA,2,5),
  x5 = c(5,4,1,4,5)
)
d
## I deliberately set this order to show you
## the difference between "vars" and "varrange".

## ====== Usage 1: data.table `:=` ====== ##
d[, `:=`(
  na = COUNT(d, "x", 1:5, value=NA),
  n.2 = COUNT(d, "x", 1:5, value=2),
  sum = SUM(d, "x", 1:5),
  m1 = MEAN(d, "x", 1:5),
  m2 = MEAN(d, vars=c("x1", "x4")),
  m3 = MEAN(d, varrange="x1:x2", rev="x2", range=1:5),
  cons1 = CONSEC(d, "x", 1:5),
  cons2 = CONSEC(d, varrange="x1:x5")
)]
d

## ====== Usage 2: `add()` &amp; `added()` ====== ##
data = as.data.table(psych::bfi)
added(data, {
  gender = as.factor(gender)
  education = as.factor(education)
  E = .mean("E", 1:5, rev=c(1,2), range=1:6)
  A = .mean("A", 1:5, rev=1, range=1:6)
  C = .mean("C", 1:5, rev=c(4,5), range=1:6)
  N = .mean("N", 1:5, range=1:6)
  O = .mean("O", 1:5, rev=c(2,5), range=1:6)
}, drop=TRUE)
data

## ====== New Feature for `var` &amp; `items` ====== ##
d = data.table(
  XX.1.pre = 1:5,
  XX.2.pre = 6:10,
  XX.3.pre = 11:15
)
add(d, { XX.mean = .mean("XX.{i}.pre", 1:3) })
add(d, { XX.mean = .mean("XX.{items}.pre", 1:3) })  # the same
add(d, { XX.mean = .mean("XX.{#$%^&amp;}.pre", 1:3) })  # the same

</code></pre>


</div>