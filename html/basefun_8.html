<div class="container">

<table style="width: 100%;"><tr>
<td>b</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Box Product of Basis Functions
</h2>

<h3>Description</h3>

<p>Box product of two basis functions
</p>


<h3>Usage</h3>

<pre><code class="language-R">b(..., sumconstr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>named objects of class <code>basis</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sumconstr</code></td>
<td>
<p>a logical indicating if sum constraints shall be applied</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>b()</code> joins the corresponding design matrices 
by the row-wise Kronecker (or box) product.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
  ### set-up a Bernstein polynomial
  xv &lt;- numeric_var("x", support = c(1, pi))
  bb &lt;- Bernstein_basis(xv, order = 3, ui = "increasing")
  ## and treatment contrasts for a factor at three levels
  fb &lt;- as.basis(~ g, data = factor_var("g", levels = LETTERS[1:3]))
  
  ### join them: we get one intercept and two deviation _functions_
  bfb &lt;- b(bern = bb, f = fb)

  ### generate data + coefficients
  x &lt;- expand.grid(mkgrid(bfb, n = 10))
  cf &lt;- c(1, 2, 2.5, 2.6)
  cf &lt;- c(cf, cf + 1, cf + 2)

  ### evaluate bases
  model.matrix(bfb, data = x)

  ### plot functions
  plot(x$x, predict(bfb, newdata = x, coef = cf), type = "p",
       pch = (1:3)[x$g])
  legend("bottomright", pch = 1:3, 
         legend = colnames(model.matrix(fb, data = x)))

</code></pre>


</div>