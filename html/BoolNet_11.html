<div class="container">

<table style="width: 100%;"><tr>
<td>generateTimeSeries</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Generate time series from a network
</h2>

<h3>Description</h3>

<p>Generates time series by simulating successive state transitions from random start states. In addition, the resulting matrices can be perturbed by Gaussian noise.
</p>


<h3>Usage</h3>

<pre><code class="language-R">generateTimeSeries(network, 
                   numSeries, 
                   numMeasurements, 
                   type = c("synchronous","asynchronous","probabilistic"),
                   geneProbabilities, 
                   perturbations = 0,
                   noiseLevel = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>network</code></td>
<td>

<p>An object of class <code>BooleanNetwork</code> or <code>SymbolicBooleanNetwork</code> that contains the network for which time series are generated
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numSeries</code></td>
<td>

<p>The number of random start states used to generate successive series of states, that is, the number of time series matrices to generate
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numMeasurements</code></td>
<td>

<p>The number of states in each of the time series matrices. The first state of each time series is the randomly generated start state. The remaining <code>numMeasurements - 1</code> states are obtained by successive state transitions.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>

<p>The type of state transitions to be performed (see <code>stateTransition</code>)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geneProbabilities</code></td>
<td>

<p>An optional vector of probabilities for the genes if <code>type="asynchronous"</code>. By default, each gene has the same probability to be chosen for the next state transition. These probabilities can be modified by supplying a vector of probabilities for the genes which sums up to one.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perturbations</code></td>
<td>

<p>If this argument has a value greater than 0, artificial perturbation experiments are generated. That is, <code>perturbations</code> genes in each time series are knocked out or overexpressed artificially using the <code>fixGenes</code> function.   
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noiseLevel</code></td>
<td>

<p>If this is non-zero, it specifies the standard deviation of the Gaussian noise which is added to all entries of the time series matrices. By default, no noise is added to the time series.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list of matrices, each corresponding to one time series. Each row of these matrices contains measurements for one gene on a time line, i. e. column <code>i+1</code> contains the successor states of column <code>i+1</code>. If <code>noiseLevel</code> is non-zero, the matrices contain real values, otherwise they contain only 0 and 1. 
</p>
<p>If <code>perturbations&gt;0</code>, the result list contains an additional matrix <code>perturbations</code> specifying the artificial perturbations applied to the different time series. This matrix has <code>numSeries</code> columns and one row for each gene in the network. A matrix entry is 0 for a knock-out of the corresponding gene in the corresponding time series, 1 for overexpression, and NA for no perturbation.
</p>
<p>The result format is compatible with the input parameters of <code>binarizeTimeSeries</code>  and <code>reconstructNetwork</code>.
</p>


<h3>See Also</h3>

<p><code>stateTransition</code>, <code>binarizeTimeSeries</code>, <code>reconstructNetwork</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# generate noisy time series from the cell cycle network
data(cellcycle)
ts &lt;- generateTimeSeries(cellcycle, numSeries=50, numMeasurements=10, noiseLevel=0.1)

# binarize the noisy time series
bin &lt;- binarizeTimeSeries(ts, method="kmeans")$binarizedMeasurements

# reconstruct the network
print(reconstructNetwork(bin, method="bestfit"))

## End(Not run)
</code></pre>


</div>