<div class="container">

<table style="width: 100%;"><tr>
<td>bdm.ptsne</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Parallelized t-SNE</h2>

<h3>Description</h3>

<p>Starts the ptSNE algorithm (first step of the mapping protocol).
</p>


<h3>Usage</h3>

<pre><code class="language-R">bdm.ptsne(bdm, threads = 3, type = "SOCK", layers = 2, rounds = 1,
  boost = 2, whiten = 4, input.dim = NULL, ppx = 100, itr = 100,
  tol = 1e-05, alpha = 0.5, Y.init = NULL, info = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>bdm</code></td>
<td>
<p>A <var>bdm</var> instance as generated by <code>bdm.init()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threads</code></td>
<td>
<p>The number of parallel threads (in principle only limited by hardware resources, <code>i.e.</code> number of cores and available memory)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>The type of cluster: 'SOCK' (default) for intra-node parallelization, 'MPI' (<code>message passing interface</code>) for inter-node parallelization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>layers</code></td>
<td>
<p>The number of layers (<code>minimum</code> 2, <code>maximum</code> the number of threads).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rounds</code></td>
<td>
<p>The number of rounds (2 by default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boost</code></td>
<td>
<p>A running time accelerator factor. By default (<code>boost == 1</code>). See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>whiten</code></td>
<td>
<p>Preprocessing of raw data. If <code>whiten = 4</code> (default value) raw data is transformed to principal components (PCA) and whitened afterwards. If <code>whiten = 3</code> only PCA is performed with NO whitening. If <code>whiten = 2</code> raw data is only centered and scaled. If <code>whiten = 1</code> raw data is only centered. If <code>whiten = 0</code> no preprocessing is performed at all.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>input.dim</code></td>
<td>
<p>If raw data is given as (or is transformed to) principal components, <var>input.dim</var> sets the number of principal components to be used as input dimensions. Otherwise all data columns are used as input dimensions. By default <code>input.dim = ncol(bdm$data)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ppx</code></td>
<td>
<p>The value of perplexity to compute similarities (100 by default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>itr</code></td>
<td>
<p>The number of iterations for computing input similarities (100 by default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>The tolerance lower bound for computing input similarities (1e-05 by default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>The momentum factor (0.5 by default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y.init</code></td>
<td>
<p>A <code>nx2</code> matrix with initial mapping positions. By default (<code>NULL</code>) will use random initial positions)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>info</code></td>
<td>
<p>Progress output information: 1 yields inter-round results for progressive analytics, 0 disables intermediate results. Default value is 1.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>By default the algorithm is structured in <code class="reqn">\sqrt{n}</code> epochs of <code class="reqn">\sqrt{z}</code> iterations each, where <var>n</var> is the dataset size and <var>z</var> is the thread-size (<code class="reqn">z=n*layers/threads</code>). The running time of the algorithm is then determined by <code class="reqn">epochs*iters*t_i+ epochs*t_e</code> where <var>t_i</var> is the running time of a single iteration and <var>t_e</var> is the inter-epoch running time.
</p>
<p>The <var>boost</var> factor is meant to reduce the running time. With <code class="reqn">boost &gt; 1</code> the algorithm is structured in <code class="reqn">n/boost</code> epochs with <code class="reqn">z*boost</code> iterations each. This structure performs the same total number of iterations but arranged into a lower number of epochs, thus decreasing the total running time to <code class="reqn">epochs*iters*t_i + 1/boost*epochs*t_e</code>. When the number of threads is high, the inter-epoch time can be high, in particular when using 'MPI' parallelization, thus, reducing the number of epochs can result in a significant reduction of the total running time. The counterpart is that increasing the number of iterations per epoch might result in a lack of convergence, thus the <var>boost</var> factor must be used with caution. To the most of our knowledge using values up to <code class="reqn">boost=2.5</code> is generally safe.
</p>
<p>In case of extremely large datasets, we strongly recommend to initialize the <var>bdm</var> instance with already preprocessed data and use <code>whiten = 0</code>. Fast principal components approximations can be computed by means of <var>e.g.</var> <code>flashpcaR</code> or <code>scater</code> R packages.
</p>


<h3>Value</h3>

<p>A copy of the input <var>bdm</var> instance with new element <var>bdm$ptsne</var> (t-SNE output).
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# --- load example dataset
bdm.example()
# --- perform ptSNE
## Not run: 
exMap &lt;- bdm.ptsne(exMap, threads = 10, layers = 2, rounds = 2, ppx = 200)

## End(Not run)
# --- plot the Cost function
bdm.cost(exMap)
# --- plot ptSNE output
bdm.ptsne.plot(exMap)
</code></pre>


</div>