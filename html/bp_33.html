<div class="container">

<table style="width: 100%;"><tr>
<td>sv</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Successive Variation (SV)</h2>

<h3>Description</h3>

<p>THIS IS A DEPRECATED FUNCTION. USE bp_sv INSTEAD.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sv(
  data,
  inc_date = FALSE,
  subj = NULL,
  bp_type = 0,
  add_groups = NULL,
  inc_wake = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Required argument. Pre-processed dataframe with SBP and DBP columns
with optional ID, VISIT, WAKE, and DATE columns if available.
Use <code>process_data</code> to properly format data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inc_date</code></td>
<td>
<p>Optional argument. Default is FALSE. As ABPM data typically
overlaps due to falling asleep on one date and waking up on another, the <code>inc_date</code>
argument is typically kept as FALSE, but the function will work regardless. Setting
<code>inc_date = TRUE</code> will include these dates as a grouping level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subj</code></td>
<td>
<p>Optional argument. Allows the user to specify and subset specific subjects
from the <code>ID</code> column of the supplied data set. The <code>subj</code> argument can be a single
value or a vector of elements. The input type should be character, but the function will
comply with integers so long as they are all present in the <code>ID</code> column of the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bp_type</code></td>
<td>
<p>Optional argument. Determines whether to calculate ARV for SBP
values or DBP values. Default is 0 corresponding to output for both SBP &amp; DBP.
For <strong>both</strong> SBP and DBP ARV values use bp_type = 0, for <strong>SBP-only</strong>
use bp_type = 1, and for <strong>DBP-only</strong> use bp_type = 2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add_groups</code></td>
<td>
<p>Optional argument. Allows the user to aggregate the data by an
additional "group" to further refine the output. The supplied input must be a
character vector with the strings corresponding to existing column names of the
processed <code>data</code> input supplied. Capitalization of <code>add_groups</code> does not matter.
Ex: <code>add_groups = c("Time_of_Day")</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inc_wake</code></td>
<td>
<p>Optional argument corresponding to whether or not to include <code>WAKE</code>
in the grouping of the final output (if <code>WAKE</code> column is available). By default,
<code>inc_wake = TRUE</code> which will include the <code>WAKE</code> column in the groups by which
to calculate the respective metrics.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Calculate the successive variation (SV) at various levels of granularity
based on what is supplied (ID, VISIT, WAKE, and / or DATE)for either SBP,
DBP, or both. SV is a measure of dispersion that takes into account the
temporal structure of the data and relies on the sum of squared differences
in successive observations, unlike the average real variability (ARV)
which relies on the sum of absolute differences.
$$SV = sqrt(sum(x_i+1 - x_i)^2/n-1)$$
</p>
<p><strong>NOTE:</strong> The canonical standard deviation, independent of the temporal
structure using the sample average, is added for comparison:
$$SD = sqrt(sum(x_i+1 - xbar)^2/n-1)$$
</p>


<h3>Value</h3>

<p>A tibble object with a row corresponding to each subject, or alternatively
a row corresponding to each date if inc_date = TRUE. The resulting tibble consists of:
</p>

<ul>
<li> <p><code>ID</code>: The unique identifier of the subject. For single-subject datasets, ID = 1
</p>
</li>
<li> <p><code>VISIT</code>: (If applicable) Corresponds to the visit # of the subject, if more than 1
</p>
</li>
<li> <p><code>WAKE</code>: (If applicable) Corresponds to the awake status of the subject (0 = asleep |
1 = awake)
</p>
</li>
<li> <p><code>SV_SBP</code> / <code>SV_DBP</code>: Calculates the square root of the average squared differences
between successive measurements. The resulting value averages across the granularity
grouping for however many observations are present.
</p>
</li>
<li>
<p> N: The number of observations for that particular grouping. If <code>inc_date = TRUE</code>,
<code>N</code> corresponds to the number of observations for that date. If <code>inc_date = FALSE</code>, N
corresponds to the number of observations for the most granular grouping available (i.e.
a combination of <code>ID</code>, <code>VISIT</code>, and <code>WAKE</code>)
</p>
</li>
<li>
<p> Any add_groups variables supplied to function argument will be present as a column in the
resulting tibble.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R"># Load data
data(bp_hypnos)
data(bp_jhs)

# Process bp_hypnos
hypnos_proc &lt;- process_data(bp_hypnos, sbp = "SYST", dbp = "DIAST", date_time = "date.time",
id = "id", wake = "wake", visit = "visit", hr = "hr", pp ="pp", map = "map", rpp = "rpp")
# Process bp_jhs data
jhs_proc &lt;- process_data(bp_jhs, sbp = "Sys.mmHg.", dbp = "Dias.mmHg.", date_time = "DateTime",
hr = "Pulse.bpm.")

# SV Calculation
## Not run: 
bp_sv(hypnos_proc)
bp_sv(jhs_proc, add_groups = c("meal_time"))
# Notice that meal_time is not a column from process_data, but it still works

## End(Not run)
</code></pre>


</div>