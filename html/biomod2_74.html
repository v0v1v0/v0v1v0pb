<div class="container">

<table style="width: 100%;"><tr>
<td>bm_CrossValidation</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Build cross-validation table</h2>

<h3>Description</h3>

<p>This internal <span class="pkg">biomod2</span> function allows to build a cross-validation table 
according to 6 different methods : <code>random</code>, <code>kfold</code>, <code>block</code>, <code>strat</code>, 
<code>env</code> or <code>user.defined</code> (see Details).
</p>


<h3>Usage</h3>

<pre><code class="language-R">bm_CrossValidation(
  bm.format,
  strategy = "random",
  nb.rep = 0,
  perc = 0.8,
  k = 0,
  balance = "presences",
  env.var = NULL,
  strat = "both",
  user.table = NULL,
  do.full.models = FALSE
)

bm_CrossValidation_user.defined(bm.format, ...)

## S4 method for signature 'BIOMOD.formated.data'
bm_CrossValidation_user.defined(bm.format, user.table)

## S4 method for signature 'BIOMOD.formated.data.PA'
bm_CrossValidation_user.defined(bm.format, user.table)

bm_CrossValidation_random(bm.format, ...)

## S4 method for signature 'BIOMOD.formated.data'
bm_CrossValidation_random(bm.format, nb.rep, perc)

## S4 method for signature 'BIOMOD.formated.data.PA'
bm_CrossValidation_random(bm.format, nb.rep, perc)

bm_CrossValidation_kfold(bm.format, ...)

## S4 method for signature 'BIOMOD.formated.data'
bm_CrossValidation_kfold(bm.format, nb.rep, k)

## S4 method for signature 'BIOMOD.formated.data.PA'
bm_CrossValidation_kfold(bm.format, nb.rep, k)

bm_CrossValidation_block(bm.format, ...)

## S4 method for signature 'BIOMOD.formated.data'
bm_CrossValidation_block(bm.format)

## S4 method for signature 'BIOMOD.formated.data.PA'
bm_CrossValidation_block(bm.format)

bm_CrossValidation_strat(bm.format, ...)

## S4 method for signature 'BIOMOD.formated.data'
bm_CrossValidation_strat(bm.format, balance, strat, k)

## S4 method for signature 'BIOMOD.formated.data.PA'
bm_CrossValidation_strat(bm.format, balance, strat, k)

bm_CrossValidation_env(bm.format, ...)

## S4 method for signature 'BIOMOD.formated.data'
bm_CrossValidation_env(bm.format, balance, k, env.var)

## S4 method for signature 'BIOMOD.formated.data.PA'
bm_CrossValidation_env(bm.format, balance, k, env.var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>bm.format</code></td>
<td>
<p>a <code>BIOMOD.formated.data</code> or <code>BIOMOD.formated.data.PA</code> 
object returned by the <code>BIOMOD_FormatingData</code> function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strategy</code></td>
<td>
<p>a <code>character</code> corresponding to the cross-validation selection strategy, 
must be among <code>random</code>, <code>kfold</code>, <code>block</code>, <code>strat</code>, <code>env</code> or 
<code>user.defined</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nb.rep</code></td>
<td>
<p>(<em>optional, default</em> <code>0</code>) <br>
If <code>strategy = 'random'</code> or <code>strategy = 'kfold'</code>, an <code>integer</code> corresponding 
to the number of sets (repetitions) of cross-validation points that will be drawn</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perc</code></td>
<td>
<p>(<em>optional, default</em> <code>0</code>) <br>
If <code>strategy = 'random'</code>, a <code>numeric</code> between <code>0</code> and <code>1</code> defining the 
percentage of data that will be kept for calibration</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>(<em>optional, default</em> <code>0</code>) <br>
If <code>strategy = 'kfold'</code> or <code>strategy = 'strat'</code> or <code>strategy = 'env'</code>, an 
<code>integer</code> corresponding to the number of partitions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>balance</code></td>
<td>
<p>(<em>optional, default</em> <code>'presences'</code>) <br> 
If <code>strategy = 'strat'</code> or <code>strategy = 'env'</code>, a <code>character</code> corresponding 
to how data will be balanced between partitions, must be either <code>presences</code> or 
<code>absence</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>env.var</code></td>
<td>
<p>(<em>optional</em>) <br> 
If <code>strategy = 'env'</code>, a <code>character</code> corresponding to the environmental variables 
used to build the partition. <code>k</code> partitions will be built for each environmental 
variables. <em>By default the function uses all environmental variables available.</em></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strat</code></td>
<td>
<p>(<em>optional, default</em> <code>'both'</code>) <br> 
If <code>strategy = 'env'</code>, a <code>character</code> corresponding to how data will partitioned 
along gradient, must be among <code>x</code>, <code>y</code>, <code>both</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>user.table</code></td>
<td>
<p>(<em>optional, default</em> <code>NULL</code>) <br>
If <code>strategy = 'user.defined'</code>, a <code>matrix</code> or <code>data.frame</code> defining for each 
repetition (in columns) which observation lines should be used for models calibration 
(<code>TRUE</code>) and validation (<code>FALSE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>do.full.models</code></td>
<td>
<p>(<em>optional, default</em> <code>TRUE</code>) <br>
A <code>logical</code> value defining whether models should be also calibrated and validated over 
the whole dataset (and pseudo-absence datasets) or not</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>(<em>optional, one or several of the following arguments depending on the 
selected method</em>)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Several parameters are available within the function and some of them can be used with 
different cross-validation strategies :
</p>
<p><code>| ....... | random | kfold | block | strat | env |</code> <br>
__________________________________________________ <br><code>| nb.rep. | x..... | x.... | ..... | ..... | ... |</code> <br><code>| perc... | x..... | ..... | ..... | ..... | ... |</code> <br><code>| k...... | ...... | x.... | ..... | x.... | x.. |</code> <br><code>| balance | ...... | ..... | ..... | x.... | x.. |</code> <br><code>| strat.. | ...... | ..... | ..... | x.... | ... |</code> <br><br><br></p>
<p><b>Concerning column names of <code>matrix</code> output :</b>
</p>
<p>The number of columns depends on the strategy selected. 
The column names are given <em>a posteriori</em> of the selection, ranging from 1 to the 
number of columns. 
If <code>do.full.models = TRUE</code>, columns merging runs (and/or pseudo-absence datasets) 
are added at the end. <br><br></p>
<p><b>Concerning cross-validation strategies :</b>
</p>

<dl>
<dt>random</dt>
<dd>
<p>Most simple method to calibrate and validate a model is to split the original 
dataset in two datasets : one to calibrate the model and the other one to validate it. The 
splitting can be repeated <code>nb.rep</code> times.</p>
</dd>
<dt>k-fold</dt>
<dd>
<p>The k-fold method splits the original dataset in <code>k</code> datasets of equal 
sizes : each part is used successively as the validation dataset while the other <code>k-1</code> 
parts are used for the calibration, leading to <code>k</code> calibration/validation ensembles. 
This multiple splitting can be repeated <code>nb.rep</code> times.</p>
</dd>
<dt>block</dt>
<dd>
<p>It may be used to test for model overfitting and to assess transferability in 
geographic space. <code>block</code> stratification was described in <em>Muscarella et al. 2014</em> 
(see References). Four bins of equal size are partitioned (bottom-left, bottom-right, 
top-left and top-right).</p>
</dd>
<dt>stratified</dt>
<dd>
<p>It may be used to test for model overfitting and to assess transferability 
in geographic space. <code>x</code> and <code>y</code> stratification was described in <em>Wenger and 
Olden 2012</em> (see References). <code>y</code> stratification uses <code>k</code> partitions along the 
y-gradient, <code>x</code> stratification does the same for the x-gradient. <code>both</code> returns 
<code>2k</code> partitions: <code>k</code> partitions stratified along the x-gradient and <code>k</code> 
partitions stratified along the y-gradient.</p>
</dd>
<dt>environmental</dt>
<dd>
<p>It may be used to test for model overfitting and to assess 
transferability in environmental space. It returns <code>k</code> partitions for each variable 
given in <code>env.var</code>.</p>
</dd>
<dt>user-defined</dt>
<dd>
<p>Allow the user to give its own crossvalidation table. For a 
presence-absence dataset, column names must be formatted as: <code>_allData_RUNx</code> with 
<code>x</code> an integer. For a presence-only dataset for which several pseudo-absence dataset 
were generated, column names must be formatted as: <code>_PAx_RUNy</code> with <code>x</code> an 
integer and <code>PAx</code> an existing pseudo-absence dataset and <code>y</code> an integer <br><br></p>
</dd>
</dl>
<p><b>Concerning balance parameter :</b>
</p>
<p>If <code>balance = 'presences'</code>, presences are divided (balanced) equally over the partitions 
(e.g. <em>Fig. 1b in Muscarelly et al. 2014</em>). 
Absences or pseudo-absences will however be unbalanced over the partitions especially if the 
presences are clumped on an edge of the study area.
</p>
<p>If <code>balance = 'absences'</code>, absences (resp. pseudo-absences or background) are divided 
(balanced) as equally as possible between the partitions (geographical balanced bins given 
that absences are spread over the study area equally, approach similar to <em>Fig. 1 in 
Wenger et Olden 2012</em>). Presences will however be unbalanced over the partitions especially
if the presences are clumped on an edge of the study area.
</p>


<h3>Value</h3>

<p>A <code>matrix</code> or <code>data.frame</code> defining for each repetition (in columns) which 
observation lines should be used for models calibration (<code>TRUE</code>) and validation 
(<code>FALSE</code>).
</p>


<h3>Author(s)</h3>

<p>Frank Breiner, Maya Gueguen
</p>


<h3>References</h3>


<ul>
<li>
<p> Muscarella, R., Galante, P.J., Soley-Guardia, M., Boria, R.A., Kass, J.M., Uriarte, M. 
&amp; Anderson, R.P. (2014). ENMeval: An R package for conducting spatially independent 
evaluations and estimating optimal model complexity for Maxent ecological niche models. 
<em>Methods in Ecology and Evolution</em>, <b>5</b>, 1198-1205.
</p>
</li>
<li>
<p> Wenger, S.J. &amp; Olden, J.D. (2012). Assessing transferability of ecological models: an 
underappreciated aspect of statistical validation. <em>Methods in Ecology and Evolution</em>, 
<b>3</b>, 260-267.
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>get.block</code>, <code>kfold</code>, 
<code>BIOMOD_FormatingData</code>, <code>BIOMOD_Modeling</code>
</p>
<p>Other Secundary functions: 
<code>bm_BinaryTransformation()</code>,
<code>bm_FindOptimStat()</code>,
<code>bm_MakeFormula()</code>,
<code>bm_ModelingOptions()</code>,
<code>bm_PlotEvalBoxplot()</code>,
<code>bm_PlotEvalMean()</code>,
<code>bm_PlotRangeSize()</code>,
<code>bm_PlotResponseCurves()</code>,
<code>bm_PlotVarImpBoxplot()</code>,
<code>bm_PseudoAbsences()</code>,
<code>bm_RunModelsLoop()</code>,
<code>bm_SRE()</code>,
<code>bm_SampleBinaryVector()</code>,
<code>bm_SampleFactorLevels()</code>,
<code>bm_Tuning()</code>,
<code>bm_VariablesImportance()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(terra)
# Load species occurrences (6 species available)
data(DataSpecies)
head(DataSpecies)

# Select the name of the studied species
myRespName &lt;- 'GuloGulo'

# Get corresponding presence/absence data
myResp &lt;- as.numeric(DataSpecies[, myRespName])

# Get corresponding XY coordinates
myRespXY &lt;- DataSpecies[, c('X_WGS84', 'Y_WGS84')]

# Load environmental variables extracted from BIOCLIM (bio_3, bio_4, bio_7, bio_11 &amp; bio_12)
data(bioclim_current)
myExpl &lt;- terra::rast(bioclim_current)



# --------------------------------------------------------------- #
# Format Data with true absences
myBiomodData &lt;- BIOMOD_FormatingData(resp.var = myResp,
                                     expl.var = myExpl,
                                     resp.xy = myRespXY,
                                     resp.name = myRespName)

# --------------------------------------------------------------- #
# Create the different validation datasets

# random selection
cv.r &lt;- bm_CrossValidation(bm.format = myBiomodData,
                           strategy = "random",
                           nb.rep = 3,
                           k = 0.8)

# k-fold selection
cv.k &lt;- bm_CrossValidation(bm.format = myBiomodData,
                           strategy = "kfold",
                           nb.rep = 2,
                           k = 3)

# block selection
cv.b &lt;- bm_CrossValidation(bm.format = myBiomodData,
                           strategy = "block")

# stratified selection (geographic)
cv.s &lt;- bm_CrossValidation(bm.format = myBiomodData,
                           strategy = "strat",
                           k = 2,
                           balance = "presences",
                           strat = "x")

# stratified selection (environmental)
cv.e &lt;- bm_CrossValidation(bm.format = myBiomodData,
                           strategy = "env",
                           k = 2,
                           balance = "presences")

head(cv.r)
apply(cv.r, 2, table)
head(cv.k)
apply(cv.k, 2, table)
head(cv.b)
apply(cv.b, 2, table)
head(cv.s)
apply(cv.s, 2, table)
head(cv.e)
apply(cv.e, 2, table)


</code></pre>


</div>