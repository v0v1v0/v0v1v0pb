<div class="container">

<table style="width: 100%;"><tr>
<td>computeModules</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>computeModules</h2>

<h3>Description</h3>

<p>This function takes a bipartite weighted graph and computes modules by applying Newman's modularity measure in a bipartite weighted version to it. 
<code>metaComputeModules</code> re-runs the algorithm several times, returning the most modular result, to stabilise modularity computation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">computeModules(web, method="Beckett", deep = FALSE, deleteOriginalFiles = TRUE, 
	steps = 1000000, tolerance = 1e-10, experimental = FALSE, forceLPA=FALSE)
	
metaComputeModules(moduleObject, N=5, method="Beckett", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>web</code></td>
<td>

<p><code>web</code> is the matrix representing the weighted bipartite graph (as an example, see e.g. web <code>small1976</code> in this package). This matrix can be binary (i.e. consist only of 0s and 1s), in which case the output will be Newman's (2006) modularity.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Choice between the algorithm(s) provided by Stephen Beckett (2016) or Dormann &amp; Strauss (2016) (<span class="option">method="DormannStrauss"</span>). Defaults to the much faster and in the majority of cases better algorithm of Beckett. (Note the optional argument <span class="option">forceLPA</span> to use his slightly inferior but even faster pure LPA algorithm.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deep</code></td>
<td>

<p>If <code>deep</code> is set to FALSE (default), a flat clustering is computed, otherwise submodules are identified recursively within modules. Works only with <span class="option">method="DormannnStrauss"</span>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deleteOriginalFiles</code></td>
<td>

<p>If <code>deleteOriginalFiles</code> is set to TRUE (default), the files mentioned above in the description are deleted from the hard drive disk, otherwise not. Applies only to <span class="option">method="DormannnStrauss"</span>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>steps</code></td>
<td>

<p><code>steps</code> is the number of steps after which the computation of modules stops if no better division into modules than the current one can be found. Applies only to <span class="option">method="DormannnStrauss"</span>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tolerance</code></td>
<td>
<p>How small should the difference between MCMC-swap results be? At some point computer precision fluctuations make the algorithm fail to converge, which is why we choose a (very low) defaults of 1E-10. Applies only to <span class="option">method="DormannnStrauss"</span>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>experimental</code></td>
<td>
<p>Logical; using an undescribed and untested version for which no detail is available? (We suggest: not yet.) Applies only to <span class="option">method="DormannnStrauss"</span>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>moduleObject</code></td>
<td>
<p>Output from running <code>computeModules</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>forceLPA</code></td>
<td>
<p>Logical; should the even faster pure LPA-algorithm of Beckett be used? DIRT-LPA, the default, is less likely to get trapped in a local minimum, but is slightly slower. Defaults to FALSE.  Applies only to <span class="option">method="Beckett"</span>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>Number of replicate runs; defaults to 5. Not really required for <span class="option">method="Beckett"</span>, which starts in different places anyway.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed on to <code>computeModules</code>, which is called internally.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class "moduleWeb" containing information about the computed modules. For details, please refer to the corresponding documentation file. 
</p>


<h3>Note</h3>

<p>For perfectly compartmentalised networks the algorithm may throw an error message. Please add a little bit of noise (e.g. uniform between 0 and 1 or so) or a small constant (1E-5 or so) and it will work again. 
</p>
<p>When using the method <span class="option">DormannStrauss</span>, files are written onto the hard drive during the computation. These files are by default deleted after the computation terminates, unless it breaks. Details of the modularity algorithm can be found in Dormann &amp; Strauß (2013).
</p>


<h3>Author(s)</h3>

<p>Rouven Strauss, with fixes by Carsten Dormann and Tobias Hegemann; modified to accommodate Beckett's algorithm by Carsten Dormann</p>


<h3>References</h3>

 
<p>Beckett, S.J. 2016 Improved community detection in weighted bipartite networks. <em>Royal Society open science</em> <b>3</b>, 140536.
</p>
<p>Dormann, C. F., and R. Strauß. 2014. Detecting modules in quantitative bipartite networks: the QuanBiMo algorithm. <em>Methods in Ecology &amp; Evolution</em> <b>5</b> 90–98 (and <b>arXiv [q-bio.QM]</b> 1304.3218.)
</p>
<p>Liu X. &amp; Murata T. 2010. An Efficient Algorithm for Optimizing Bipartite Modularity in Bipartite Networks. <em>Journal of Advanced Computational Intelligence and Intelligent Informatics (JACIII)</em> <b>14</b> 408–415.
</p>
<p>Newman M.E.J. 2004. <em>Physical Review E</em> <b>70</b> 056131
</p>
<p>Newman, M.E.J. 2006. Modularity and community structure in networks. <em>Proceedings of the National Academy of Sciences of the United States of America</em>, <b>103</b>, 8577–-8582.
</p>


<h3>See Also</h3>

<p>See also class "moduleWeb", <code>plotModuleWeb</code>, <code>listModuleInformation</code>, <code>printoutModuleInformation</code>, <code>DIRT_LPA_wb_plus</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">	## Not run: 
		data(small1976)
		(res &lt;- computeModules(small1976)) 
		plotModuleWeb(res)
		
		# slow:
		res2 &lt;- metaComputeModules(small1976, method="DormannStrauss")
		res2
	
## End(Not run)
</code></pre>


</div>