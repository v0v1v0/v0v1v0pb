<div class="container">

<table style="width: 100%;"><tr>
<td>REGE.FC</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>REGE - Algorithms for compiting (dis)similarities in terms of regular equivalnece</h2>

<h3>Description</h3>

<p>REGE - Algorithms for compiting (dis)similarities in terms of regular equivalnece (White &amp; Reitz, 1983). 
<code>REGE, REGE.for</code> - Classical REGE or REGGE, as also implemented in Ucinet. Similarities in terms of regular equivalence are computed.  The <code>REGE.for</code> is a wrapper for calling the FORTRAN subrutine written by White (1985a), modified to be called by R. The <code>REGE</code> does the same, however it is written in R. The functions with and without ".for" differ only in whether they are implemented  in R of FORTRAN. Needless to say, the functions implemented in FORTRAN are much faster.
<code>REGE.ow, REGE.ow.for</code> - The above function, modified so that a best match is searched for each arc separately (and not for both arcs, if they exist, together). 
<code>REGE.nm.for</code> - REGE or REGGE, modified to use row and column normalized matrices instead of the original matrix.
<code>REGE.ownm.for</code> - The above function, modified so that a best match for an outgoing ties is searched on row-normalized network and for incoming ties on column-normalized network.
<code>REGD.for</code> - REGD or REGDI, a dissimilarity version of the classical REGE or REGGE. Dissimilarities in terms of regular equivalence  are computed.  The <code>REGD.for</code> is a wrapper for calling the FORTRAN subroutine written by White (1985b), modified to be called by R.
<code>REGE.FC</code>  - Actually an earlier version of REGE. The difference is in the denominator. See Žiberna (2007) for details.
<code>REGE.FC.ow</code> - The above function, modified so that a best match is searched for each arc separately (and not for both arcs, if they exist, together).
other - still in testing stage.
</p>


<h3>Usage</h3>

<pre><code class="language-R">REGE.FC(
  M,
  E = 1,
  iter = 3,
  until.change = TRUE,
  use.diag = TRUE,
  normE = FALSE
)

REGE.FC.ow(
  M,
  E = 1,
  iter = 3,
  until.change = TRUE,
  use.diag = TRUE,
  normE = FALSE
)

REGE(M, E = 1, iter = 3, until.change = TRUE, use.diag = TRUE)

REGE.ow(M, E = 1, iter = 3, until.change = TRUE, use.diag = TRUE)

REGE.for(M, iter = 3, E = 1)

REGD.for(M, iter = 3, E = 0)

REGE.ow.for(M, iter = 3, E = 1)

REGD.ow.for(M, iter = 3, E = 0)

REGE.ownm.for(M, iter = 3, E = 1)

REGE.ownm.diag.for(M, iter = 3, E = 1)

REGE.nm.for(M, iter = 3, E = 1)

REGE.nm.diag.for(M, iter = 3, E = 1)

REGE.ne.for(M, iter = 3, E = 1)

REGE.ow.ne.for(M, iter = 3, E = 1)

REGE.ownm.ne.for(M, iter = 3, E = 1)

REGE.nm.ne.for(M, iter = 3, E = 1)

REGD.ne.for(M, iter = 3, E = 0)

REGD.ow.ne.for(M, iter = 3, E = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>Matrix or a 3 dimensional array representing the network. The third dimension allows for several relations to be analyzed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>E</code></td>
<td>
<p>Initial (dis)similarity in terms of regular equivalnece.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>The desired number of iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>until.change</code></td>
<td>
<p>Should the iterations be stopped when no change occurs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.diag</code></td>
<td>
<p>Should the diagonal be used. If <code>FALSE</code>, all diagonal elements are set to 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normE</code></td>
<td>
<p>Should the equivalence matrix be normalized after each iteration.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>E</code></td>
<td>
<p>A matrix of (dis)similarities in terms of regular equivalnece.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Eall</code></td>
<td>
<p>An array of (dis)similarity matrices in terms of regular equivalence, each third dimension represets one iteration. For ".for" functions, only the initial and the final (dis)similarities are returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>Matrix or a 3 dimensional array representing the network used in the call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>The desired number of iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.diag</code></td>
<td>
<p>Should the diagonal be used - for functions implemented in R only.</p>
</td>
</tr>
</table>
<p>...
</p>


<h3>References</h3>

<p>Žiberna, A. (2008). Direct and indirect approaches to blockmodeling of valued networks in terms of regular equivalence. Journal of Mathematical Sociology, 32(1), 57-84. doi: 10.1080/00222500701790207
</p>
<p>White, D. R., &amp; Reitz, K. P. (1983). Graph and semigroup homomorphisms on networks of relations. Social Networks, 5(2), 193-234.
</p>
<p>White, D. R.(1985a). DOUG WHITE'S REGULAR EQUIVALENCE PROGRAM. Retrieved from http://eclectic.ss.uci.edu/~drwhite/REGGE/REGGE.FOR
</p>
<p>White, D. R. (1985b). DOUG WHITE'S REGULAR DISTANCES PROGRAM. Retrieved from http://eclectic.ss.uci.edu/~drwhite/REGGE/REGDI.FOR
</p>
<p>White, D. R. (2005). REGGE. Retrieved from http://eclectic.ss.uci.edu/~drwhite/REGGE/
</p>
<p>#' @author Aleš Žiberna based on Douglas R. White's original REGE and REGD
</p>


<h3>See Also</h3>

<p><code>sedist</code>, <code>critFunC</code>, <code>optParC</code>, <code>plot.mat</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">n &lt;- 20
net &lt;- matrix(NA, ncol = n, nrow = n)
clu &lt;- rep(1:2, times = c(5, 15))
tclu &lt;- table(clu)
net[clu == 1, clu == 1] &lt;- 0
net[clu == 1, clu == 2] &lt;- rnorm(n = tclu[1] * tclu[2], mean = 4, sd = 1) * sample(c(0, 1),
   size = tclu[1] * tclu[2], replace = TRUE, prob = c(3/5, 2/5))
net[clu == 2, clu == 1] &lt;- 0
net[clu == 2, clu == 2] &lt;- 0

D &lt;- REGE.for(M = net)$E # Any other REGE function can be used
plot.mat(net, clu = cutree(hclust(d = as.dist(1 - D), method = "ward.D"),
   k = 2))
# REGE returns similarities, which have to be converted to
# disimilarities

res &lt;- optRandomParC(M = net, k = 2, rep = 10, approaches = "hom", homFun = "ss", blocks = "reg")
plot(res) # Hopefully we get the original partition

</code></pre>


</div>