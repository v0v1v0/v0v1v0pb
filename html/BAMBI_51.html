<div class="container">

<table style="width: 100%;"><tr>
<td>rwnorm2</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The bivariate Wrapped Normal distribution</h2>

<h3>Description</h3>

<p>The bivariate Wrapped Normal distribution
</p>


<h3>Usage</h3>

<pre><code class="language-R">rwnorm2(n, kappa1 = 1, kappa2 = 1, kappa3 = 0, mu1 = 0, mu2 = 0, ...)

dwnorm2(
  x,
  kappa1 = 1,
  kappa2 = 1,
  kappa3 = 0,
  mu1 = 0,
  mu2 = 0,
  int.displ,
  log = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of observations. Ignored if at least one of the other parameters have length k &gt; 1, in which
case, all the parameters are recycled to length k to produce k random variates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa1, kappa2, kappa3</code></td>
<td>
<p>vectors of concentration parameters; <code>kappa1, kappa2 &gt; 0</code>,
and <code>kappa3^2 &lt; kappa1*kappa2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu1, mu2</code></td>
<td>
<p>vectors of mean parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to rmvnorm from package <code>mvtnorm</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>bivariate vector  or a two-column matrix with each row being a bivariate vector of angles
(in radians)  where the densities are to be evaluated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>int.displ</code></td>
<td>
<p>integer displacement. If <code>int.displ =</code> M, then each infinite sum in the
density is approximated by a finite sum over 2*M + 1 elements. (See Details.) The allowed values are 1, 2, 3, 4 and 5. Default is 3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p>logical. Should the log density be returned instead?</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The bivariate wrapped normal density at the point <code class="reqn">x = (x_1, x_2)</code> is given by,
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \sqrt((\kappa_1 \kappa_2 - (\kappa_3)^2)) / (2\pi) \sum \exp(-1/2 * (\kappa_1 (T_1)^2 + \kappa_2 (T_2)^2 + 2 \kappa_3 (T_1) (T_2)) )</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">T_1 = T_1(x, \mu, \omega) = (x_1 - \mu_1(2\pi\omega_1))</code>
</p>

<p style="text-align: center;"><code class="reqn">T_2 = T_2(x, \mu, \omega) = (x_2 - \mu_1(2\pi\omega_2))</code>
</p>

<p>the sum extends over all pairs of integers <code class="reqn">\omega = (\omega_1, \omega_2)</code>,
and is approximated by a sum over <code class="reqn">(\omega_1, \omega_2)</code> in <code class="reqn">\{-M, -M+1, ..., M-1, M \}^2</code> if <code>int.displ = </code> <code class="reqn">M</code>.
</p>
<p>Note that above density is essentially the "wrapped" version of a bivariate normal density with mean
</p>
<p style="text-align: center;"><code class="reqn">\mu = (\mu_1, \mu_2)</code>
</p>

<p>and dispersion matrix  <code class="reqn">\Sigma = \Delta^{-1}</code>, where
</p>

<table>
<tr>
<td style="text-align: left;">
               </td>
<td style="text-align: right;"> <code class="reqn">\kappa_1</code> </td>
<td style="text-align: right;">  <code class="reqn"> </code> </td>
<td style="text-align: right;"> <code class="reqn">\kappa_3</code> </td>
</tr>
<tr>
<td style="text-align: left;">
<code class="reqn">\Delta =</code> </td>
<td style="text-align: right;"> <code class="reqn"> </code>        </td>
<td style="text-align: right;">  <code class="reqn"> </code> </td>
<td style="text-align: right;"> <code class="reqn"> </code> </td>
</tr>
<tr>
<td style="text-align: left;">
               </td>
<td style="text-align: right;"> <code class="reqn">\kappa_3</code> </td>
<td style="text-align: right;">  <code class="reqn"> </code> </td>
<td style="text-align: right;">  <code class="reqn">\kappa_2</code>.
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>dwnorm2</code> gives the density  and <code>rwnorm2</code> generates random deviates.
</p>


<h3>Examples</h3>

<pre><code class="language-R">kappa1 &lt;- c(1, 2, 3)
kappa2 &lt;- c(1, 6, 5)
kappa3 &lt;- c(0, 1, 2)
mu1 &lt;- c(1, 2, 5)
mu2 &lt;- c(0, 1, 3)
x &lt;- diag(2, 2)
n &lt;- 10

# when x is a bivariate vector and parameters are all scalars,
# dwnorm2 returns single density
dwnorm2(x[1, ], kappa1[1], kappa2[1], kappa3[1], mu1[1], mu2[1])

# when x is a two column matrix and parameters are all scalars,
# dmvsin returns a vector of densities calculated at the rows of
# x with the same parameters
dwnorm2(x, kappa1[1], kappa2[1], kappa3[1], mu1[1], mu2[1])

# if x is a bivariate vector and at least one of the parameters is
# a vector, all parameters are recycled to the same length, and
# dwnorm2 returns a vector of with ith element being the density
# evaluated at x with parameter values kappa1[i], kappa2[i],
# kappa3[i], mu1[i] and mu2[i]
dwnorm2(x[1, ], kappa1, kappa2, kappa3, mu1, mu2)

# if x is a two column matrix and at least one of the parameters is
# a vector, rows of x and the parameters are recycled to the same
# length, and dwnorm2 returns a vector of with ith element being the
# density evaluated at ith row of x with parameter values kappa1[i],
# kappa2[i], # kappa3[i], mu1[i] and mu2[i]
dwnorm2(x, kappa1, kappa2, kappa3, mu1, mu2)

# when parameters are all scalars, number of observations generated
# by rwnorm2 is n
rwnorm2(n, kappa1[1], kappa2[1], kappa3[1], mu1[1], mu2[1])

# when at least one of the parameters is a vector, all parameters are
# recycled to the same length, n is ignored, and the number of
# observations generated by rwnorm2 is the same as the length of the
# recycled vectors
rwnorm2(n, kappa1, kappa2, kappa3, mu1, mu2)

</code></pre>


</div>