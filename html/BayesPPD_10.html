<div class="container">

<table style="width: 100%;"><tr>
<td>power.two.grp.random.a0</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Power/type I error calculation for two groups (treatment and control group, no covariates) with random a0</h2>

<h3>Description</h3>

<p>Power/type I error calculation using normalized power priors for two groups (treatment and control group, no covariates) with random <code class="reqn">a_0</code>
</p>


<h3>Usage</h3>

<pre><code class="language-R">power.two.grp.random.a0(
  data.type,
  n.t,
  n.c,
  historical,
  nullspace.ineq = "&gt;",
  samp.prior.mu.t,
  samp.prior.mu.c,
  samp.prior.var.t = 0,
  samp.prior.var.c = 0,
  prior.mu.t.shape1 = 1,
  prior.mu.t.shape2 = 1,
  prior.mu.c.shape1 = 1,
  prior.mu.c.shape2 = 1,
  prior.a0.shape1 = rep(1, 10),
  prior.a0.shape2 = rep(1, 10),
  lower.limits = rep(0, 10),
  upper.limits = rep(1, 10),
  slice.widths = rep(0.1, 10),
  delta = 0,
  gamma = 0.95,
  nMC = 10000,
  nBI = 250,
  N = 10000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data.type</code></td>
<td>
<p>Character string specifying the type of response. The options are "Normal", "Bernoulli", "Poisson" and "Exponential".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.t</code></td>
<td>
<p>Sample size of the treatment group for the simulated datasets.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.c</code></td>
<td>
<p>Sample size of the control group for the simulated datasets.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>historical</code></td>
<td>
<p>Matrix of historical dataset(s). If <code>data.type</code> is "Normal", <code>historical</code> is a matrix with three columns:
</p>

<ul>
<li>
<p> The first column contains the sum of responses for the control group.
</p>
</li>
<li>
<p> The second column contains the sample size of the control group.
</p>
</li>
<li>
<p> The third column contains the sample variance of responses for the control group.
</p>
</li>
</ul>
<p>For all other data types, <code>historical</code> is a matrix with two columns:
</p>

<ul>
<li>
<p> The first column contains the sum of responses for the control group.
</p>
</li>
<li>
<p> The second column contains the sample size of the control group.
</p>
</li>
</ul>
<p>Each row represents a historical dataset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nullspace.ineq</code></td>
<td>
<p>Character string specifying the inequality of the null hypothesis. The options are "&gt;" and "&lt;". If "&gt;" is specified, the null hypothesis (for non-exponential data) is <code class="reqn">H_0</code>: <code class="reqn">\mu_t</code> - <code class="reqn">\mu_c</code> <code class="reqn">\ge</code> <code class="reqn">\delta</code>. If "&lt;" is specified, the null hypothesis is <code class="reqn">H_0</code>: <code class="reqn">\mu_t</code> - <code class="reqn">\mu_c</code> <code class="reqn">\le</code> <code class="reqn">\delta</code>. The default choice is "&gt;".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>samp.prior.mu.t</code></td>
<td>
<p>Vector of possible values of <code class="reqn">\mu_t</code> to sample (with replacement) from. The vector contains realizations from the sampling prior (e.g. normal distribution) for <code class="reqn">\mu_t</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>samp.prior.mu.c</code></td>
<td>
<p>Vector of possible values of <code class="reqn">\mu_c</code> to sample (with replacement) from. The vector contains realizations from the sampling prior (e.g. normal distribution) for <code class="reqn">\mu_c</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>samp.prior.var.t</code></td>
<td>
<p>Vector of possible values of <code class="reqn">\sigma^2_t</code> to sample (with replacement) from. Only applies if <code>data.type</code> is "Normal". The vector contains realizations from the sampling prior (e.g. inverse-gamma distribution) for <code class="reqn">\sigma^2_t</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>samp.prior.var.c</code></td>
<td>
<p>Vector of possible values of <code class="reqn">\sigma^2_c</code> to sample (with replacement) from. Only applies if <code>data.type</code> is "Normal". The vector contains realizations from the sampling prior (e.g. inverse-gamma distribution) for <code class="reqn">\sigma^2_c</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.mu.t.shape1</code></td>
<td>
<p>First hyperparameter of the initial prior for <code class="reqn">\mu_t</code>. The default is 1. Does not apply if <code>data.type</code> is "Normal".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.mu.t.shape2</code></td>
<td>
<p>Second hyperparameter of the initial prior for <code class="reqn">\mu_t</code>. The default is 1. Does not apply if <code>data.type</code> is "Normal".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.mu.c.shape1</code></td>
<td>
<p>First hyperparameter of the initial prior for <code class="reqn">\mu_c</code>. The default is 1. Does not apply if <code>data.type</code> is "Normal".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.mu.c.shape2</code></td>
<td>
<p>Second hyperparameter of the initial prior for <code class="reqn">\mu_c</code>. The default is 1. Does not apply if <code>data.type</code> is "Normal".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.a0.shape1</code></td>
<td>
<p>Vector of the first shape parameters of the independent beta priors for <code class="reqn">a_0</code>. The length of the vector should be equal to the number of historical datasets. The default is a vector of one's.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.a0.shape2</code></td>
<td>
<p>Vector of the second shape parameters of the independent beta priors for <code class="reqn">a_0</code>. The length of the vector should be equal to the number of historical datasets. The default is a vector of one's.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower.limits</code></td>
<td>
<p>Vector of lower limits for parameters to be used by the slice sampler. The length of the vector should be equal to the number of historical datasets. The default is 0 for all parameters (may not be appropriate for all situations).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper.limits</code></td>
<td>
<p>Vector of upper limits for parameters to be used by the slice sampler. The length of the vector should be equal to the number of historical datasets. The default is 1 for all parameters (may not be appropriate for all situations).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>slice.widths</code></td>
<td>
<p>Vector of initial slice widths used by the slice sampler. The length of the vector should be equal to the number of historical datasets. The default is 0.1 for all parameter (may not be appropriate for all situations).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>Prespecified constant that defines the boundary of the null hypothesis. The default is zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>Posterior probability threshold for rejecting the null. The null hypothesis is rejected if posterior probability is greater <code>gamma</code>. The default is 0.95.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nMC</code></td>
<td>
<p>Number of iterations (excluding burn-in samples) for the slice sampler or Gibbs sampler. The default is 10,000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nBI</code></td>
<td>
<p>Number of burn-in samples for the slice sampler or Gibbs sampler. The default is 250.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>Number of simulated datasets to generate. The default is 10,000.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>data.type</code> is "Bernoulli", "Poisson" or "Exponential", a single response from the treatment group is assumed to follow Bern(<code class="reqn">\mu_t</code>), Pois(<code class="reqn">\mu_t</code>) or Exp(rate=<code class="reqn">\mu_t</code>), respectively,
where <code class="reqn">\mu_t</code> is the mean of responses for the treatment group. If <code>data.type</code> is "Normal", a single response from the treatment group is assumed to follow <code class="reqn">N(\mu_t, \tau^{-1})</code>
where <code class="reqn">\tau</code> is the precision parameter.
The distributional assumptions for the control group data are analogous.
</p>
<p><code>samp.prior.mu.t</code> and <code>samp.prior.mu.c</code> can be generated using the sampling priors (see example).
</p>
<p>If <code>data.type</code> is "Bernoulli", the initial prior for <code class="reqn">\mu_t</code> is beta(<code>prior.mu.t.shape1</code>, <code>prior.mu.t.shape2</code>).
If <code>data.type</code> is "Poisson", the initial prior for <code class="reqn">\mu_t</code> is Gamma(<code>prior.mu.t.shape1</code>, rate=<code>prior.mu.t.shape2</code>).
If <code>data.type</code> is "Exponential", the initial prior for <code class="reqn">\mu_t</code> is Gamma(<code>prior.mu.t.shape1</code>, rate=<code>prior.mu.t.shape2</code>).
The initial priors used for the control group data are analogous.
</p>
<p>If <code>data.type</code> is "Normal", historical datasets are assumed to have the same precision parameter as the current dataset for computational simplicity.
The initial prior for <code class="reqn">\tau</code> is the Jeffery's prior, <code class="reqn">\tau^{-1}</code>. The initial prior for the <code class="reqn">\mu_c</code> is the uniform improper prior.
Posterior samples of <code class="reqn">\mu_c</code> and <code class="reqn">\tau</code> are obtained through Gibbs sampling.
</p>
<p>Independent beta(<code>prior.a0.shape1</code>,<code>prior.a0.shape1</code>) priors are used for <code class="reqn">a_0</code>. Posterior samples of <code class="reqn">a_0</code> are obtained through slice sampling. The default lower limits for the parameters are 0. The default upper limits
for the parameters are 1.  The default slice widths for the parameters are 0.1.
The defaults may not be appropriate for all situations, and the user can specify the appropriate limits
and slice width for each parameter.
</p>
<p>If a sampling prior with support in the null space is used, the value returned is a Bayesian type I error rate.
If a sampling prior with support in the alternative space is used, the value returned is a Bayesian power.
</p>


<h3>Value</h3>

<p>The function returns a S3 object with a <code>summary</code> method. Power or type I error is returned, depending on the sampling prior used.
The posterior probabilities of the alternative hypothesis are returned.
Average posterior means of <code class="reqn">\mu_t</code> and <code class="reqn">\mu_c</code> and their corresponding biases are returned.
The average posterior mean of <code class="reqn">a_0</code> is returned.
If <code>data.type</code> is "Normal", the average posterior mean of <code class="reqn">\tau</code> is also returned.
</p>


<h3>References</h3>

<p>Chen, Ming-Hui, et al. "Bayesian design of noninferiority trials for medical devices using historical data." Biometrics 67.3 (2011): 1163-1170.
</p>
<p>Neal, Radford M. Slice sampling. Ann. Statist. 31 (2003), no. 3, 705–767.
</p>


<h3>See Also</h3>

<p><code>two.grp.random.a0</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data.type &lt;- "Bernoulli"
n.t &lt;- 100
n.c &lt;- 100

# Simulate three historical datasets
historical &lt;- matrix(0, ncol=2, nrow=3)
historical[1,] &lt;- c(70, 100)
historical[2,] &lt;- c(60, 100)
historical[3,] &lt;- c(50, 100)

# Generate sampling priors
set.seed(1)
b_st1 &lt;- b_st2 &lt;- 1
b_sc1 &lt;- b_sc2 &lt;- 1
samp.prior.mu.t &lt;- rbeta(50000, b_st1, b_st2)
samp.prior.mu.c &lt;- rbeta(50000, b_st1, b_st2)
# The null hypothesis here is H0: mu_t - mu_c &gt;= 0. To calculate power,
# we can provide samples of mu.t and mu.c such that the mass of mu_t - mu_c &lt; 0.
# To calculate type I error, we can provide samples of mu.t and mu.c such that
# the mass of mu_t - mu_c &gt;= 0.
sub_ind &lt;- which(samp.prior.mu.t &lt; samp.prior.mu.c)
# Here, mass is put on the alternative region, so power is calculated.
samp.prior.mu.t &lt;- samp.prior.mu.t[sub_ind]
samp.prior.mu.c &lt;- samp.prior.mu.c[sub_ind]

N &lt;- 10 # N should be larger in practice
result &lt;- power.two.grp.random.a0(data.type=data.type, n.t=n.t, n.c=n.c, historical=historical,
                                  samp.prior.mu.t=samp.prior.mu.t, samp.prior.mu.c=samp.prior.mu.c,
                                  delta=0, nMC=10000, nBI=250, N=N)
summary(result)
</code></pre>


</div>