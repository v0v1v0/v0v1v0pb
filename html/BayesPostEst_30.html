<div class="container">

<table style="width: 100%;"><tr>
<td>mcmcRocPrcGen</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>ROC and Precision-Recall Curves using Bayesian MCMC estimates generalized</h2>

<h3>Description</h3>

<p>This function generates ROC and Precision-Recall curves 
after fitting a Bayesian logit or probit regression. For fast calculation for 
from an "rjags" object use <code>mcmcRocPrc</code>
</p>


<h3>Usage</h3>

<pre><code class="language-R">mcmcRocPrcGen(
  modelmatrix,
  mcmcout,
  modelframe,
  curves = FALSE,
  link = "logit",
  fullsims = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>modelmatrix</code></td>
<td>
<p>model matrix, including intercept (if the intercept is among the
parameters estimated in the model). Create with model.matrix(formula, data).
Note: the order of columns in the model matrix must correspond to the order of columns 
in the matrix of posterior draws in the <code>mcmcout</code> argument. See the <code>mcmcout</code>
argument for more and Beger (2016) for background.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mcmcout</code></td>
<td>
<p>posterior distributions of all logit coefficients, 
in matrix form. This can be created from rstan, MCMCpack, R2jags, etc. and transformed
into a matrix using the function as.mcmc() from the coda package for <code>jags</code> class
objects, as.matrix() from base R for <code>mcmc</code>, <code>mcmc.list</code>, <code>stanreg</code>, and 
<code>stanfit</code> class objects, and <code>object$sims.matrix</code> for <code>bugs</code> class objects.
Note: the order of columns in this matrix must correspond to the order of columns 
in the model matrix. One can do this by examining the posterior distribution matrix and sorting the 
variables in the order of this matrix when creating the model matrix. A useful function for sorting 
column names containing both characters and numbers as 
you create the matrix of posterior distributions is <code>mixedsort()</code> from the gtools package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modelframe</code></td>
<td>
<p>model frame in matrix form. Can be created using 
as.matrix(model.frame(formula, data))</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>curves</code></td>
<td>
<p>logical indicator of whether or not to return values to plot the ROC or Precision-Recall 
curves. If set to <code>FALSE</code> (default), results are returned as a list without the extra
values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link</code></td>
<td>
<p>type of generalized linear model; a character vector set to <code>"logit"</code> (default) or <code>"probit"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fullsims</code></td>
<td>
<p>logical indicator of whether full object (based on all MCMC draws 
rather than their average) will be returned. Default is <code>FALSE</code>. Note:  If <code>TRUE</code>
is chosen, the function takes notably longer to execute.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function generates ROC and precision-recall curves
after fitting a Bayesian logit or probit model.
</p>


<h3>Value</h3>

<p>This function returns a list with 4 elements:
</p>

<ul>
<li>
<p> area_under_roc: area under ROC curve (scalar)
</p>
</li>
<li>
<p> area_under_prc: area under precision-recall curve (scalar)
</p>
</li>
<li>
<p> prc_dat: data to plot precision-recall curve (data frame)
</p>
</li>
<li>
<p> roc_dat: data to plot ROC curve (data frame)
</p>
</li>
</ul>
<h3>References</h3>

<p>Beger, Andreas. 2016. “Precision-Recall Curves.” Available at SSRN: 
https://ssrn.com/Abstract=2765419. http://dx.doi.org/10.2139/ssrn.2765419.
</p>


<h3>Examples</h3>

<pre><code class="language-R">

if (interactive()) {
# simulating data

set.seed(123456)
b0 &lt;- 0.2 # true value for the intercept
b1 &lt;- 0.5 # true value for first beta
b2 &lt;- 0.7 # true value for second beta
n &lt;- 500 # sample size
X1 &lt;- runif(n, -1, 1)
X2 &lt;- runif(n, -1, 1)
Z &lt;- b0 + b1 * X1 + b2 * X2
pr &lt;- 1 / (1 + exp(-Z)) # inv logit function
Y &lt;- rbinom(n, 1, pr) 
df &lt;- data.frame(cbind(X1, X2, Y))

# formatting the data for jags
datjags &lt;- as.list(df)
datjags$N &lt;- length(datjags$Y)

# creating jags model
model &lt;- function()  {
  
  for(i in 1:N){
    Y[i] ~ dbern(p[i])  ## Bernoulli distribution of y_i
    logit(p[i]) &lt;- mu[i]    ## Logit link function
    mu[i] &lt;- b[1] + 
      b[2] * X1[i] + 
      b[3] * X2[i]
  }
  
  for(j in 1:3){
    b[j] ~ dnorm(0, 0.001) ## Use a coefficient vector for simplicity
  }
  
}

params &lt;- c("b")
inits1 &lt;- list("b" = rep(0, 3))
inits2 &lt;- list("b" = rep(0, 3))
inits &lt;- list(inits1, inits2)

## fitting the model with R2jags
set.seed(123)
fit &lt;- R2jags::jags(data = datjags, inits = inits, 
                    parameters.to.save = params, n.chains = 2, n.iter = 2000, 
                    n.burnin = 1000, model.file = model)

# processing the data
mm &lt;- model.matrix(Y ~ X1 + X2, data = df)
xframe &lt;- as.matrix(model.frame(Y ~ X1 + X2, data = df))
mcmc &lt;- coda::as.mcmc(fit)
mcmc_mat &lt;- as.matrix(mcmc)[, 1:ncol(xframe)]

# using mcmcRocPrcGen
fit_sum &lt;- mcmcRocPrcGen(modelmatrix = mm,
                      modelframe = xframe,
                      mcmcout = mcmc_mat,
                      curves = TRUE,
                      fullsims = FALSE)
}



</code></pre>


</div>