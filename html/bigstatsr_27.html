<div class="container">

<table style="width: 100%;"><tr>
<td>big_scale</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Some scaling functions</h2>

<h3>Description</h3>

<p>Some scaling functions for a Filebacked Big Matrix to be used as
the <strong><code>fun.scaling</code></strong> parameter of some functions of this package.
</p>


<h3>Usage</h3>

<pre><code class="language-R">big_scale(center = TRUE, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>A logical value: whether to return means or 0s.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>A logical value: whether to return standard deviations or 1s.
<strong>You can't use scale without using center.</strong></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>One could think about less common scalings, such as for example the
"y-aware" scaling which uses the inverse of betas of column-wise linear
regression as scaling. See <a href="https://goo.gl/8G8WMa">this post</a> for details.
It would be easy to implement it using <code>big_colstats</code> to get column means
and <code>big_univLinReg</code> to get betas (and then inverse them).
</p>


<h3>Value</h3>

<p>A new <strong>function</strong> that returns a data.frame of two vectors
"center" and "scale" which are of the length of <code>ind.col</code>.
</p>


<h3>See Also</h3>

<p>as_scaling_fun
</p>


<h3>Examples</h3>

<pre><code class="language-R">X &lt;- big_attachExtdata()

# No scaling
big_noscale &lt;- big_scale(center = FALSE, scale = FALSE)
class(big_noscale) # big_scale returns a new function
str(big_noscale(X))
big_noscale2 &lt;- big_scale(center = FALSE)
str(big_noscale2(X)) # you can't scale without centering

# Centering
big_center &lt;- big_scale(scale = FALSE)
str(big_center(X))
# + scaling
str(big_scale()(X))
</code></pre>


</div>