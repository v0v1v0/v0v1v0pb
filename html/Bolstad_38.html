<div class="container">

<table style="width: 100%;"><tr>
<td>sd.Bolstad</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Posterior standard deviation</h2>

<h3>Description</h3>

<p>Posterior standard deviation
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'Bolstad'
sd(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object of class <code>Bolstad</code> for which we want to compute the standard deviation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Any additional arguments to be passed to <code>sd</code>.
</p>
<p>Calculate the posterior standard deviation of an object of class <code>Bolstad</code>. If the 
object has a member <code>sd</code> then it will return this value otherwise it 
will calculate the posterior standard deviation <code class="reqn">sd[\theta|x]</code> using 
linear interpolation to approximate the density function and numerical 
integration where <code class="reqn">\theta</code> is the variable for which we want to do 
Bayesian inference, and <code class="reqn">x</code> is the data.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>Examples</h3>

<pre><code class="language-R">## The usefulness of this method is really highlighted when we have a general 
## continuous prior. In this example we are interested in the posterior
## standard deviation of an normal mean. Our prior is triangular over [-3, 3]
set.seed(123)
x = rnorm(20, -0.5, 1)

mu = seq(-3, 3, by = 0.001)

mu.prior = rep(0, length(mu))
mu.prior[mu &lt;= 0] = 1 / 3 + mu[mu &lt;= 0] / 9
mu.prior[mu &gt; 0] = 1 / 3 - mu[mu &gt; 0] / 9

results = normgcp(x, 1, density = "user", mu = mu, mu.prior = mu.prior, plot = FALSE)
sd(results)
</code></pre>


</div>