<div class="container">

<table style="width: 100%;"><tr>
<td>MDL</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
BIMETS Model Description Language
</h2>

<h3>Description</h3>

<p>BIMETS provides a language to unambiguously specify an econometric model. This page describes how to create a model and its general structure. The specification of an econometric model is translated and identified by keyword statements which are grouped in a model file, i.e. a plain text file or a <code>character</code> variable with a specific syntax. Collectively, these keyword statements constitute the BIMETS Model Description Language (from now on <code>MDL</code>). The model specifications consist of groups of statements. Each statement begins with a keyword. The keyword classifies the component of the model which is being specified.<br><br>
Below is an example of a Klein's model  with an <code>MDL</code> compliant syntax which can either be stored in a <code>character</code> variable or in a plain text file.<br><br> 
For more realistic scenarios, several advanced econometric exercises on the US Federal Reserve FRB/US econometric model (e.g., dynamic simulation in a monetary policy shock, rational expectations, endogenous targeting, stochastic simulation, etc.) are available in the <a href="https://cran.r-project.org/package=bimets/vignettes/frb2bimets.pdf">"US Federal Reserve quarterly model (FRB/US) in R with bimets"</a> vignette. <br><br>
The content of the <em>klein1.txt</em> variable  is:
</p>
<pre>
R&gt; klein1.txt="
MODEL 

COMMENT&gt; Consumption
BEHAVIORAL&gt; cn
TSRANGE 1921 1 1941 1
EQ&gt; cn =  a1 + a2*p + a3*TSLAG(p,1) + a4*(w1+w2) 
COEFF&gt; a1 a2 a3 a4

COMMENT&gt; Investment
BEHAVIORAL&gt; i
TSRANGE 1921 1 1941 1
EQ&gt; i = b1 + b2*p + b3*TSLAG(p,1) + b4*TSLAG(k,1)
COEFF&gt; b1 b2 b3 b4

COMMENT&gt; Demand for Labor
BEHAVIORAL&gt; w1 
TSRANGE 1921 1 1941 1
EQ&gt; w1 = c1 + c2*(y+t-w2) + c3*TSLAG(y+t-w2,1)+c4*time
COEFF&gt; c1 c2 c3 c4

COMMENT&gt; Gross National Product
IDENTITY&gt; y
EQ&gt; y = cn + i + g - t

COMMENT&gt; Profits
IDENTITY&gt; p
EQ&gt; p = y - (w1+w2)

COMMENT&gt; Capital Stock
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1) + i

END
"
</pre>
<p>Please note that there are circular dependencies between equations of the model, e.g. <code>p &lt;- w1 &lt;- y &lt;- p</code> as shown in the <code>"BIMETS package"</code> section figure in the <a href="https://CRAN.R-project.org/package=bimets/bimets.pdf">pdf version</a> of this reference manual. Circular dependencies imply that the model simulation must be solved with an iterative algorithm.<br><br>
As shown, the model definition is quite intuitive. The first keyword is <code>MODEL</code>, while at the end of the model definition we can find the <code>END</code> keyword. Available tags in the definition of a generic BIMETS model are: 
<br><br>
- <b>EQUATION&gt;</b> or <b>BEHAVIORAL&gt;</b> indicate the beginning of a series of keyword statements describing a behavioral equation. The behavioral statement general form is: <br><code>BEHAVIORAL&gt; name  [TSRANGE startYear, startPeriod, endYear, endPeriod]</code>  <br>
where <code>name</code> is the name of the behavioral equation and the optional <code>TSRANGE</code> specifies that the provided time interval must be used to estimate the coefficients. The optional <code>TSRANGE</code> is defined as a 4-dimensional numerical array built with starting year, starting period, ending year, and ending period.<br><br>
Given <code class="reqn">Y=\beta*X+\epsilon</code>, where <code class="reqn">Y</code> are the historical values of the dependent variable and <code class="reqn">X</code> are the historical values of the regressors, if the requested estimation method is <code>OLS</code> (Ordinary Least Squares), in the general case (i.e. no restrictions nor error auto-correlation, as described later) the coefficients will be calculated as: <code class="reqn">\beta_{OLS}=(X' * X) ^{-1} * X' * Y</code>.<br><br>
If the requested estimation method is <code>IV</code> (Instrumental Variables), given <code class="reqn">Z</code> the matrix built with instrumental variables as columns <code class="reqn">Z_i</code>, that should not be correlated to the disturbance terms, i.e. <code class="reqn">E[ \epsilon ' * Z_i] = 0</code>, the coefficients will be either calculated as <br><code class="reqn">\beta_{IV}=(Z' * X) ^{-1} * Z' * Y</code>, or more generally as: <code class="reqn">\beta_{IV}=(\hat{X}' * \Omega^{-1} * \hat{X}) ^{-1} * \hat{X}' * \Omega^{-1} * Y</code> where <code class="reqn">\hat{X} = Z * (Z' * Z)^{-1} * Z' * X</code> and <code class="reqn">\Omega = \sigma^{2} * I</code>,  <code class="reqn">\sigma^{2} = E[ \epsilon' * \epsilon]</code><br><br>
- <b>IDENTITY&gt;</b> indicates the beginning of a series of keyword statements describing an identity or technical equation. The identity statement general form is: <br><code>IDENTITY&gt; name</code><br> where <code>name</code> is the identity name.<br><br>
- <b>EQ&gt;</b> specifies the mathematical expression for a behavioral or an identity equation. <br><br>
The equation statement general form for a behavioral equation is:<br><code>EQ&gt; LHS = coeff1*f1 + coeff2*f2 + coeff3*f3 + ...</code><br>
where <code>LHS</code> is a function of the behavioral variable, <br><code>coeff1, coeff2, coeff3, ...</code> are the coefficient names of the equation and <br><code>f1, f2, f3, ...</code> are functions of variables.<br><br>
The equation statement general form for an identity equation is:<br><code>EQ&gt; LHS = f1 + f2 + f3 + ...</code> <br> where <code>LHS</code> is a function of the identity variable and <br><code>f1, f2, f3, ...</code> are functions of variables.<br><br>
The following <code>MDL</code> functions can be used in the <code>LHS</code> left-hand side of the equation, with <code>name</code> as the name of the behavioral or the identity variable: <br><br>
- <code>name</code> - i.e. the identity function;<br><br>
- <code>TSDELTA(name,i)</code> - <code>i</code>-periods difference of the <code>name</code> time series;<br><br>
- <code>TSDELTAP(name,i)</code> - <code>i</code>-periods percentage difference of the <code>name</code> time series;<br><br>
- <code>TSDELTALOG(name,i)</code> - <code>i</code>-periods logarithmic difference of the <code>name</code> time series;<br><br>
- <code>LOG(name)</code> - log of the <code>name</code> time series;<br><br>
- <code>EXP(name)</code> - exponential of the <code>name</code> time series. <br><br>
On the other side, the mathematical expression available for use in the <code>RHS</code> right-hand side of the <code>EQ&gt;</code> equation and in the <code>IV&gt;</code> expression described later in this page (i.e. <code>f1, f2, f3, ...</code>) can include the standard arithmetic operators, parentheses and the following <code>MDL</code> functions:<br><br>
- <code>TSLAG(ts,i)</code> - lag the <code>ts</code> time series by <code>i</code>-periods;<br><br>
- <code>TSLEAD(ts,i)</code> - lead the <code>ts</code> time series by <code>i</code>-periods;<br><br>
- <code>TSDELTA(ts,i)</code> - <code>i</code>-periods difference of the <code>ts</code> time series;<br><br>
- <code>TSDELTAP(ts,i)</code> - <code>i</code>-periods percentage difference of the <code>ts</code> time series;<br><br>
- <code>TSDELTALOG(ts,i)</code> - <code>i</code>-periods logarithmic difference of the <code>ts</code> time series;<br><br>
- <code>MOVAVG(ts,i)</code> - <code>i</code>-periods moving average of the <code>ts</code> time series;<br><br>
- <code>MOVSUM(ts,i)</code> - <code>i</code>-periods moving sum of the <code>ts</code> time series;<br><br>
- <code>LOG(ts)</code> - log of the <code>ts</code> time series;<br><br>
- <code>EXP(ts)</code> - exponential of the <code>ts</code> time series; <br><br>
- <code>ABS(ts)</code> - absolute values of the <code>ts</code> time series.<br><br>
Note that BIMETS classifies a model as a forward-looking model if any model equation contains the <code>TSLEAD</code> time series function. More details about forward-looking models are available in the "Rational Expectations Models" section of the <code>SIMULATE</code> help pages.<br><br><code>MDL</code> function names are reserved names. They cannot be used as variable or coefficient names. The coefficient names are specified in a subsequent <code>COEFF&gt;</code> keyword statement within a behavioral equation. By definition, identities do not have any coefficient that must be assessed. Any name not specified as a coefficient name or mentioned on the list of the available <code>MDL</code> functions is assumed to be a variable.<br><br>
- <b>COEFF&gt;</b> specifies the coefficient names used in the EQ&gt; keyword statement of a behavioral equation. The coefficients statement general form is:<br><code>COEFF&gt; coeff0 coeff1 coeff2 ... coeffn</code>. <br> The coefficients order in this statement must be the same as it appears in the behavioral equation.<br><br>
- <b>ERROR&gt;</b> specifies an autoregressive process of a given order for the regression error. The error statement general form is:<br><code>ERROR&gt; AUTO(n)</code> <br> where <code>n</code> is the order of the autoregressive process for the error.<br><br> During an estimation, users must ensure that the required data are available for the specified error structure: <code>n</code> periods of data before the time interval specified by <code>TSRANGE</code> must be defined in any time series involved in the regression.<br><br> The solution requires an iterative algorithm. Given <code class="reqn">Y_{1}=\beta_{1}*X_{1}+\epsilon_{1}</code>, where <code class="reqn">Y_{1}</code> are the historical values of the dependent variable and <code class="reqn">X_{1}</code> are the historical values of the regressors, the iterative algorithm is based on the Cochrane-Orcutt procedure:<br><br>
1) Make an initial estimation by using the original TSRANGE extended backward <code>n</code> periods (given <code>n</code> as the autocorrelation order).<br><br>
2) Estimate the error autocorrelation coefficients <code class="reqn">\rho_{i}=\rho_{i,1},...,\rho_{i,n}</code> with <code class="reqn">i=1</code> by regressing the residuals <code class="reqn">\epsilon_{i}</code> on their lagged values by using the auxiliary model: <br><code class="reqn">\epsilon_{i}=\rho_{i,1}*TSLAG(\epsilon_{i},1)+...+\rho_{i,n}*TSLAG(\epsilon_{i},n)</code><br><br>
3) Transform the data for the dependent and the independent variables by using the estimated <code class="reqn">\rho_{i}</code>. The new dependent variable will be: <code class="reqn">Y_{i+1}=P_i*Y_i</code>, and the new independent variables will be <code class="reqn">X_{i+1}=P_i*X_i</code> with the matrix <code class="reqn">P_i</code> defined as:
</p>
<p style="text-align: center;"><code class="reqn"> P_i = \left( \begin{array}{ccccccc}
1 &amp; 0 &amp; 0 &amp; 0 &amp; ... &amp; 0 &amp; 0 \cr 
-\rho_{i,1} &amp; 1 &amp; 0 &amp; 0 &amp; ... &amp; 0 &amp; 0 \cr 
-\rho_{i,2} &amp; -\rho_{i,1} &amp; 1 &amp; 0 &amp; ... &amp; 0 &amp; 0 \cr 
 &amp;  &amp;  &amp; ... &amp;  &amp;  &amp;  \cr 
0 &amp; 0 &amp; ... &amp; -\rho_{i,n} &amp; ... &amp; -\rho_{i,1} &amp; 1 
\end{array} \right) </code>
</p>
 <p><br>
4) Run another estimation on the original model <code class="reqn">Y_{i+1}=\beta_{i+1}*X_{i+1}+\epsilon_{i+1}</code> by using the suitable <code>TSRANGE</code> and the transformed data coming out of step 3 and compute the new time series for the residuals. <br><br>
5) Estimate the new autocorrelation coefficients <code class="reqn">\rho_{i+1}=\rho_{i+1,1},...,\rho_{i+1,n}</code>, by regressing the new residuals arising from step 4 (similar to step 2)<br><br>
6) Carry out the convergence check through a comparison among the previous <code class="reqn">\rho_{i}</code> and the new ones arising from steps 5. <br> If <code class="reqn">all(abs(\rho_{i+1}-\rho_{i})&lt;\delta)</code>, where <code class="reqn">\rho_{i}</code> is the <code class="reqn">\rho</code> vector at the iteration <code class="reqn">i</code> and <code class="reqn">\delta</code> is a small convergence factor, then exit otherwise repeat from step 3 with <code>i &lt;- i+1</code>. <br><br>
- <b>RESTRICT&gt;</b> is a keyword that can be used to specify linear coefficient restrictions. A deterministic restriction can be applied to any equation coefficient. Any number of <code>RESTRICT&gt;</code> keywords is allowed for each behavioral equation.<br><br> A deterministic (exact) coefficient restriction sets a linear expression containing one or more coefficients equal to a constant. The restriction only affects the coefficients of the behavioral equation in which it is specified. The restriction statement general form is:
</p>
<pre>
RESTRICT&gt; linear_combination_of_coefficients_1 = value_1
...
linear_combination_of_coefficients_n = value_n
</pre>
<p> where <code>linear_combination_of_coefficients_i, i=1..n</code> is a linear combination of the coefficient(s) to be restricted and <code>value_i</code> is the in-place scalar value to which the linear combination of the coefficients is set equal. Each linear combination can be set equal to a different value.<br><br><code>MDL</code> example:
</p>
<pre>
RESTRICT&gt; coeff1 = 0
coeff2 = 10.5
coeff3-3*coeff4+1.2*coeff5 = 0
</pre>
<p>In many econometric packages, linear restrictions have to be coded by hand in the equations. BIMETS allows users to write down the restriction in a natural way, thus applying a constrained minimization. This procedure, although it leads to approximate numerical estimates, allows an easy implementation.<br><br>
The theory behind this procedure is that of the Lagrange multipliers. Presented here is an example of its implementation.<br><br> Suppose that we have an equation defined as:
</p>
<pre>
EQUATION&gt; Y TSRANGE 2010 1 2015 4 
EQ&gt; Y = C1*X1 + C2*X2 + C3*X3 
COEFF&gt; C1 C2 C3 
RESTRICT&gt; 1.1*C1 + 1.3*C3 = 2.1 
1.2*C2 = 0.8
</pre>
<p>Coefficients <code>C1, C2, C3</code> are to be estimated. They are subject to the linear constraints specified by the <code>RESTRICT&gt;</code> keyword statement. In the case of <code>OLS</code> estimation, this is carried out in the following steps:<br><br>
1) Compute the cross-product matrices <code class="reqn">X' X </code> and <code class="reqn">X' Y</code> where <code class="reqn">X</code> is a matrix with dimension <br><code>[NOBS x NREG]</code> containing the values of the independent variables (regressors) historical observations (and a vector of ones for the constant term, if any), and where <code class="reqn">Y</code> is a <code>NOBS</code> elements vector of the dependent variable (regressand) historical observations; <code>NOBS</code> is the number of observations available on the <code>TSRANGE</code> specified in the behavioral equation, and <code>NREG</code> is the number of regressors, or coefficients;<br><br>
2) Build the restriction matrices. In the example:<br><br><code class="reqn">R = \left( \begin{array}{ccc}1.1 &amp; 0 &amp; 1.3  \cr 0 &amp; 1.2 &amp; 0 \end{array} \right) </code> <br><br>
and <br><br><code class="reqn">r = \left( \begin{array}{c} 2.1  \cr 0.8  \end{array} \right)</code> <br><br></p>
<p><code>R</code> is a matrix of <code>[NRES x NREG]</code> size, and <code>r</code> is a vector of <code>[NRES]</code> length, where <code>NRES</code> is the number of restrictions;<br><br>
3) Compute the scaling factors for the augmentation to be performed in the next step:<br></p>
<p style="text-align: center;"><code class="reqn">Rscale[i]=\frac{mean(X' X)}{max(abs(R[i,]))}</code>
</p>

<p>where <code class="reqn">R[i,]</code> is the i-th row of the <code>R</code> matrix.<br><br>
Assuming <code class="reqn">mean(X' X) = 5000</code>, in the example above we will have:<br><code class="reqn">Rscale[1]=5000 / 1.3</code> <br><code class="reqn">Rscale[2]=5000 / 1.2</code> <br><br>
The augmented matrices will then be defined as:<br><br><code class="reqn">R_{aug} = \left( \begin{array}{ccc} 1.1 * Rscale[1] &amp; 0 &amp; 1.3 * Rscale[1] \cr 0 &amp; 1.2 * Rscale[2] &amp; 0 \end{array} \right) </code>
</p>
<p>and <br><br><code class="reqn">r_{aug} = \left( \begin{array}{c} 2.1 * Rscale[1] \cr 0.8 * Rscale[2]  \end{array} \right) </code> <br></p>
<p>4) Compute the so-called "augmented" cross-product matrix <code class="reqn">(X' X)_{aug}</code> by adding to the cross-product matrix <code class="reqn">(X' X)</code> a total of <code>NRES</code> rows and <code>NRES</code> columns:
<br><br><code class="reqn">(X' X)_{aug} = \left( \begin{array}{cc} X' X &amp; R_{aug}' \cr R_{aug} &amp; 0 \end{array} \right) </code>
<br><br>
5) Similarly, compute the so-called "augmented" cross-product matrix <code class="reqn">(X' Y)_{aug}</code> by adding a total of <code>NRES</code> elements to the cross-product matrix <code class="reqn">(X' Y)</code>:
<br><br><code class="reqn">(X' Y)_{aug}=\left( \begin{array}{c} X' Y \cr r_{aug}  \end{array} \right) </code>
<br><br>
6) Calculate the <code class="reqn">\hat{\beta}_{aug}</code> augmented coefficients by regressing the <code class="reqn">(X' Y)_{aug}</code> on the <code class="reqn">(X' X)_{aug}</code>.<br><br> The first <code>NREG</code> values of the augmented coefficients <code class="reqn">\hat{\beta}_{aug}</code> array are the estimated coefficients with requested restrictions. The last <code>NRES</code> values are the errors we have on the deterministic restrictions.<br><br>
In the case of <code>IV</code> estimation, the procedure is the same as in the <code>OLS</code> case, but the matrix <code class="reqn">X</code> has to be replaced with the matrix <code class="reqn">\hat{X}</code>, as previously defined in the <code>BEHAVIORAL&gt;</code> keyword.<br><br>
- <b>PDL&gt;</b> is a keyword that defines an Almon polynomial distributed lag to be used in estimation. Almon Polynomial distributed lags are specific kind of deterministic restrictions imposed on the coefficients of the distributed lags of a specific regressor. Multiple PDLs on a single behavioral equation can be defined. <br><br> The PDL&gt; statement general form is:<br><code>PDL&gt; coeffname degree laglength [N] [F]</code><br> where <code>coeffname</code> is the name of a coefficient, <code>degree</code> is an integer scalar specifying the degree of the polynomial, <code>laglength</code> is an integer scalar specifying the length of the polynomial (in number of time periods), the optional <code>N</code> (i.e. "nearest") means that the nearest lagged term of the expansion, i.e., the first term, is restricted to zero, and the optional <code>F</code> (i.e. "farthest") means that the farthest lagged term of the expansion, i.e., the last term, is restricted to zero; the <code>PDL&gt;</code> keyword statement thusly defined applies an Almon polynomial distributed lag to the regressor associated with the <code>coeffname</code> coefficient, of <code>laglength</code> length and <code>degree</code> degree, by providing the appropriate expansion and the deterministic restrictions for the degree and length specified. These expansions are not explicitly shown to the user, i.e., the original model is not changed.<br><br><code>laglength</code> must be greater than <code>degree</code> (see example below).<br><br> A PDL term can be further referenced in a <code>RESTRICT&gt;</code> keyword statement by using the following syntax: <code>LAG(coefname, pdllag)</code>.<br><br> Example: <code>RESTRICT&gt; LAG(coeff2,3) = 0</code> means that, during the estimation, the regressor related to the coefficient <code>coeff2</code> and lagged by 3 periods in the PDL expansion must have a coefficient equal to zero. This example also implies that a <code>PDL&gt; coeff2 x y</code> with <code>y &gt; 3</code> has been declared in the same behavioral. <br><br>
The implementing rules are the following:<br><br>
1) Read off the <code>laglength</code> of the PDL keyword and expand the column of the regressor related to <code>coeffname</code> in the matrix <code>X</code> (i.e. the original regressors matrix) with the lagged values of the regressor, from left to right, starting form the lag 1 to the lag <code>laglength-1</code>. The matrix <code>X</code> will now have a <code>[NOBS x (NREG+laglength-1)]</code> size, with <code>NOBS</code> as the number of observations in the specified <code>TSRANGE</code> and <code>NREG</code> as the number of regressors, or coefficients.<br><br>
2) Build the restriction matrix <code>R</code> with the following <code>[ Nrow x Ncol ]</code> dimensions:<br><code>Nrow = laglength - ( degree + 1 )</code><br><code>Ncol = NREG + laglength - 1</code><br><br>
This matrix's elements will be zero except for the (<code>laglength</code>)-columns related to the section of the expanded columns in the <code>X</code> matrix. For every row we will have to insert <code>degree+2</code> numbers different from zero.<br><br>
The <code>degree+2</code> numbers are taken form the Tartaglia's-like triangle:
</p>
<pre>
1 -2  1
1 -3  3 -1
1 -4  6 -4   1
1 -5 10 -10  5  1
... ... ... ...
</pre>
<p>where in the <code>i</code>-th row we find the numbers for a PDL of <code>degree=i</code>.<br><br>
The <code>r</code> vector giving the knows terms for the restrictions is a vector of<br><code>NRES = laglength - (degree + 1)</code> elements equal to zero.<br><br>
An example will clarify:
</p>
<pre>
EQUATION&gt; Y TSRANGE 2010 1 2015 4 
EQ&gt; Y = C1*X1 + C2*X2 + C3*X3 
COEFF&gt; C1 C2 C3 
PDL&gt; C2 2 5
</pre>
<p> then <br><br><code class="reqn">R = \left( \begin{array}{ccccccc} 0 &amp; 1 &amp; -3 &amp; 3 &amp; 1 &amp; 0 &amp; 0 \cr 0 &amp; 0 &amp; 1 &amp; -3 &amp; 3 &amp; 1 &amp; 0 \end{array} \right) </code>
<br><br> and <br><br><code class="reqn">r = \left( \begin{array}{c} 0  \cr 0 \end{array} \right) </code>
<br><br><br>
The expanded regressors are:<br><code>X1, X2, TSLAG(X2,1), TSLAG(X2,2), TSLAG(X2,3), TSLAG(X2,4), X3</code>.<br><br> The scaling factor is given, as in the standard restriction case, by: <code class="reqn">mean(X' X) / max(abs(R[i,]))</code> <br><br></p>
<p>- <b>IF&gt;</b> keyword is used to conditionally evaluate an identity during a simulation, depending on a logical expression's value. Thus, it is possible to have a model alternating between two or more identity specifications for each simulation period, depending upon results from other equations.<br><br>
The IF&gt; statement general form is:<br><code>IF&gt; logical_expression</code><br><br> The <code>IF&gt;</code> keyword must be specified within an identity group; this keyword causes the equation specified in the identity group to be evaluated during the current simulation period only when the <code>logical_expression</code> is <code>TRUE</code>.<br><br> Only one <code>IF&gt;</code> keyword is allowed in an identity group. Further occurrences produce an error message, and processing stops.<br><br>
The <code>logical_expression</code> can be composed of constants, endogenous variables, exogenous variables, an expression among variables, combinations of the logical operators; mathematical operators and the <code>MDL</code> functions listed in the <code>EQ&gt;</code> section are allowed.<br><br>
In the following <code>MDL</code> example, the value of the endogenous <code>myIdentity</code> variable is specified with two complementary conditional identities, depending on the <code>TSDELTA()</code> result:
</p>
<pre>
IDENTITY&gt; myIdentity
IF&gt; TSDELTA(myEndog*(1-myExog)) &gt; 0
EQ&gt; myIdentity = TSLAG(myIdentity)+1

IDENTITY&gt; myIdentity
IF&gt; TSDELTA(myEndog*(1-myExog)) &lt;= 0
EQ&gt; myIdentity = TSLAG(myIdentity)
</pre>
<p>- <b>IV&gt;</b> specifies the mathematical expression for an instrumental variable used in a behavioral equation. <br><br>
The general form for an instrumental variable expression is:<br><code>IV&gt; f1 + f2 + f3 + ...</code> <br><code>f1, f2, f3, ...</code> are functions of variables.<br><br>
The mathematical expression available for use in the <code>IV&gt;</code> definition are those already described in the <code>EQ&gt;</code> section.<br><br>
- <b>COMMENT&gt;</b> can be used to insert comments into a model. The general form of this keyword is:<br><code>COMMENT&gt; text</code><br><br>
The <code>text</code> following the <code>COMMENT&gt;</code> keyword is ignored during all processing and must lie in the same line. Comments cannot be inserted within another keyword statement. A dollar sign in the first position of a line is equivalent to using the COMMENT&gt; keyword, as in this exmaple:<br><code>
$This is a comment
</code>
<br><br> No other keywords are currently allowed in the <code>MDL</code> syntax.<br><br></p>


<h3>See Also</h3>

<p><code>LOAD_MODEL</code><br><code>ESTIMATE</code><br><code>SIMULATE</code><br><code>STOCHSIMULATE</code><br><code>MULTMATRIX</code><br><code>RENORM</code><br><code>OPTIMIZE</code><br><code>TIMESERIES</code><br><code>BIMETS indexing</code><br><code>BIMETS configuration</code><br><code>summary</code><br></p>


<h3>Examples</h3>

<pre><code class="language-R">
#########################################################
#KLEIN MODEL WITH AUTOCORRELATION, RESTRICTIONS AND 
#CONDITIONAL EVALUATIONS

#define model
myModel&lt;-
"MODEL

COMMENT&gt; Modified Klein Model 1 of the U.S. Economy with PDL, 
COMMENT&gt; autocorrelation on errors, restrictions and conditional evaluations

COMMENT&gt; Consumption with autocorrelation on errors
BEHAVIORAL&gt; cn
TSRANGE 1925 1 1941 1
EQ&gt; cn =  a1 + a2*p + a3*TSLAG(p,1) + a4*(w1+w2) 
COEFF&gt; a1 a2 a3 a4
ERROR&gt; AUTO(2)

COMMENT&gt; Investment with restrictions
BEHAVIORAL&gt; i
TSRANGE 1923 1 1941 1
EQ&gt; i = b1 + b2*p + b3*TSLAG(p,1) + b4*TSLAG(k,1)
COEFF&gt; b1 b2 b3 b4
RESTRICT&gt; b2 + b3 = 1

COMMENT&gt; Demand for Labor with PDL
BEHAVIORAL&gt; w1 
TSRANGE 1925 1 1941 1
EQ&gt; w1 = c1 + c2*(y+t-w2) + c3*TSLAG(y+t-w2,1)+c4*time
COEFF&gt; c1 c2 c3 c4
PDL&gt; c3 1 2

COMMENT&gt; Gross National Product
IDENTITY&gt; y
EQ&gt; y = cn + i + g - t

COMMENT&gt; Profits
IDENTITY&gt; p
EQ&gt; p = y - (w1+w2)

COMMENT&gt; Capital Stock with switches
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1) + i
IF&gt; i &gt; 0
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1) 
IF&gt; i &lt;= 0

END"

#define model data
modelData&lt;-list(
  cn    =TIMESERIES(39.8,41.9,45,49.2,50.6,52.6,55.1,56.2,57.3,57.8,55,50.9,
            45.6,46.5,48.7,51.3,57.7,58.7,57.5,61.6,65,69.7,
            START=c(1920,1),FREQ=1),
  g     =TIMESERIES(4.6,6.6,6.1,5.7,6.6,6.5,6.6,7.6,7.9,8.1,9.4,10.7,10.2,9.3,10,
            10.5,10.3,11,13,14.4,15.4,22.3,
            START=c(1920,1),FREQ=1),
  i     =TIMESERIES(2.7,-.2,1.9,5.2,3,5.1,5.6,4.2,3,5.1,1,-3.4,-6.2,-5.1,-3,-1.3,
            2.1,2,-1.9,1.3,3.3,4.9,
            START=c(1920,1),FREQ=1),
  k     =TIMESERIES(182.8,182.6,184.5,189.7,192.7,197.8,203.4,207.6,210.6,215.7,
            216.7,213.3,207.1,202,199,197.7,199.8,201.8,199.9,
            201.2,204.5,209.4,
            START=c(1920,1),FREQ=1),
  p     =TIMESERIES(12.7,12.4,16.9,18.4,19.4,20.1,19.6,19.8,21.1,21.7,15.6,11.4,
            7,11.2,12.3,14,17.6,17.3,15.3,19,21.1,23.5,
            START=c(1920,1),FREQ=1),
  w1    =TIMESERIES(28.8,25.5,29.3,34.1,33.9,35.4,37.4,37.9,39.2,41.3,37.9,34.5,
            29,28.5,30.6,33.2,36.8,41,38.2,41.6,45,53.3,
            START=c(1920,1),FREQ=1),
  y     =TIMESERIES(43.7,40.6,49.1,55.4,56.4,58.7,60.3,61.3,64,67,57.7,50.7,41.3,
            45.3,48.9,53.3,61.8,65,61.2,68.4,74.1,85.3,
            START=c(1920,1),FREQ=1),
  t     =TIMESERIES(3.4,7.7,3.9,4.7,3.8,5.5,7,6.7,4.2,4,7.7,7.5,8.3,5.4,6.8,7.2,
            8.3,6.7,7.4,8.9,9.6,11.6,
            START=c(1920,1),FREQ=1),
  time  =TIMESERIES(NA,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,  
            START=c(1920,1),FREQ=1),   
  w2    =TIMESERIES(2.2,2.7,2.9,2.9,3.1,3.2,3.3,3.6,3.7,4,4.2,4.8,5.3,5.6,6,6.1,
            7.4,6.7,7.7,7.8,8,8.5,
            START=c(1920,1),FREQ=1)
)

#load model and model data
model&lt;-LOAD_MODEL(modelText=myModel)
model&lt;-LOAD_MODEL_DATA(model,modelData)

#estimate model
model&lt;-ESTIMATE(model)

#simulate model
model&lt;-SIMULATE(model
               ,TSRANGE=c(1923,1,1941,1)
               ,simConvergence=0.00001
               ,simIterLimit=100
)


#########################################################
#KLEIN MODEL WITH LHS FUNCTIONS


#define the model with LHS funs
myModel&lt;-'MODEL

COMMENT&gt; Modified Klein Model 1 of the U.S. Economy with PDL,
COMMENT&gt; autocorrelation on errors, restrictions and conditional evaluations
COMMENT&gt; LHS functions on EQ

COMMENT&gt; Exp Consumption
BEHAVIORAL&gt; cn
TSRANGE 1925 1 1941 1
EQ&gt; EXP(cn) = a1 + a2*p + a3*TSLAG(p,1) + a4*(w1+w2)
COEFF&gt; a1 a2 a3 a4
ERROR&gt; AUTO(2)

COMMENT&gt; Log Investment
BEHAVIORAL&gt; i
TSRANGE 1925 1 1941 1
EQ&gt; LOG(i) = b1 + b2*p + b3*TSLAG(p,1) + b4*TSLAG(k,1)
COEFF&gt; b1 b2 b3 b4
RESTRICT&gt; b2 + b3 = 1

COMMENT&gt; Demand for Labor
BEHAVIORAL&gt; w1
TSRANGE 1925 1 1941 1
EQ&gt; w1 = c1 + c2*(TSDELTA(y)+t-w2) + c3*TSLAG(TSDELTA(y)+t-w2,1)+c4*time
COEFF&gt; c1 c2 c3 c4
PDL&gt; c3 1 3

COMMENT&gt; Delta Gross National Product
IDENTITY&gt; y
EQ&gt; TSDELTA(y) = EXP(cn) + LOG(i) + g - t

COMMENT&gt; Profits
IDENTITY&gt; p
EQ&gt; p = TSDELTA(y) - (w1+w2)

COMMENT&gt; Capital Stock with switches
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1) + LOG(i)
IF&gt; LOG(i) &gt; 0
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1)
IF&gt; LOG(i) &lt;= 0

END'

 
#define model data
modelData&lt;-list(
  cn=TSERIES(39.8,41.9,45,49.2,50.6,52.6,55.1,56.2,57.3,
            57.8,55,50.9,45.6,46.5,48.7,51.3,57.7,58.7,57.5,61.6,65,69.7,
            START=c(1920,1),FREQ=1),
  g=TSERIES(4.6,6.6,6.1,5.7,6.6,6.5,6.6,7.6,7.9,8.1,9.4,
            10.7,10.2,9.3,10,10.5,10.3,11,13,14.4,15.4,22.3,
            START=c(1920,1),FREQ=1),
  i=TSERIES(2.7,-.2,1.9,5.2,3,5.1,5.6,4.2,3,5.1,1,-3.4,
            -6.2,-5.1,-3,-1.3,2.1,2,-1.9,1.3,3.3,4.9,
            START=c(1920,1),FREQ=1),
  k=TSERIES(182.8,182.6,184.5,189.7,192.7,197.8,203.4,
            207.6,210.6,215.7,216.7,213.3,207.1,202,
            199,197.7,199.8,201.8,199.9,201.2,204.5,209.4,
            START=c(1920,1),FREQ=1),
  p=TSERIES(12.7,12.4,16.9,18.4,19.4,20.1,19.6,19.8,21.1,
            21.7,15.6,11.4,7,11.2,12.3,14,17.6,17.3,15.3,19,21.1,23.5,
            START=c(1920,1),FREQ=1),
  w1=TSERIES(28.8,25.5,29.3,34.1,33.9,35.4,37.4,37.9,39.2,
            41.3,37.9,34.5,29,28.5,30.6,33.2,36.8,41,38.2,41.6,45,53.3,
            START=c(1920,1),FREQ=1),
  y=TSERIES(43.7,40.6,49.1,55.4,56.4,58.7,60.3,61.3,64,67,
            57.7,50.7,41.3,45.3,48.9,53.3,61.8,65,61.2,68.4,74.1,85.3,
            START=c(1920,1),FREQ=1),
  t=TSERIES(3.4,7.7,3.9,4.7,3.8,5.5,7,6.7,4.2,4,7.7,7.5,
            8.3,5.4,6.8,7.2,8.3,6.7,7.4,8.9,9.6,11.6,
            START=c(1920,1),FREQ=1),
  time=TSERIES(NA,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,
            3,4,5,6,7,8,9,10,  
            START=c(1920,1),FREQ=1),   
  w2=TSERIES(2.2,2.7,2.9,2.9,3.1,3.2,3.3,3.6,3.7,4,4.2,
            4.8,5.3,5.6,6,6.1,7.4,6.7,7.7,7.8,8,8.5,
            START=c(1920,1),FREQ=1)
)


#example data transformation
modelData&lt;-within(modelData,{
  i=exp(i);     #we have LOG(i)     in the model MDL definition
  cn=log(cn);   #we have EXP(cn)    in the model MDL definition
  y=CUMSUM(y)   #we have TSDELTA(y) in the model MDL definition
})

#load model and model data
model&lt;-LOAD_MODEL(modelText=myModel)
model&lt;-LOAD_MODEL_DATA(model,modelData)

#estimate model
model&lt;-ESTIMATE(model)

#simulate model
model&lt;-SIMULATE(model
               ,TSRANGE=c(1925,1,1930,1)
               ,simConvergence=0.00001
               ,simIterLimit=100
)

#########################################################
#SIMPLE MODEL WITH IV


#define the model with IVs
myShortModelDefinition&lt;-"
MODEL
COMMENT&gt; Consumption with IV
BEHAVIORAL&gt; cn
TSRANGE 1925 1 1941 1
EQ&gt; cn = a1 + a2*p + a3*TSLAG(p,1) + a4*(w1+w2)
COEFF&gt; a1 a2 a3 a4
IV&gt; 1
IV&gt; TSLAG(y)
IV&gt; TSLAG(w1)*pi+0.5
IV&gt; exp(w2)
END
" 

#load model 
myShortModel&lt;-LOAD_MODEL(modelText=myShortModelDefinition)

</code></pre>


</div>