<div class="container">

<table style="width: 100%;"><tr>
<td>MixNRMI2</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Normalized Random Measures Mixture of Type II</h2>

<h3>Description</h3>

<p>Bayesian nonparametric estimation based on normalized measures driven
mixtures for locations and scales.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MixNRMI2(
  x,
  probs = c(0.025, 0.5, 0.975),
  Alpha = 1,
  Kappa = 0,
  Gama = 0.4,
  distr.k = "normal",
  distr.py0 = "normal",
  distr.pz0 = "gamma",
  mu.pz0 = 3,
  sigma.pz0 = sqrt(10),
  delta_S = 4,
  kappa = 2,
  delta_U = 2,
  Meps = 0.01,
  Nx = 150,
  Nit = 1500,
  Pbi = 0.1,
  epsilon = NULL,
  printtime = TRUE,
  extras = TRUE,
  adaptive = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Numeric vector. Data set to which the density is fitted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>probs</code></td>
<td>
<p>Numeric vector. Desired quantiles of the density estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Alpha</code></td>
<td>
<p>Numeric constant. Total mass of the centering measure.  See
details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Kappa</code></td>
<td>
<p>Numeric positive constant. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Gama</code></td>
<td>
<p>Numeric constant. <code class="reqn">0 \leq Gama \leq 1</code>.  See
details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distr.k</code></td>
<td>
<p>The distribution name for the kernel. Allowed names are "normal", "gamma", "beta", "double exponential", "lognormal" or their common abbreviations "norm", "exp", or an integer number identifying the mixture kernel: 1 = Normal; 2 = Gamma; 3 = Beta; 4 = Double Exponential; 5 = Lognormal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distr.py0</code></td>
<td>
<p>The distribution name for the centering measure for locations. Allowed names are "normal", "gamma", "beta", or their common abbreviations "norm", "exp", or an integer number identifying the centering measure for locations: 1 = Normal; 2 = Gamma; 3 = Beta.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distr.pz0</code></td>
<td>
<p>The distribution name for the centering measure for scales.  Allowed names are "gamma", or an integer number identifying the centering measure for
scales: 2 = Gamma. For more options use <code>MixNRMI2cens</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu.pz0</code></td>
<td>
<p>Numeric constant. Prior mean of the centering measure for
scales.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma.pz0</code></td>
<td>
<p>Numeric constant. Prior standard deviation of the centering
measure for scales.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta_S</code></td>
<td>
<p>Numeric positive constant. Metropolis-Hastings proposal
variation coefficient for sampling the scales.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa</code></td>
<td>
<p>Numeric positive constant. Metropolis-Hastings proposal
variation coefficient for sampling the location parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta_U</code></td>
<td>
<p>Numeric positive constant. Metropolis-Hastings proposal
variation coefficient for sampling the latent U. If 'adaptive=TRUE', 'delta_U'is the starting value for the adaptation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Meps</code></td>
<td>
<p>Numeric constant. Relative error of the jump sizes in the
continuous component of the process. Smaller values imply larger number of
jumps.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nx</code></td>
<td>
<p>Integer constant. Number of grid points for the evaluation of the
density estimate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nit</code></td>
<td>
<p>Integer constant. Number of MCMC iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Pbi</code></td>
<td>
<p>Numeric constant. Burn-in period proportion of <code>Nit</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>Numeric constant. Extension to the evaluation grid range.
See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>printtime</code></td>
<td>
<p>Logical. If TRUE, prints out the execution time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extras</code></td>
<td>
<p>Logical. If TRUE, gives additional objects: means, sigmas,
weights and Js.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adaptive</code></td>
<td>
<p>Logical. If TRUE, uses an adaptive MCMC strategy to sample the latent U (adaptive delta_U).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This generic function fits a normalized random measure (NRMI) mixture model
for density estimation (James et al. 2009). Specifically, the model assumes
a normalized generalized gamma (NGG) prior for both, locations (means) and
standard deviations, of the mixture kernel, leading to a fully nonparametric
mixture model.
</p>
<p>The details of the model are: </p>
<p style="text-align: center;"><code class="reqn">X_i|Y_i,Z_i \sim
k(\cdot|Y_i,Z_i)</code>
</p>
 <p style="text-align: center;"><code class="reqn">(Y_i,Z_i)|P \sim P,
i=1,\dots,n</code>
</p>
 <p style="text-align: center;"><code class="reqn">P \sim
\textrm{NGG}(\texttt{Alpha, Kappa, Gama; P\_0})</code>
</p>
<p> where, <code class="reqn">X_i</code>'s are the observed data, <code class="reqn">(Y_i,Z_i)</code>'s are
bivariate latent (location and scale) vectors, <code>k</code> is a parametric
kernel parameterized in terms of mean and standard deviation, <code>(Alpha,
Kappa, Gama; P_0)</code> are the parameters of the NGG prior with a bivariate
<code>P_0</code> being the centering measure with independent components, that is,
<code class="reqn">P_0(Y,Z) = P_0(Y)*P_0(Z)</code>. The parameters of <code>P_0(Y)</code> are assigned
vague hyper prior distributions and <code>(mu.pz0,sigma.pz0)</code> are the
hyper-parameters of <code>P_0(Z)</code>. In particular, <code>NGG(Alpha, 1, 0;
P_0)</code> defines a Dirichlet process; <code>NGG(1, Kappa, 1/2;P_0)</code> defines a
Normalized inverse Gaussian process; and <code>NGG(1, 0, Gama; P_0)</code> defines
a normalized stable process. The evaluation grid ranges from <code>min(x) -
epsilon</code> to <code>max(x) + epsilon</code>. By default <code>epsilon=sd(x)/4</code>.
</p>


<h3>Value</h3>

<p>The function returns a list with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>xx</code></td>
<td>
<p>Numeric vector. Evaluation grid.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qx</code></td>
<td>
<p>Numeric array. Matrix
of dimension <code class="reqn">\texttt{Nx} \times (\texttt{length(probs)} + 1)</code> with the posterior mean and the desired quantiles input
in <code>probs</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cpo</code></td>
<td>
<p>Numeric vector of <code>length(x)</code> with
conditional predictive ordinates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>Numeric vector of
<code>length(Nit*(1-Pbi))</code> with the number of mixtures components
(clusters).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>U</code></td>
<td>
<p>Numeric vector of <code>length(Nit*(1-Pbi))</code> with the
values of the latent variable U.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Allocs</code></td>
<td>
<p>List of
<code>length(Nit*(1-Pbi))</code> with the clustering allocations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>means</code></td>
<td>
<p>List of <code>length(Nit*(1-Pbi))</code> with the cluster means
(locations). Only if extras = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigmas</code></td>
<td>
<p>Numeric vector of
<code>length(Nit*(1-Pbi))</code> with the cluster standard deviations. Only if
extras = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>List of <code>length(Nit*(1-Pbi))</code> with the
mixture weights. Only if extras = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Js</code></td>
<td>
<p>List of
<code>length(Nit*(1-Pbi))</code> with the unnormalized weights (jump sizes). Only
if extras = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nm</code></td>
<td>
<p>Integer constant. Number of jumps of the
continuous component of the unnormalized process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta_Us</code></td>
<td>
<p>List of
<code>length(Nit*(1-Pbi))</code> with the sequence of adapted delta_U used in the MH step for the latent variable U.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nx</code></td>
<td>
<p>Integer
constant. Number of grid points for the evaluation of the density estimate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nit</code></td>
<td>
<p>Integer constant. Number of MCMC iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Pbi</code></td>
<td>
<p>Numeric constant. Burn-in period proportion of <code>Nit</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>procTime</code></td>
<td>
<p>Numeric vector with execution time provided by <code>proc.time</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distr.k</code></td>
<td>
<p>Integer corresponding to the kernel chosen for the mixture</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Data used for the fit</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NRMI_params</code></td>
<td>
<p>A named list with the parameters of the NRMI process</p>
</td>
</tr>
</table>
<h3>Warning </h3>

<p>The function is computing intensive. Be patient.
</p>


<h3>Author(s)</h3>

<p>Barrios, Kon Kam King, G., E., Lijoi, A., Nieto-Barajas, L.E. and Prüenster, I.
</p>


<h3>References</h3>

<p>1.- Barrios, E., Lijoi, A., Nieto-Barajas, L. E. and Prünster,
I. (2013). Modeling with Normalized Random Measure Mixture Models.
Statistical Science. Vol. 28, No. 3, 313-334.
</p>
<p>2.- James, L.F., Lijoi, A. and Prünster, I. (2009). Posterior analysis for
normalized random measure with independent increments. Scand. J. Statist 36,
76-97.
</p>
<p>3.- Arbel, J., Kon Kam King, G.,  Lijoi, A., Nieto-Barajas, L.E. and Prüenster, I. (2021). BNPdensity: a package for Bayesian Nonparametric density estimation using Normalised Random Measures with Independent Increments.. Australian and New Zealand Journal of Statistics, to appear
</p>


<h3>See Also</h3>

<p><code>MixNRMI2</code>, <code>MixNRMI1cens</code>,
<code>MixNRMI2cens</code>, <code>multMixNRMI1</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
### Example 1
# Data
data(acidity)
x &lt;- acidity
# Fitting the model under default specifications
out &lt;- MixNRMI2(x)
# Plotting density estimate + 95% credible interval
plot(out)

## End(Not run)

### Example 2
## Do not run
# set.seed(150520)
# data(enzyme)
# x &lt;- enzyme
#  Enzyme2.out &lt;- MixNRMI2(x, Alpha = 1, Kappa = 0.007, Gama = 0.5,
#                          distr.k = "gamma", distr.py0 = "gamma",
#                          distr.pz0 = "gamma", mu.pz0 = 1, sigma.pz0 = 1, Meps=0.005,
#                          Nit = 5000, Pbi = 0.2)
# The output of this run is already loaded in the package
# To show results run the following
# Data
data(enzyme)
x &lt;- enzyme
data(Enzyme2.out)
attach(Enzyme2.out)
# Plotting density estimate + 95% credible interval
plot(Enzyme2.out)
# Plotting number of clusters
par(mfrow = c(2, 1))
plot(R, type = "l", main = "Trace of R")
hist(R, breaks = min(R - 0.5):max(R + 0.5), probability = TRUE)
# Plotting u
par(mfrow = c(2, 1))
plot(U, type = "l", main = "Trace of U")
hist(U, nclass = 20, probability = TRUE, main = "Histogram of U")
# Plotting cpo
par(mfrow = c(2, 1))
plot(cpo, main = "Scatter plot of CPO's")
boxplot(cpo, horizontal = TRUE, main = "Boxplot of CPO's")
print(paste("Average log(CPO)=", round(mean(log(cpo)), 4)))
print(paste("Median log(CPO)=", round(median(log(cpo)), 4)))
detach()

### Example 3
## Do not run
# set.seed(150520)
# data(galaxy)
# x &lt;- galaxy
#  Galaxy2.out &lt;- MixNRMI2(x, Alpha = 1, Kappa = 0.015, Gama = 0.5,
#                          distr.k = "normal", distr.py0 = "gamma",
#                          distr.pz0 = "gamma", mu.pz0 = 1, sigma.pz0 = 1,  Meps=0.005,
#                          Nit = 5000, Pbi = 0.2)
# The output of this run is already loaded in the package
# To show results run the following
# Data
data(galaxy)
x &lt;- galaxy
data(Galaxy2.out)
attach(Galaxy2.out)
# Plotting density estimate + 95% credible interval
plot(Galaxy2.out)
# Plotting number of clusters
par(mfrow = c(2, 1))
plot(R, type = "l", main = "Trace of R")
hist(R, breaks = min(R - 0.5):max(R + 0.5), probability = TRUE)
# Plotting u
par(mfrow = c(2, 1))
plot(U, type = "l", main = "Trace of U")
hist(U, nclass = 20, probability = TRUE, main = "Histogram of U")
# Plotting cpo
par(mfrow = c(2, 1))
plot(cpo, main = "Scatter plot of CPO's")
boxplot(cpo, horizontal = TRUE, main = "Boxplot of CPO's")
print(paste("Average log(CPO)=", round(mean(log(cpo)), 4)))
print(paste("Median log(CPO)=", round(median(log(cpo)), 4)))
detach()
</code></pre>


</div>