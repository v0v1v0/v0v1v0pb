<div class="container">

<table style="width: 100%;"><tr>
<td>split_rank_hatR</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Computes the split-<code class="reqn">\hat{R}</code> estimate based on the rank normalization</h2>

<h3>Description</h3>

<p>The function computes the split-<code class="reqn">\hat{R}</code> estimate based on the rank
normalization.
</p>


<h3>Usage</h3>

<pre><code class="language-R">split_rank_hatR(MC)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>MC</code></td>
<td>
<p>An <code class="reqn">N \times M</code> matrix with N draws in each of M constructed
Markov chains.</p>
</td>
</tr></table>
<h3>Value</h3>

<p>a value with the the split-<code class="reqn">\hat{R}</code> estimate based on the rank
normalization
</p>


<h3>Examples</h3>

<pre><code class="language-R">dataREM&lt;-mvmeta::hyp
# Observation matrix X
X&lt;-t(cbind(dataREM$sbp,dataREM$dbp))
p&lt;-nrow(X) # model dimension
n&lt;-ncol(X) # sample size
# Matrix U
U&lt;-matrix(0,n*p,n*p)
for (i_n in 1:n) {
  Use&lt;-diag(c(dataREM$sbp_se[i_n],dataREM$dbp_se[i_n]))
  Corr_mat&lt;-matrix(c(1,dataREM$rho[i_n],dataREM$rho[i_n],1),p,p)
  U[(p*(i_n-1)+1):(p*i_n),(p*(i_n-1)+1):(p*i_n)]&lt;- Use%*%Corr_mat%*%Use
}
# Generating M Markov chains for mu_1
M&lt;-4 # number of chains
MC &lt;-NULL
for (i in 1:M) {
  chain &lt;-  BayesMultMeta(X, U, 1e2, burn_in = 1e2,
                          likelihood = "t", prior="jeffrey",
                          algorithm_version = "mu",d=3)
  MC&lt;- cbind(MC,chain$mu[1,])
}
split_rank_hatR(MC)

</code></pre>


</div>