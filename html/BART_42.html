<div class="container">

<table style="width: 100%;"><tr>
<td>pbart</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Probit BART for dichotomous outcomes with Normal latents</h2>

<h3>Description</h3>

<p>BART is a Bayesian “sum-of-trees” model.<br>



For a binary response <code class="reqn">y</code>, <code class="reqn">P(Y=1 | x) = F(f(x))</code>, where <code class="reqn">F</code>
denotes the standard Normal CDF (probit link).
</p>
<p>In both cases, <code class="reqn">f</code> is the sum of many tree models.
The goal is to have very flexible inference for the uknown
function <code class="reqn">f</code>.
</p>
<p>In the spirit of “ensemble models”,
each tree is constrained by a prior to be a weak learner
so that it contributes a
small amount to the overall fit.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pbart(
   x.train, y.train, x.test=matrix(0.0,0,0),
   sparse=FALSE, theta=0, omega=1,
   a=0.5, b=1, augment=FALSE, rho=NULL,
   xinfo=matrix(0.0,0,0), usequants=FALSE,
   cont=FALSE, rm.const=TRUE,
   k=2.0, power=2.0, base=.95,
   binaryOffset=NULL, 
   ntree=50L, numcut=100L,
   ndpost=1000L, nskip=100L, keepevery=1L,
   nkeeptrain=ndpost, nkeeptest=ndpost,

   nkeeptreedraws=ndpost,
   printevery=100L, transposed=FALSE 
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x.train</code></td>
<td>

<p>Explanatory variables for training (in sample) data.<br>
May be a matrix or a data frame,
with (as usual) rows corresponding to observations and columns to variables.<br>
If a variable is a factor in a data frame, it is replaced with dummies.
Note that q dummies are created if q&gt;2 and
one dummy is created if q=2, where q is the number of levels of the factor.
<code>pbart</code> will generate draws of <code class="reqn">f(x)</code> for each <code class="reqn">x</code>
which is a row of x.train.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y.train</code></td>
<td>

<p>Binary dependent variable for training (in sample) data.<br></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.test</code></td>
<td>

<p>Explanatory variables for test (out of sample) data.<br>
Should have same structure as x.train.<br><code>pbart</code> will generate draws of <code class="reqn">f(x)</code> for each <code class="reqn">x</code> which is a row of x.test.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sparse</code></td>
<td>
<p>Whether to perform variable selection based on a
sparse Dirichlet prior rather than simply uniform; see Linero 2016.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>Set <code class="reqn">theta</code> parameter; zero means random.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omega</code></td>
<td>
<p>Set <code class="reqn">omega</code> parameter; zero means random.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>Sparse parameter for <code class="reqn">Beta(a, b)</code> prior:
<code class="reqn">0.5&lt;=a&lt;=1</code> where lower values inducing more sparsity.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>Sparse parameter for <code class="reqn">Beta(a, b)</code> prior; typically,
<code class="reqn">b=1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>Sparse parameter: typically <code class="reqn">rho=p</code> where <code class="reqn">p</code> is the
number of covariates under consideration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>augment</code></td>
<td>
<p>Whether data augmentation is to be performed in sparse
variable selection.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xinfo</code></td>
<td>
<p> You can provide the cutpoints to BART or let BART
choose them for you.  To provide them, use the <code>xinfo</code>
argument to specify a list (matrix) where the items (rows) are the
covariates and the contents of the items (columns) are the
cutpoints.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>usequants</code></td>
<td>
<p> If <code>usequants=FALSE</code>, then the
cutpoints in <code>xinfo</code> are generated uniformly; otherwise,
if <code>TRUE</code>, uniform quantiles are used for the cutpoints. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cont</code></td>
<td>
<p> Whether or not to assume all variables are continuous.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rm.const</code></td>
<td>
<p> Whether or not to remove constant variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>




<p>For binary y,
k is the number of prior standard deviations <code class="reqn">f(x)</code> is away from +/-3.

The bigger k is, the more conservative the fitting will be.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>power</code></td>
<td>

<p>Power parameter for tree prior.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>base</code></td>
<td>

<p>Base parameter for tree prior.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>binaryOffset</code></td>
<td>

<p>Used for binary <code class="reqn">y</code>.<br>
The model is <code class="reqn">P(Y=1 | x) = F(f(x) + binaryOffset)</code>.<br></p>
</td>
</tr>
</table>
<table>
<tr style="vertical-align: top;">
<td><code>ntree</code></td>
<td>

<p>The number of trees in the sum.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numcut</code></td>
<td>

<p>The number of possible values of c (see usequants).
If a single number if given, this is used for all variables.
Otherwise a vector with length equal to ncol(x.train) is required,
where the <code class="reqn">i^{th}</code> element gives the number of c used for
the <code class="reqn">i^{th}</code> variable in x.train.
If usequants is false, numcut equally spaced cutoffs
are used covering the range of values in the corresponding
column of x.train.  If usequants is true, then  min(numcut, the number of unique values in the
corresponding columns of x.train - 1) c values are used.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ndpost</code></td>
<td>

<p>The number of posterior draws returned.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nskip</code></td>
<td>

<p>Number of MCMC iterations to be treated as burn in.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nkeeptrain</code></td>
<td>

<p>Number of MCMC iterations to be returned for train data.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nkeeptest</code></td>
<td>

<p>Number of MCMC iterations to be returned for test data.
</p>
</td>
</tr>
</table>
<table>
<tr style="vertical-align: top;">
<td><code>nkeeptreedraws</code></td>
<td>

<p>Number of MCMC iterations to be returned for tree draws.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keepevery</code></td>
<td>

<p>Every keepevery draw is kept to be returned to the user.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>printevery</code></td>
<td>

<p>As the MCMC runs, a message is printed every printevery draws.
</p>
</td>
</tr>
</table>
<table><tr style="vertical-align: top;">
<td><code>transposed</code></td>
<td>

<p>When running <code>pbart</code> in parallel, it is more memory-efficient
to transpose <code>x.train</code> and <code>x.test</code>, if any, prior to
calling <code>mc.pbart</code>.
</p>
</td>
</tr></table>
<h3>Details</h3>

<p>BART is an Bayesian MCMC method.
At each MCMC interation, we produce a draw from 


<code class="reqn">f</code> in the binary <code class="reqn">y</code> case.
</p>
<p>Thus, unlike a lot of other modelling methods in R, we do not produce a single model object
from which fits and summaries may be extracted.  The output consists of values
<code class="reqn">f^*(x)</code>

where * denotes a particular draw.
The <code class="reqn">x</code> is either a row from the training data (x.train) or the test data (x.test).
</p>


<h3>Value</h3>

<p><code>pbart</code> returns an object of type <code>pbart</code> which is
essentially a list. 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>yhat.train</code></td>
<td>

<p>A matrix with ndpost rows and nrow(x.train) columns.
Each row corresponds to a draw <code class="reqn">f^*</code> from the posterior of <code class="reqn">f</code>
and each column corresponds to a row of x.train.
The <code class="reqn">(i,j)</code> value is <code class="reqn">f^*(x)</code> for the <code class="reqn">i^{th}</code> kept draw of <code class="reqn">f</code>
and the <code class="reqn">j^{th}</code> row of x.train.<br>
Burn-in is dropped.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yhat.test</code></td>
<td>
<p>Same as yhat.train but now the x's are the rows of the test data.</p>
</td>
</tr>
</table>
<table><tr style="vertical-align: top;">
<td><code>varcount</code></td>
<td>
<p>a matrix with ndpost rows and nrow(x.train) columns.
Each row is for a draw. For each variable (corresponding to the columns),
the total count of the number of times
that variable is used in a tree decision rule (over all trees) is given.</p>
</td>
</tr></table>
<p>In addition the list
has a binaryOffset component giving the value used.
</p>
<p>Note that in the binary <code class="reqn">y</code>, case yhat.train and yhat.test are
<code class="reqn">f(x)</code> + binaryOffset.  If you want draws of the probability
<code class="reqn">P(Y=1 | x)</code> you need to apply the Normal CDF (<code>pnorm</code>)
to these values.
</p>


<h3>See Also</h3>

<p><code>wbart</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data(ACTG175)

## exclude those who do not have CD4 count at 96 weeks
ex &lt;- is.na(ACTG175$cd496)
table(ex)

## inclusion criteria are CD4 counts between 200 and 500
ACTG175$cd40 &lt;- min(500, max(250, ACTG175$cd40))

## calculate relative CD4 decline
y &lt;- ((ACTG175$cd496-ACTG175$cd40)/ACTG175$cd40)[!ex]
summary(y)

## 0=failure, 1=success
y &lt;- 1*(y &gt; -0.5)

## summarize CD4 outcomes
table(y, ACTG175$arms[!ex])

table(y, ACTG175$arms[!ex])/
    matrix(table(ACTG175$arms[!ex]), nrow=2, ncol=4, byrow=TRUE)

## drop unneeded and unwanted variables
## 1: 'pidnum' patient ID number
##14: 'str2' which will be handled by strat1 below
##15: 'strat' which will be handled by strat1-strat3 below
##17: 'treat' handled by arm0-arm3 below
##18: 'offtrt' indicator of off-treatment before 96 weeks
##20: 'cd420' CD4 T cell count at 20 weeks
##21: 'cd496' CD4 T cell count at 96 weeks
##22: 'r' missing CD4 T cell count at 96 weeks
##24: 'cd820' CD8 T cell count at 20 weeks
##25: 'cens' indicator of observing the event in days
##26: 'days' number of days until the primary endpoint
##27: 'arms' handled by arm0-arm3 below
train &lt;- as.matrix(ACTG175)[!ex, -c(1, 14:15, 17, 18, 20:22, 24:27)]
train &lt;- cbind(1*(ACTG175$strat[!ex]==1), 1*(ACTG175$strat[!ex]==2),
               1*(ACTG175$strat[!ex]==3), train)
dimnames(train)[[2]][1:3] &lt;- paste0('strat', 1:3)
train &lt;- cbind(1*(ACTG175$arms[!ex]==0), 1*(ACTG175$arms[!ex]==1),
               1*(ACTG175$arms[!ex]==2), 1*(ACTG175$arms[!ex]==3), train)
dimnames(train)[[2]][1:4] &lt;- paste0('arm', 0:3)

N &lt;- nrow(train)

test0 &lt;- train; test0[ , 1:4] &lt;- 0; test0[ , 1] &lt;- 1
test1 &lt;- train; test1[ , 1:4] &lt;- 0; test1[ , 2] &lt;- 1
test2 &lt;- train; test2[ , 1:4] &lt;- 0; test2[ , 3] &lt;- 1
test3 &lt;- train; test3[ , 1:4] &lt;- 0; test3[ , 4] &lt;- 1

test &lt;- rbind(test0, test1, test2, test3)

##test BART with token run to ensure installation works
set.seed(21)
post &lt;- pbart(train, y, test, nskip=5, ndpost=5)

## Not run: 
set.seed(21)
post &lt;- pbart(train, y, test)

## turn z-scores into probabilities
post$prob.test &lt;- pnorm(post$yhat.test)

## average over the posterior samples
post$prob.test.mean &lt;- apply(post$prob.test, 2, mean)

## place estimates for arms 0-3 next to each other for convenience
itr &lt;- cbind(post$prob.test.mean[(1:N)], post$prob.test.mean[N+(1:N)],
             post$prob.test.mean[2*N+(1:N)], post$prob.test.mean[3*N+(1:N)])

## find the BART ITR for each patient
itr.pick &lt;- integer(N)
for(i in 1:N) itr.pick[i] &lt;- which(itr[i, ]==max(itr[i, ]))-1

## arms 0 and 3 (monotherapy) are never chosen
table(itr.pick)

## do arms 1 and 2 show treatment heterogeneity?
diff. &lt;- apply(post$prob.test[ , 2*N+(1:N)]-post$prob.test[ , N+(1:N)], 2, mean)
plot(sort(diff.), type='h', main='ACTG175 trial: 50% CD4 decline from baseline at 96 weeks',
     xlab='Arm 2 (1) Preferable to the Right (Left)', ylab='Prob.Diff.: Arms 2 - 1')

library(rpart)
library(rpart.plot)

## make data frame for nicer names in the plot
var &lt;- as.data.frame(train[ , -(1:4)])

dss &lt;- rpart(diff. ~ var$age+var$gender+var$race+var$wtkg+var$cd40+var$cd80+
                   var$karnof+var$symptom+var$hemo+var$homo+var$drugs+var$z30+
                   var$zprior+var$oprior+var$strat1+var$strat2+var$strat3,
               method='anova', control=rpart.control(cp=0.1))
rpart.plot(dss, type=3, extra=101)

## if strat1==1 (antiretroviral naive), then arm 2 is better
## otherwise, arm 1
print(dss)

all0 &lt;- apply(post$prob.test[ , (1:N)], 1, mean)
all1 &lt;- apply(post$prob.test[ , N+(1:N)], 1, mean)
all2 &lt;- apply(post$prob.test[ , 2*N+(1:N)], 1, mean)
all3 &lt;- apply(post$prob.test[ , 3*N+(1:N)], 1, mean)

## BART ITR
BART.itr &lt;- apply(post$prob.test[ , c(N+which(itr.pick==1), 2*N+which(itr.pick==2))], 1, mean)

test &lt;- train
test[ , 1:4] &lt;- 0
test[test[ , 5]==0, 2] &lt;- 1
test[test[ , 5]==1, 3] &lt;- 1

## BART ITR simple
BART.itr.simp &lt;- pwbart(test, post$treedraws)
BART.itr.simp &lt;- apply(pnorm(BART.itr.simp), 1, mean)

plot(density(BART.itr), xlab='Value', xlim=c(0.475, 0.775), lwd=2,
     main='ACTG175 trial: 50% CD4 decline from baseline at 96 weeks')
lines(density(BART.itr.simp), col='brown', lwd=2)
lines(density(all0), col='green', lwd=2)
lines(density(all1), col='red', lwd=2)
lines(density(all2), col='blue', lwd=2)
lines(density(all3), col='yellow', lwd=2)
legend('topleft', legend=c('All Arm 0 (ZDV only)', 'All Arm 1 (ZDV+DDI)',
                           'All Arm 2 (ZDV+DDC)', 'All Arm 3 (DDI only)',
                           'BART ITR simple', 'BART ITR'),
       col=c('green', 'red', 'blue', 'yellow', 'brown', 'black'), lty=1, lwd=2)


## End(Not run)
</code></pre>


</div>