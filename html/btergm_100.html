<div class="container">

<table style="width: 100%;"><tr>
<td>gof-statistics</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Statistics for goodness-of-fit assessment of network models</h2>

<h3>Description</h3>

<p>Statistics for goodness-of-fit assessment of network models.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dsp(mat, ...)

esp(mat, ...)

nsp(mat, ...)

deg(mat, ...)

b1deg(mat, ...)

b2deg(mat, ...)

odeg(mat, ...)

ideg(mat, ...)

kstar(mat, ...)

b1star(mat, ...)

b2star(mat, ...)

ostar(mat, ...)

istar(mat, ...)

kcycle(mat, ...)

geodesic(mat, ...)

triad.directed(mat, ...)

triad.undirected(mat, ...)

comemb(vec)

walktrap.modularity(mat, ...)

walktrap.roc(sim, obs, ...)

walktrap.pr(sim, obs, ...)

fastgreedy.modularity(mat, ...)

fastgreedy.roc(sim, obs, ...)

fastgreedy.pr(sim, obs, ...)

louvain.modularity(mat, ...)

louvain.roc(sim, obs, ...)

louvain.pr(sim, obs, ...)

maxmod.modularity(mat, ...)

maxmod.roc(sim, obs, ...)

maxmod.pr(sim, obs, ...)

edgebetweenness.modularity(mat, ...)

edgebetweenness.roc(sim, obs, ...)

edgebetweenness.pr(sim, obs, ...)

spinglass.modularity(mat, ...)

spinglass.roc(sim, obs, ...)

spinglass.pr(sim, obs, ...)

rocpr(sim, obs, roc = TRUE, pr = TRUE, joint = TRUE, pr.impute = "poly4", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mat</code></td>
<td>
<p>A sparse network matrix as created by the <code>Matrix</code> function
in the <span class="pkg">Matrix</span> package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments. This must be present in all auxiliary GOF
statistics.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vec</code></td>
<td>
<p>A vector of community memberships in order to create a community
co-membership matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sim</code></td>
<td>
<p>A list of simulated networks. Each element in the list should be a
sparse matrix as created by the <code>Matrix</code> function in
the <span class="pkg">Matrix</span> package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obs</code></td>
<td>
<p>A list of observed (= target) networks. Each element in the list
should be a sparse matrix as created by the <code>Matrix</code>
function in the <span class="pkg">Matrix</span> package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>roc</code></td>
<td>
<p>Compute receiver-operating characteristics (ROC)?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pr</code></td>
<td>
<p>Compute precision-recall curve (PR)?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>joint</code></td>
<td>
<p>Merge all time steps into a single big prediction task and
compute predictive fit (instead of computing GOF for all time steps
separately)?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pr.impute</code></td>
<td>
<p>In some cases, the first precision value of the
precision-recall curve is undefined. The <code>pr.impute</code> argument serves
to impute this missing value to ensure that the AUC-PR value is not
severely biased. Possible values are <code>"no"</code> for no imputation,
<code>"one"</code> for using a value of <code>1.0</code>, <code>"second"</code> for using the
next (= adjacent) precision value, <code>"poly1"</code> for fitting a straight
line through the remaining curve to predict the first value, <code>"poly2"</code>
for fitting a second-order polynomial curve etc. until <code>"poly9"</code>.
Warning: this is a pragmatic solution. Please double-check whether the
imputation makes sense. This can be checked by plotting the resulting
object and using the <code>pr.poly</code> argument to plot the predicted curve on
top of the actual PR curve.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functions can be plugged into the <code>statistics</code> argument of the
<code>gof</code> methods in order to compare observed with simulated networks (see
the gof-methods help page). There are three types of statistics:
</p>

<ol>
<li>
<p> Univariate statistics, which aggregate a network into a single
quantity. For example, modularity measures or density. The distribution
of statistics can be displayed using histograms, density plots, and
median bars. Univariate statistics take a sparse matrix (<code>mat</code>)
as an argument and return a single numeric value that summarize a network
matrix.
</p>
</li>
<li>
<p> Multivariate statistics, which aggregate a network into a vector of
quantities. For example, the distribution of geodesic distances, edgewise
shared partners, or indegree. These statistics typically have multiple
values, e.g., esp(1), esp(2), esp(3) etc. The results can be displayed
using multiple boxplots for simulated networks and a black curve for the
observed network(s). Multivariate statistics take a sparse matrix
(<code>mat</code>) as an argument and return a vector of numeric values that
summarize a network matrix.
</p>
</li>
<li>
<p> Tie prediction statistics, which predict dyad states the observed
network(s) by the dyad states in the simulated networks. For example,
receiver operating characteristics (ROC) or precision-recall curves (PR)
of simulated networks based on the model, or ROC or PR predictions of
community co-membership matrices of the simulated vs. the observed
network(s). Tie prediction statistics take a list of simulated sparse
network matrices and another list of observed sparse network matrices
(possibly containing only a single sparse matrix) as arguments and return
a <code>rocpr</code>, <code>roc</code>, or <code>pr</code> object (as created by the
rocpr function).
</p>
</li>
</ol>
<p>Users can create their own statistics for use with the <code>gof</code> methods. To
do so, one needs to write a function that accepts and returns the respective
objects described in the enumeration above. It is advisable to look at the
definitions of some of the existing functions to add custom functions. It is
also possible to add an attribute called <code>label</code> to the return object,
which describes what is being returned by the function. This label will be
used as a descriptive label in the plot and for verbose output during
computations. The examples section contains an example of a custom user
statistic. Note that all statistics <em>must</em> contain the <code>...</code>
argument to ensure that custom arguments of other statistics do not cause an
error.
</p>
<p>To aid the development of custom statistics, the helper function
<code>comemb</code> is available: it accepts a vector of community memberships and
converts it to a co-membership matrix. This function is also used internally
by statistics like <code>walktrap.roc</code> and others.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>dsp()</code>: Multivariate GOF statistic: dyad-wise shared
partner distribution
</p>
</li>
<li> <p><code>esp()</code>: Multivariate GOF statistic: edge-wise shared
partner distribution
</p>
</li>
<li> <p><code>nsp()</code>: Multivariate GOF statistic: non-edge-wise shared
partner distribution
</p>
</li>
<li> <p><code>deg()</code>: Multivariate GOF statistic: degree distribution
</p>
</li>
<li> <p><code>b1deg()</code>: Multivariate GOF statistic: degree distribution
for the first mode
</p>
</li>
<li> <p><code>b2deg()</code>: Multivariate GOF statistic: degree distribution
for the second mode
</p>
</li>
<li> <p><code>odeg()</code>: Multivariate GOF statistic: outdegree distribution
</p>
</li>
<li> <p><code>ideg()</code>: Multivariate GOF statistic: indegree distribution
</p>
</li>
<li> <p><code>kstar()</code>: Multivariate GOF statistic: k-star distribution
</p>
</li>
<li> <p><code>b1star()</code>: Multivariate GOF statistic: k-star distribution
for the first mode
</p>
</li>
<li> <p><code>b2star()</code>: Multivariate GOF statistic: k-star distribution
for the second mode
</p>
</li>
<li> <p><code>ostar()</code>: Multivariate GOF statistic: outgoing k-star
distribution
</p>
</li>
<li> <p><code>istar()</code>: Multivariate GOF statistic: incoming k-star
distribution
</p>
</li>
<li> <p><code>kcycle()</code>: Multivariate GOF statistic: k-cycle distribution
</p>
</li>
<li> <p><code>geodesic()</code>: Multivariate GOF statistic: geodesic distance
distribution
</p>
</li>
<li> <p><code>triad.directed()</code>: Multivariate GOF statistic: triad census in
directed networks
</p>
</li>
<li> <p><code>triad.undirected()</code>: Multivariate GOF statistic: triad census in
undirected networks
</p>
</li>
<li> <p><code>comemb()</code>: Helper function: create community co-membership
matrix
</p>
</li>
<li> <p><code>walktrap.modularity()</code>: Univariate GOF statistic: Walktrap modularity
distribution
</p>
</li>
<li> <p><code>walktrap.roc()</code>: Tie prediction GOF statistic: ROC of Walktrap
community detection. Receiver-operating characteristics of predicting the
community structure in the observed network(s) by the community structure
in the simulated networks, as computed by the Walktrap algorithm.
</p>
</li>
<li> <p><code>walktrap.pr()</code>: Tie prediction GOF statistic: PR of Walktrap
community detection. Precision-recall curve for predicting the community
structure in the observed network(s) by the community structure in the
simulated networks, as computed by the Walktrap algorithm.
</p>
</li>
<li> <p><code>fastgreedy.modularity()</code>: Univariate GOF statistic: fast and greedy
modularity distribution
</p>
</li>
<li> <p><code>fastgreedy.roc()</code>: Tie prediction GOF statistic: ROC of fast and
greedy community detection. Receiver-operating characteristics of
predicting the community structure in the observed network(s) by the
community structure in the simulated networks, as computed by the fast and
greedy algorithm. Only sensible with undirected networks.
</p>
</li>
<li> <p><code>fastgreedy.pr()</code>: Tie prediction GOF statistic: PR of fast and
greedy community detection. Precision-recall curve for predicting the
community structure in the observed network(s) by the community structure
in the simulated networks, as computed by the fast and greedy algorithm.
Only sensible with undirected networks.
</p>
</li>
<li> <p><code>louvain.modularity()</code>: Univariate GOF statistic: Louvain clustering
modularity distribution
</p>
</li>
<li> <p><code>louvain.roc()</code>: Tie prediction GOF statistic: ROC of Louvain
community detection. Receiver-operating characteristics of predicting the
community structure in the observed network(s) by the community structure
in the simulated networks, as computed by the Louvain algorithm.
</p>
</li>
<li> <p><code>louvain.pr()</code>: Tie prediction GOF statistic: PR of Louvain
community detection. Precision-recall curve for predicting the community
structure in the observed network(s) by the community structure in the
simulated networks, as computed by the Louvain algorithm.
</p>
</li>
<li> <p><code>maxmod.modularity()</code>: Univariate GOF statistic: maximal modularity
distribution
</p>
</li>
<li> <p><code>maxmod.roc()</code>: Tie prediction GOF statistic: ROC of maximal
modularity community detection. Receiver-operating characteristics of
predicting the community structure in the observed network(s) by the
community structure in the simulated networks, as computed by the
modularity maximization algorithm.
</p>
</li>
<li> <p><code>maxmod.pr()</code>: Tie prediction GOF statistic: PR of maximal
modularity community detection. Precision-recall curve for predicting the
community structure in the observed network(s) by the community structure
in the simulated networks, as computed by the modularity maximization
algorithm.
</p>
</li>
<li> <p><code>edgebetweenness.modularity()</code>: Univariate GOF statistic: edge betweenness
modularity distribution
</p>
</li>
<li> <p><code>edgebetweenness.roc()</code>: Tie prediction GOF statistic: ROC of edge
betweenness community detection. Receiver-operating characteristics of
predicting the community structure in the observed network(s) by the
community structure in the simulated networks, as computed by the
Girvan-Newman edge betweenness community detection method.
</p>
</li>
<li> <p><code>edgebetweenness.pr()</code>: Tie prediction GOF statistic: PR of edge
betweenness community detection. Precision-recall curve for predicting the
community structure in the observed network(s) by the community structure
in the simulated networks, as computed by the Girvan-Newman edge
betweenness community detection method.
</p>
</li>
<li> <p><code>spinglass.modularity()</code>: Univariate GOF statistic: spinglass modularity
distribution
</p>
</li>
<li> <p><code>spinglass.roc()</code>: Tie prediction GOF statistic: ROC of spinglass
community detection. Receiver-operating characteristics of predicting the
community structure in the observed network(s) by the community structure
in the simulated networks, as computed by the Spinglass algorithm.
</p>
</li>
<li> <p><code>spinglass.pr()</code>: Tie prediction GOF statistic: PR of spinglass
community detection. Precision-recall curve for predicting the community
structure in the observed network(s) by the community structure in the
simulated networks, as computed by the Spinglass algorithm.
</p>
</li>
<li> <p><code>rocpr()</code>: Tie prediction GOF statistic: ROC and PR curves.
Receiver-operating characteristics (ROC) and precision-recall curve (PR).
Prediction of the dyad states of the observed network(s) by the dyad states
of the simulated networks.
</p>
</li>
</ul>
<h3>References</h3>

<p>Leifeld, Philip, Skyler J. Cranmer and Bruce A. Desmarais (2018): Temporal
Exponential Random Graph Models with btergm: Estimation and Bootstrap
Confidence Intervals. <em>Journal of Statistical Software</em> 83(6): 1–36.
<a href="https://doi.org/10.18637/jss.v083.i06">doi:10.18637/jss.v083.i06</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># To see how these statistics are used, look at the examples section of 
# ?"gof-methods". The following example illustrates how custom 
# statistics can be created. Suppose one is interested in the density 
# of a network. Then a univariate statistic can be created as follows.

dens &lt;- function(mat, ...) {        # univariate: one argument
  mat &lt;- as.matrix(mat)             # sparse matrix -&gt; normal matrix
  d &lt;- sna::gden(mat)               # compute the actual statistic
  attributes(d)$label &lt;- "Density"  # add a descriptive label
  return(d)                         # return the statistic
}

# Note that the '...' argument must be present in all statistics. 
# Now the statistic can be used in the statistics argument of one of 
# the gof methods.

# For illustrative purposes, let us consider an existing statistic, the 
# indegree distribution, a multivariate statistic. It also accepts a 
# single argument. Note that the sparse matrix is converted to a 
# normal matrix object when it is used. First, statnet's summary 
# method is used to compute the statistic. Names are attached to the 
# resulting vector for the different indegree values. Then the vector 
# is returned.

ideg &lt;- function(mat, ...) {
  d &lt;- summary(mat ~ idegree(0:(nrow(mat) - 1)))
  names(d) &lt;- 0:(length(d) - 1)
  attributes(d)$label &lt;- "Indegree"
  return(d)
}

# See the gofstatistics.R file in the package for more complex examples.

</code></pre>


</div>