<div class="container">

<table style="width: 100%;"><tr>
<td>dgemm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Matrix Multiply</h2>

<h3>Description</h3>

<p>This is function provides dgemm functionality, which DGEMM 
performs one of the matrix-matrix operations.
C := ALPHA * op(A) * op(B) + BETA * C.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dgemm(
  TRANSA = "N",
  TRANSB = "N",
  M = NULL,
  N = NULL,
  K = NULL,
  ALPHA = 1,
  A,
  LDA = NULL,
  B,
  LDB = NULL,
  BETA = 0,
  C,
  LDC = NULL,
  COFF = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>TRANSA</code></td>
<td>
<p>a character. TRANSA specifies the form of op( A ) to be used in the matrix multiplication as follows:
</p>

<dl>
<dt>TRANSA =</dt>
<dd>
<p> 'N' or 'n',  op( A ) = A.</p>
</dd>
<dt>TRANSA =</dt>
<dd>
<p> 'T' or 't',  op( A ) = A**T.</p>
</dd>
<dt>TRANSA =</dt>
<dd>
<p> 'C' or 'c',  op( A ) = A**T.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>TRANSB</code></td>
<td>
<p>a character. TRANSB specifies the form of op( B ) to be used in the matrix multiplication as follows:
#' </p>

<dl>
<dt>TRANSA =</dt>
<dd>
<p> 'N' or 'n',  op( B ) = B.</p>
</dd>
<dt>TRANSA =</dt>
<dd>
<p> 'T' or 't',  op( B ) = B**T.</p>
</dd>
<dt>TRANSA =</dt>
<dd>
<p> 'C' or 'c',  op( B ) = B**T.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>an integer. M specifies the number of rows  of the  matrix op( A )  and of the  matrix  C.  M  must  be at least  zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>an integer. N specifies the number of columns  of the  matrix op( B )  and of the  matrix  C.  N  must  be at least  zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>an integer. K specifies the number of columns  of the  matrix op( A )  and the number of rows of the  matrix  op( B ).  K  must  be at least  zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ALPHA</code></td>
<td>
<p>a real number. Specifies the scalar alpha.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>a matrix of dimension (LDA, ka), where ka is k  when  TRANSA = 'N' or 'n',  and is  m  otherwise. Before entry with  TRANSA = 'N' or 'n',  the leading  m by k part of the array  A  must contain the matrix  A,  otherwise the leading  k by m  part of the array  A  must contain  the matrix A.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LDA</code></td>
<td>
<p>an integer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>a matrix of dimension ( LDB, kb ), where kb is n  when  TRANSB = 'N' or 'n',  and is  k  otherwise. Before entry with  TRANSB = 'N' or 'n',  the leading  k by n part of the array  B  must contain the matrix  B,  otherwise the leading  n by k  part of the array  B  must contain  the matrix B.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LDB</code></td>
<td>
<p>an integer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BETA</code></td>
<td>
<p>a real number. Specifies the scalar beta</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>
<p>a matrix of dimension ( LDC, N ). Before entry, the leading  m by n  part of the array  C must contain the matrix  C,  except when  beta  is zero, in which case C need not be set on entry. On exit, the array  C  is overwritten by the  m by n  matrix ( alpha*op( A )*op( B ) + beta*C ).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LDC</code></td>
<td>
<p>an integer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>COFF</code></td>
<td>
<p>offset for C.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Update C with the result.
</p>


<h3>Examples</h3>

<pre><code class="language-R">require(bigmemory)
A = as.big.matrix(matrix(1, nrow=3, ncol=2))
B &lt;- big.matrix(2, 3, type="double", init=-1,
                dimnames=list(NULL, c("alpha", "beta")), shared=FALSE)
C = big.matrix(3, 3, type="double", init=1,
               dimnames=list(NULL, c("alpha", "beta", "gamma")), shared=FALSE)  
2*A[,]%*%B[,]+0.5*C[,]
E = dgemm(ALPHA=2.0, A=A, B=B, BETA=0.5, C=C)
E[,] # Same result

# The big.matrix file backings will be deleted when garbage collected.
rm(A,B,C,E)
gc()
</code></pre>


</div>