<div class="container">

<table style="width: 100%;"><tr>
<td>mi.eval</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Multiple-imputation evaluation
</h2>

<h3>Description</h3>

<p>Evaluation of an expression across multiply imputed data sets.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mi.eval(EXPR, robust, cluster, coef., vcov., df.=NULL,
parallel=FALSE, lazy=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>EXPR</code></td>
<td>

<p>An R expression to evaluate. This expression must contain a <code>data</code>
argument that specifies a list containing the imputed data sets or a
an object of class
<code>amelia</code>,
<code>mids</code>,
or
<code>imputationList</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>robust</code></td>
<td>

<p>Whether to use Huber-White robust standard errors. The default is
<code>TRUE</code> if <code>cluster</code> is specified and <code>FALSE</code> otherwise.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>

<p>A vector specifying clusters for the purpose of computing clustered
robust standard errors. This can be a variable inside the
imputed data set. If unspecified, standard errors are not clustered. If
specified, <code>robust</code> cannot be <code>FALSE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coef.</code></td>
<td>

<p>The function used to get a numeric vector of coefficient estimates when
evaluated on  an object returned from evaluating <code>EXPR</code> for each
data set. The default is to use <code>coef</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov.</code></td>
<td>

<p>The function that returns a numeric matrix giving the variance-covariance
matrix when evaluated on an object returned from evaluating <code>EXPR</code>
for each data set. The default is to use <code>vcovCR</code> if
<code>cluster</code> is specified, <code>vcovHC</code> if
<code>robust=TRUE</code> and <code>cluster</code> is not specified, and
<code>vcov</code> otherwise.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df.</code></td>
<td>

<p>Either the degrees of freedom for each model or a function that
calculates degrees of freedom on an object returned from evaluating
<code>EXPR</code> for each data set. The default value of <code>NULL</code> uses
the minimum result of applying <code>df.residual</code> it
returns a numeric value when applied to the object returned by
<code>EXPR</code> and this object is not of class <code>glm</code> and <code>Inf</code>
otherwise.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>

<p>A logical indicating whether to evaluate <code>EXPR</code> across data sets in
parallel using <code>mclapply</code>. Otherwise, 
evaluation is done serially using <code>lapply</code>.
<code>NULL</code> means to use parallel evaluation if and only if the
'parallel' package can be loaded and
<code>getOption("mc.cores", detectCores()-1L)</code> is greater than 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lazy</code></td>
<td>

<p>A logical indicating whether to use lazy evaluation to avoid copying all
imputed data sets into memory. When the <code>data</code> argument to
<code>EXPR</code> generates the multiply imputed data set, this is generally a
bad idea because it means redoing the imputation multiple times. The
default value of <code>NULL</code> means to use lazy evaluation if and only if
the <code>data</code> argument to <code>EXPR</code> is a <code>name</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Any additional arguments to be passed to <code>lapply</code> or
<code>mclapply</code> when evaluating <code>EXPR</code> across data sets.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function evaluates a R command for each of several multiply imputed
data sets and combines results across data sets into a single set of
estimates. This is similar to the functionality provided by
<code>with.mids</code> but also works with multiply-imputed data
sets generated by other packages like 'Amelia' as well as those from
'mice'.
</p>
<p>For generating formatted tables of
regression coefficients, the outputted objects should be
compatible with the 'texreg' package. When used with <code>lm</code>,
<code>glm</code> or a few other types of models, these objects are also
compatible with the 'stargazer' package.
</p>


<h3>Value</h3>

<p>An object of class <code>mi.estimates</code> containing the coefficient
estimates, variance-covariance matrix, and related information.
</p>


<h3>See Also</h3>

<p>See Also <code>summary.mi.estimates</code>,
<code>with.mids</code>,
<code>amelia</code>,
<code>mice</code>,
<code>coef</code>,
<code>vcov</code>
and
<code>df.residual</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (require("Amelia")) {
    ## Load data
    data(africa)
    africa$civlib &lt;- factor(round(africa$civlib*6), ordered=TRUE)

    ## Estimate a linear model using imputed data sets
    model0 &lt;- lm(trade ~ log(gdp_pc), data=africa, subset=year==1973)
    summary(model0)

    ## Impute using Amelia    
    a.out &lt;- amelia(x = africa, cs = "country", ts = "year",
                    logs = "gdp_pc", ord="civlib")

    ## Estimate a linear model using imputed data sets
    model1 &lt;- mi.eval(lm(trade ~ log(gdp_pc), data=a.out, subset=year==1973))

    ## Show estimates
    model1
    coef(model1)

    ## Show summary information
    summary(model1)

    if (require("MASS")) {
        ## Estimate an ordered logit model
        model2 &lt;- mi.eval(polr(civlib ~ log(gdp_pc) + log(population),
                               data=a.out))
        summary(model2)

        ## Also show thresholds by including thresholds with coefficients
        model3 &lt;- mi.eval(polr(civlib ~ log(gdp_pc) + log(population),
                               data=a.out),
                          coef=function(x) c(x$coefficients, x$zeta))
        summary(model2)
    }
}
</code></pre>


</div>