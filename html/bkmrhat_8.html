<div class="container">

<table style="width: 100%;"><tr>
<td>kmbayes_continue</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Continue sampling from existing bkmr fit</h2>

<h3>Description</h3>

<p>Use this when you've used MCMC sampling with the <code>kmbayes</code> function, but you did not take enough samples and do not want to start over.
</p>


<h3>Usage</h3>

<pre><code class="language-R">kmbayes_continue(fit, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>output from <code>kmbayes</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments to <code>kmbayes_continue</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Note this does not fully start from the prior values of the MCMC chains. The <code>kmbayes</code> function does not allow full specification of the kernel function parameters, so this will restart the chain at the last values of all fixed effect parameters, and start the kernel <code>r</code> parmeters at the arithmetic mean of all <code>r</code> parameters from the last step in the previous chain.
</p>


<h3>Value</h3>

<p>a <code>bkmrfit.continued</code> object, which inherits from <code>bkmrfit</code> objects similar to <code>kmbayes</code> output, and which can be used to make inference using functions from the <code>bkmr</code> package.
</p>


<h3>See Also</h3>

<p><code>kmbayes_parallel</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(111)
dat &lt;- bkmr::SimData(n = 50, M = 4)
y &lt;- dat$y
Z &lt;- dat$Z
X &lt;- dat$X
## Not run: 
fitty1 = bkmr::kmbayes(y=y,Z=Z,X=X, est.h=TRUE, iter=100)
# do some diagnostics here to see if 100 iterations (default) is enough
# add 100 additional iterations (for illustration - still will not be enough)
fitty2 = kmbayes_continue(fitty1, iter=100)
cobj = as.mcmc(fitty2)
varnames(cobj)


## End(Not run)

</code></pre>


</div>