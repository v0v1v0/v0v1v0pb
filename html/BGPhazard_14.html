<div class="container">

<table style="width: 100%;"><tr>
<td>CGaMRes</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Markov Gamma Model with Covariates</h2>

<h3>Description</h3>

<p>Posterior inference for the Bayesian non-parametric Markov gamma model with
covariates in survival analysis.
</p>


<h3>Usage</h3>

<pre><code class="language-R">CGaMRes(
  data,
  type.t = 2,
  length = 1,
  K = 5,
  alpha = rep(0.01, K),
  beta = rep(0.01, K),
  c.r = rep(1, K - 1),
  c.nu = 1,
  var.theta.str = 25,
  var.theta.ini = 100,
  a.eps = 0.1,
  b.eps = 0.1,
  type.c = 4,
  epsilon = 1,
  iterations = 1000,
  burn.in = floor(iterations * 0.2),
  thinning = 3,
  printtime = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Double tibble. Contains failure times in the first column,
status indicator in the second, and, from the third to the last column, the
covariate(s).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type.t</code></td>
<td>
<p>Integer. 1=computes uniformly-dense intervals; 2=length
intervals defined by user and 3=same length intervals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>length</code></td>
<td>
<p>Integer. Interval length of the partition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>Integer. Partition length for the hazard function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Nonnegative entry vector. Small entries are recommended in
order to specify a non-informative prior distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>Nonnegative entry vector. Small entries are recommended in order
to specify a non-informative prior distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.r</code></td>
<td>
<p>Nonnegative vector. The higher the entries, the higher the correlation of 
two consecutive intervals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.nu</code></td>
<td>
<p>Tuning parameter for the proposal distribution for c.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.theta.str</code></td>
<td>
<p>Double. Variance of the proposal normal distribution
for theta in the Metropolis-Hastings step.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.theta.ini</code></td>
<td>
<p>Double. Variance of the prior normal distribution for theta.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a.eps</code></td>
<td>
<p>Double. Shape parameter for the prior gamma distribution of
epsilon when <code>type.c = 4</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.eps</code></td>
<td>
<p>Double. Scale parameter for the prior gamma distribution of
epsilon when <code>type.c = 4</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type.c</code></td>
<td>
<p>1=defines <code>c.r</code> as a zero-entry vector; 2=lets the user
define <code>c.r</code> freely; 3=assigns <code>c.r</code> by computing an exponential
prior distribution with mean 1; 4=assigns <code>c.r</code> an exponential hierarchical
distribution with mean <code>epsilon</code> which in turn has a Ga(a.eps, b.eps)
distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>Double. Mean of the exponential distribution assigned to
<code>c.r</code> when <code>type.c = 3</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterations</code></td>
<td>
<p>Integer. Number of iterations including the <code>burn.in</code>
to be computed for the Markov chain.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burn.in</code></td>
<td>
<p>Integer. Length of the burn-in period for the Markov chain.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thinning</code></td>
<td>
<p>Integer. Factor by which the chain will be thinned. Thinning
the Markov chain reduces autocorrelation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>printtime</code></td>
<td>
<p>Logical. If <code>TRUE</code>, prints out the execution time.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Computes the Gibbs sampler with the full conditional distributions of
Lambda and Theta (Nieto-Barajas, 2003) and arranges the resulting Markov
chain into a matrix which can be used to obtain posterior summaries. Prior
distributions for the re gression coefficients (Theta) are assumed independent normals
with zero mean and variance <code>var.theta.ini</code>.
</p>


<h3>Note</h3>

<p>It is recommended to verify chain's stationarity. This can be done by
checking each element individually. See CGaPlotDiag
To obtain posterior summaries of the coefficients use function
CGaPloth.
</p>


<h3>References</h3>

<p>- Nieto-Barajas, L. E. (2003). Discrete time Markov gamma
processes and time dependent covariates in survival analysis. <em>Bulletin
of the International Statistical Institute 54th Session</em>. Berlin. (CD-ROM).
</p>
<p>- Nieto-Barajas, L. E. &amp; Walker, S. G. (2002). Markov beta and gamma
processes for modelling hazard rates. <em>Scandinavian Journal of
Statistics</em> <strong>29</strong>: 413-424.
</p>


<h3>See Also</h3>

<p>CGaPlotDiag, CGaPloth
</p>


<h3>Examples</h3>

<pre><code class="language-R">


## Simulations may be time intensive. Be patient.

## Example 1
#  data(leukemiaFZ)
#  leukemia1 &lt;- leukemiaFZ
#  leukemia1$wbc &lt;- log(leukemiaFZ$wbc)
#  CGEX1 &lt;- CGaMRes(data = leukemia1, K = 10, iterations = 100, thinning = 1)

## Example 2. Refer to "Cox-gamma model example" section in package vignette for details.
# SampWeibull &lt;- function(n, a = 10, b = 1, beta = c(1, 1)) {
#   M &lt;- tibble(i = seq(n), x_i1 = runif(n), x_i2 = runif(n), 
#               t_i = rweibull(n, shape = b, 
#                                 scale = 1 / (a * exp(x_i1*beta[1] + x_i2*beta[2]))),
#               c_i = rexp(n), delta = t_i &gt; c_i,
#               `min{c_i, d_i}` = min(t_i, c_i))
#   return(M)
# }
#  dat &lt;- SampWeibull(100, 0.1, 1, c(1, 1))
#  dat &lt;- dat %&gt;% select(4,6,2,3) 
#  CG &lt;- CGaMRes(data = leukemia1, K = 10, iterations = 100, thinning = 1)
#  CGaPloth(CG)



</code></pre>


</div>