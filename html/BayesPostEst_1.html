<div class="container">

<table style="width: 100%;"><tr>
<td>print.mcmcRocPrc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>ROC and Precision-Recall Curves using Bayesian MCMC estimates</h2>

<h3>Description</h3>

<p>Generate ROC and Precision-Recall curves after fitting a Bayesian logit or
probit regression using <code>rstan::stan()</code>, <code>rstanarm::stan_glm()</code>,
<code>R2jags::jags()</code>, <code>R2WinBUGS::bugs()</code>, <code>MCMCpack::MCMClogit()</code>, or other
functions that provide samples from a posterior density.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'mcmcRocPrc'
print(x, ...)

## S3 method for class 'mcmcRocPrc'
plot(x, n = 40, alpha = 0.5, ...)

## S3 method for class 'mcmcRocPrc'
as.data.frame(
  x,
  row.names = NULL,
  optional = FALSE,
  what = c("auc", "roc", "prc"),
  ...
)

mcmcRocPrc(object, curves = FALSE, fullsims = FALSE, ...)

## Default S3 method:
mcmcRocPrc(object, curves, fullsims, yvec, ...)

## S3 method for class 'jags'
mcmcRocPrc(
  object,
  curves = FALSE,
  fullsims = FALSE,
  yname,
  xnames,
  posterior_samples,
  ...
)

## S3 method for class 'rjags'
mcmcRocPrc(object, curves = FALSE, fullsims = FALSE, yname, xnames, ...)

## S3 method for class 'runjags'
mcmcRocPrc(object, curves = FALSE, fullsims = FALSE, yname, xnames, ...)

## S3 method for class 'stanfit'
mcmcRocPrc(object, curves = FALSE, fullsims = FALSE, data, xnames, yname, ...)

## S3 method for class 'stanreg'
mcmcRocPrc(object, curves = FALSE, fullsims = FALSE, ...)

## S3 method for class 'brmsfit'
mcmcRocPrc(object, curves = FALSE, fullsims = FALSE, ...)

## S3 method for class 'bugs'
mcmcRocPrc(
  object,
  curves = FALSE,
  fullsims = FALSE,
  data,
  xnames,
  yname,
  type = c("logit", "probit"),
  ...
)

## S3 method for class 'mcmc'
mcmcRocPrc(
  object,
  curves = FALSE,
  fullsims = FALSE,
  data,
  xnames,
  yname,
  type = c("logit", "probit"),
  force = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a <code>mcmcRocPrc()</code> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Used by methods</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>plot method: if 'fullsims = TRUE', how many sample curves to draw?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>plot method: alpha value for plotting sampled curves; between 0 and 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row.names</code></td>
<td>
<p>see [base::as.data.frame()]</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optional</code></td>
<td>
<p>see [base::as.data.frame()]</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>what</code></td>
<td>
<p>which information to extract and convert to a data frame?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A fitted binary choice model, e.g. "rjags" object
(see <code>R2jags::jags()</code>), or a <code style="white-space: pre;">⁠[N, iter]⁠</code> matrix of predicted probabilites.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>curves</code></td>
<td>
<p>logical indicator of whether or not to return values to plot
the ROC or Precision-Recall curves. If set to <code>FALSE</code> (default),
results are returned as a list without the extra values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fullsims</code></td>
<td>
<p>logical indicator of whether full object (based on all MCMC
draws rather than their average) will be returned. Default is <code>FALSE</code>.
Note: If <code>TRUE</code> is chosen, the function takes notably longer to execute.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yvec</code></td>
<td>
<p>A <code>numeric(N)</code> vector of observed outcomes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yname</code></td>
<td>
<p>(<code>character(1)</code>)<br>
The name of the dependent variable, should match the variable name in the
JAGS data object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xnames</code></td>
<td>
<p>(<code>base::character()</code>)<br>
A character vector of the independent variable names, should match the
corresponding names in the JAGS data object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>posterior_samples</code></td>
<td>
<p>a "mcmc" object with the posterior samples</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>the data that was used in the 'stan(data = ?, ...)' call</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>"logit" or "probit"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>force</code></td>
<td>
<p>for MCMCpack models, suppress warning if the model does not 
appear to be a binary choice model?</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If only the average AUC-ROC and PR are of interest, setting
<code>curves = FALSE</code> and <code>fullsims = FALSE</code> can greatly speed up calculation
time. The curve data (<code>curves = TRUE</code>) is needed for plotting. The plot
method will always plot both the ROC and PR curves, but the underlying
data can easily be extracted from the output for your own plotting;
see the documentation of the value returned below.
</p>
<p>The default method works with a matrix of predicted probabilities and the
vector of observed incomes as input. Other methods accommodate some of the
common Bayesian modeling packages like rstan (which returns class "stanfit"),
rstanarm ("stanreg"), R2jags ("jags"), R2WinBUGS ("bugs"), and
MCMCpack ("mcmc"). Even if a package-specific method is not implemented,
the default method can always be used as a fallback by manually calculating
the matrix of predicted probabilities for each posterior sample.
</p>
<p>Note that MCMCpack returns generic "mcmc" output that is annotated with
some additional information as attributes, including the original function
call. There is no inherent way to distinguish any other kind of "mcmc"
object from one generated by a proper MCMCpack modeling function, but as a
basic precaution, <code>mcmcRocPrc()</code> will check the saved call and return an
error if the function called was not <code>MCMClogit()</code> or <code>MCMCprobit()</code>.
This behavior can be suppressed by setting <code>force = TRUE</code>.
</p>


<h3>Value</h3>

<p>Returns a list with length 2 or 4, depending on the on the "curves"
and "fullsims" argument values:
</p>

<ul>
<li>
<p> "area_under_roc": <code>numeric()</code>; either length 1 if <code>fullsims = FALSE</code>, or
one value for each posterior sample otherwise
</p>
</li>
<li>
<p> "area_under_prc": <code>numeric()</code>; either length 1 if <code>fullsims = FALSE</code>, or
one value for each posterior sample otherwise
</p>
</li>
<li>
<p> "prc_dat": only if <code>curves = TRUE</code>; a list with length 1 if
<code>fullsims = FALSE</code>, longer otherwise
</p>
</li>
<li>
<p> "roc_dat": only if <code>curves = TRUE</code>; a list with length 1 if
<code>fullsims = FALSE</code>, longer otherwise
</p>
</li>
</ul>
<h3>References</h3>

<p>Beger, Andreas. 2016. “Precision-Recall Curves.” Available at
doi: <a href="https://doi.org/10.2139/ssrn.2765419">10.2139/ssrn.2765419</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
if (interactive()) {
# load simulated data and fitted model (see ?sim_data and ?jags_logit)
data("jags_logit")

# using mcmcRocPrc
fit_sum &lt;- mcmcRocPrc(jags_logit,
                      yname = "Y",
                      xnames = c("X1", "X2"),
                      curves = TRUE,
                      fullsims = FALSE)
fit_sum                     
plot(fit_sum)

# Equivalently, we can calculate the matrix of predicted probabilities 
# ourselves; using the example from ?jags_logit:
library(R2jags)

data("sim_data")
yvec &lt;- sim_data$Y
xmat &lt;- sim_data[, c("X1", "X2")]

# add intercept to the X data
xmat &lt;- as.matrix(cbind(Intercept = 1L, xmat))

beta &lt;- as.matrix(as.mcmc(jags_logit))[, c("b[1]", "b[2]", "b[3]")]
pred_mat &lt;- plogis(xmat %*% t(beta)) 

# the matrix of predictions has rows matching the number of rows in the data;
# the column are the predictions for each of the 2,000 posterior samples
nrow(sim_data)
dim(pred_mat)

# now we can call mcmcRocPrc; the default method works with the matrix
# of predictions and vector of outcomes as input
mcmcRocPrc(object = pred_mat, curves = TRUE, fullsims = FALSE, yvec = yvec)
}


</code></pre>


</div>