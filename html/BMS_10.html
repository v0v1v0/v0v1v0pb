<div class="container">

<table style="width: 100%;"><tr>
<td>c.bma</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Concatenate bma objects</h2>

<h3>Description</h3>

<p>Combines bma objects (resulting from <code>bms</code>). Can be used to
split estimation over several machines, or combine the MCMC results obtained
from different starting points.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'bma'
c(..., recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>At least two 'bma' objects (cf. <code>bms</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>recursive</code></td>
<td>
<p>retained for compatibility with <code>c</code> method</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Aggregates the information obtained from several chains. The result is a
'bma' object (cf. 'Values' in <code>bms</code>) that can be used just as a
standard 'bma' object.<br> Note that <code>combine_chains</code> helps in
particular to paralllelize the enumeration of the total model space: A model
with <code class="reqn">K</code> regressors has <code class="reqn">2^K</code> potential covariate combinations: With
<code class="reqn">K</code> large (more than 25), this can be pretty time intensive.  With the
<code>bms</code> arguments <code>start.value</code> and <code>iter</code>, sampling can
be done in steps: cf. example 'enumeration' below.
</p>


<h3>See Also</h3>

<p><code>bms</code> for creating bma objects
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
 data(datafls)
  
 #MCMC case ############################
 model1=bms(datafls,burn=1000,iter=4000,mcmc="bd",start.value=c(20,30,35))
 model2=bms(datafls,burn=1500,iter=7000,mcmc="bd",start.value=c(1,10,15))
 
 model_all=c(model1,model2)
 coef(model_all)
 plot(model_all)
 
 
 
 #splitting enumeration ########################
 
 #standard case with 12 covariates (4096 differnt combinations):
 enum0=bms(datafls[,1:13],mcmc="enumerate")
 
 # now split the task:
 # enum1 does everything from model zero (the first model) to model 1999
 enum1=bms(datafls[,1:13],mcmc="enumerate",start.value=0,iter=1999)
 
 # enum2 does models from index 2000 to the index 3000 (in total 1001 models)
 enum2=bms(datafls[,1:13],mcmc="enumerate",start.value=2000,iter=1000)
 
 # enum3 does models from index 3001 to the end
 enum3=bms(datafls[,1:13],mcmc="enumerate",start.value=3001)
 
 enum_combi=c(enum1,enum2,enum3)
 coef(enum_combi)
 coef(enum0)
 #both enum_combi and enum0 have exactly the same results 
 #(one difference: enum_combi has more 'top models' (1500 instead of 500))

</code></pre>


</div>