<div class="container">

<table style="width: 100%;"><tr>
<td>e0.diagnose</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Convergence Diagnostics for Markov Chain Monte Carlo of Life Expectancy
</h2>

<h3>Description</h3>

<p>Function <code>e0.diagnose</code> runs convergence diagnostics of existing MCMCs, using the <code>raftery.diag</code> function from the <span class="pkg">coda</span> package. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">e0.diagnose(sim.dir, thin = 225, burnin = 10000, express = FALSE, 
    country.sampling.prop = NULL, keep.thin.mcmc = FALSE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sim.dir</code></td>
<td>
<p>Directory with the MCMC simulation results.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>Thinning interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>Number of iterations to be discarded from the beginning of the parameter traces.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>express</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the convergence diagnostics is run only on the country-independent parameters. If <code>FALSE</code>, the country-specific parameters are included in the diagnostics. The number of countries can be controlled by <code>country.sampling.prop</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>country.sampling.prop</code></td>
<td>
<p>Proportion of countries that are included in the diagnostics. If it is <code>NULL</code> and <code>express=FALSE</code>, all countries are included. Setting here a number between 0 and 1, one can limit the number of countries which are then randomly sampled. Note that for long MCMCs, this argument may significantly influence the run-time of this function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.thin.mcmc</code></td>
<td>
<p>Logical. If <code>TRUE</code> the thinned traces used for computing the diagnostics are stored on disk (see <code>create.thinned.e0.mcmc</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function invokes the <code>e0.raftery.diag</code> function separately for country-independent parameters and for country-specific parameters. It results in two possible states: red, i.e. it did not converge, and green, i.e. it converged.
The resulting object is stored in <br> ‘<span class="file">{sim.dir}/diagnostics/bayesLife.convergence_{thin}_{burnin}.rda</span>’ and can be accessed using the function <code>get.e0.convergence</code>.
</p>
<p>Function <code>has.mcmc.converged</code> from the <span class="pkg">bayesTFR</span> package can be used to check if the existing diagnostics converged.
</p>


<h3>Value</h3>

<p><code>e0.diagnose</code> returns an object of class <code>bayesLife.convergence</code> with components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>result</code></td>
<td>
<p>Table containing all not-converged parameters. Its columns include ‘Total iterations needed’ and ‘Remaining iterations’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lresult.country.independent</code></td>
<td>
<p>Number of rows in <code>result</code> that correspond to country-independent paramters. These rows are groupped at the beginning of the table.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>country.independent</code></td>
<td>
<p>Result of <code>e0.raftery.diag</code> processed on country-independent parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>country.specific</code></td>
<td>
<p>Result of <code>e0.raftery.diag</code> processed on country-specific parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter.needed</code></td>
<td>
<p>Number of additional iterations suggested in order to achieve convergence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter.total</code></td>
<td>
<p>Total number of iterations of the original unthinned set of chains.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.nr.traj</code></td>
<td>
<p>Suggestion for number of trajectories in generating predictions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>Burnin used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>Thinning interval used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>status</code></td>
<td>
<p>Vector of character strings containing the result status. Possible values: ‘green’, ‘red’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mcmc.set</code></td>
<td>
<p>Object of class <code>bayesLife.mcmc.set</code> that corresponds to the original set of MCMCs on which the diagnostics was run.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin.mcmc</code></td>
<td>
<p>If <code>keep.thin.mcmc</code> is <code>TRUE</code>, it is an object of class <code>bayesLife.mcmc.set</code> that corresponds to the thinned mcmc set on which the diagnostics was run, otherwise <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>express</code></td>
<td>
<p>Value of the input argument <code>express</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nr.countries</code></td>
<td>
<p>Vector with elements <code>used</code> - number of countries used in this diagnostics, and <code>total</code> - number of countries that this <code>mcmc.set</code> object was estimated on.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Hana Sevcikova, Adrian Raftery
</p>


<h3>See Also</h3>

<p><code>e0.raftery.diag</code>, <code>raftery.diag</code>, <code>summary.bayesLife.convergence</code>, <code>get.e0.convergence</code>, <code>create.thinned.e0.mcmc</code>
</p>


</div>