<div class="container">

<table style="width: 100%;"><tr>
<td>d_fitted</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Density and random deviates from an angmcmc object</h2>

<h3>Description</h3>

<p>Density and random deviates from an angmcmc object
</p>


<h3>Usage</h3>

<pre><code class="language-R">d_fitted(x, object, type = "point-est", fn = mean, log = FALSE, chain.no, ...)

r_fitted(n = 1, object, type = "point-est", fn = mean, chain.no, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>vector, if univariate or a two column matrix, if bivariate, with each row a 2-D vector, (can
also be a data frame of similar dimensions) of points where the
densities are to be computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>angular MCMC object. The dimension of the model must match with <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Method of estimating density/generating random deviates. Possible choices are
<code>"post-pred"</code> and <code>"point-est"</code>. See details. Defaults to <code>"point-est"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fn</code></td>
<td>
<p>function, or a single character string specifying its name, to evaluate on MCMC samples to estimate
parameters.  Defaults to <code>mean</code>, which computes the estimated posterior mean.
Note that if <code>fn = "MODE"</code> (warning: not <code>"mode"</code>) or <code>fn = "MAP"</code>, then the maximum aposteriori estimate (MAP) is
calculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p>logical. Should the log density be returned instead?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chain.no</code></td>
<td>
<p>vector of chain numbers whose samples are to be be used.
in the estimation. By default all chains are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments to be passed to the function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of observations to be generated.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>type = 'point-est'</code>, density is evaluated/random samples are generated at a point estimate of
the parameter values.  To estimate the mixture density, first the parameter vector <code class="reqn">\eta</code> is estimated
by applying <code>fn</code> on the MCMC samples (using the function pointest), yielding the (consistent) Bayes estimate <code class="reqn">\hat{\eta}</code>.
Then the mixture density <code class="reqn">f(x|\eta)</code> at any point <code class="reqn">x</code> is (consistently) estimated by
<code class="reqn">f(x|\hat{\eta})</code>. The random deviates are generated from the estimated mixture density <code class="reqn">f(x|\hat{\eta})</code>.
</p>
<p>If <code>type == 'post-pred'</code>, posterior predictive samples and densities are returned. That
is, the average density <code class="reqn">S^{-1} \sum_{s = 1}^S f(x | \eta_s)</code> is returned in <code>d_fitted</code>,
where <code class="reqn">\eta_1, \dots, \eta_S</code> is the set posterior MCMC samples obtained from <code>object</code>. In
<code>r_fitted</code>, first a random sub-sample <code class="reqn">\eta_{(1)}, \dots, \eta_{(n)}</code> of size <code>n</code> from the
set of posterior samples <code class="reqn">\eta_1, \dots, \eta_S</code> is drawn (with replacement if <code>n</code> &gt; S). Then
the i-th posterior predictive data point is generated from the mixture density
<code class="reqn">f(x|\eta_{(i)})</code> for i = 1,..., n.
</p>


<h3>Value</h3>

<p><code>d_fitted</code> gives a vector the densities computed at the given points  and <code>r_fitted</code>
creates a vector (if univariate) or a matrix (if bivariate) with each row being a 2-D point, of random deviates.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1)
# illustration only - more iterations needed for convergence
fit.vmsin.20 &lt;- fit_vmsinmix(tim8, ncomp = 3, n.iter =  20,
                             n.chains = 1)
d_fitted(c(0,0), fit.vmsin.20, type = "post-pred")
d_fitted(c(0,0), fit.vmsin.20, type = "point-est")

r_fitted(10, fit.vmsin.20, type = "post-pred")
r_fitted(10, fit.vmsin.20, type = "point-est")
</code></pre>


</div>