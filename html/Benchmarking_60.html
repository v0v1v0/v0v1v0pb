<div class="container">

<table style="width: 100%;"><tr>
<td>sdea</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Super efficiency </h2>

<h3>Description</h3>

<p> The method <code>sdea</code> calculates super-efficiency and
returns the same class of object as <code>dea</code>.  </p>


<h3>Usage</h3>

<pre><code class="language-R">sdea(X, Y, RTS = "vrs", ORIENTATION = "in", DIRECT = NULL, param = NULL,
     TRANSPOSE = FALSE, LP = FALSE, CONTROL = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Inputs of firms to be evaluated, a K x m matrix
of observations of K firms with m inputs (firm x input).  In case
<code>TRANSPOSE=TRUE</code> the input matrix is transposed to input x
firm. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>Outputs of firms to be evaluated, a K x n matrix
of observations of K firms with n outputs (firm x input).  In case
<code>TRANSPOSE=TRUE</code> the output matrix is transposed to output x
firm. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RTS</code></td>
<td>
<p> Text string or a number defining the underlying DEA
technology / returns to scale assumption, the same values as for
<code>dea</code>.
</p>

<table>
<tr>
<td style="text-align: right;">

0 </td>
<td style="text-align: left;"> fdh </td>
<td style="text-align: left;"> Free disposability hull, no convexity assumption </td>
</tr>
<tr>
<td style="text-align: right;">

1 </td>
<td style="text-align: left;"> vrs </td>
<td style="text-align: left;"> Variable returns to scale, convexity and free
disposability </td>
</tr>
<tr>
<td style="text-align: right;">

2 </td>
<td style="text-align: left;"> drs </td>
<td style="text-align: left;"> Decreasing returns to scale, convexity, down-scaling
and free disposability </td>
</tr>
<tr>
<td style="text-align: right;">

3 </td>
<td style="text-align: left;"> crs </td>
<td style="text-align: left;"> Constant returns to scale, convexity and free
disposability </td>
</tr>
<tr>
<td style="text-align: right;">

4 </td>
<td style="text-align: left;"> irs </td>
<td style="text-align: left;"> Increasing returns to scale, (up-scaling, but not
down-scaling), convexity and free disposability </td>
</tr>
<tr>
<td style="text-align: right;">

5 </td>
<td style="text-align: left;"> irs2 </td>
<td style="text-align: left;"> Increasing returns to scale (up-scaling, but not
down-scaling), additivity, and free disposability </td>
</tr>
<tr>
<td style="text-align: right;">

6 </td>
<td style="text-align: left;"> add </td>
<td style="text-align: left;"> Additivity (scaling up and down, but only with
integers), and free disposability </td>
</tr>
<tr>
<td style="text-align: right;">

7 </td>
<td style="text-align: left;"> fdh+ </td>
<td style="text-align: left;"> A combination of free disposability and restricted
 or local constant return to scale

</td>
</tr>
</table>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ORIENTATION</code></td>
<td>
<p>Input efficiency "in" (1), output efficiency
"out" (2), and graph efficiency "graph" (3). For use with
<code>DIRECT</code>, an additional option is "in-out" (0).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DIRECT</code></td>
<td>
<p>Directional efficiency, <code>DIRECT</code> is either a
scalar, an array, or a matrix with non-negative elements.
</p>
<p>If the argument is a scalar, the direction is (1,1,...,1) times
the scalar; the value of the efficiency depends on the scalar as
well as on the unit of measurements.
</p>
<p>If the argument an array, this is used for the direction for
every firm; the length of the array must correspond to the
number of inputs and/or outputs depending on the
<code>ORIENTATION</code>.
</p>
<p>If the argument is a matrix then different directions are used
for each firm. The dimensions depends on the <code>ORIENTATION</code>,
the number of firms must correspond to the number of firms in
<code>X</code> and <code>Y</code>.
</p>
<p><code>DIRECT</code> must not be used in connection with
<code>DIRECTION="graph"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param</code></td>
<td>
<p>Argument is at present only used when
<code>RTS="fdh+"</code>, see <code>dea</code> for a description.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>TRANSPOSE</code></td>
<td>
<p>See the description in <code>dea</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LP</code></td>
<td>
<p>Only for debugging, see the description in
<code>dea</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CONTROL</code></td>
<td>
<p>Possible controls to <span class="pkg">lpSolveAPI</span>, see the
documentation for that package. For examples of use see the
function <code>dea</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Super-efficiency measures are constructed by avoiding that
the evaluated firm can help span the technology, i.e. if the firm in
qestuen is a firm on the frontier in a normal dea approach then
this firm in super efficiency might be outside the technology set.
</p>


<h3>Value</h3>

<p> The object returned is a Farrell object with the component
described in <code>dea</code>.  The relevant components are
</p>
<table>
<tr style="vertical-align: top;">
<td><code>eff</code></td>
<td>
<p>The efficiencies.  Note when DIRECT is used then the
efficencies are not Farrell efficiencies but rather excess values
in DIRECT units of measurement. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The lambdas, i.e. the weight of the peers, for each
Firm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>objval</code></td>
<td>
<p>The objective value as returned from the LP program;
normally the same as eff. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RTS</code></td>
<td>
<p>The return to scale assumption as in the option
<code>RTS</code> in the call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ORIENTATION</code></td>
<td>
<p>The efficiency orientation as in the call.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p> Calculation of slacks for super efficiency should be done by
using the option <code>SLACK=TRUE</code> in the call of the method
<code>sdea</code>.  If the two phases are done in two steps as first a
call to <code>sdea</code> and then a call to <code>slacks</code> the user must
make sure to set the reference technology to the one corresponding
to super-efficiency in the call to <code>slack</code> and this requires a
loop with calls to <code>slack</code>.  </p>


<h3>Author(s)</h3>

<p> Peter Bogetoft and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a></p>


<h3>References</h3>

<p> Peter Bogetoft and Lars Otto; <em>Benchmarking with
DEA, SFA, and R</em>; Springer 2011. Sect. 5.2 page 115
</p>
<p>P Andersen and NC Petersen; “A procedure for ranking efficient
units in data envelopment analysis”;  <em>Management Science</em> 1993
39(10):1261–1264</p>


<h3>See Also</h3>

<p><code>dea</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- matrix(c(100,200,300,500,100,200,600),ncol=1)
y &lt;- matrix(c(75,100,300,400,25,50,400),ncol=1)
se &lt;- sdea(x,y)
se

# Leave out firm 3 as a determining firm of the technology set
n &lt;- 3
dea.plot.frontier(x[-n], y[-n], txt=(1:dim(x)[1])[-n])
# Plot and label firm 3
points(x[n],y[n],cex=1.25,pch=16)
text(x[n],y[n],n,adj=c(-.75,.75))
</code></pre>


</div>