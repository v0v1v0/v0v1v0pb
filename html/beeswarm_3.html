<div class="container">

<table style="width: 100%;"><tr>
<td>beeswarm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bee swarm plot</h2>

<h3>Description</h3>

<p>Create a bee swarm plot.  A bee swarm plot is a one-dimensional scatter plot similar to <code>stripchart</code>, but with various methods to separate coincident points such that each point is visible.  Also, <code>beeswarm</code> introduces additional features unavailable in <code>stripchart</code>, such as the ability to control the color and plotting character of each point. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">beeswarm(x, ...)

## S3 method for class 'formula'
beeswarm(formula, data = NULL, subset, na.action = NULL, 
         pwpch = NULL, pwcol = NULL, pwbg = NULL, pwcex = NULL, dlab, glab, ...)

## Default S3 method:
beeswarm(x, 
    method = c("swarm", "compactswarm", "center", "hex", "square"), 
    vertical = TRUE, horizontal = !vertical, 
    cex = 1, spacing = 1, breaks = NULL,
    labels, at = NULL, 
    corral = c("none", "gutter", "wrap", "random", "omit"),
    corralWidth, side = 0L, 
    priority = c("ascending", "descending", "density", "random", "none"),
    fast = TRUE,
    pch = par("pch"), col = par("col"), bg = NA, 
    pwpch = NULL, pwcol = NULL, pwbg = NULL, pwcex = NULL,
    do.plot = TRUE, add = FALSE, axes = TRUE, log = FALSE,
    xlim = NULL, ylim = NULL, dlim = NULL, glim = NULL,
    xlab = NULL, ylab = NULL, dlab = "", glab = "",
    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>A formula, such as <code>y ~ grp</code>, where <code>y</code> is a
numeric vector of data values to be split into groups according to
the grouping variable <code>grp</code> (usually a factor).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data.frame (or list) from which the variables in
<code>formula</code> should be taken.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>An optional vector specifying a subset of observations
to be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>A function which indicates what should happen
when the data contain <code>NA</code>s.  The default is to quietly ignore missing
values in either the response or the group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> A numeric vector, or a data frame or list of numeric vectors, each of which is plotted as an individual swarm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p> Method for arranging points (see Details). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vertical, horizontal</code></td>
<td>
<p> Orientation of the plot. <code>horizontal</code> takes precedence if both are specified. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex</code></td>
<td>
<p> Size of points relative to the default given by <code>par("cex")</code>. Unlike other plotting functions, this must be a single value. (But see also the <code>pwcex</code> argument)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spacing</code></td>
<td>
<p> Relative spacing between points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>breaks</code></td>
<td>
<p> Breakpoints (optional).  If <code>NULL</code>, breakpoints are chosen automatically. If <code>NA</code>, bins are not used (similar to <code>stripchart</code> with <code>method = "stack"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels</code></td>
<td>
<p> Labels for each group. Recycled if necessary. By default, these are inferred from the data. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>at</code></td>
<td>
<p> Numeric vector giving the locations where the swarms should be drawn; defaults to <code>1:n</code> where <var>n</var> is the number of groups. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>corral</code></td>
<td>
<p> Method to adjust points that would be placed outside their own group region (see Details). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>corralWidth</code></td>
<td>
<p> Width of the "corral" in user coordinates. If missing, a sensible value will be chosen. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>side</code></td>
<td>
<p> Direction to perform jittering: 0: both directions; 1: to the right or upwards; -1: to the left or downwards.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priority</code></td>
<td>
<p> Order used to perform point layout when method is <code>"swarm"</code> or <code>"compactswarm"</code>; ignored otherwise (see Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fast</code></td>
<td>
<p> Use compiled version of algorithm?  This option is ignored for all methods except <code>"swarm"</code> and <code>"compactswarm"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pch, col, bg</code></td>
<td>
<p> Plotting characters and colors, specified by group. Recycled if necessary (see Details). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pwpch, pwcol, pwbg, pwcex</code></td>
<td>
 <p>“Point-wise” plotting characteristics, specified for each data point (see Details). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>do.plot</code></td>
<td>
<p> Draw a plot? </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add</code></td>
<td>
<p> Add to an existing plot? </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>axes</code></td>
<td>
<p> Draw axes and box? </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p> Use a logarithmic scale on the data axis? </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlim, ylim</code></td>
<td>
<p> Limits of the plot. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dlim, glim</code></td>
<td>
<p> An alternative way to specify limits (see Details). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlab, ylab</code></td>
<td>
<p> Axis labels. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dlab, glab</code></td>
<td>
<p> An alternative way to specify axis labels (see Details). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> Further arguments passed to <code>plot</code>. </p>
</td>
</tr>
</table>
<h3>Details</h3>

 
<p>Several methods for placing the points are available; each method uses a different algorithm to avoid overlapping points. 
</p>
<p>The default method, <code>swarm</code>, places points in increasing order. If a point would overlap an existing point, it is shifted sideways (along the group axis) by a minimal amount sufficient to avoid overlap. <code>breaks</code> is ignored.
</p>
<p>The other three methods first discretize the values along the data axis, in order to create more efficient packing: <code>square</code> places the points on a square grid, whereas <code>hex</code> uses a hexagonal grid.  <code>center</code> uses a  square grid to produce a symmetric swarm. By default, the number of breakpoints for discretization is determined by a combination of the available plotting area and the plotting character size. The discretization of the data can be explicitly controlled using <code>breaks</code>. If <code>breaks</code> is set to <code>NA</code>, the data will not be grouped into intervals; this may be a sensible option if the data is already discrete.
</p>
<p>In contrast to most other plotting functions, changing the size of the graphics device will often change the position of the points.  
</p>
<p>The plotting characters and colors can be controlled in two ways. First, the arguments <code>pch</code>, <code>col</code> and <code>bg</code> can specify plotting characters and colors in the same way as <code>stripchart</code> and <code>boxplot</code>: in short, the arguments apply to each group as a whole (and are recycled if necessary).
</p>
<p>Alternatively, the “point-wise” characteristics of each individual data point can be controlled using <code>pwpch</code>, <code>pwcol</code>, and <code>pwbg</code>, which override <code>pch</code>, <code>col</code> and <code>bg</code> if these are also specified. Likewise, <code>pwcex</code> controls the size of each point relative to the default (which may be adjusted by <code>cex</code>). Notably, the point layout algorithm is applied without considering the point-wise arguments; thus setting <code>pwcex</code> larger than 1 will usually result in partially overlapping points. These arguments can be specified as a list or vector.  If supplied using the formula method, the arguments can be specified as part of the formula interface; i.e. they are affected by <code>data</code> and <code>subset</code>.
</p>
<p>The <code>dlab</code> and <code>glab</code> labels may be used instead of <code>xlab</code> and <code>ylab</code> if those are not specified.  <code>dlab</code> applies to the continuous data axis (the Y axis unless <code>horizontal</code> is <code>TRUE</code>); <code>glab</code> to the group axis. Likewise, <code>dlim</code> and <code>glim</code> can be used to specify limits of the axes instead of <code>xlim</code> or <code>ylim</code>.
</p>
<p>This function is intended to be mostly compatible with calls to <code>stripchart</code> or <code>boxplot</code>.  Thus, code that works with these functions should work with <code>beeswarm</code> with minimal modification.
</p>
<p>By default, swarms from different groups are not prevented from overlapping. Thus, large data sets, or data sets with uneven distributions, may produce somewhat unpleasing beeswarms. If this is a problem, consider reducing <code>cex</code>. Another approach is to control runaway points (those that would be plotted outside a region allotted to each group) with the <code>corral</code> argument: The default, <code>"none"</code>, does not control runaway points. <code>"gutter"</code> collects runaway points along the boundary between groups. <code>"wrap"</code> implements periodic boundaries. <code>"random"</code> places runaway points randomly in the region. <code>"omit"</code> omits runaway points. See Examples below.
</p>
<p>When using the <code>"swarm"</code> method, <code>priority</code> controls the order in which the points are placed; this generally has a noticeable effect on the resulting appearance. <code>"ascending"</code> gives the "traditional" beeswarm plot in which the points are placed in an ascending order. <code>"descending"</code> is the opposite. <code>"density"</code> prioritizes points with higher local density. <code>"random"</code> places points in a random order. <code>"none"</code> places points in the order provided.
</p>
<p>Whereas the <code>"swarm"</code> method places points in a predetermined order, the <code>"compactswarm"</code> method uses a greedy strategy to determine which point will be placed next. This often leads to a more tightly-packed layout. The strategy is very simple: on each iteration, a point that can be placed as close as possible to the non-data axis is chosen and placed. If there are two or more equally good points, <code>priority</code> is used to break ties.
</p>


<h3>Value</h3>

<p> A data frame with plotting information, invisibly. </p>


<h3>See Also</h3>

 <p><code>stripchart</code>, <code>boxplot</code> </p>


<h3>Examples</h3>

<pre><code class="language-R"> 
  
  ## One of the examples from 'stripchart'
  beeswarm(decrease ~ treatment,
    data = OrchardSprays, log = TRUE, 
    pch = 16, col = rainbow(8))

  ## One of the examples from 'boxplot', with a beeswarm overlay
   boxplot(len ~ dose, data = ToothGrowth,
              main = "Guinea Pigs' Tooth Growth",
              xlab = "Vitamin C dose mg",
              ylab = "Tooth length")  
   beeswarm(len ~ dose, data = ToothGrowth, col = 2, add = TRUE)

  ## Compare the 5 methods
  op &lt;- par(mfrow = c(2,3))
  for (m in c("swarm", "compactswarm", "center", "hex", "square")) {
    beeswarm(len ~ dose, data = ToothGrowth, method = m, main = m)
  }
  par(op)

  ## Demonstrate the use of 'pwcol'
  data(breast)
  beeswarm(time_survival ~ ER, data = breast,
    pch = 16, pwcol = 1 + as.numeric(event_survival),
    xlab = "", ylab = "Follow-up time (months)",
    labels = c("ER neg", "ER pos"))
  legend("topright", legend = c("Yes", "No"),
    title = "Censored", pch = 16, col = 1:2)

  ## The list interface
  distributions &lt;- list(runif = runif(200, min = -3, max = 3), 
                        rnorm = rnorm(200),
                        rlnorm = rlnorm(200, sdlog = 0.5))
  beeswarm(distributions, col = 2:4)

  ## Demonstrate 'pwcol' with the list interface 
  myCol &lt;- lapply(distributions, function(x) cut(x, breaks = quantile(x), labels = FALSE))
  beeswarm(distributions, pch = 16, pwcol = myCol)
  legend("bottomright", legend = 1:4, pch = 16, col = 1:4, title = "Quartile")

  ## Demonstrate the 'corral' methods
  par(mfrow = c(2,3))
  beeswarm(distributions, col = 2:4, 
    main = 'corral = "none" (default)')
  beeswarm(distributions, col = 2:4, corral = "gutter", 
    main = 'corral = "gutter"')
  beeswarm(distributions, col = 2:4, corral = "wrap", 
    main = 'corral = "wrap"')
  beeswarm(distributions, col = 2:4, corral = "random", 
    main = 'corral = "random"')
  beeswarm(distributions, col = 2:4, corral = "omit", 
    main = 'corral = "omit"')  
 
  ## Demonstrate 'side' and 'priority'
  par(mfrow = c(2,3))
  beeswarm(distributions, col = 2:4, 
    main = 'Default')
  beeswarm(distributions, col = 2:4, side = -1, 
    main = 'side = -1')
  beeswarm(distributions, col = 2:4, side = 1, 
    main = 'side = 1')
  beeswarm(distributions, col = 2:4, priority = "descending", 
    main = 'priority = "descending"')
  beeswarm(distributions, col = 2:4, priority = "random", 
    main = 'priority = "random"')  
  beeswarm(distributions, col = 2:4, priority = "density", 
    main = 'priority = "density"')  

  ## Demonstrate 'side' and 'priority' for compact method
  par(mfrow = c(2,3))
  beeswarm(distributions, col = 2:4, method = "compactswarm",
    main = 'Default')
  beeswarm(distributions, col = 2:4, method = "compactswarm", side = -1, 
    main = 'side = -1')
  beeswarm(distributions, col = 2:4, method = "compactswarm", side = 1, 
    main = 'side = 1')
  beeswarm(distributions, col = 2:4, method = "compactswarm",
    priority = "descending",  main = 'priority = "descending"')
  beeswarm(distributions, col = 2:4, method = "compactswarm",
    priority = "random",  main = 'priority = "random"')  
  beeswarm(distributions, col = 2:4, method = "compactswarm",
    priority = "density",  main = 'priority = "density"')  

  ## Demonstrate pwcol, pwpch, pwbg, and pwcex
  beeswarm(mpg ~ cyl, data = mtcars, cex = 3, 
    pwcol = gear, pwbg = am + 1, pwpch = gear + 18, pwcex = hp / 335)
  
</code></pre>


</div>