<div class="container">

<table style="width: 100%;"><tr>
<td>biclustermd</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bicluster data with non-random missing values</h2>

<h3>Description</h3>

<p>Bicluster data with non-random missing values
</p>


<h3>Usage</h3>

<pre><code class="language-R">biclustermd(
  data,
  row_clusters = floor(sqrt(nrow(data))),
  col_clusters = floor(sqrt(ncol(data))),
  miss_val = mean(data, na.rm = TRUE),
  miss_val_sd = 1,
  similarity = "Rand",
  row_min_num = floor(nrow(data)/row_clusters),
  col_min_num = floor(ncol(data)/col_clusters),
  row_num_to_move = 1,
  col_num_to_move = 1,
  row_shuffles = 1,
  col_shuffles = 1,
  max.iter = 100,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Dataset to bicluster. Must to be a data matrix with only numbers
and missing values in the data set. It should have row names and column names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row_clusters</code></td>
<td>
<p>The number of clusters to partition the rows into. The
default is <code>floor(sqrt(nrow(data)))</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col_clusters</code></td>
<td>
<p>The number of clusters to partition the columns into. The
default is <code>floor(sqrt(ncol(data)))</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>miss_val</code></td>
<td>
<p>Value or function to put in empty cells of the prototype matrix.
If a value, a random normal variable with sd = <code>miss_val_sd</code> is used each
iteration. By default, this equals the mean of <code>data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>miss_val_sd</code></td>
<td>
<p>Standard deviation of the normal distribution <code>miss_val</code> follows
if <code>miss_val</code> is a number. By default this equals 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>similarity</code></td>
<td>
<p>The metric used to compare two successive clusterings. Can be
"Rand" (default), "HA" for the Hubert and Arabie adjusted Rand index or "Jaccard".
See RRand for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row_min_num</code></td>
<td>
<p>Minimum row prototype size in order to be eligible to be
chosen when filling an empty row prototype. Default is <code>floor(nrow(data) / row_clusters)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col_min_num</code></td>
<td>
<p>Minimum column prototype size in order to be eligible to be
chosen when filling an empty row prototype. Default is <code>floor(ncol(data) / col_clusters)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row_num_to_move</code></td>
<td>
<p>Number of rows to remove from the sampled prototype to
put in the empty row prototype. Default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col_num_to_move</code></td>
<td>
<p>Number of columns to remove from the sampled prototype to
put in the empty column prototype. Default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row_shuffles</code></td>
<td>
<p>Number of times to shuffle rows in each iteration. Default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col_shuffles</code></td>
<td>
<p>Number of times to shuffle columns in each iteration. Default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.iter</code></td>
<td>
<p>Maximum number of iterations to let the algorithm run for.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical. If TRUE, will report progress.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list of class <code>biclustermd</code>:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>params </code></td>
<td>
<p>a list of all arguments passed to the function, including defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data </code></td>
<td>
<p>the inputted two way table of data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>P0 </code></td>
<td>
<p>the initial column partition matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q0 </code></td>
<td>
<p>the initial row partition matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>InitialSSE </code></td>
<td>
<p>the SSE of the original partitioning.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>P </code></td>
<td>
<p>the final column partition matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q </code></td>
<td>
<p>the final row partition matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SSE </code></td>
<td>
<p>a matrix of class biclustermd_sse detailing the SSE recorded at the end of each iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Similarities </code></td>
<td>
<p>a data frame of class biclustermd_sim detailing the
value of row and column similarity measures recorded at the end of each
iteration. Contains information for all three similarity measures.
This carries an attribute <code>"used"</code> which provides the similarity
measure used as the stopping condition for the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iteration </code></td>
<td>
<p>the number of iterations the algorithm ran for, whether <code>max.iter</code> was reached or convergence was achieved.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A </code></td>
<td>
<p>the final prototype matrix which gives the average of each bicluster.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Li, J., Reisner, J., Pham, H., Olafsson, S., and Vardeman, S. (2020) <em>Biclustering with Missing Data. Information Sciences, 510, 304â€“316.</em>
</p>


<h3>See Also</h3>

<p><code>rep_biclustermd</code>, <code>tune_biclustermd</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("synthetic")
# default parameters
bc &lt;- biclustermd(synthetic)
bc
autoplot(bc)

# providing the true number of row and column clusters
bc &lt;- biclustermd(synthetic, col_clusters = 3, row_clusters = 2)
bc
autoplot(bc)

# an example with the nycflights13::flights dataset
library(nycflights13)
data("flights")

library(dplyr)
flights_bcd &lt;- flights %&gt;%
  select(month, dest, arr_delay)

flights_bcd &lt;- flights_bcd %&gt;%
  group_by(month, dest) %&gt;%
  summarise(mean_arr_delay = mean(arr_delay, na.rm = TRUE)) %&gt;%
  spread(dest, mean_arr_delay) %&gt;%
  as.data.frame()

rownames(flights_bcd) &lt;- flights_bcd$month
flights_bcd &lt;- as.matrix(flights_bcd[, -1])

flights_bc &lt;- biclustermd(data = flights_bcd, col_clusters = 6, row_clusters = 4,
                  row_min_num = 3, col_min_num = 5,
                  max.iter = 20, verbose = TRUE)
flights_bc

</code></pre>


</div>