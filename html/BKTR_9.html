<div class="container">

<table style="width: 100%;"><tr>
<td>BKTRRegressor</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>R6 class encapsulating the BKTR regression elements</h2>

<h3>Description</h3>

<p>A BKTRRegressor holds all the key elements to accomplish the MCMC sampling
algorithm (<strong>Algorithm 1</strong> of the paper).
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>data_df</code></dt>
<dd>
<p>The dataframe containing all the covariates through time and space (including
the response variable)</p>
</dd>
<dt><code>y</code></dt>
<dd>
<p>The response variable tensor</p>
</dd>
<dt><code>omega</code></dt>
<dd>
<p>The tensor indicating which response values are not missing</p>
</dd>
<dt><code>covariates</code></dt>
<dd>
<p>The tensor containing all the covariates</p>
</dd>
<dt><code>covariates_dim</code></dt>
<dd>
<p>The dimensions of the covariates tensor</p>
</dd>
<dt><code>logged_params_tensor</code></dt>
<dd>
<p>The tensor containing all the sampled hyperparameters</p>
</dd>
<dt><code>tau</code></dt>
<dd>
<p>The precision hyperparameter</p>
</dd>
<dt><code>spatial_decomp</code></dt>
<dd>
<p>The spatial covariate decomposition</p>
</dd>
<dt><code>temporal_decomp</code></dt>
<dd>
<p>The temporal covariate decomposition</p>
</dd>
<dt><code>covs_decomp</code></dt>
<dd>
<p>The feature covariate decomposition</p>
</dd>
<dt><code>result_logger</code></dt>
<dd>
<p>The result logger instance used to store the results of the MCMC sampling</p>
</dd>
<dt><code>has_completed_sampling</code></dt>
<dd>
<p>Boolean showing wheter the MCMC sampling has been completed</p>
</dd>
<dt><code>spatial_kernel</code></dt>
<dd>
<p>The spatial kernel used</p>
</dd>
<dt><code>temporal_kernel</code></dt>
<dd>
<p>The temporal kernel used</p>
</dd>
<dt><code>spatial_positions_df</code></dt>
<dd>
<p>The dataframe containing the spatial positions</p>
</dd>
<dt><code>temporal_positions_df</code></dt>
<dd>
<p>The dataframe containing the temporal positions</p>
</dd>
<dt><code>spatial_params_sampler</code></dt>
<dd>
<p>The spatial kernel hyperparameter sampler</p>
</dd>
<dt><code>temporal_params_sampler</code></dt>
<dd>
<p>The temporal kernel hyperparameter sampler</p>
</dd>
<dt><code>tau_sampler</code></dt>
<dd>
<p>The tau hyperparameter sampler</p>
</dd>
<dt><code>precision_matrix_sampler</code></dt>
<dd>
<p>The precision matrix sampler</p>
</dd>
<dt><code>spatial_ll_evaluator</code></dt>
<dd>
<p>The spatial likelihood evaluator</p>
</dd>
<dt><code>temporal_ll_evaluator</code></dt>
<dd>
<p>The temporal likelihood evaluator</p>
</dd>
<dt><code>rank_decomp</code></dt>
<dd>
<p>The rank of the CP decomposition</p>
</dd>
<dt><code>burn_in_iter</code></dt>
<dd>
<p>The number of burn in iterations</p>
</dd>
<dt><code>sampling_iter</code></dt>
<dd>
<p>The number of sampling iterations</p>
</dd>
<dt><code>max_iter</code></dt>
<dd>
<p>The total number of iterations</p>
</dd>
<dt><code>a_0</code></dt>
<dd>
<p>The initial value for the shape in the gamma function generating tau</p>
</dd>
<dt><code>b_0</code></dt>
<dd>
<p>The initial value for the rate in the gamma function generating tau</p>
</dd>
<dt><code>formula</code></dt>
<dd>
<p>The formula used to specify the relation between the response variable and the covariates</p>
</dd>
<dt><code>spatial_labels</code></dt>
<dd>
<p>The spatial labels</p>
</dd>
<dt><code>temporal_labels</code></dt>
<dd>
<p>The temporal labels</p>
</dd>
<dt><code>feature_labels</code></dt>
<dd>
<p>The feature labels</p>
</dd>
<dt><code>geo_coords_projector</code></dt>
<dd>
<p>The geographic coordinates projector</p>
</dd>
</dl>
</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>summary</code></dt>
<dd>
<p>A summary of the BKTRRegressor instance</p>
</dd>
<dt><code>beta_covariates_summary</code></dt>
<dd>
<p>A dataframe containing the summary of the beta covariates</p>
</dd>
<dt><code>y_estimates</code></dt>
<dd>
<p>A dataframe containing the y estimates</p>
</dd>
<dt><code>imputed_y_estimates</code></dt>
<dd>
<p>A dataframe containing the imputed y estimates</p>
</dd>
<dt><code>beta_estimates</code></dt>
<dd>
<p>A dataframe containing the beta estimates</p>
</dd>
<dt><code>hyperparameters_per_iter_df</code></dt>
<dd>
<p>A dataframe containing the beta estimates per iteration</p>
</dd>
<dt><code>decomposition_tensors</code></dt>
<dd>
<p>List of all used decomposition tensors</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-BKTRRegressor-new"><code>BKTRRegressor$new()</code></a>
</p>
</li>
<li> <p><a href="#method-BKTRRegressor-mcmc_sampling"><code>BKTRRegressor$mcmc_sampling()</code></a>
</p>
</li>
<li> <p><a href="#method-BKTRRegressor-predict"><code>BKTRRegressor$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-BKTRRegressor-get_iterations_betas"><code>BKTRRegressor$get_iterations_betas()</code></a>
</p>
</li>
<li> <p><a href="#method-BKTRRegressor-get_beta_summary_df"><code>BKTRRegressor$get_beta_summary_df()</code></a>
</p>
</li>
<li> <p><a href="#method-BKTRRegressor-clone"><code>BKTRRegressor$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-BKTRRegressor-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create a new <code>BKTRRegressor</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>BKTRRegressor$new(
  data_df,
  spatial_positions_df,
  temporal_positions_df,
  rank_decomp = 10,
  burn_in_iter = 500,
  sampling_iter = 500,
  formula = NULL,
  spatial_kernel = KernelMatern$new(smoothness_factor = 3),
  temporal_kernel = KernelSE$new(),
  sigma_r = 0.01,
  a_0 = 1e-06,
  b_0 = 1e-06,
  has_geo_coords = TRUE,
  geo_coords_scale = 10
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data_df</code></dt>
<dd>
<p>data.table: A dataframe containing all the covariates
through time and space. It is important that the dataframe has a two
indexes named 'location' and 'time' respectively. The dataframe should
also contain every possible combinations of 'location' and 'time'
(i.e. even missing rows should be filled present but filled with NaN).
So if the dataframe has 10 locations and 5 time points, it should have
50 rows (10 x 5). If formula is None, the dataframe should contain
the response variable 'Y' as the first column. Note that the covariate
columns cannot contain NaN values, but the response variable can.</p>
</dd>
<dt><code>spatial_positions_df</code></dt>
<dd>
<p>data.table: Spatial kernel input tensor used
to calculate covariates' distance. Vector of length equal to the number of location points.</p>
</dd>
<dt><code>temporal_positions_df</code></dt>
<dd>
<p>data.table: Temporal kernel input tensor used to
calculate covariate distance. Vector of length equal to the number of time points.</p>
</dd>
<dt><code>rank_decomp</code></dt>
<dd>
<p>Integer: Rank of the CP decomposition (Paper – <code class="reqn">R</code>). Defaults to 10.</p>
</dd>
<dt><code>burn_in_iter</code></dt>
<dd>
<p>Integer: Number of iteration before sampling (Paper – <code class="reqn">K_1</code>). Defaults to 500.</p>
</dd>
<dt><code>sampling_iter</code></dt>
<dd>
<p>Integer: Number of sampling iterations (Paper – <code class="reqn">K_2</code>). Defaults to 500.</p>
</dd>
<dt><code>formula</code></dt>
<dd>
<p>A Wilkinson R formula to specify the relation
between the response variable 'Y' and the covariates. If Null, the first
column of the data frame will be used as the response variable and all the
other columns will be used as the covariates.  Defaults to Null.</p>
</dd>
<dt><code>spatial_kernel</code></dt>
<dd>
<p>Kernel: Spatial kernel Used. Defaults to
a KernelMatern(smoothness_factor=3).</p>
</dd>
<dt><code>temporal_kernel</code></dt>
<dd>
<p>Kernel: Temporal kernel used. Defaults to KernelSE().</p>
</dd>
<dt><code>sigma_r</code></dt>
<dd>
<p>Numeric:  Variance of the white noise process (<code class="reqn">\tau^{-1}</code>)
defaults to 1E-2.</p>
</dd>
<dt><code>a_0</code></dt>
<dd>
<p>Numeric: Initial value for the shape (<code class="reqn">\alpha</code>) in the gamma function
generating tau defaults to 1E-6.</p>
</dd>
<dt><code>b_0</code></dt>
<dd>
<p>Numeric: Initial value for the rate (<code class="reqn">\beta</code>) in the gamma function
generating tau defaults to 1E-6.</p>
</dd>
<dt><code>has_geo_coords</code></dt>
<dd>
<p>Boolean: Whether the spatial positions df use geographic coordinates
(latitude, longitude). Defaults to TRUE.</p>
</dd>
<dt><code>geo_coords_scale</code></dt>
<dd>
<p>Numeric: Scale factor to convert geographic coordinates to euclidean
2D space via Mercator projection using x &amp; y domains of [-scale/2, +scale/2]. Only used if
has_geo_coords is TRUE. Defaults to 10.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A new <code>BKTRRegressor</code> object.
</p>


<hr>
<a id="method-BKTRRegressor-mcmc_sampling"></a>



<h4>Method <code>mcmc_sampling()</code>
</h4>

<p>Launch the MCMC sampling process. <br>
For a predefined number of iterations:
</p>

<ol>
<li>
<p>Sample spatial kernel hyperparameters
</p>
</li>
<li>
<p>Sample temporal kernel hyperparameters
</p>
</li>
<li>
<p>Sample the precision matrix from a wishart distribution
</p>
</li>
<li>
<p>Sample a new spatial covariate decomposition
</p>
</li>
<li>
<p>Sample a new feature covariate decomposition
</p>
</li>
<li>
<p>Sample a new temporal covariate decomposition
</p>
</li>
<li>
<p>Calculate respective errors for the iterations
</p>
</li>
<li>
<p>Sample a new tau value
</p>
</li>
<li>
<p>Collect all the important data for the iteration
</p>
</li>
</ol>
<h5>Usage</h5>

<div class="r"><pre>BKTRRegressor$mcmc_sampling()</pre></div>



<h5>Returns</h5>

<p>NULL Results are stored and can be accessed via summary()
</p>


<hr>
<a id="method-BKTRRegressor-predict"></a>



<h4>Method <code>predict()</code>
</h4>

<p>Use interpolation to predict betas and response values for new data.
</p>


<h5>Usage</h5>

<div class="r"><pre>BKTRRegressor$predict(
  new_data_df,
  new_spatial_positions_df = NULL,
  new_temporal_positions_df = NULL,
  jitter = 1e-05
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>new_data_df</code></dt>
<dd>
<p>data.table: New covariates. Must have the same columns as
the covariates used to fit the model. The index should contain the combination
of all old spatial coordinates with all new temporal coordinates, the combination
of all new spatial coordinates with all old temporal coordinates, and the
combination of all new spatial coordinates with all new temporal coordinates.</p>
</dd>
<dt><code>new_spatial_positions_df</code></dt>
<dd>
<p>data.table or NULL: A data frame containing the new
spatial positions. Defaults to NULL.</p>
</dd>
<dt><code>new_temporal_positions_df</code></dt>
<dd>
<p>data.table or NULL: A data frame containing the new
temporal positions. Defaults to NULL.</p>
</dd>
<dt><code>jitter</code></dt>
<dd>
<p>Numeric or NULL: A small value to add to the diagonal of the precision matrix.
Defaults to NULL.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>List: A list of two dataframes. The first represents the beta
forecasted for all new spatial locations or temporal points.
The second represents the forecasted response for all new spatial
locations or temporal points.
</p>


<hr>
<a id="method-BKTRRegressor-get_iterations_betas"></a>



<h4>Method <code>get_iterations_betas()</code>
</h4>

<p>Return all sampled betas through sampling iterations for a given
set of spatial, temporal and feature labels. Useful for plotting the
distribution of sampled beta values.
</p>


<h5>Usage</h5>

<div class="r"><pre>BKTRRegressor$get_iterations_betas(
  spatial_label,
  temporal_label,
  feature_label
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>spatial_label</code></dt>
<dd>
<p>String: The spatial label for which we want to get the betas</p>
</dd>
<dt><code>temporal_label</code></dt>
<dd>
<p>String: The temporal label for which we want to get the betas</p>
</dd>
<dt><code>feature_label</code></dt>
<dd>
<p>String: The feature label for which we want to get the betas</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A list containing the sampled betas through iteration for the given labels
</p>


<hr>
<a id="method-BKTRRegressor-get_beta_summary_df"></a>



<h4>Method <code>get_beta_summary_df()</code>
</h4>

<p>Get a summary of estimated beta values. If no labels are given,
then the summary is for all the betas. If labels are given, then the summary
is for the given labels.
</p>


<h5>Usage</h5>

<div class="r"><pre>BKTRRegressor$get_beta_summary_df(
  spatial_labels = NULL,
  temporal_labels = NULL,
  feature_labels = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>spatial_labels</code></dt>
<dd>
<p>vector: The spatial labels used in summary. If NULL,
then all spatial labels are used. Defaults to NULL.</p>
</dd>
<dt><code>temporal_labels</code></dt>
<dd>
<p>vector: The temporal labels used in summary. If NULL,
then all temporal labels are used. Defaults to NULL.</p>
</dd>
<dt><code>feature_labels</code></dt>
<dd>
<p>vector: The feature labels used in summary. If NULL,
then all feature labels are used. Defaults to NULL.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A new data.table with the beta summary for the given labels.
</p>


<hr>
<a id="method-BKTRRegressor-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>BKTRRegressor$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>Examples</h3>

<pre><code class="language-R">
# Create a BIXI data collection instance containing multiple dataframes
bixi_data &lt;- BixiData$new(is_light = TRUE) # Use light version for example

# Create a BKTRRegressor instance
bktr_regressor &lt;- BKTRRegressor$new(
  formula = nb_departure ~ 1 + mean_temp_c + area_park,
  data_df &lt;- bixi_data$data_df,
  spatial_positions_df = bixi_data$spatial_positions_df,
  temporal_positions_df = bixi_data$temporal_positions_df,
  burn_in_iter = 5, sampling_iter = 10) # For example only (too few iterations)

# Launch the MCMC sampling
bktr_regressor$mcmc_sampling()

# Get the summary of the bktr regressor
summary(bktr_regressor)

# Get estimated response variables for missing values
bktr_regressor$imputed_y_estimates

# Get the list of sampled betas for given spatial, temporal and feature labels
bktr_regressor$get_iterations_betas(
  spatial_label = bixi_data$spatial_positions_df$location[1],
  temporal_label = bixi_data$temporal_positions_df$time[1],
  feature_label = 'mean_temp_c')

# Get the summary of all betas for the 'mean_temp_c' feature
bktr_regressor$get_beta_summary_df(feature_labels = 'mean_temp_c')


## PREDICTION EXAMPLE ##
# Create a light version of the BIXI data collection instance
bixi_data &lt;- BixiData$new(is_light = TRUE)
# Simplify variable names
data_df &lt;- bixi_data$data_df
spa_pos_df &lt;- bixi_data$spatial_positions_df
temp_pos_df &lt;- bixi_data$temporal_positions_df

# Keep some data aside for prediction
new_spa_pos_df &lt;- spa_pos_df[1:2, ]
new_temp_pos_df &lt;- temp_pos_df[1:5, ]
reg_spa_pos_df &lt;- spa_pos_df[-(1:2), ]
reg_temp_pos_df &lt;- temp_pos_df[-(1:5), ]
reg_data_df_mask &lt;- data_df$location %in% reg_spa_pos_df$location &amp;
  data_df$time %in% reg_temp_pos_df$time
reg_data_df &lt;- data_df[reg_data_df_mask, ]
new_data_df &lt;- data_df[!reg_data_df_mask, ]

# Launch mcmc sampling on regression data
bktr_regressor &lt;- BKTRRegressor$new(
  formula = nb_departure ~ 1 + mean_temp_c + area_park,
  data_df = reg_data_df,
  spatial_positions_df = reg_spa_pos_df,
  temporal_positions_df = reg_temp_pos_df,
  burn_in_iter = 5, sampling_iter = 10) # For example only (too few iterations)
bktr_regressor$mcmc_sampling()

# Predict response values for new data
bktr_regressor$predict(
  new_data_df = new_data_df,
  new_spatial_positions_df = new_spa_pos_df,
  new_temporal_positions_df = new_temp_pos_df)

</code></pre>


</div>