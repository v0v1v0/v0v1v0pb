<div class="container">

<table style="width: 100%;"><tr>
<td>tidy_marginal_contrasts</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Marginal Contrasts with <code>marginaleffects::avg_comparisons()</code>
</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt="[Experimental]"></a>
Use <code>marginaleffects::avg_comparisons()</code> to estimate marginal contrasts for
each variable of a model and return a tibble tidied in a way that it could
be used by <code>broom.helpers</code> functions.
See <code>marginaleffects::avg_comparisons()</code> for a list of supported models.
</p>


<h3>Usage</h3>

<pre><code class="language-R">tidy_marginal_contrasts(
  x,
  variables_list = "auto",
  conf.int = TRUE,
  conf.level = 0.95,
  ...
)

variables_to_contrast(
  model,
  interactions = TRUE,
  cross = FALSE,
  var_categorical = "reference",
  var_continuous = 1,
  by_categorical = unique,
  by_continuous = stats::fivenum
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>(a model object, e.g. <code>glm</code>)<br>
A model to be tidied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variables_list</code></td>
<td>
<p>(<code>list</code> or <code>string</code>)<br>
A list whose elements will be sequentially passed to
<code>variables</code> in <code>marginaleffects::avg_comparisons()</code> (see details below);
alternatively, it could also be the string <code>"auto"</code> (default), <code>"cross"</code> or
<code>"no_interaction"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.int</code></td>
<td>
<p>(<code>logical</code>)<br>
Whether or not to include a confidence interval in the tidied output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.level</code></td>
<td>
<p>(<code>numeric</code>)<br>
The confidence level to use for the confidence interval (between <code>0</code> ans <code>1</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional parameters passed to
<code>marginaleffects::avg_comparisons()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>(a model object, e.g. <code>glm</code>)<br>
A model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interactions</code></td>
<td>
<p>(<code>logical</code>)<br>
Should combinations of variables corresponding to interactions be returned?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cross</code></td>
<td>
<p>(<code>logical</code>)<br>
If <code>interaction</code> is <code>TRUE</code>, should "cross-contrasts" be
computed? (if <code>FALSE</code>, only the last term of an interaction is passed to
<code>variable</code> and the other terms are passed to <code>by</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var_categorical</code></td>
<td>
<p>(<code>predictor values</code>)<br>
Default <code>variable</code> value for categorical variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var_continuous</code></td>
<td>
<p>(<code>predictor values</code>)<br>
Default <code>variable</code> value for continuous variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by_categorical</code></td>
<td>
<p>(<code>predictor values</code>)<br>
Default <code>by</code> value for categorical variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by_continuous</code></td>
<td>
<p>(<code>predictor values</code>)<br>
Default <code>by</code> value for continuous variables.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Marginal contrasts are obtained by calling, for each variable or combination
of variables, <code>marginaleffects::avg_comparisons()</code>.
</p>
<p><code>tidy_marginal_contrasts()</code> will compute marginal contrasts for each
variable or combination of variables, before stacking the results in a unique
tibble. This is why <code>tidy_marginal_contrasts()</code> has a <code>variables_list</code>
argument consisting of a list of specifications that will be passed
sequentially to the <code>variables</code> and the <code>by</code> argument of
<code>marginaleffects::avg_comparisons()</code>.
</p>
<p>Considering a single categorical variable named <code>cat</code>, <code>tidy_marginal_contrasts()</code>
will call <code>avg_comparisons(model, variables = list(cat = "reference"))</code>
to obtain average marginal contrasts for this variable.
</p>
<p>Considering a single continuous variable named <code>cont</code>, <code>tidy_marginalcontrasts()</code>
will call <code>avg_comparisons(model, variables = list(cont = 1))</code>
to obtain average marginal contrasts for an increase of one unit.
</p>
<p>For a combination of variables, there are several possibilities. You could
compute "cross-contrasts" by providing simultaneously several variables
to <code>variables</code> and specifying <code>cross = TRUE</code> to
<code>marginaleffects::avg_comparisons()</code>. Alternatively, you could compute the
contrasts of a first variable specified to <code>variables</code> for the
different values of a second variable specified to <code>by</code>.
</p>
<p>The helper function <code>variables_to_contrast()</code> could be used to automatically
generate a suitable list to be used with <code>variables_list</code>. Each combination
of variables should be a list with two named elements: <code>"variables"</code> a list
of named elements passed to <code>variables</code> and <code>"by"</code> a list of named elements
used for creating a relevant <code>datagrid</code> and whose names are passed to <code>by</code>.
</p>
<p><code>variables_list</code>'s default value, <code>"auto"</code>, calls
<code>variables_to_contrast(interactions = TRUE, cross = FALSE)</code> while
<code>"no_interaction"</code> is a shortcut for
<code>variables_to_contrast(interactions = FALSE)</code>. <code>"cross"</code> calls
<code>variables_to_contrast(interactions = TRUE, cross = TRUE)</code>
</p>
<p>You can also provide custom specifications (see examples).
</p>
<p>By default, <em>average marginal contrasts</em> are computed: contrasts are computed
using a counterfactual grid for each value of the variable of interest,
before averaging the results. <em>Marginal contrasts at the mean</em> could be
obtained by indicating <code>newdata = "mean"</code>. Other assumptions are possible,
see the help file of <code>marginaleffects::avg_comparisons()</code>.
</p>
<p>For more information, see <code>vignette("marginal_tidiers", "broom.helpers")</code>.
</p>


<h3>See Also</h3>

<p><code>marginaleffects::avg_comparisons()</code>, <code>tidy_avg_comparisons()</code>
</p>
<p>Other marginal_tieders: 
<code>tidy_all_effects()</code>,
<code>tidy_avg_comparisons()</code>,
<code>tidy_avg_slopes()</code>,
<code>tidy_ggpredict()</code>,
<code>tidy_marginal_means()</code>,
<code>tidy_marginal_predictions()</code>,
<code>tidy_margins()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Average Marginal Contrasts
df &lt;- Titanic |&gt;
  dplyr::as_tibble() |&gt;
  tidyr::uncount(n) |&gt;
  dplyr::mutate(Survived = factor(Survived, c("No", "Yes")))
mod &lt;- glm(
  Survived ~ Class + Age + Sex,
  data = df, family = binomial
)
tidy_marginal_contrasts(mod)
tidy_plus_plus(mod, tidy_fun = tidy_marginal_contrasts)

mod2 &lt;- lm(Petal.Length ~ poly(Petal.Width, 2) + Species, data = iris)
tidy_marginal_contrasts(mod2)
tidy_marginal_contrasts(
  mod2,
  variables_list = variables_to_predict(
    mod2,
    continuous = 3,
    categorical = "pairwise"
  )
)

# Model with interactions
mod3 &lt;- glm(
  Survived ~ Sex * Age + Class,
  data = df, family = binomial
)
tidy_marginal_contrasts(mod3)
tidy_marginal_contrasts(mod3, "no_interaction")
tidy_marginal_contrasts(mod3, "cross")
tidy_marginal_contrasts(
  mod3,
  variables_list = list(
    list(variables = list(Class = "pairwise"), by = list(Sex = unique)),
    list(variables = list(Age = "all")),
    list(variables = list(Class = "sequential", Sex = "reference"))
  )
)

mod4 &lt;- lm(Sepal.Length ~ Petal.Length * Petal.Width + Species, data = iris)
tidy_marginal_contrasts(mod4)
tidy_marginal_contrasts(
  mod4,
  variables_list = list(
    list(
      variables = list(Species = "sequential"),
      by = list(Petal.Length = c(2, 5))
    ),
    list(
      variables = list(Petal.Length = 2),
      by = list(Species = unique, Petal.Width = 2:4)
    )
  )
)

# Marginal Contrasts at the Mean
tidy_marginal_contrasts(mod, newdata = "mean")
tidy_marginal_contrasts(mod3, newdata = "mean")

</code></pre>


</div>