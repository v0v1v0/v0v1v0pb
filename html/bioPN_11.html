<div class="container">

<table style="width: 100%;"><tr>
<td>b) Simulation Functions</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulation of a biochemical system</h2>

<h3>Description</h3>

<p>These functions simulate a biochemical reacton system
parameterized as a Petri Net. 
<code>GillespieOptimDirect</code>, <code>GillespieDirectGB</code>,
<code>GibsonBruck</code>, and <code>GillespieDirectCR</code> performs pure
stochastic simulations, <code>RungeKuttaDormandPrince45</code> a pure
deterministic integration, <code>HaseltineRawlings</code> a hybrid of the
above. <code>PartitionedLeaping</code> a dynamic-repartitioning
simulation. Multiple runs can be performed at once.
</p>
<p>See <code>init</code> for a way of defining the model that is close
to the way reactions are written.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## Exact stochastic simulation: 
GillespieOptimDirect(model, timep, delta=1, runs=1)
GillespieDirectGB(model, timep, delta=1, runs=1)
GibsonBruck(model, timep, delta=1, runs=1)
GillespieDirectCR(model, timep, delta=1, runs=1)

## Pure deterministic:
RungeKuttaDormandPrince45(model, timep, delta=1, ect = 1e-09)

## Hybrid stochastic/deterministic:
HaseltineRawlings(model, timep, delta=1, runs=1, ect = 1e-09)

## Dynamic re-partitioning:
PartitionedLeaping(model, timep, delta=1, runs=1, ect = 1e-09)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>list containing named elements:</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timep</code></td>
<td>
<p>It can be either a numeric, indicating for how long (in
the same time units as the propensity constants) the process will
run, or a functions (R or C), in which case can be used to change
the protocol at time intervals. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>Interval time at which the state will be saved.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>runs</code></td>
<td>
<p>How many runs will be performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ect</code></td>
<td>
<p>Precision for the fast reactions.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>model is a list containing the following elements:
</p>

<ul>
<li>
<p>model$pre: pre matrix, with as many rows as transitions
(reactions), and columns as places (reactants). It has
the stoichiometrics of the left sides of the reactions.
</p>
</li>
<li>
<p>model$post: post matrix, with as many rows as transitions,
and columns as places (products). It has the stoichiometrics of
the right sides of the reactions.
</p>
</li>
<li>
<p>model$h: list of propensity constants or functions returning
the propensity (with as many elements as transitions).
</p>
</li>
<li>
<p>model$slow: vector of zeros for slow transitions and ones
for fast transitions. Only needed for
<code>HaseltineRawlings</code>. Ignored otherwise.
</p>
</li>
<li>
<p>model$M: initial marking (state) of the system.
</p>
</li>
<li>
<p>model$place: vector with names of the places.
</p>
</li>
<li>
<p>model$transition: vector with names of the transitions.
</p>
</li>
</ul>
<h3>Value</h3>

<p>The functions return a list with the following elements:  
</p>
<table>
<tr style="vertical-align: top;">
<td><code>place</code></td>
<td>
<p>vector with the names of the places if supplied. If not, the function creates names as follows: P1, P2, ...</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transition</code></td>
<td>
<p>vector with the names of the transitions if supplied. If not, the function creates names as follows: T1, T2, ...</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dt</code></td>
<td>
<p>vector containing the discretized times at which the state is saved (according to delta)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>run</code></td>
<td>
<p>list with as many elements as runs. We will describe the first element, run[[1]], as the rest have exactly the same structure. It is also a list, with the following elements:</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>run[[1]]$M</code></td>
<td>
<p>list with as many elements as places, each of them containing the state of the system sampled according to delta.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>run[[1]]$transitions</code></td>
<td>
<p>vector with as many elements as transitions, with the total of time each slow reaction fired.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>run[[1]]$tot.transitions</code></td>
<td>
<p>numeric with the summ of run[[1]]$transitions.</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>init</code>, <code>atr</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## bioPN has been tested only on 64 bits machines.
## It may fail in 32 bits architecture.
if (.Machine$sizeof.pointer == 8) {

####### Reaction constants
H &lt;- 10
K &lt;- 6
r &lt;- 0.25
c &lt;- 3
b &lt;- 2
#######

Gi &lt;- 1
Ga &lt;- 2
mRNA &lt;- 3
Protein &lt;- 4

model &lt;- list(
    pre=matrix(c(1,0,0,0, 0,1,0,0, 0,1,0,0,
        0,0,1,0, 0,0,1,0, 0,0,0,1),
        ncol=4, byrow=TRUE),
    post=matrix(c(0,1,0,0, 1,0,0,0, 0,1,1,0,
        0,0,0,0, 0,0,1,1, 0,0,0,0),
        ncol=4, byrow=TRUE),
    h=list(c, b, H, 1, K, r),
    M=c(1,0,0,0))

timep &lt;- 200
delta &lt;- 1

##############################
## Completely Deterministic ##
##############################
Sim &lt;- RungeKuttaDormandPrince45(model, timep, delta)

## Note, it could also be done as follows
## slow &lt;- rep(0, transitions)
## Sim &lt;- HaseltineRawlings(model, timep, delta, runs = 1)

mRNA.run &lt;- Sim$run[[1]]$M[[mRNA]]
protein.run &lt;- Sim$run[[1]]$M[[Protein]]

## Theoretical results (red lines in following plots)
Mean.mRNA &lt;- c/(c+b)*H
Mean.protein &lt;- Mean.mRNA * K/r

par(mfrow=c(1,2))
par(mar=c(2, 4, 2, 1) + 0.1)
plot(Sim$dt, mRNA.run,type="l", ylab="Mean",main="mRNA")
legend(x="bottom", paste("Deterministic run"))
abline(h=Mean.mRNA,col="red", lwd=1)
plot(Sim$dt, protein.run,type="l", ylab="Mean",main="Protein")
legend(x="bottom", paste("Deterministic run"))
abline(h=Mean.protein,col="red", lwd=1)


runs &lt;- 100	## Increase to 10000 for better fit
###########################
## Completely Stochastic ##
###########################
set.seed(19761111)  ## Set a seed (for reproducible results)
Sim &lt;- GillespieOptimDirect(model, timep, delta, runs)

## Note, it could also be done as follows
## slow &lt;- rep(1, transitions)
## Sim &lt;- HaseltineRawlings(model, timep, delta, runs)

mRNA.run &lt;- sapply(Sim$run, function(run) {run$M[[mRNA]]})
protein.run &lt;- sapply(Sim$run, function(run) {run$M[[Protein]]})

## Histograms of protein at different time points.
par(mfrow=c(2,2))
par(mar=c(2, 4, 2.5, 1) + 0.1)
hist(protein.run[Sim$dt == 1,], main="Protein Distribution at t=1sec")
hist(protein.run[Sim$dt == 2,], main="Protein Distribution at t=2sec")
hist(protein.run[Sim$dt == 10,], main="Protein Distribution at t=10sec")
hist(protein.run[Sim$dt == 200,], main="Protein Distribution at t=200sec")

## Theoretical results (red lines in following plots)
Mean.mRNA &lt;- c/(c+b)*H
Var.mRNA &lt;- b/(c*(1+c+b))*Mean.mRNA^2 + Mean.mRNA
Mean.protein &lt;- Mean.mRNA * K/r
Var.protein &lt;- r*b*(1+c+b+r)/(c*(1+r)*(1+c+b)*(r+c+b))*Mean.protein^2 +
  r/(1+r)*Mean.protein^2/Mean.mRNA + Mean.protein

if (runs &gt; 1 ) {
  par(mfrow=c(2,2))
} else {
  par(mfrow=c(1,2))
}
par(mar=c(2, 4, 2, 1) + 0.1)
plot(Sim$dt, apply(mRNA.run,1,function(tpt) {mean(tpt)}),type="l", ylab="Mean",main="mRNA")
legend(x="bottom", paste("Gene, mRNA and Protein Stochastic\nRuns :", runs))
abline(h=Mean.mRNA,col="red", lwd=1)
plot(Sim$dt, apply(protein.run,1,function(tpt) {mean(tpt)}),type="l", ylab="Mean",main="Protein")
legend(x="bottom", paste("Gene, mRNA and Protein Stochastic\nRuns :", runs))
abline(h=Mean.protein,col="red", lwd=1)
if (runs &gt; 1 ) {
  par(mar=c(2, 4, 0, 1) + 0.1)
  plot(Sim$dt, apply(mRNA.run,1,function(tpt) {var(tpt)}),type="l", ylab="Var")
  abline(h=Var.mRNA,col="red", lwd=1)
  plot(Sim$dt, apply(protein.run,1,function(tpt) {var(tpt)}),type="l", ylab="Var")
  abline(h=Var.protein,col="red", lwd=1)
}


######################################################################
## Hybrid: mRNA and protein fast, gene activation/inactivation slow ##
######################################################################
model$slow &lt;- c(1,1,0,0,0,0)

Sim &lt;- HaseltineRawlings(model, timep, delta, runs)

mRNA.run &lt;- sapply(Sim$run, function(run) {run$M[[mRNA]]})
protein.run &lt;- sapply(Sim$run, function(run) {run$M[[Protein]]})
    
Mean.mRNA &lt;- c/(c+b)*H
Var.mRNA &lt;- b/(c*(1+c+b))*Mean.mRNA^2
Mean.protein &lt;- Mean.mRNA * K/r
Var.protein &lt;- r*b*(1+c+b+r)/(c*(1+r)*(1+c+b)*(r+c+b))*Mean.protein^2

if (runs &gt; 1 ) {
  par(mfrow=c(2,2))
} else {
  par(mfrow=c(1,2))
}
par(mar=c(2, 4, 2, 1) + 0.1)
plot(Sim$dt, apply(mRNA.run,1,function(tpt) {mean(tpt)}),type="l", ylab="Mean",main="mRNA")
legend(x="bottom", paste("Only Gene Stochastic\nRuns :", runs))
abline(h=Mean.mRNA,col="red", lwd=1)
plot(Sim$dt, apply(protein.run,1,function(tpt) {mean(tpt)}),type="l", ylab="Mean",main="Protein")
legend(x="bottom", paste("Only Gene Stochastic\nRuns :", runs))
abline(h=Mean.protein,col="red", lwd=1)
if (runs &gt; 1 ) {
  par(mar=c(2, 4, 0, 1) + 0.1)
  plot(Sim$dt, apply(mRNA.run,1,function(tpt) {var(tpt)}),type="l", ylab="Var")
  abline(h=Var.mRNA,col="red", lwd=1)
  plot(Sim$dt, apply(protein.run,1,function(tpt) {var(tpt)}),type="l", ylab="Var")
  abline(h=Var.protein,col="red", lwd=1)
}
}
</code></pre>


</div>