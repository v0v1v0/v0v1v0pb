<div class="container">

<table style="width: 100%;"><tr>
<td>sol.tguh</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Solution path generation via the Tail-Greedy Unbalanced Haar method</h2>

<h3>Description</h3>

<p>This function arranges all possible change-points in the mean of the input vector in the order of importance, via the Tail-Greedy Unbalanced Haar method.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sol.tguh(x, type = "const", p = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A numeric vector containing the data to be processed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>The model type considered. <code>type = "const"</code> means piecewise-constant; this is the only type currently supported in <code>sol.tguh</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Specifies the number of region pairs merged 
in each pass through the data, as the proportion of all remaining region pairs. The default is
<code>p = 0.01</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The Tail-Greedy Unbalanced Haar decomposition algorithm is described in 
"Tail-greedy bottom-up data decompositions and fast multiple change-point 
detection", P. Fryzlewicz (2018), The Annals of Statistics, 46, 3390–3421.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>cptpath</code>, which contains the following fields: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>solutions.nested</code></td>
<td>
<p><code>TRUE</code>, i.e., the change-point outputs are nested</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solution.path</code></td>
<td>
<p>Locations of possible change-points in the mean of <code>x</code>, arranged in decreasing order of change-point importance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solution.set</code></td>
<td>
<p>Empty list</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Input vector <code>x</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Input parameter <code>type</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Input parameter <code>p</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cands</code></td>
<td>
<p>Matrix of dimensions length(<code>x</code>) - 1 by 4. The first two columns are (start, end)-points of the detection intervals of the corresponding possible change-point location in the third column. The fourth column is a measure of strength of the corresponding possible change-point. The order of the rows is the same as the order returned in <code>solution.path</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>The method used, which has value "tguh" here</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>P. Fryzlewicz (2018). Tail-greedy bottom-up data decompositions and fast multiple change-point detection. <em>The Annals of Statistics</em>, 46, 3390–3421.
</p>


<h3>See Also</h3>

<p><code>sol.idetect</code>, <code>sol.idetect_seq</code>, <code>sol.not</code>, <code>sol.wbs</code>, <code>sol.wbs2</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">r3 &lt;- rnorm(1000) + c(rep(0,300), rep(2,200), rep(-4,300), rep(0,200))
sol.tguh(r3)
</code></pre>


</div>