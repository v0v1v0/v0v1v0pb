<div class="container">

<table style="width: 100%;"><tr>
<td>getAttractors</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Identify attractors in a Boolean network</h2>

<h3>Description</h3>

<p>Identifies attractors (cycles) in a supplied Boolean network using synchronous or asynchronous state transitions</p>


<h3>Usage</h3>

<pre><code class="language-R">getAttractors(network, 
              type = c("synchronous","asynchronous"), 
              method = c("exhaustive",
                         "sat.exhaustive",
                         "sat.restricted",
                         "random",
                         "chosen"), 
              startStates = list(),
              genesON = c(), genesOFF = c(), 
              canonical = TRUE,
              randomChainLength = 10000, 
              avoidSelfLoops = TRUE, 
              geneProbabilities = NULL, 
              maxAttractorLength = Inf,
              returnTable = TRUE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>network</code></td>
<td>

<p>A network structure of class <code>BooleanNetwork</code> or <code>SymbolicBooleanNetwork</code>. These networks can be read from files by <code>loadNetwork</code>, generated by <code>generateRandomNKNetwork</code>, or reconstructed by <code>reconstructNetwork</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>

<p>If <code>type="synchronous"</code>, synchronous state transitions are used, i.e. all genes are updated at the same time. Synchronous attractor search can be performed in an exhaustive manner or using a heuristic that starts from predefined states. For symbolic networks, only synchronous updates are possible.
</p>
<p>If <code>type="asynchronous"</code>, asynchronous state transitions are performed, i.e. one (randomly chosen) gene is updated in each transition. Steady-state attractors are the same in asynchronous and synchronous networks, but the asynchronous search is also able to identify complex/loose attractors. Asynchronous search relies on a heuristic algorithm that starts from predefined states.
</p>
<p>See Details for more information on the algorithms.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>The search method to be used. If "exhaustive", attractors are identified by exhaustive state space search, i.e. by calculating the sucessors of all 2^n states (where n is the number of genes that are not set to a fixed value). This kind of search is only available for synchronous attractor search, and the maximum number of genes allowed for exhaustive search is 29. Apart from the attractors, this method generates the full state transition graph.
</p>
<p>If <code>method</code> is "sat.exhaustive" or "sat.restricted", attractors are identified using algorithms based on the satisfiability problem. This search type is also restricted to synchronous networks. It can be used to identify attractors in much larger networks than with <code>method="exhaustive"</code>, but does not return the state transition graph. For <code>method="sat.exhaustive"</code>, an exhaustive attractor search is performed, while <code>method="sat.restricted"</code> only searches for attractors of a specified maximum length <code>maxAttractorLength</code>.
</p>
<p>If <code>method</code> is "random", <code>startStates</code> is interpreted as an integer value specifying the number of states to be generated randomly. The algorithm is then initialized with these random states and identifies the attractors to which these states lead.
</p>
<p>If <code>method</code> is "chosen", <code>startStates</code> is interpreted as a list of binary vectors, each specifying one input state. Each vector must have <code>length(network$genes)</code> elements with 0 or 1 values. The algorithm identifies the attractors to which the supplied states lead. If <code>network</code> is of class <code>SymbolicBooleanNetwork</code> and makes use of more than one predecessor state, this can also be a list of matrices with the genes in the columns and multiple predecessor states in the rows.
</p>
<p>If <code>method</code> is not supplied, the desired method is inferred from the type of <code>startStates</code>. By default, if neither <code>method</code> nor <code>startStates</code> are provided, an exhaustive search is performed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>startStates</code></td>
<td>

<p>The value of <code>startStates</code> depends on the chosen method. See <code>method</code> for more details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>genesON</code></td>
<td>

<p>A vector of genes whose values are fixed to 1, which reduces the complexity of the search. This is equivalent to a preceding call of <code>fixGenes</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>genesOFF</code></td>
<td>

<p>A vector of genes whose values are fixed to 0, which reduces the complexity of the search. This is equivalent to a preceding call of <code>fixGenes</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>canonical</code></td>
<td>

<p>If set to true, the states in the attractors are rearranged such that the state whose binary encoding
makes up the smallest number is the first element of the vector. This ensures that attractors found by different heuristic runs of <code>getAttractors</code> are comparable, as the cycles may have been entered at different states in different runs of the algorithm.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>randomChainLength</code></td>
<td>

<p>If <code>type="asynchronous"</code>, this parameter specifies the number of random transitions performed by the search to enter a potential attractor (see Details). Defaults to 10000.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>avoidSelfLoops</code></td>
<td>

<p>If <code>type="asynchronous"</code> and <code>avoidSelfLoops=TRUE</code>, the asynchronous attractor search only enters self loops (i.e. transitions that result in the same state) if none of the possible transitions can leave the state. This results in attractors with fewer edges. Otherwise, self loops are included in the attractors. By default, self loops are avoided.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geneProbabilities</code></td>
<td>

<p>If <code>type="asynchronous"</code>, this allows to specify probabilities for the genes. By default, each gene has the same probability to be chosen for the next state transition. You can supply a vector of probabilities for each of the genes which sums up to one.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxAttractorLength</code></td>
<td>
<p>If <code>method="sat.restricted"</code>, this required parameter specifies the maximum size of attractors (i.e. the number of states in the loop) to be searched. For <code>method="sat.exhaustive"</code>, this parameter is optional and specifies the maximum attractor length for the initial length-restricted search phase that is performed to speed up the subsequent exhaustive search. In this case, changing this value might bring performance benefits, but does not change the results.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnTable</code></td>
<td>

<p>Specifies whether a transition table is included in the returned <code>AttractorInfo</code> structure. If <code>type="asynchronous"</code> or <code>method="sat"</code>, this parameter is ignored, as the corresponding algorithms never return a transition table.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Depending on the type of network and the chosen parameters, different search algorithms are started.
</p>
<p>For <code>BooleanNetwork</code> networks, there are three different modes of attractor search:
</p>

<dl>
<dt>Exhaustive synchronous state space search</dt>
<dd>
<p>In this mode, synchronous state transitions are carried out from each of the possible states until an attractor is reached. This identifies all synchronous attractors.
</p>
</dd>
<dt>Heuristic synchronous state space search</dt>
<dd>
<p>In contrast to exhaustive synchronous search, only a subset of the possible states is used. From these states, synchronous transitions are carried out until an attractor is reached. This subset is specified in <code>startStates</code>.
</p>
</dd>
<dt>Exhaustive synchronous SAT-based search</dt>
<dd>
<p>Here, the attractor search problem is formulated as a satisfiability problem and solved using Armin Biere's PicoSAT solver. The algorithm is a variant of the method by Dubrova and Teslenko which searches for a satisfying assignment of a chain constructed by unfolding the transition relation. Depending on <code>maxAttractorLength</code>, it additionally applies an initial size-restricted SAT-based search (see below) to increase overall search speed. This method is suitable for larger networks of up to several hundreds of genes and exhaustively identifies all attractors in these networks. In contrast to the state space search, it does not construct and return a state transition table.
</p>
</dd>
<dt>Size-restricted synchronous SAT-based search</dt>
<dd>
<p>Here, the SAT solver directly looks for satisfying assignments for loops of a specific size. This may be more efficient for large networks and is guaranteed to find all attractors that comprise up to <code>maxAttractorLength</code> states (e.g. all steady states for <code>maxAttractorLength=1</code>) , but does not find any larger attractors. As for the exhaustive SAT-based method, no transition table is returned.
</p>
</dd>
<dt>Heuristic asynchronous search</dt>
<dd>
<p>This algorithm uses asynchronous state transitions and is able to identify steady-state and complex/loose attractors (see Harvey and Bossomaier, Garg et al.). These attractors are sets of states from which all possible asynchronous transitions lead into a state that is member of the set as well.
The heuristic algorithm does the following for each of the input state specified by <code>startStates</code>:
</p>

<ol>
<li>
<p> Perform <code>randomChainLength</code> random asynchronous transitions. After these transitions, the network state is expected to be located in an attractor with a high probability.
</p>
</li>
<li>
<p> Calculate the forward reachable set of the current state. Then, compare this set to the forward reachable set of all states in the set. If all sets are equal, a complex attractor is found.
</p>
</li>
</ol>
</dd>
</dl>
<p>For <code>SymbolicBooleanNetwork</code> networks, <code>getAttractors</code> is simply a wrapper for <code>simulateSymbolicModel</code> with preset parameters. 

</p>
<p>Printing the return value of <code>getAttractors</code> using <code>print</code> visualizes the identified attractors.</p>


<h3>Value</h3>

<p>For <code>BooleanNetwork</code> networks, this returns a list of class <code>AttractorInfo</code> with components
</p>
<table>
<tr style="vertical-align: top;">
<td><code>attractors</code></td>
<td>
<p>A list of attractors. Each element is a 2-element list with the following components:
</p>

<dl>
<dt>involvedStates</dt>
<dd>
<p>A matrix containing the states that make up the attractor. Each column represents one state. The entries are decimal numbers that internally represent the states of the genes. The number of rows depends on the number of genes in the network: The first 32 genes are encoded in the first row, genes 33-64 are encoded in the second row, etc.</p>
</dd>
<dt>initialStates</dt>
<dd>
<p>This element is only available if an asynchronous search was carried out and this is a complex attractor. In this case, it holds the encoded start states of the transitions in the complex attractor</p>
</dd>
<dt>nextStates</dt>
<dd>
<p>This element is only available if an asynchronous search was carried out and this is a complex attractor. In this case, it holds the encoded successor states of the transitions in the complex attractor</p>
</dd>
<dt>basinSize</dt>
<dd>
<p>The number of states in the basin of attraction. Details on the states in the basin can be retrieved via <code>getBasinOfAttraction</code>.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stateInfo</code></td>
<td>
<p>A summary structure of class <code>BooleanStateInfo</code> containing information on the transition table. It has the following components:
</p>

<dl>
<dt>initialStates</dt>
<dd>
<p>This element is only available if <code>type="synchronous"</code>, <code>method</code> is "random" or "chosen", and <code>returnTable=TRUE</code>. This is a matrix describing the initial states that lead to the states in <code>table</code> after a state transition.	If <code>method</code> is "exhaustive", this component is <code>NULL</code>. In this case, the initial states can be inferred, as all states are used. The format of the matrix is described in <code>involvedStates</code>.</p>
</dd>
<dt>table</dt>
<dd>
<p>This element is only available if <code>type="synchronous"</code> and <code>returnTable=TRUE</code>. It holds result vector of the transition table as a matrix with one column for each state. These are encoded bit vectors in decimal numbers as described above.</p>
</dd>
<dt>attractorAssignment</dt>
<dd>
<p>This element is only available if <code>type="synchronous"</code> and <code>returnTable=TRUE</code>. It contains a vector that corresponds to the entries in <code>table</code> and describes the attractor index in <code>attractors</code> to which successive transitions from the described state finally lead.</p>
</dd>
<dt>stepsToAttractor</dt>
<dd>
<p>This element is only available if <code>type="synchronous"</code> and <code>returnTable=TRUE</code>. Referring to <code>attractorAssignment</code>, this is the number of transitions needed to reach the attractor.</p>
</dd>
<dt>genes</dt>
<dd>
<p>A list of names of the genes in <code>network</code>.</p>
</dd>
<dt>fixedGenes</dt>
<dd>
<p>Specifies the fixed genes as in the <code>fixed</code> component of <code>network</code>.</p>
</dd>
</dl>
<p>The structure supports pretty printing using the <code>print</code> method.</p>
</td>
</tr>
</table>
<p>For <code>SymbolicBooleanNetwork</code> networks, <code>getAttractors</code> redirects the call to <code>simulateSymbolicModel</code> and returns an object of class <code>SymbolicSimulation</code> containing the attractors and (if <code>returnTable=TRUE</code>) the transition graph.  
</p>


<h3>References</h3>

<p>S. A. Kauffman (1969), Metabolic stability and epigenesis in randomly constructed nets. J. Theor. Biol. 22:437–467.
</p>
<p>S. A. Kauffman (1993), The Origins of Order. Oxford University Press.
</p>
<p>I. Harvey, T. Bossomaier (1997), Time out of joint: Attractors in asynchronous random Boolean networks. Proc. of the Fourth European Conference on
Artificial Life, 67–75.
</p>
<p>A. Garg, A. Di Cara, I. Xenarios, L. Mendoza, G. De Micheli (2008), Synchronous versus asynchronous modeling of gene regulatory networks. Bioinformatics 24(17):1917–1925. 
</p>
<p>E. Dubrova, M. Teslenko (2011), A SAT-based algorithm for finding attractors in synchronous Boolean networks. IEEE/ACM Transactions on Computational Biology and Bioinformatics 8(5):1393–1399.
</p>
<p>A. Biere (2008), PicoSAT Essentials. Journal on Satisfiability, Boolean Modeling and Computation 4:75-97.
</p>


<h3>See Also</h3>

<p><code>loadNetwork</code>, <code>generateRandomNKNetwork</code>, <code>simulateSymbolicModel</code>, <code>plotAttractors</code>, <code>attractorsToLaTeX</code>, <code>getTransitionTable</code>, <code>getBasinOfAttraction</code>, <code>getAttractorSequence</code>, <code>getStateSummary</code>, <code>getPathToAttractor</code>, <code>fixGenes</code>, <code>generateState</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# load example data
data(cellcycle)

# get all synchronous attractors by exhaustive search
attractors &lt;- getAttractors(cellcycle)

# plot attractors side by side
par(mfrow=c(2, length(attractors$attractors)))
plotAttractors(attractors)

# finds the synchronous attractor with 7 states
attractors &lt;- getAttractors(cellcycle, method="chosen",
                            startStates=list(rep(1, length(cellcycle$genes))))
plotAttractors(attractors)

# finds the attractor with 1 state
attractors &lt;- getAttractors(cellcycle, method="chosen",
                            startStates=list(rep(0, length(cellcycle$genes))))
plotAttractors(attractors)

# also finds the attractor with 1 state by restricting the attractor length
attractors &lt;- getAttractors(cellcycle, method="sat.restricted",
                            maxAttractorLength=1)
plotAttractors(attractors)

# identifies asynchronous attractors
attractors &lt;- getAttractors(cellcycle, type="asynchronous", startStates=100)
plotAttractors(attractors, mode="graph")

## End(Not run)
</code></pre>


</div>