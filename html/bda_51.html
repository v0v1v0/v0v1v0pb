<div class="container">

<table style="width: 100%;"><tr>
<td>lpsmooth</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>non-parametric regression</h2>

<h3>Description</h3>

<p>To fit nonparametric regression model.
</p>


<h3>Usage</h3>

<pre><code class="language-R"> lpsmooth(y,x, bw, sd.y,lscv=FALSE, adaptive=FALSE,
 	  from, to, gridsize,conf.level=0.95)
 npr(y,x,sd.x,bw,kernel='decon',optimal=FALSE,adaptive=FALSE,
     x0,from, to, gridsize,conf.level=0.95)
 wlpsmooth(y,x,w,s.x,bw,from,to,gridsize,conf.level=0.95)
 bootsmooth(y,x,type="relative",iter=100,conf.level=0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y,x</code></td>
<td>
<p>Two numerical vectors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>weights</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s.x</code></td>
<td>
<p>standard deviation of the measurement error â€“ Laplacian
errors are assumed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x0,from,to,gridsize</code></td>
<td>
<p>'x0' is the grid points where the fitted 
values will be evaluated. If it is missing, define a fine grid using 
the start point ("from"), end point ("to") and size ("gridsize").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bw</code></td>
<td>
<p>Smoothing parameter.  Numeric or character value is 
allowed.  If missing, adaptive (LSCV) bandwidth selector will 
be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>
<p>kernel type: "normal","gauss","nw","decon" (default),
"lp","nadaraya-watson"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lscv,adaptive</code></td>
<td>
<p>If <code>lscv = FALSE</code>, use the given
bandwidth to fit lpr directly.  If <code>lscv = TRUE</code> and
<code>adaptive = FALSE</code>, compute lscv bandwidth and fit lpr.
Initial bandwidth should be given.  If <code>lscv = TRUE</code> and
<code>adaptive = TURE</code>, compute lscv bandwidth, then compute
varying smoothing parameter, then fit lpr.  This algorithm
could be extremeely slow when the sample size is very large.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimal</code></td>
<td>
<p>Search for optimal bandwidth if TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd.y</code></td>
<td>
<p>Standard deviation of <code>y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd.x</code></td>
<td>
<p>Standard deviation of the measurement error <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.level</code></td>
<td>
<p>Confidence level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>Bootstrapping iteration number.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>"relative" changes or "absolute" changes for effectiveness
evaluation.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Estimated values of the smooth function over a fine grid.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>grid points where the smoothed function are evaluated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x0,y0</code></td>
<td>
<p>cleaned data of x and y.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.level</code></td>
<td>
<p>confidence level of the simultaneous confidence bands.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pars</code></td>
<td>
<p>estimate parameters including smoothing bandwidth, and parameters for the tube formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ucb,lcb</code></td>
<td>
<p>upper and lower confidence bands.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>function called</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">
 x &lt;- rnorm(100,34.5,1.5)
 e &lt;- rnorm(100,0,2)
 y &lt;- (x-32)^2 + e
 out &lt;- lpsmooth(y,x)
 out
 plot(out, type='l')
 x0 &lt;- seq(min(x),max(x),length=100)
 y0 &lt;- (x0-32)^2
 lines(x0, y0, col=2)
 points(x, y, pch="*", col=4)


 </code></pre>


</div>