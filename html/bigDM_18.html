<div class="container">

<table style="width: 100%;"><tr>
<td>random_partition</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Define a random partition of the spatial domain based on a regular grid</h2>

<h3>Description</h3>

<p>The function takes an object of class <code>SpatialPolygonsDataFrame</code> or <code>sf</code> and
defines a random partition of the spatial polygons based on a regular grid over the whole domain
using the <code>st_make_grid</code> function of the <code>sf</code> package.
</p>


<h3>Usage</h3>

<pre><code class="language-R">random_partition(
  carto,
  rows = 3,
  columns = 3,
  min.size = 50,
  max.size = 1000,
  prop.zero = NULL,
  O = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>carto</code></td>
<td>
<p>object of class <code>SpatialPolygonsDataFrame</code> or <code>sf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rows</code></td>
<td>
<p>integer; number of rows to define the regular grid. Default to 3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>columns</code></td>
<td>
<p>integer; number of columns to define the regular grid. Default to 3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.size</code></td>
<td>
<p>numeric; value to fix the minimum number of areas in each spatial partition (if <code>NULL</code>, this step is skipped). Default to 50.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.size</code></td>
<td>
<p>numeric; value to fix the maximum number of areas in each spatial partition (if <code>NULL</code>, this step is skipped). Default to 600.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prop.zero</code></td>
<td>
<p>numeric; value between 0 and 1 that indicates the maximum proportion of areas with no cases for each spatial partition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>O</code></td>
<td>
<p>character; name of the variable that contains the observed number of disease cases for each areal units. Only required if <code>prop.zero</code> argument is set.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>After defining a random partition of the spatial polygons based on a regular grid, the subregions with number of areas smaller than the value given by the <code>min.size</code> are merged to its nearest neighbour.
Then, the subregions with number of areas greater than the value given by the <code>max.size</code> argument are divided.
Finally, if <code>prop.zero</code> argument is set, the subregions with proportion of areas with zero cases below that threshold are merged to its smallest neighbour.
</p>


<h3>Value</h3>

<p><code>sf</code> object with the original data and a grouping variable named 'ID.group'
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
library(tmap)
tmap4 &lt;- packageVersion("tmap") &gt;= "3.99"

## Load the Spain colorectal cancer mortality data ##
data(Carto_SpainMUN)

## Random partition based on a 3x3 regular grid (with no size restrictions) ##
carto.r1 &lt;- random_partition(carto=Carto_SpainMUN, rows=3, columns=3,
                             min.size=NULL, max.size=NULL)
table(carto.r1$ID.group)

part1 &lt;- aggregate(carto.r1[,"geometry"], by=list(ID.group=carto.r1$ID.group), head)

if(tmap4){
        tm_shape(carto.r1) +
                tm_polygons(fill="ID.group",
                            fill.scale=tm_scale(values="brewer.set3"),
                            fill.legend=tm_legend(frame=FALSE)) +
                tm_shape(part1) + tm_borders(col="black", lwd=2) +
                tm_title(text="3x3 regular grid (with no size restrictions)")
}else{
        tm_shape(carto.r1) +
                tm_polygons(col="ID.group") +
                tm_shape(part1) + tm_borders(col="black", lwd=2) +
                tm_layout(main.title="3x3 regular grid (with no size restrictions)",
                          main.title.position="center", main.title.size=1,
                          legend.outside=TRUE)
}

## Random partition based on a 6x4 regular grid (with size restrictions) ##
carto.r2 &lt;- random_partition(carto=Carto_SpainMUN, rows=6, columns=4,
                             min.size=50, max.size=600)
table(carto.r2$ID.group)

part2 &lt;- aggregate(carto.r2[,"geometry"], by=list(ID.group=carto.r2$ID.group), head)

if(tmap4){
        tm_shape(carto.r2) +
                tm_polygons(fill="ID.group",
                            fill.scale=tm_scale(values="brewer.set3"),
                            fill.legend=tm_legend(frame=FALSE)) +
                tm_shape(part2) + tm_borders(col="black", lwd=2) +
                tm_title(text="6x4 regular grid (min.size=50, max.size=600)")
}else{
        tm_shape(carto.r2) +
                tm_polygons(col="ID.group") +
                tm_shape(part2) + tm_borders(col="black", lwd=2) +
                tm_layout(main.title="6x4 regular grid (min.size=50, max.size=600)",
                          main.title.position="center", main.title.size=1,
                          legend.outside=TRUE)
}

## Random partition based on a 6x4 regular grid (with size and proportion of zero restrictions) ##
carto.r3 &lt;- random_partition(carto=Carto_SpainMUN, rows=6, columns=4,
                             min.size=50, max.size=600, prop.zero=0.5, O="obs")
table(carto.r3$ID.group)

part3 &lt;- aggregate(carto.r3[,"geometry"], by=list(ID.group=carto.r3$ID.group), head)

if(tmap4){
        tm_shape(carto.r3) +
                tm_polygons(fill="ID.group",
                            fill.scale=tm_scale(values="brewer.set3"),
                            fill.legend=tm_legend(frame=FALSE)) +
                tm_shape(part3) + tm_borders(col="black", lwd=2) +
                tm_title(text="6x4 regular grid (min.size=50, max.size=600, prop.zero=0.5)")
}else{
        tm_shape(carto.r3) +
                tm_polygons(col="ID.group") +
                tm_shape(part3) + tm_borders(col="black", lwd=2) +
                tm_layout(main.title="6x4 regular grid (min.size=50, max.size=600, prop.zero=0.5)",
                          main.title.position="center", main.title.size=1,
                          legend.outside=TRUE)
}

## End(Not run)

</code></pre>


</div>