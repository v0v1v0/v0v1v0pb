<div class="container">

<table style="width: 100%;"><tr>
<td>estimateRuntimes</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate Remaining Runtimes</h2>

<h3>Description</h3>

<p>Estimates the runtimes of jobs using the random forest implemented in <span class="pkg">ranger</span>.
Observed runtimes are retrieved from the <code>Registry</code> and runtimes are
predicted for unfinished jobs.
</p>
<p>The estimated remaining time is calculated in the <code>print</code> method.
You may also pass <code>n</code> here to determine the number of parallel jobs which is then used
in a simple Longest Processing Time (LPT) algorithm to give an estimate for the parallel runtime.
</p>


<h3>Usage</h3>

<pre><code class="language-R">estimateRuntimes(tab, ..., reg = getDefaultRegistry())

## S3 method for class 'RuntimeEstimate'
print(x, n = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>tab</code></td>
<td>
<p>[<code>data.table</code>]<br>
Table with column “job.id” and additional columns to predict the runtime.
Observed runtimes will be looked up in the registry and serve as dependent variable.
All columns in <code>tab</code> except “job.id” will be passed to <code>ranger</code> as
independent variables to fit the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>[ANY]<br>
Additional parameters passed to <code>ranger</code>. Ignored for the <code>print</code> method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reg</code></td>
<td>
<p>[<code>Registry</code>]<br>
Registry. If not explicitly passed, uses the default registry (see <code>setDefaultRegistry</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>[<code>RuntimeEstimate</code>]<br>
Object to print.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>[<code>integer(1)</code>]<br>
Number of parallel jobs to assume for runtime estimation.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>[<code>RuntimeEstimate</code>] which is a <code>list</code> with two named elements:
“runtimes” is a <code>data.table</code> with columns “job.id”,
“runtime” (in seconds) and “type” (“estimated” if runtime is estimated,
“observed” if runtime was observed).
The other element of the list named “model”] contains the fitted random forest object.
</p>


<h3>See Also</h3>

<p><code>binpack</code> and <code>lpt</code> to chunk jobs according to their estimated runtimes.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Create a simple toy registry
set.seed(1)
tmp = makeExperimentRegistry(file.dir = NA, make.default = FALSE, seed = 1)
addProblem(name = "iris", data = iris, fun = function(data, ...) nrow(data), reg = tmp)
addAlgorithm(name = "nrow", function(instance, ...) nrow(instance), reg = tmp)
addAlgorithm(name = "ncol", function(instance, ...) ncol(instance), reg = tmp)
addExperiments(algo.designs = list(nrow = data.table::CJ(x = 1:50, y = letters[1:5])), reg = tmp)
addExperiments(algo.designs = list(ncol = data.table::CJ(x = 1:50, y = letters[1:5])), reg = tmp)

# We use the job parameters to predict runtimes
tab = unwrap(getJobPars(reg = tmp))

# First we need to submit some jobs so that the forest can train on some data.
# Thus, we just sample some jobs from the registry while grouping by factor variables.
library(data.table)
ids = tab[, .SD[sample(nrow(.SD), 5)], by = c("problem", "algorithm", "y")]
setkeyv(ids, "job.id")
submitJobs(ids, reg = tmp)
waitForJobs(reg = tmp)

# We "simulate" some more realistic runtimes here to demonstrate the functionality:
# - Algorithm "ncol" is 5 times more expensive than "nrow"
# - x has no effect on the runtime
# - If y is "a" or "b", the runtimes are really high
runtime = function(algorithm, x, y) {
  ifelse(algorithm == "nrow", 100L, 500L) + 1000L * (y %in% letters[1:2])
}
tmp$status[ids, done := done + tab[ids, runtime(algorithm, x, y)]]
rjoin(sjoin(tab, ids), getJobStatus(ids, reg = tmp)[, c("job.id", "time.running")])

# Estimate runtimes:
est = estimateRuntimes(tab, reg = tmp)
print(est)
rjoin(tab, est$runtimes)
print(est, n = 10)

# Submit jobs with longest runtime first:
ids = est$runtimes[type == "estimated"][order(runtime, decreasing = TRUE)]
print(ids)
## Not run: 
submitJobs(ids, reg = tmp)

## End(Not run)

# Group jobs into chunks with runtime &lt; 1h
ids = est$runtimes[type == "estimated"]
ids[, chunk := binpack(runtime, 3600)]
print(ids)
print(ids[, list(runtime = sum(runtime)), by = chunk])
## Not run: 
submitJobs(ids, reg = tmp)

## End(Not run)

# Group jobs into 10 chunks with similar runtime
ids = est$runtimes[type == "estimated"]
ids[, chunk := lpt(runtime, 10)]
print(ids[, list(runtime = sum(runtime)), by = chunk])
</code></pre>


</div>