<div class="container">

<table style="width: 100%;"><tr>
<td>roc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Build a ROC curve </h2>

<h3>Description</h3>

 
<p>This function builds a ROC curve specifically for graph structure learning and returns a “roc” object, a list of class
“roc”. This object can be <code>prin</code>ted, <code>plot</code>ted, or
passed to the functions <code>pROC::roc()</code>, <code>pROC::ci()</code>, <code>pROC::smooth.roc()</code>
and <code>pROC::coords()</code>. Additionally, two <code>roc</code> objects can be compared with <code>pROC::roc.test()</code>. 
This function is based on the <code>roc</code> function of <code>R</code> package <code>pROC</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R"> 
roc( pred, actual, auc = TRUE, smooth = FALSE, plot = FALSE, quiet = TRUE, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pred  </code></td>
<td>

<p>adjacency matrix (or a vector) corresponding to an estimated graph. 
It can be an object with <code>S3</code> class "<code>bdgraph</code>" from function <code>bdgraph</code>. 
It can be an object of <code>S3</code> class <code>"ssgraph"</code>, from the function <code>ssgraph::ssgraph()</code> of <code>R</code> package <code>ssgraph::ssgraph()</code>.
It can be a <code>numeric</code> or <code>ordered</code> vector of the same length than <code>actual</code>, containing the predicted
value of each observation.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>actual</code></td>
<td>
<p> adjacency matrix (or a vector) corresponding to the actual graph structure in which <code class="reqn">a_{ij}=1</code> if there is a link between notes <code class="reqn">i</code> and <code class="reqn">j</code>, otherwise <code class="reqn">a_{ij}=0</code>.
It can be an object with <code>S3</code> class "<code>sim</code>" from function <code>bdgraph.sim</code>.
It can be an object with <code>S3</code> class <code>"graph"</code> from function <code>graph.sim</code>.
It can be a factor, numeric or character vector of responses (true class), typically encoded with 0 (controls) and 1 (cases).
Only two classes can be used in a ROC curve. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth</code></td>
<td>
<p>if TRUE, the ROC curve is passed to <code>smooth</code>
to be smoothed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>auc</code></td>
<td>
<p>compute the area under the curve (AUC)? If <code>TRUE</code>
(default), additional arguments can be passed to <code>pROC::auc()</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>plot the ROC curve? If <code>TRUE</code>, additional
arguments can be passed to <code>pROC::plot.roc()</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quiet</code></td>
<td>
<p>if <code>TRUE</code>, turn off <code>message</code>s when <code>direction</code> and <code>levels</code> are auto-detected.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> further arguments to be passed to <code>pROC::roc()</code>. </p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>If the data contained any <code>NA</code> value and <code>na.rm=FALSE</code>, <code>NA</code> is
returned. Otherwise, if <code>smooth=FALSE</code>, a list of class
“roc” with the following fields: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>auc</code></td>
<td>
<p>if called with <code>auc=TRUE</code>, a numeric of class “auc” as
defined in <code>pROC::auc()</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci</code></td>
<td>
<p>if called with <code>ci=TRUE</code>, a numeric of class “ci” as
defined in <code>pROC::ci()</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>response</code></td>
<td>
<p>the response vector. Patients whose response is not
<code>%in%</code> <code>levels</code> are discarded. If <code>NA</code> values
were removed, a <code>na.action</code> attribute similar
to <code>na.omit</code> stores the row numbers. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predictor</code></td>
<td>
<p>predictor vector converted to numeric as used to build the ROC
curve. Patients whose response is not <code>%in%</code> <code>levels</code> are discarded. If
<code>NA</code> values were removed, a <code>na.action</code> attribute similar
to <code>na.omit</code> stores the row numbers.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>original.predictor, original.response</code></td>
<td>
<p>response and predictor vectors as passed in argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>levels</code></td>
<td>
<p>levels of the response as defined in argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>controls</code></td>
<td>
<p>predictor values for the control observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cases</code></td>
<td>
<p>predictor values for the cases.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>percent</code></td>
<td>
<p>if the sensitivities, specificities and AUC are
reported in percent, as defined in argument.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>direction</code></td>
<td>
<p>direction of the comparison, as defined in argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun.sesp</code></td>
<td>
<p>function used to compute sensitivities and specificities.
Will be re-used in bootstrap operations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sensitivities</code></td>
<td>
<p>sensitivities defining the ROC curve.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>specificities</code></td>
<td>
<p>specificities defining the ROC curve.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresholds</code></td>
<td>
<p>thresholds at which the sensitivities and
specificities were computed. See below for details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>how the function was called. See function <code>match.call</code> for
more details.
</p>
</td>
</tr>
</table>
<p>If <code>smooth=TRUE</code> a list of class “smooth.roc” as returned
by <code>pROC::smooth()</code>, with or without additional elements
<code>auc</code> and <code>ci</code> (according to the call).
</p>


<h3>Author(s)</h3>

<p>Reza Mohammadi <a href="mailto:a.mohammadi@uva.nl">a.mohammadi@uva.nl</a>; Lucas Vogels <a href="mailto:l.f.o.vogels@uva.nl">l.f.o.vogels@uva.nl</a></p>


<h3>References</h3>

<p>Tom Fawcett (2006) “An introduction to ROC analysis”. <em>Pattern
Recognition Letters</em> <b>27</b>, 861–874, <a href="https://doi.org/10.1016/j.patrec.2005.10.010">doi:10.1016/j.patrec.2005.10.010</a>
</p>
<p>Xavier Robin, Natacha Turck, Alexandre Hainard, <em>et al.</em>
(2011) “pROC: an open-source package for R and S+ to analyze and
compare ROC curves”. <em>BMC Bioinformatics</em>, <b>7</b>, 77, 
<a href="https://doi.org/10.1186/1471-2105-12-77">doi:10.1186/1471-2105-12-77</a>.
</p>


<h3>See Also</h3>

 <p><code>plotroc</code>, <code>pROC::plot.roc()</code>, <code>pROC::auc()</code>, <code>pROC::print.roc()</code>, <code>bdgraph</code>, <code>bdgraph.mpl</code>, <code>compare</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
set.seed( 5 )

# Generating multivariate normal data from a 'scale-free' graph
data.sim = bdgraph.sim( n = 200, p = 15, graph = "scale-free", vis = TRUE )

# Running BDMCMC algorithm 
sample.bdmcmc = bdgraph( data = data.sim, algorithm = "bdmcmc", iter = 10000 )

# ROC curve for BDMCMC algorithm 
roc.bdmcmc = BDgraph::roc( pred = sample.bdmcmc, actual = data.sim, plot = TRUE )

# Running RJMCMC algorithm
sample.rjmcmc = bdgraph( data = data.sim, algorithm = "rjmcmc", iter = 10000 )

# ROC curve for RJMCMC algorithm
roc.rjmcmc = BDgraph::roc( pred = sample.rjmcmc, actual = data.sim, plot = TRUE )

# ROC curve for both BDMCMC and RJMCMC algorithms
pROC::ggroc( list( BDMCMC = roc.bdmcmc, RJMCMC = roc.rjmcmc ) )

## End(Not run)
</code></pre>


</div>