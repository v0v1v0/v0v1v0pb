<div class="container">

<table style="width: 100%;"><tr>
<td>initial</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Initial values constructor for bayesPO modeling</h2>

<h3>Description</h3>

<p>Helper function to create a valid set of initial values to be used with the
fit_bayesPO function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">initial(
  beta = numeric(),
  delta = numeric(),
  lambdaStar = numeric(),
  random = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>Either a vector or a single integer. The vector is used if the
initial values are provided and the integer is used as the vector size to
be randomly generated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>Either a vector or a single integer. The vector is used if the
initial values are provided and the integer is used as the vector size to
be randomly generated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdaStar</code></td>
<td>
<p>A positive number.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, then the initial values are
generated from standard normal distribution for <code>beta</code> and <code>delta</code>
and from a <code>Beta(lambdaStar, 1)</code> for <code>lambdaStar</code>. The latter is
generated as a low value due to potential explosive values resulting from
background area scaling.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A <code>bayesPO_initial</code> object. It can be used in the
<code>fit_bayesPO</code> function by itself, but must be in a list if multiple
initial values are supplied. Initial values can be combined by adding them
(with the use of '+').
</p>


<h3>See Also</h3>

<p><code>bayesPO_initial-class</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Let us create initial values for a model with, say, 3 intensity covariates
# and 4 observability covariates. We add an initial values for both these
# cases due to the intercepts.

# This first one is
in1 &lt;- initial(rep(0, 4), c(0, 2, -1, -2, 3), 100)

# Then we initalize some randomly.
in2 &lt;- initial(4, 5, 100, random = TRUE)

# We can even multiply the random one to generate more. Let us join them all
# to include in a model.
initial_values &lt;- in1 + in2 * 3
# 4 chains are initialized.
</code></pre>


</div>