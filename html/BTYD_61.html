<div class="container">

<table style="width: 100%;"><tr>
<td>dc.MakeRFmatrixCal</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Make Calibration Period Recency-Frequency Matrix</h2>

<h3>Description</h3>

<p>Make a calibration period recency-frequency matrix.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dc.MakeRFmatrixCal(
  frequencies,
  periods.of.final.purchases,
  num.of.purchase.periods,
  holdout.frequencies = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>frequencies</code></td>
<td>
<p>vector which indicates the number of repeat transactions
made by customers in the calibration period.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>periods.of.final.purchases</code></td>
<td>
<p>a vector indicating in which period
customers made their final purchases.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.of.purchase.periods</code></td>
<td>
<p>the number of transaction opportunities in
the calibration period.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>holdout.frequencies</code></td>
<td>
<p>an optional vector indicating the number of
transactions made by customers in the holdout period.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A matrix with all possible frequency-recency combinations, and the
number of customers with each combination. It contains columns for
frequency ("x"), recency ("t.x"), number of transaction opportunities in
the calibration period ("n.cal"), number of customers with this combination
of recency, frequency, and number of periods observed ("custs"), and
optionally, number of transactions in the holdout period ("x.star").
</p>


<h3>Examples</h3>

<pre><code class="language-R">elog &lt;- dc.ReadLines(system.file("data/discreteSimElog.csv", package="BTYD"),1,2)
elog[,"date"] &lt;- as.Date(elog[,"date"])

cutoff.date &lt;- as.Date("1977-01-01")
cbt &lt;- dc.CreateReachCBT(elog)
cal.cbt &lt;- cbt[,as.Date(colnames(cbt)) &lt;= cutoff.date]
holdout.cbt &lt;- cbt[,as.Date(colnames(cbt)) &gt; cutoff.date]

cal.start.dates.indices &lt;- dc.GetFirstPurchasePeriodsFromCBT(cal.cbt)
cal.start.dates &lt;- as.Date(colnames(cal.cbt)[cal.start.dates.indices])
cal.end.dates.indices &lt;- dc.GetLastPurchasePeriodsFromCBT(cal.cbt)
cal.end.dates &lt;- as.Date(colnames(cal.cbt)[cal.end.dates.indices])
T.cal.total &lt;- rep(cutoff.date, nrow(cal.cbt))
cal.dates &lt;- data.frame(cal.start.dates, cal.end.dates, T.cal.total)

# Create calibration period customer-by-sufficient-statistic data frame,
# using years as the unit of time.
cal.cbs &lt;- dc.BuildCBSFromCBTAndDates(cal.cbt,
                                      cal.dates,
                                      per="year",
                                      cbt.is.during.cal.period=TRUE)

holdout.start &lt;- as.Date(colnames(holdout.cbt)[1])
holdout.end &lt;- as.Date(tail(colnames(holdout.cbt),n=1))
# The (-1) below is to remove the effect of the birth period - we are only
# interested in repeat transactions in the calibration period.
frequencies &lt;- (cal.cbs[,"x"] - 1)
periods.of.final.purchases &lt;- cal.cbs[,"t.x"]
num.of.purchase.periods &lt;- ncol(cal.cbt) - 1

# Create a calibration period recency-frequency matrix
cal.rf.matrix &lt;- dc.MakeRFmatrixCal(frequencies,
                                    periods.of.final.purchases,
                                    num.of.purchase.periods)
</code></pre>


</div>