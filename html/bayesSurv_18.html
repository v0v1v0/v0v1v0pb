<div class="container">

<table style="width: 100%;"><tr>
<td>bayessurvreg1</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
A Bayesian survival regression with an error distribution
expressed as a~normal mixture with unknown number of components
</h2>

<h3>Description</h3>

<p>A function to sample from the posterior distribution for a survival
regression  model
</p>
<p style="text-align: center;"><code class="reqn">\log(T_{i,l}) = \beta^T x_{i,l} + b_i^T z_{i,l} +
    \varepsilon_{i,l},\quad i=1,\dots,N,\ l=1,\dots,n_i,</code>
</p>

<p>where distribution of <code class="reqn">\varepsilon_{i,l}</code> is specified
as a normal mixture with unknown number of components as in Richardson
and Green (1997) and random effect <code class="reqn">b_i</code> is normally distributed.
</p>
<p>See Komárek (2006) or
Komárek and Lesaffre (2007)
for more detailed description of prior assumptions.
</p>
<p>Sampled values are stored on a disk to be further worked out by e.g.
<code>coda</code> or <code>boa</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bayessurvreg1(formula, random,
   data = parent.frame(), subset,
   na.action = na.fail,
   x = FALSE, y = FALSE, onlyX = FALSE,
   nsimul = list(niter = 10, nthin = 1, nburn = 0,
                 nnoadapt = 0, nwrite = 10),
   prior = list(kmax = 5, k.prior = "poisson", poisson.k = 3,
                dirichlet.w = 1,
                mean.mu = NULL, var.mu = NULL,
                shape.invsig2 = 1.5,
                shape.hyper.invsig2 = 0.8, rate.hyper.invsig2 = NULL,
                pi.split = NULL, pi.birth = NULL,
                Eb0.depend.mix = FALSE),
   prior.beta, prior.b, prop.revjump,
   init = list(iter = 0, mixture = NULL, beta = NULL,
               b = NULL, D = NULL,
               y = NULL, r = NULL, otherp = NULL, u = NULL),
   store = list(y = TRUE, r = TRUE, b = TRUE, u = TRUE,
                MHb = FALSE, regresres = FALSE),
   dir,
   toler.chol = 1e-10, toler.qr = 1e-10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>model formula for the ‘fixed’ part of the model, i.e. the
part that specifies <code class="reqn">\beta^T x_{i,l}</code>. See
<code>survreg</code> for further details. Intercept is implicitely
included in the model by estimation of the error distribution. As a
consequence <code>-1</code> in the model formula does not have any effect
on the model.
</p>
<p>The left-hand side of the <code>formula</code> must be an~objecy created
using <code>Surv</code>.
</p>
<p>If <code>random</code> is used then the formula must contain
an identification of clusters in the form <code>cluster(id)</code>, where
<code>id</code> is a name of the variable that determines clusters, e.g.
</p>

<table><tr>
<td style="text-align: center;">
      <code>Surv(time, event)~gender + cluster(id)</code>.
    </td>
</tr></table>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random</code></td>
<td>
<p>formula for the ‘random’ part of the model, i.e. the
part that specifies <code class="reqn">b_i^T z_{i,l}</code>. If omitted,
no random part is included in the model. E.g. to specify the model with a
random intercept, say <code>random=~1</code>. All effects mentioned in
<code>random</code> should also be mentioned on the right-hand side of
<code>formula</code>.
</p>
<p>When some random effects are included the random intercept is added
by default. It can be removed using e.g. <code>random=~-1 + gender</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>optional data frame in which to interpret the variables
occuring in the formulas.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>subset of the observations to be used in the fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>function to be used to handle any <code>NA</code>s in the
data. The user is discouraged to change a default value
<code>na.fail</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>if <code>TRUE</code> then the <code>X</code> matrix is returned. This
matrix contain all columns appearing in both <code>formula</code> and
<code>random</code> parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>if <code>TRUE</code> then the <code>y</code> matrix (of log-survival
times) is returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>onlyX</code></td>
<td>
<p>if TRUE, no McMC is performed. The function returns only
a design matrix of your model (intercept excluded). It might be
useful to set up correctly a parameter for a block update of
<code class="reqn">\beta</code> (regression parameters related to the fixed
effects) and <code class="reqn">\gamma</code> (means of the random effects,
random intercept excluded) parameters in the model if
Metropolis-Hastings is to be used instead of default Gibbs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsimul</code></td>
<td>
<p>a list giving the number of iterations of the McMC and
other parameters of the simulation.
</p>

<dl>
<dt>niter</dt>
<dd>
<p>total number of sampled values after discarding
thinned ones, burn-up included.</p>
</dd>
<dt>nthin</dt>
<dd>
<p>thinning interval.</p>
</dd>
<dt>nburn</dt>
<dd>
<p>number of sampled values in a burn-up period after
discarding thinned values. This value should be smaller than
<code>niter</code>. If not, <code>nburn</code> is set to <code>niter - 1</code>. It can be set to zero.</p>
</dd>
<dt>nnoadapt</dt>
<dd>
<p>applicable if some blocks of parameters are
updated using an adaptive Metropolis algorithm. This is a number
of sampled values that are generated using an initial and fixed
proposal covariance matrix. It should be smaller or equal to
<code>nburn</code>. If not, <code>nnoadapt</code> is set to <code>nburn</code>.</p>
</dd>
<dt>nwrite</dt>
<dd>
<p>an interval at which sampled values are written to
files. </p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>
<p>a list that identifies prior hyperparameters and prior
choices. See accompanying paper for more details.
Some prior parameters can be guessed by the function itself. If you
want to do so, set such parameters to <code>NULL</code>. Set to
<code>NULL</code> also the parameters that are not needed in your model.
</p>

<dl>
<dt>kmax</dt>
<dd>
<p>value of <code class="reqn">k_{max}</code>, upper limit for the
number of mixture components. Its high values like 100 will
usually correspond to <code class="reqn">\infty</code>.</p>
</dd>
<dt>k.prior</dt>
<dd>
<p>a string specifying the prior distribution of
<code class="reqn">k</code>, number of mixture components. Valid are either
“poisson”, “uniform”, or “fixed”. When “fixed” is given
then the number of mixture components is not sampled.</p>
</dd>
<dt>poisson.k</dt>
<dd>
<p>prior hyperparameter <code class="reqn">\lambda</code> for
the number of mixture components $k$ if Poisson prior for this
parameter is used.</p>
</dd>
<dt>dirichlet.w</dt>
<dd>
<p>prior hyperparameter <code class="reqn">\delta</code> for
the Dirichlet distribution of mixture weights
<code class="reqn">w_1,\dots,w_k</code>.</p>
</dd>
<dt>mean.mu</dt>
<dd>
<p>prior hyperparameter <code class="reqn">\xi</code> for the mean of
the normal prior for mixture means
<code class="reqn">\mu_1,\dots,\mu_k</code>.</p>
</dd>
<dt>var.mu</dt>
<dd>
<p>prior hyperparameter <code class="reqn">\kappa</code> for the
variance of the normal prior for mixture means <code class="reqn">\mu_1,\dots,\mu_k</code>.</p>
</dd>
<dt>shape.invsig2</dt>
<dd>
<p>prior hyperparameter <code class="reqn">\zeta</code> for
the shape of the inverse-gamma distribution for the mixture
variances
<code class="reqn">\sigma_1^2,\dots,\sigma_k^2</code>.</p>
</dd>
<dt>shape.hyper.invsig2</dt>
<dd>
<p>prior hyperparameter (shape) <code class="reqn">g</code> for the
gamma distribution of the parameter <code class="reqn">\eta</code>. Remember,
<code class="reqn">\eta</code> is a scale parameter of the inverse-gamma distribution for the mixture
variances
<code class="reqn">\sigma_1^2,\dots,\sigma_k^2</code>.</p>
</dd>
<dt>rate.hyper.invsig2</dt>
<dd>
<p>prior hyperparameter (rate) <code class="reqn">h</code> for the
gamma distribution of the parameter <code class="reqn">\eta</code>. Remember,
<code class="reqn">\eta</code> is a scale parameter of the inverse-gamma distribution for the mixture
variances
<code class="reqn">\sigma_1^2,\dots,\sigma_k^2</code>.</p>
</dd>
<dt>pi.split</dt>
<dd>
<p>probabilities of a split move within the
reversible jump McMC. It must be a vector of length equal to
<code>kmax</code> with the first component equal to 1 and the last
component equal to 0. If <code>NULL</code> 2nd to (k-1)th components
are set to 0.5.</p>
</dd>
<dt>pi.birth</dt>
<dd>
<p>probabilities of a birth move within the
reversible jump McMC. It must be a vector of length equal to
<code>kmax</code> with the first component equal to 1 and the last
component equal to 0. If <code>NULL</code> 2nd to (k-1)th components
are set to 0.5.</p>
</dd>
<dt>Eb0.depend.mix</dt>
<dd>
<p>this will normally be <code>FALSE</code>. Setting
this option to <code>TRUE</code> served for some experiments during
the development of this function. In principle, when this is set
to <code>TRUE</code> and the random intercept is included in the model
then it is assumed that the mean of the random intercept is not
zero but <code class="reqn">\sum_{j=1}^k w_j\mu_j</code>,
i.e. the mean of the random intercept depends on
mixture. However, this did not werk too well.	
</p>
</dd>	
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.beta</code></td>
<td>
<p>a list defining the blocks of <code class="reqn">\beta</code>
parameters (both fixed effects and means of random effects, except
the random intercept) that are to be updated together (in a block),
a description of how they are updated and a specification of priors.
The list is assumed to have the following components.
</p>

<dl>
<dt>mean.prior</dt>
<dd>
<p>a vector specifying a prior mean for each
<code class="reqn">\beta</code> parameter in the model.</p>
</dd>
<dt>var.prior</dt>
<dd>
<p>a vector specifying a prior variance for each
<code class="reqn">\beta</code> parameter. It is recommended to run the function
<code>bayessurvreg1</code> first with its argument <code>onlyX</code> set to
<code>TRUE</code> to find out how the <code class="reqn">\beta</code>s are
sorted. They must correspond to a design matrix X.</p>
</dd>
<dt>blocks</dt>
<dd>
<p>a list with the following components.
</p>

<dl>
<dt>ind.block</dt>
<dd>
<p>a list with vectors with indeces of columns of
the design matrix X defining the effect of <code class="reqn">\beta</code>s in the
block. If not specified, all <code class="reqn">\beta</code> parameters
corresponding to fixed effects are updated in one block and
remaining <code class="reqn">\beta</code> parameters (means of random
effects) in the second block using the Gibbs move.</p>
</dd>
<dt>cov.prop</dt>
<dd>
<p>a list with vectors with a lower triangle of the covariance
matrix which is used in the normal proposal (use a command
<code>lower.tri</code> with <code>diag = TRUE</code> to get a lower
triangle from a matrix) when one of the Metopolis-like
algorithms is used for
a given block. This matrix is used at each iteration if the given
block is updated using a standard random-walk Metropolis-Hastings step. If the
block is updated using an adaptive Metropolis step this matrix is
used only at start. If not specified and Metropolis-like
algorith is required a diagonal matrix with prior
variances for corresponding <code class="reqn">\beta</code> on a diagonal is
used. It is set to a vector of zeros of appropriate length when the Gibbs move is required
for a given block.</p>
</dd>
</dl>
</dd>
<dt>type.upd</dt>
<dd>
<p>a character vector specifying the type of the update
that will be used for each block. Valid are substrings of
either "gibbs" or "adaptive.metropolis" or "random.walk.metropolis".
Default is "gibbs" for all blocks.</p>
</dd>
<dt>mean.sampled</dt>
<dd>
<p>a vector of means of up to now sampled
values. This component is useful when the adaptive Metropolis
algorithm is used and we do not start from the beginning
(e.g. already several iterations of McMC have already been
performed). Otherwise, this component does not have to be filled.</p>
</dd>
<dt>eps.AM</dt>
<dd>
<p>a vector with <code class="reqn">\epsilon</code> from the
adaptive Metropolis algorithm for each block.</p>
</dd>
<dt>sd.AM</dt>
<dd>
<p>a vector specifying <code class="reqn">s_d, d = 1,\dots, D</code> numbers from the
adaptive Metropolis algorithm for each dimension. This vector must
be of length equal at least to the length of the longest
block. Defaults values are <code class="reqn">\frac{1}{d}2.4^2</code>
where <code class="reqn">d</code> denotes a length of the block.</p>
</dd>
<dt>weight.unif</dt>
<dd>
<p>a vector specifying the weight of the uniform
component in the proposal for each block. If not specified, it is
equal to 0.5 for all parameters.</p>
</dd>
<dt>half.range.unif</dt>
<dd>
<p>a vector of same length as the number of
columns in the design matrix X specifying the half range of the
uniform component of the proposal.</p>
</dd>     
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.b</code></td>
<td>
<p>a list defining the way in which the random effects are
to be updated and the specification of priors for random effects
related parameters. The list is assumed to have following components.
</p>

<dl>
<dt>prior.D</dt>
<dd>
<p>a string defining the prior distribution for the
covariance matrix of random effects <code class="reqn">D</code>. It can be either
“inv.wishart” or “sduniform”.
</p>

<dl>
<dt>inv.wishart</dt>
<dd>
<p>in that case is assumed that the prior distribution
of the matrix <code class="reqn">D</code> is Inverse-Wishart with degrees of freedom
equal to <code class="reqn">\tau</code> and a scale matrix equal to
<code class="reqn">S</code>. When <code class="reqn">D</code> is a matrix <code class="reqn">q\times q</code> a
prior expectation of <code class="reqn">D</code> is equal to
<code class="reqn">(\tau - q - 1)^{-1}S</code> if
<code class="reqn">\tau &gt; q + 1</code>. For
<code class="reqn">q - 1 &lt; \tau \leq q + 1</code> a prior
expectation is not finite.	
Degrees of freedom parameter <code class="reqn">\tau</code> does not have to be an
integer. It has to only satisfy a condition
<code class="reqn">\tau &gt; q - 1</code>. <code>prior.b$df.D</code> gives a prior
degrees of freedom parameter <code class="reqn">\tau</code> and
<code>prior.b$scale.D</code> determines the scale matrix <code class="reqn">D</code>.
This is also the default choice.
</p>
</dd>
<dt>sduniform</dt>
<dd>
<p>this can be used only when the random effect is
univariate. Then the matrix <code class="reqn">D</code> is just a scalar and the
prior of <code class="reqn">\sqrt{D}</code> (standard deviation of the
univariate random effect) is assumed to be uniform on interval
<code class="reqn">(0, S)</code>. The upper limit <code class="reqn">S</code> is given by <code>prior.b$scale.D</code>.
</p>
</dd>	
</dl>
</dd>
<dt>df.D</dt>
<dd>
<p>degrees of freedom parameter <code class="reqn">\tau</code> in the case
that the prior of the matrix <code class="reqn">D</code> is inverse-Wishart.
</p>
</dd>
<dt>scale.D</dt>
<dd>
<p>a lower triangle of the scale matrix <code class="reqn">S</code> in
the case that the prior of the matrix <code class="reqn">D</code> is
inverse-Wishart or the upper limit <code class="reqn">S</code> of the uniform distribution in
the case that <code class="reqn">\sqrt{D} \sim \mbox{Unif}(0, S)</code>.</p>
</dd>
<dt>type.upd</dt>
<dd>
<p>a character vector specifying the type of the
update. Valid are substrings of either "random.walk.metropolis" or
"gibbs". Default is "gibbs". In contrast to <code class="reqn">\beta</code>
parameters, all random effects are updated using the same type of
the move. If "random.walk.metropolis" is used, random effects may
be divided into blocks in which they are updated. With "gibbs",
there is only one block defined for all random effects.
which are updated in one step using its full conditional distribution.</p>
</dd>
<dt>blocks</dt>
<dd>
<p>a list with the following components. This is set to
NULL if <code>type.upd = "gibbs"</code>.      
</p>

<dl>
<dt>ind.block</dt>
<dd>
<p>a list with vectors with indeces of random
effects defining the block. Random intercept has always an
index 1, remaining random effects have subsequent indeces
according to their appearance in the design matrix X.</p>
</dd>
<dt>cov.prop</dt>
<dd>
<p>a list with vectors with a lower triangle of the covariance
matrix which is used in the normal proposal (use a command
<code>lower.tri</code> with <code>diag = TRUE</code> to get a lower triangle from a matrix) for
a given block when
</p>

<table><tr>
<td style="text-align: center;">
	     <code>type.upd = "random.walk.metropolis"</code>. 
	   </td>
</tr></table>
</dd>      	
</dl>
</dd>	 
<dt>weight.unif</dt>
<dd>
<p>a vector specifying the weight of the uniform
component in the proposal for each block when
</p>

<table><tr>
<td style="text-align: center;">
	<code>type.upd = "random.walk.metropolis"</code>. 
      </td>
</tr></table>
<p>If not specified, it is
equal to 0.5 for all parameters. It is set to NULL if <code>type.upd = "gibbs"</code>.</p>
</dd> 
<dt>half.range.unif</dt>
<dd>
<p>a vector of same length as the number of
random effects specifying the half range of the uniform component
of the proposal when <code>type.upd = "random.walk.metropolis"</code>.
It is set to NULL if <code>type.upd = "gibbs"</code>.</p>
</dd>       
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prop.revjump</code></td>
<td>
<p>a list of values defining in which way the
reversible jumps will be performed. 
</p>

<dl>
<dt>algorithm</dt>
<dd>
<p>a string defining the algorithm used to generate
canonical proposal vectors
<code class="reqn">u = (u_{3k+1},\dots, u_{3k_{max}})'</code>
where <code class="reqn">u_{3k+1}, u_{3k+2}, u_{3k+3}</code>
are directly used when a jump to a space of higher dimension is
proposed. These canonical proposal vectors are further
transformed to give desired parameters (mixture component's weight, mean and
variance). 
Valid values of <code>prop.revjump$algorithm</code> are substrings of
"basic", "independent.av", "correlated.av". <code>"basic"</code> means
that both components of vectors <code class="reqn">u</code> and vectors
<code class="reqn">u</code> in time are generated independently from a standard
uniform distribution. This corresponds to a basic reversible
jumps McMC algorithm of Green (1995). Other two methods
implement an auxiliary variable method of Brooks et
al. (2003). The first one an independent auxiliary variable
method where vectors <code class="reqn">u</code> may be correlated in time
however their components are independent and the second one the
correlated auxiliary method where vectors <code class="reqn">u</code> are
correlated in time and also their components may be
correlated. In both cases components of vectors <code class="reqn">u</code>
follow marginally a standard uniform distribution. A moody ring
method of Brooks et al. (2003) is used to generate <code class="reqn">u</code> vectors.
</p>
</dd>
<dt>moody.ring</dt>
<dd>
<p>parameters for the moody ring when
<code>algorithm</code> is either "independent.av" or
"correlated.av". This is a two component vector with both
components taking values between 0 and 0.5 defining the strength
of a correlation in time and between the components of
<code class="reqn">u</code> vectors. This vector is ignored when <code>algorithm
	  = "basic"</code>. The first component of this vector determines
dependence between <code class="reqn">u</code> vectors in time
(<code class="reqn">\varepsilon</code> in Brooks et al. (2003)), the second
component determines dependence between components of <code class="reqn">u</code>
vectors (<code class="reqn">\delta</code> in Brooks et al. (2003)). The
second compoenent is ignored when <code>algorithm = "independent.av"</code>.
Note that both <code class="reqn">\varepsilon</code> and
<code class="reqn">\delta</code> do not have a meaning of correlation. They
determine a range of additional uniform distributions. So that
their values equal to <code class="reqn">0</code> mean perfect correlation and
their values equal to <code class="reqn">0.5</code> mean
independence. I.e. "correlated.av" with <code class="reqn">\delta = 0.5</code> is same as "independent.av" and "correlated.av" with
<code class="reqn">\delta = 0.5, \varepsilon = 0.5</code> is same as "basic".</p>
</dd>
<dt>transform.split.combine</dt>
<dd>
<p>a description of how the canonical
variables <code class="reqn">u</code> are to be transformed to give new values of
mixture component's weight, mean and variance when a split move
is proposed. Possible values are substrings of
"richardson.green", "brooks" and "identity". In all cases, the
<code class="reqn">(0, 1)</code> canonical variables <code class="reqn">u</code> are transformed 
to <code class="reqn">(0, 1)</code> variates <code class="reqn">v</code> that are than used
to compute new values of mixture component's weight, mean and
variance using a method of moments matching described in
Richardson and Green (1997). When "identity", no further
transformation is performed, when "richardson.green", <code class="reqn">u</code>
vectors are transformed such that the components of resulting <code class="reqn">v</code>
vectors follow independently beta distributions with parameters
given further by <code>p = prop.revjump$transform.split.combine.parms</code>
such that in the triplet of v's used in a particular split move,
<code class="reqn">v_1 \sim beta(p_1, p_2), v_2 \sim beta(p_3, p_4), v_3 \sim beta(p_5, p_6)</code>.
When "brooks" <code class="reqn">v_2</code> is further transformed by
<code class="reqn">|2v_2 - 1|</code>. Default values of
</p>

<table><tr>
<td style="text-align: center;">
	<code>prop.revjump$transform.split.combine$parms</code> 
	</td>
</tr></table>
<p>is <code>c(2, 2, 2, 2, 1, 1)</code>.</p>
</dd>
<dt>transform.split.combine.parms</dt>
<dd>
<p>see above.</p>
</dd>
<dt>transform.birth.death</dt>
<dd>
<p>a description of how the canonical
variables <code class="reqn">u</code> are to be transformed to give new values of
mixture component's weight, mean and variance when a birth move
is proposed. At this moment only one value is possible:
"richardson.green" implementing the proposal as in Richardson
and Green (1997).</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>a list of the initial values to start the McMC. Set to
<code>NULL</code> such parameters that you want the program should itself sample
for you or parameters that are not needed in your model.
</p>

<dl>
<dt>iter</dt>
<dd>
<p>index of the iteration to which initial values
correspond, usually zero.</p>
</dd>
<dt>mixture</dt>
<dd>
<p>initial mixture for the error random variable
<code class="reqn">\varepsilon</code>. It must a vector of length <code>1 +
        3*kmax</code>, where <code>mixture[1]</code> gives initial number of mixture
of components <code class="reqn">k</code>,
<code>mixture[2:(k+1)]</code> gives initial mixture weights,
<code>mixture[(2+kmax):(2+kmax+k-1)]</code> gives initial mixture means, 
<code>mixture[(2+2*kmax):(2+2*kmax+k-1)]</code> gives initial mixture
variances. Remaining components of this vector are ignored.</p>
</dd>
<dt>beta</dt>
<dd>
<p>initial values of regression parameters in the same
order as columns of the design matrix <code>X</code>. Call the
function <code>bayessurvreg1</code> with <code>onlyX = TRUE</code> to see
how the columns are sorted. Remember, <code>beta</code> in this
function contains both fixed effects <code class="reqn">\beta</code> and
means of random effect <code class="reqn">\gamma</code> in the notation of
the accompanying paper except the mean of
the random intercept which is always zero.</p>
</dd>
<dt>b</dt>
<dd>
<p>initial values of random effects <code class="reqn">b_i</code> for each
cluster. This must a matrix of size <code class="reqn">q \times N</code> or a
vector of length <code class="reqn">q*N</code>,
where <code class="reqn">q</code> is a number of random effects and <code class="reqn">N</code>
number of clusters, one column per cluster.</p>
</dd>
<dt>D</dt>
<dd>
<p>initial value for the covariance matrix of random effects
<code class="reqn">D</code>. Only its lower triangle must be given in a
vector, e.g. <code>c(d[1,1], d[2,1], d[3,1], d[2,2], d[3,2],
          d[3,3])</code> for a matrix <code class="reqn">3 \times 3</code>.</p>
</dd>
<dt>y</dt>
<dd>
<p>initial values of true log-event times. This must be a
vector of length <code class="reqn">\sum_{i=1}^N n_i</code>.</p>
</dd>
<dt>r</dt>
<dd>
<p>initial values of component labels
<code class="reqn">r_{i,l}</code>. This must be a vector of length
<code class="reqn">\sum_{i=1}^N n_i</code>.</p>
</dd>
<dt>otherp</dt>
<dd>
<p>initial values for other parameters. At this moment,
only a value of the parameter <code class="reqn">\eta</code> is given here.</p>
</dd>
<dt>u</dt>
<dd>
<p>initial canonical proposal vector of length
<code class="reqn">3k_{max}</code>. When initial number of compoents
given by <code>init$mixture[1]</code> is <code class="reqn">k</code>, effectively only
last <code class="reqn">3k_{max} - 3*k</code> components of the
initial <code class="reqn">u</code> vector are used. Further, when
<code>prop.revjump$algorithm = "correlated.av"</code>, the first
component of <code>init$u</code> (<code>init$u[1]</code>) contains an
initial mood parameter (<code class="reqn">C_0</code> in Brooks et al. (2003))
for the moody ring.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store</code></td>
<td>
<p>a list that defines which sampled values besides
regression parameters <code class="reqn">\beta</code>, means of random effects
<code class="reqn">\gamma</code> (both stored in a file called <code>beta.sim</code>),
a covariance matrix of random effects <code class="reqn">D</code> (stored
in a file <code>D.sim</code>),
the mixture (stored in file <code>mixmoment.sim, mweight.sim,
      mmean.sim, mvariance.sim</code>),
values of other parameters - <code class="reqn">\eta</code> (stored in a file <code>otherp.sim</code>),
values of log-likelihoods (stored in a file <code>loglik.sim</code>),
information concerning the performance of the reversible jump McMC
and acceptance of regression parameters (stored in a file <code>MHinfo.sim</code>),
iteration indeces (stored in a file <code>iteration.sim</code>)
are to be stored. The list <code>store</code> has the following
components.
</p>

<dl>
<dt>y</dt>
<dd>
<p>if <code>TRUE</code> sampled true log-event times are  stored.</p>
</dd>
<dt>r</dt>
<dd>
<p>if <code>TRUE</code> sampled component labels are stored.</p>
</dd>
<dt>b</dt>
<dd>
<p>if <code>TRUE</code> sampled values of random effects
<code class="reqn">b_i</code> are stored.</p>
</dd>
<dt>u</dt>
<dd>
<p>if <code>TRUE</code> sampled values of canonical proposal
vectors for the reversible jump McMC are stored.</p>
</dd>
<dt>MHb</dt>
<dd>
<p>if <code>TRUE</code> information concerning the performance
of the Metropolis-Hastings algorithm for the update of random
effects (if used instead of a dafault Gibbs) is stored.</p>
</dd>
<dt>regresres</dt>
<dd>
<p>if <code>TRUE</code> sampled values of regression
residuals at each iteration are stored. The regression residual
is defined as <code class="reqn">res_{i,l} = \log(t_{i,l}) - \beta^T x_{i,l} -
	b_i^T z_{i,l}</code>.</p>
</dd>
</dl>
<p>In the case that either <code>store$y</code>, or <code>store$r</code>, or
<code>store$b</code>, or <code>store$u</code> are <code>FALSE</code>, only the last
values of either <code>y</code>, or <code>r</code>, or <code>b</code>, or <code>u</code>
at the time of writting of remaining quantities are stored in
appropriate files (without headers) to be possibly used by
<code>bayessurvreg1.files2init</code> function.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dir</code></td>
<td>
<p>a string that specifies a directory where all sampled
values are to be stored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>toler.chol</code></td>
<td>
<p>tolerance for the Cholesky decomposition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>toler.qr</code></td>
<td>
<p>tolerance for the QR decomposition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>who knows?</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list of class <code>bayessurvreg</code> containing an information
concerning the initial values and prior choices.
</p>


<h3>Files created</h3>

  
<p>Additionally, the following files with sampled values
are stored in a directory specified by <code>dir</code> parameter of this
function (some of them are created only on request, see <code>store</code>
parameter of this function).
</p>

<dl>
<dt>iteration.sim</dt>
<dd>
<p>one column labeled <code>iteration</code> with
indeces of McMC iterations to which the stored sampled values correspond.</p>
</dd>
<dt>loglik.sim</dt>
<dd>
<p>two columns labeled <code>loglik</code> and
<code>randomloglik</code>.
</p>
<p style="text-align: center;"><code class="reqn">\mbox{\code{loglik}} = \sum_{i=1}^{N}\sum_{l=1}^{n_i}\Biggl[
	\biggl\{
        \log\Bigl(\frac{1}{\sqrt{2\pi\sigma_{r_{i,l}}^2}}\Bigr)
	-\frac{(y_{i,l} - \beta^T x_{i,l} - b_i^T z_{i,l} - \mu_{r_{i,l}})^2}{2\sigma_{r_{i,l}}^2}
	\biggr\}
	\Biggr],</code>
</p>

<p>where
<code class="reqn">y_{i,l}</code> denotes (sampled) <em>(i,l)</em>th true
log-event time,
<code class="reqn">b_i</code> sampled value of the random effect vector for the
<em>i</em>th cluster,
<code class="reqn">\beta</code> sampled value of the regression parameter
<code class="reqn">\beta</code> and
<code class="reqn">k, w_j, \mu_j, \sigma_j^2, j = 1,\dots,k</code> sampled mixture at each iteration.
</p>
<p style="text-align: center;"><code class="reqn">\mbox{\code{randomloglik}} =
	\sum_{i=1}^{N}\log\Bigl(g(b_i)\Bigr),</code>
</p>

<p>where <code class="reqn">g</code> denotes a density of
(multivariate) normal distribution
<code class="reqn">N(\gamma, D),</code> where
<code class="reqn">\gamma</code> is a sampled value of the mean of random
effect vector and <code class="reqn">D</code> is a sampled value of the covariance
matrix of the random effects at each iteration.      
</p>
</dd>
<dt>mixmoment.sim</dt>
<dd>
<p>three columns labeled <code>k</code>, <code>Intercept</code> and
<code>Scale</code>. These are the number of mixture components, mean and
standard deviation of the sampled error distribution (mixture) at
each iteration.</p>
</dd>
<dt>mweight.sim</dt>
<dd>
<p>each row contains mixture weights
<code class="reqn">w_1,\dots,w_k</code>
at each iteration. From the header of this file, maximal number of mixture
components specified in the prior can be derived.</p>
</dd>
<dt>mmean.sim</dt>
<dd>
<p>each row contains mixture means
<code class="reqn">\mu_1,\dots,\mu_k</code>
at each iteration. From the header of this file, maximal number of mixture
components specified in the prior can be derived.</p>
</dd>
<dt>mvariance.sim</dt>
<dd>
<p>each row contains mixture variances
<code class="reqn">\sigma^2_1,\dots,\sigma^2_k</code> at each
iteration. From the header of this file, maximal number of mixture
components specified in the prior can be derived.</p>
</dd>    
<dt>beta.sim</dt>
<dd>
<p>columns labeled according to name of the design
matrix. These are sampled values of regression parameters
<code class="reqn">\beta</code> and means of random effects <code class="reqn">\gamma</code>
(except the mean of the random intercept which is zero).</p>
</dd>
<dt>b.sim</dt>
<dd>
<p>columns labeled <code>nameb[1].id[1], ...,
	nameb[q].id[1], ..., nameb[1].id[N], ..., nameb[q].id[N]</code>,
where <code>q</code> is a dimension of the random effect vector
<code class="reqn">b_i</code> and <code>N</code> number of clusters. <code>nameb</code>
is replaced by appropriate column name from the design matrix and
<code>id</code> is replaced by identificator of the clusters. This gives
sampled values of the random effects for each cluster.</p>
</dd>
<dt>D.sim</dt>
<dd>
<p>columns labeled <code>det, D.s.t, s = 1,..., q, t =
	s,...,q</code>, where <code>q</code> is dimension of the random effect
vector <code class="reqn">b_i</code>. Column <code>det</code> gives a determinant of
the covariance matrix <code class="reqn">D</code> of the random effects at each
iteration, remaining columns give a lower triangle of this matrix
at each iteration.</p>
</dd>
<dt>Y.sim</dt>
<dd>
<p>columns labeled <code>Y[m]</code> where <code>m</code> goes from 1
to <code class="reqn">\sum_{i=1}^{N}n_i</code>. This gives sampled
log-event times for each observation in the dataset at each
iteration.</p>
</dd>
<dt>r.sim</dt>
<dd>
<p>columns labeled <code>r[m]</code> where <code>m</code> goes from 1
to <code class="reqn">\sum_{i=1}^{N}n_i</code>. This gives sampled
mixture labels for each observation in the dataset at each iteration.</p>
</dd>
<dt>otherp.sim</dt>
<dd>
<p>Currently only one column labeled <code>eta</code> that
gives sampled values of the hyperparameter <code class="reqn">\eta</code>.</p>
</dd>
<dt>MHinfo.sim</dt>
<dd>
<p>this gives the information concerning the
performance of reversible jump algorithm and a sampler of
regression parameters <code class="reqn">\beta</code> and means of random
effects <code class="reqn">\gamma</code>. It has columns
</p>

<dl>
<dt><code>accept.spl.comb</code></dt>
<dd>
<p>relative frequency of accepted
split-combine moves up to that iteration.</p>
</dd>
<dt><code>split</code></dt>
<dd>
<p>relative frequency of proposed split moves
up to that iteration.</p>
</dd>
<dt><code>accept.birth.death</code></dt>
<dd>
<p>relative frequency of accepted
birth-death moves up to that iteration.</p>
</dd>
<dt><code>birth</code></dt>
<dd>
<p>relative frequency of proposed birth moves
up to that iteration.</p>
</dd>
<dt><code>beta.block.m</code></dt>
<dd>
<p>with <code>m</code> going from 1 to number
of defined blocks of beta parameters. This gives a relative
frequency of accepted proposals for each block up to that
iteration. When Gibbs move is used, these should be columns of
ones.</p>
</dd>
</dl>
</dd>
<dt>MHbinfo.sim</dt>
<dd>
<p>this gives the information concerning the
performance of a sampler for random effects (relative frequency of
accepted values for each cluster and each block of random effects
updated together). When Gibbs move is used only ones are seen in
this file.</p>
</dd>
<dt>u.sim</dt>
<dd>
<p>Sampled values of canonical proposal variables for
reversible jump algorithm are stored here. This file is useful
only when trying to restart the simulation from some specific point.</p>
</dd>
<dt>regresres.sim</dt>
<dd>
<p>columns labeled <code>res[m]</code> where <code>m</code> goes from 1
to <code class="reqn">\sum_{i=1}^{N}n_i</code> This stores so called
regression residuals for each observation at each iteration. This
residual is defined as
</p>
<p style="text-align: center;"><code class="reqn">res_{i,l} = y_{i,l} - \beta^T x_{i,l} - b_i z_{i,l},\qquad
	i=1\dots,N,\quad l=1,\dots,n_i,</code>
</p>
<p> where <code class="reqn">y_{i,l}</code> is a (sampled)
log-event time at each iteration.
</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Komárek, A. (2006).
<em>Accelerated Failure Time Models for Multivariate
Interval-Censored Data with Flexible Distributional Assumptions</em>.
PhD. Thesis, Katholieke Universiteit Leuven, Faculteit Wetenschappen.
</p>
<p>Komárek, A. and Lesaffre, E. (2007).
Bayesian accelerated failure time model for correlated interval-censored data
with a normal mixture as an error distribution.
<em>Statistica Sinica</em>, <b>17</b>, 549 - 569.
</p>
<p>Brooks, S. P., Giudici, P., and Roberts, G. O. (2003).
Efficient construction of reversible jump Markov chain Monte Carlo
proposal distribution (with Discussion).
<em>Journal of the Royal Statistical Society B,</em> <b>65,</b> 3 - 55.
</p>
<p>Green, P. J. (1995).
Reversible jump MCMC computation and Bayesian model determination.
<em>Biometrika,</em> <b>82,</b> 711 - 732.
</p>
<p>Richardson, S., and Green, P. J. (1997).
On Bayesian analysis of mixtures with unknown number of components (with
Discussion).
<em>Journal of the Royal Statistical Society B,</em> <b>59,</b> 731 - 792.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## See the description of R commands for
## the models described in
## Komarek (2006),
## Komarek and Lesaffre (2007).
## 
## R commands available
## in the documentation
## directory of this package as
## - ex-cgd.R and
##   https://www2.karlin.mff.cuni.cz/~komarek/software/bayesSurv/ex-cgd.pdf
##
## - ex-tandmobMixture.R and
##   https://www2.karlin.mff.cuni.cz/~komarek/software/bayesSurv/ex-tandmobMixture.pdf
##
</code></pre>


</div>