<div class="container">

<table style="width: 100%;"><tr>
<td>dea.direct</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Directional efficiency </h2>

<h3>Description</h3>

<p> Directional efficiency rescaled to an interpretation a la
Farrell efficiency and the corresponding peer importance
(lambda). </p>


<h3>Usage</h3>

<pre><code class="language-R">dea.direct(X, Y, DIRECT, RTS = "vrs", ORIENTATION = "in", 
          XREF = NULL, YREF = NULL, FRONT.IDX = NULL, 
          SLACK = FALSE, param=NULL, TRANSPOSE = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Inputs of firms to be evaluated, a K x m matrix of
observations of K firms with m inputs (firm x input) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>Outputs of firms to be evaluated, a K x n matrix of
observations of K firms with n outputs (firm x input). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DIRECT</code></td>
<td>
<p> Directional efficiency, <code>DIRECT</code> is either a
scalar, an array, or a matrix with non-negative elements.
</p>
<p>If the argument is a scalar, the direction is (1,1,...,1) times
the scalar; the value of the efficiency depends on the scalar as
well as on the unit of measurements.
</p>
<p>If the argument an array, this is used for the direction for
every firm; the length of the array must correspond to the
number of inputs and/or outputs depending on the
<code>ORIENTATION</code>.
</p>
<p>If the argument is a matrix then different directions are used
for each firm. The dimensions depends on the <code>ORIENTATION</code>
(and <code>TRANSPOSE</code>), the number of firms must correspond to
the number of firms in <code>X</code> and <code>Y</code>.
</p>
<p><code>DIRECT</code> must not be used in connection with
<code>DIRECTION="graph"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RTS</code></td>
<td>
<p>Text string or a number defining the underlying DEA
technology / returns to scale assumption.
</p>

<table>
<tr>
<td style="text-align: right;">
0 </td>
<td style="text-align: left;"> fdh </td>
<td style="text-align: left;"> Free disposability hull, no convexity assumption </td>
</tr>
<tr>
<td style="text-align: right;">
1 </td>
<td style="text-align: left;"> vrs </td>
<td style="text-align: left;"> Variable returns to scale, convexity and free disposability </td>
</tr>
<tr>
<td style="text-align: right;">
2 </td>
<td style="text-align: left;"> drs </td>
<td style="text-align: left;"> Decreasing returns to scale (down-scaling, but not up-scaling), convexity, and free disposability </td>
</tr>
<tr>
<td style="text-align: right;">
3 </td>
<td style="text-align: left;"> crs </td>
<td style="text-align: left;"> Constant returns to scale, convexity and free disposability </td>
</tr>
<tr>
<td style="text-align: right;">
4 </td>
<td style="text-align: left;"> irs </td>
<td style="text-align: left;"> Increasing returns to scale (up-scaling, but not down-scaling), convexity, and free disposability </td>
</tr>
<tr>
<td style="text-align: right;">
6 </td>
<td style="text-align: left;"> add </td>
<td style="text-align: left;"> Additivity (scaling up and down, but only with integers), and free disposability</td>
</tr>
<tr>
<td style="text-align: right;">
7 </td>
<td style="text-align: left;"> fdh+ </td>
<td style="text-align: left;"> A combination of free disposability and restricted
 or local constant return to scale
</td>
</tr>
</table>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ORIENTATION</code></td>
<td>
<p>Input efficiency "in" (1), output
efficiency "out" (2), and graph efficiency "graph" (3). For use
with <code>DIRECT</code>, an additional option is "in-out" (0). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>XREF</code></td>
<td>
<p>Inputs of the firms determining the technology, defaults
to <code>X</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>YREF</code></td>
<td>
<p>Outputs of the firms determining the technology,
defaults to <code>Y</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FRONT.IDX</code></td>
<td>
<p>Index for firms determining the technology. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SLACK</code></td>
<td>
<p>See <code>dea</code> and <code>slack</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param</code></td>
<td>
<p>Possible parameters. At the moment only used for
RTS="fdh+" to set low and high values for restrictions on lambda;
see the section details and examples in <code>dea</code> for its
use. Future versions might also use <code>param</code> for other
purposes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>TRANSPOSE</code></td>
<td>
<p> see <code>dea</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>When the argument <code>DIRECT=d</code> is used then component
<code>objval</code> of the returned object for input orientation is the
maximum value of e where for input orientation <code class="reqn">x-e d</code>, and for
output orientation <code class="reqn">y+e d</code> are in the generated technology
set. The returned component <code>eff</code> is for input <code class="reqn">1-e d/X</code>
and for output <code class="reqn">1+e d /Y</code> to make the interpretation as for a
Farrell efficiency.  Note that when the direction is not
proportional to <code>X</code> or <code>Y</code> the returned <code>eff</code> are
different for different inputs or outputs and <code>eff</code> is a matrix
and not just an array.  The directional efficiency can be restricted
to inputs (<code>ORIENTATION="in"</code>), restricted to outputs
(<code>ORIENTATION="out"</code>), or both include inputs and output
directions (<code>ORIENTATION="in-out"</code>). Directional efficiency is
discussed on pages 31–35 and 121–127 in Bogetoft and Otto (2011).
</p>
<p>The Farrell efficiency interpretation is the ratio by which a firm
can proportionally reduce all inputs (or expand all outputs) without
producing less outputs (using more inputs). The directional
efficiencies have the same interpretation expect that the direction is
not proportional to the inputs (or outputs) and therefore the
different inputs may have different reduction ratios, the
efficiency is an array and not just a number.
</p>


<h3>Value</h3>

<p>The results are returned in a Farrell object with the following
components.  The method <code>slack</code> only returns the three
components in the list relevant for slacks.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>eff</code></td>
<td>
<p>The Farrell efficiencies.  Note that the efficiencies
are calculated to have the same interpretations as Farrell
efficiencies. <code>eff</code> is a matrix if there are more than 1
good.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The lambdas, i.e. the weight of the peers, for each firm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>objval</code></td>
<td>
<p>The objective value as returned from the LP program; the
<code>objval</code> are excess values in DIRECT units of measurement.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RTS</code></td>
<td>
<p>The return to scale assumption as in the option <code>RTS</code>
in the call</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ORIENTATION</code></td>
<td>
<p>The efficiency orientation as in the call</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>TRANSPOSE</code></td>
<td>
<p>As in the call</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>slack</code></td>
<td>
<p>A vector with sums of the slacks for each firm. Only
calculated in dea when option <code>SLACK=TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sx</code></td>
<td>
<p>A matrix for input slacks for each firm, only calculated if
the option <code>SLACK</code> is <code>TRUE</code> or returned from the
method <code>slack</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sy</code></td>
<td>
<p>A matrix for output slack, see <code>sx</code></p>
</td>
</tr>
</table>
<h3>Note</h3>

<p> To handle fixed, non-discretionary inputs, one can let it
appear as negative output in an input-based mode, and reversely for
fixed, non-discretionary outputs. Fixed inputs (outputs) can also be
handled by directional efficiency; set the direction, the argument
<code>DIRECT</code>, equal to the variable, discretionary inputs (outputs)
and 0 for the fixed inputs (outputs).
</p>
<p>When the argument <code>DIRECT=X</code> is used the then the returned
efficiency is equal to 1 minus the Farrell efficiency for input
orientation and equal to the Farrell efficiency minus 1 for output
orientation.
</p>


<h3>Author(s)</h3>

<p> Peter Bogetoft and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a> </p>


<h3>References</h3>

<p> Directional efficiency is discussed on pages 31–35 and
121–127 in Bogetoft and Otto (2011).
</p>
<p>Peter Bogetoft and Lars Otto; <em>Benchmarking with DEA, SFA, and
R</em>; Springer 2011 </p>


<h3>See Also</h3>

<p><code>dea</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Directional efficiency
x &lt;- matrix(c(2,5 , 1,2 , 2,2 , 3,2 , 3,1 , 4,1), ncol=2,byrow=TRUE)
y &lt;- matrix(1,nrow=dim(x)[1])
dea.plot.isoquant(x[,1], x[,2],txt=1:dim(x)[1])

E &lt;- dea(x,y)
z &lt;- c(1,1)
e &lt;- dea.direct(x,y,DIRECT=z)
data.frame(Farrell=E$eff, Perform=e$eff, objval=e$objval)
# The direction
arrows(x[,1], x[,2], (x-z)[,1], (x-z)[,2], lty="dashed")
# The efficiency (e$objval) along the direction
segments(x[,1], x[,2], (x-e$objval*z)[,1], (x-e$objval*z)[,2], lwd=2)



# Different directions
x1 &lt;- c(.5, 1, 2, 4, 3, 1)
x2 &lt;- c(4,  2, 1,.5, 2, 4)
x &lt;- cbind(x1,x2)
y &lt;- matrix(1,nrow=dim(x)[1])
dir1 &lt;- c(1,.25)
dir2 &lt;- c(.25, 4)
dir3 &lt;- c(1,4)
e &lt;- dea(x,y)
e1 &lt;- dea.direct(x,y,DIRECT=dir1)
e2 &lt;- dea.direct(x,y,DIRECT=dir2)
e3 &lt;- dea.direct(x,y,DIRECT=dir3)
data.frame(e=eff(e),e1=e1$eff,e2=e2$eff,e3=e3$eff)[6,]

# Technology and directions for all firms
dea.plot.isoquant(x[,1], x[,2],txt=1:dim(x)[1])
arrows(x[,1], x[,2],  x[,1]-dir1[1], x[,2]-dir1[2],lty="dashed")
segments(x[,1], x[,2],  
    x[,1]-e1$objval*dir1[1], x[,2]-e1$objval*dir1[2],lwd=2)
# slack for direction 1
dsl1 &lt;- slack(x,y,e1)
cbind(E=e$eff,e1$eff,dsl1$sx,dsl1$sy, sum=dsl1$sum)



# Technology and directions for firm 6, 
# Figure 2.6 page 32 in Bogetoft &amp; Otto (2011)
dea.plot.isoquant(x1,x2,lwd=1.5, txt=TRUE)
arrows(x[6,1], x[6,2],  x[6,1]-dir1[1], x[6,2]-dir1[2],lty="dashed")
arrows(x[6,1], x[6,2],  x[6,1]-dir2[1], x[6,2]-dir2[2],lty="dashed")
arrows(x[6,1], x[6,2],  x[6,1]-dir3[1], x[6,2]-dir3[2],lty="dashed")
segments(x[6,1], x[6,2],  
    x[6,1]-e1$objval[6]*dir1[1], x[6,2]-e1$objval[6]*dir1[2],lwd=2)
segments(x[6,1], x[6,2],  
    x[6,1]-e2$objval[6]*dir2[1], x[6,2]-e2$objval[6]*dir2[2],lwd=2)
segments(x[6,1], x[6,2],  
    x[6,1]-e3$objval[6]*dir3[1], x[6,2]-e3$objval[6]*dir3[2],lwd=2)
</code></pre>


</div>