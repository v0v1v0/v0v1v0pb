<div class="container">

<table style="width: 100%;"><tr>
<td>gnm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Gaussian Network Model</h2>

<h3>Description</h3>

<p>Perform Gaussian network model (GNM) based normal mode analysis (NMA) for 
a protein structure.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gnm(x, ...)

## S3 method for class 'pdb'
gnm(x, inds = NULL, temp = 300, keep = NULL,
  outmodes = NULL, gamma = 1, cutoff = 8, check.connect = TRUE, ...)

## S3 method for class 'pdbs'
gnm(x, fit = TRUE, full = FALSE, subspace = NULL,
  rm.gaps = TRUE, gc.first = TRUE, ncore = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object of class <code>pdb</code> as obtained from function <code>read.pdb</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>(in <code>gnm.pdbs</code>) additional arguments passed to <code>gnm.pdb</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inds</code></td>
<td>
<p>atom and xyz coordinate indices obtained from <code>atom.select</code> that 
selects the elements of <code>pdb</code> upon which the calculation should be based. 
If not provided the function will attempt to select all calpha atoms automatically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>temp</code></td>
<td>
<p>numerical, temperature for which the amplitudes for scaling the atomic 
displacement vectors are calculated. Set ‘temp=NULL’ to avoid scaling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep</code></td>
<td>
<p>numerical, final number of modes to be stored. Note that all subsequent analyses 
are limited to this subset of modes. This option is useful for very large structures and 
cases where memory may be limited.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outmodes</code></td>
<td>
<p>atom indices as obtained from <code>atom.select</code> specifying the atoms 
to include in the resulting mode object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>numerical, global scale of the force constant.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff</code></td>
<td>
<p>numerical, distance cutoff for pair-wise interactions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check.connect</code></td>
<td>
<p>logical, if TRUE check chain connectivity.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>logical, if TRUE C-alpha coordinate based superposition is 
performed prior to normal mode calculations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>full</code></td>
<td>
<p>logical, if TRUE return the complete, full structure,
‘nma’ objects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subspace</code></td>
<td>
<p>number of eigenvectors to store for further analysis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rm.gaps</code></td>
<td>
<p>logical, if TRUE obtain the hessian matrices for only
atoms in the aligned positions (non-gap positions in all aligned
structures). Thus, gap positions are removed from output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gc.first</code></td>
<td>
<p>logical, if TRUE will call gc() first before mode calculation
for each structure. This is to avoid memory overload when 
<code>ncore &gt; 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncore</code></td>
<td>
<p>number of CPU cores used to do the calculation.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function builds a Gaussian network model (an isotropic elastic network 
model) for C-alpha atoms and performs subsequent normal mode analysis (NMA). 
The model employs a distance cutoff for the network construction: Atom pairs with 
distance falling  within the cutoff have a harmonic interaction with a uniform force constant; 
Otherwise atoms have no interaction. Output contains N-1 (N, the number of residues) 
non-trivial modes (i.e. the degree of freedom is N-1), which can then be used to 
calculate atomic fluctuations and covariance.
</p>


<h3>Value</h3>

<p>Returns an object of class ‘gnm’ with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>force.constants</code></td>
<td>
<p> numeric vector containing the force constants corresponding 
to each mode. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fluctuations</code></td>
<td>
<p> numeric vector of atomic fluctuations. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>U</code></td>
<td>
<p> numeric matrix with columns containing the raw eigenvectors. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p> numeric vector containing the raw eigenvalues. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xyz</code></td>
<td>
<p> numeric matrix of class <code>xyz</code> containing the Cartesian coordinates 
in which the calculation was performed. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>temp</code></td>
<td>
<p> numerical, temperature for which the amplitudes for scaling the atomic 
displacement vectors are calculated. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>triv.modes</code></td>
<td>
<p> number of trivial modes. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>natoms</code></td>
<td>
<p> number of C-alpha atoms. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p> the matched call. </p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Xin-Qiu Yao &amp; Lars Skjaerven
</p>


<h3>References</h3>

<p>Bahar, I. et al. (1997) <em>Folding Des.</em> <b>2</b>, 173.
</p>


<h3>See Also</h3>

<p><code>gnm.pdbs</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">   ## Fetch stucture
   pdb &lt;- read.pdb( system.file("examples/1hel.pdb", package="bio3d") )
   
   ## Calculate normal modes
   modes &lt;- gnm(pdb)
   
   ## Print modes
   print(modes)
   
   ## Plot modes
   plot(modes)

</code></pre>


</div>