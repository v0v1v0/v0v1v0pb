<div class="container">

<table style="width: 100%;"><tr>
<td>plot.dynamic.distribution</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Plots the pointwise evolution of a distribution over an index set.
</h2>

<h3>Description</h3>

<p> Produces an dynamic distribution plot where gray scale
shading is used to show the evolution of a distribution over an index
set.  This function is particularly useful when the index set is too
large to do side-by-side boxplots.  </p>


<h3>Usage</h3>

<pre><code class="language-R">PlotDynamicDistribution(curves,
                        timestamps = NULL,
                        quantile.step=.01,
                        xlim = NULL,
                        xlab = "Time",
                        ylim = range(curves, na.rm = TRUE),
                        ylab = "distribution",
                        add = FALSE,
                        axes = TRUE,
                        ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>curves</code></td>
<td>
<p> A matrix where each row represents a curve (e.g. a
simulation of a time series from a posterior distribution) and
columns represent different points in the index set.  For example, a
long time series would be a wide matrix.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timestamps</code></td>
<td>
<p> An optional vector of "time stamps" that
<code>curves</code> will be plotted against.  The length of
<code>timestamps</code> must match the number of columns in <code>curves</code>.
If <code>timestamps</code> is <code>NULL</code> then the function attempts to
extract time stamps from the <code>colnames(curves)</code>.  If no
appropriate time stamps can be found then the positive integers will
be used as time stamps.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quantile.step</code></td>
<td>
<p>Each color step in the plot corresponds to this
difference in quantiles.  Smaller values make prettier plots, but
the plots take longer to produce.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlim</code></td>
<td>
<p>The x limits (x1, x2) of the plot.  Note that <code> x1 &gt;
    x2 </code> is allowed and leads to a "reversed axis".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlab</code></td>
<td>
<p>Label for the horzontal axis. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylim</code></td>
<td>
<p>The y limits (y1, y2) of the plot.  Note that <code> y1 &gt;
    y2 </code> is allowed and leads to a "reversed axis".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylab</code></td>
<td>
<p>Label for the vertical axis. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add</code></td>
<td>
<p>Logical.  If true then add the plot to the current plot.
Otherwise a fresh plot will be created.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>axes</code></td>
<td>
<p>Logical.  Should axes be added to the plot?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Extra arguments to pass on to <code>plot</code> </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p> The function works by passing many calls to
<code>polygon</code>.  Each polygon is associated with a quantile
level, with darker shading near the median. </p>


<h3>Value</h3>

<p> This function is called for its side effect, which is to produce
a plot on the current graphics device.  </p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  x &lt;- t(matrix(rnorm(1000 * 100, 1:100, 1:100), nrow=100))
  ## x has 1000 rows, and 100 columns.  Column i is N(i, i^2) noise.

  PlotDynamicDistribution(x)
  time &lt;- as.Date("2010-01-01", format = "%Y-%m-%d") + (0:99 - 50)*7
  PlotDynamicDistribution(x, time)
</code></pre>


</div>