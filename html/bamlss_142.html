<div class="container">

<table style="width: 100%;"><tr>
<td>jm_bamlss</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Fit Flexible Additive Joint Models
</h2>

<h3>Description</h3>

<p>Family object to fit a flexible additive joint model for longitudinal and survival
data under a Bayesian approach as presented in Koehler et al. (2017a, b). 
All parts of the joint model can be specified as structured additive predictors. 
See the details and examples.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## JM family object.
jm_bamlss(...)

## "bamlss.frame" transformer function
## to set up joint models.
jm_transform(x, y, data, terms, knots, formula, family, subdivisions = 25,
  timedependent = c("lambda", "mu", "alpha", "dalpha"), timevar = NULL, 
  idvar = NULL, alpha = .Machine$double.eps, mu = NULL, sigma = NULL, 
  sparse = TRUE, nonlinear = FALSE, edf_alt = FALSE, start_mu = NULL, 
  k_mu = 6, ...)
                    
## Posterior mode optimizing engine.     
opt_JM(x, y, start = NULL, weights = NULL, offset = NULL, 
  criterion = c("AICc", "BIC", "AIC"), maxit = c(100, 1), 
  nu = c("lambda" = 0.1, "gamma" = 0.1, "mu" = 1, "sigma" = 1,
    "alpha" = 1, "dalpha" = 1),
  update.nu = FALSE, eps = 0.0001, alpha.eps = 0.001, ic.eps = 1e-08, 
  nback = 40, verbose = TRUE, digits = 4, ...)

jm_mode(x, y, start = NULL, weights = NULL, offset = NULL, 
  criterion = c("AICc", "BIC", "AIC"), maxit = c(100, 1), 
  nu = c("lambda" = 0.1, "gamma" = 0.1, "mu" = 1, "sigma" = 1,
    "alpha" = 1, "dalpha" = 1),
  update.nu = FALSE, eps = 0.0001, alpha.eps = 0.001, ic.eps = 1e-08, 
  nback = 40, verbose = TRUE, digits = 4, ...)

## Sampler function.
sam_JM(x, y, family, start = NULL, weights = NULL, offset = NULL, 
  n.iter = 1200, burnin = 200, thin = 1, verbose = TRUE, digits = 4, 
  step = 20, ...)

jm_mcmc(x, y, family, start = NULL, weights = NULL, offset = NULL, 
  n.iter = 1200, burnin = 200, thin = 1, verbose = TRUE, digits = 4, 
  step = 20, ...)
  
## Predict function, set to default in jm_bamlss().
jm_predict(object, newdata,
  type = c("link", "parameter", "probabilities", "cumhaz", "loglik"),
  dt, steps, id, FUN = function(x) { mean(x, na.rm = TRUE) }, 
  subdivisions = 100, cores = NULL, chunks = 1,
  verbose = FALSE,  ...)
  
## Survival plot.
jm_survplot(object, id = 1, dt = NULL, steps = 10, 
  points = TRUE, rug = !points)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>The <code>x</code> list, as returned from function
<code>bamlss.frame</code> (and transformed by function <code>jm_transform()</code>),
holding all model matrices and other information that is used for
fitting the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>The model response, as returned from function <code>bamlss.frame</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A <code>data.frame</code> or <code>list</code> containing the model
response variable(s) and covariates specified in the <code>formula</code> in long format.
By default the variables are taken from <code>environment(formula)</code>:
typically the environment from which <code>bamlss</code> is called.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terms</code></td>
<td>
<p>The corresponding <code>terms.bamlss</code> object needed for processing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knots</code></td>
<td>
<p>An optional list containing user specified knots, see the documentation of
function <code>gam</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>The corresponding <code>bamlss.formula</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>The <code>bamlss.family</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subdivisions</code></td>
<td>
<p>How many time points should be created for each individual.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timedependent</code></td>
<td>
<p>A character vector specifying the names of parameters in <code>x</code>
that are time-dependent. Time grid design matrices are only computed for these parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timevar</code></td>
<td>
<p>A character specifying the name of the survival time variable in the
data set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>idvar</code></td>
<td>
<p>Depending on the type of data set, this is the name of the variable specifying
identifier of individuals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Numeric, a starting value for the intercept of the association parameter alpha.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>Numeric, a starting value for the intercept of the mu parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>Numeric, a starting value for the intercept of the sigma parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sparse</code></td>
<td>
<p>Logical, indicating if sparse matrix structures are used for updating and sampling
of mu parameter model terms.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nonlinear</code></td>
<td>
<p>Logical, indicating if association is nonlinear in mu. See Details on the different
model specifications.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edf_alt</code></td>
<td>
<p>Logical, indicating if an alternative computation of estimated degrees of freedom 
for penalized model terms should be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start_mu</code></td>
<td>
<p>Starting values for the computation of mu. For estimating associations which are 
nonlinear in mu, knot placement is based on these starting values which can improve stability. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k_mu</code></td>
<td>
<p>Number of knots for spline basis of association nonlinear in mu. Reducing this number
improves stability of the estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>A named numeric vector containing possible starting values, the names are based on
function <code>parameters</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Currently not supported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>Currently not supported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criterion</code></td>
<td>
<p>Information criterion to be used, e.g., for smoothing
variance selection. Options are the corrected AIC <code>"AICc"</code> (see Details), the <code>"BIC"</code> and
<code>"AIC"</code>. Defaults to <code>"AICc"</code>?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>Vector containing the maximum number of iterations for the backfitting
algorithm with <code>maxit[1]</code> defining the iterations for the full model and <code>maxit[2]</code>
the iterations within each predictor. <code>maxit[2]</code> defaults to 1 if only one value is
specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu</code></td>
<td>
<p>Vector of step lengths for parameter updates of one Newton-Raphson update for 
each predictor of the joint model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>update.nu</code></td>
<td>
<p>Should the updating step length be optimized in each iteration
of the backfitting algorithm? Uses <code>nu</code> as starting value if set to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>The relative convergence tolerance of the backfitting algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.eps</code></td>
<td>
<p>The relative convergence tolerance of the backfitting algorithm
for predictor alpha.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ic.eps</code></td>
<td>
<p>The relative convergence tolerance of the information criterion used, e.g.,
for smoothing variance selection.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nback</code></td>
<td>
<p>For computing <code>ic.eps</code>, how many iterations back should be included
when computing relative convergence tolerance of the information criterion.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Print information during runtime of the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>Set the digits for printing when <code>verbose = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.iter</code></td>
<td>
<p>the number of MCMC iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>the burn-in phase of the sampler, i.e., the number of starting samples that
should be removed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>the thinning parameter for MCMC simulation. E.g., <code>thin = 10</code> means,
that only every 10th sampled parameter will be stored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>step</code></td>
<td>
<p>How many times should algorithm runtime information be printed, divides <code>n.iter</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A <code>"bamlss"</code> object processed with the JM optimizer function
<code>opt_JM()</code> ans/or sampler function <code>sam_JM()</code> for which the survival plot
should be created.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>Dataset for which to create predictions. Not needed for conditional survival probabilities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Character string indicating which type of predictions to compute. <code>link</code> returns estimates
for all predictors with the respective link functions applied, <code>"parameter"</code> returns the estimates
for all pedictors, <code>"probabilities"</code> returns the survival probabilities conditional on the
survival up to the last longitudinal measurement, and <code>"cumhaz"</code> return the cumulative hazard
up to the survival time or for a time window after the last longitudinal measurement. If <code>type</code>
is set to <code>"loglik"</code>, the log-likelihood of the joint model is returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p>Integer or character, that specifies the individual for which the plot should be created.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dt</code></td>
<td>
<p>The time window after the last observed measurement for which predictions should be computed. 
The default is <code>0.4 * max(obstime)</code> and <code>obstime</code> are the individual's longitudinal measurement times.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>steps</code></td>
<td>
<p>Integer, the number of steps for which to evaluate the conditional survival probability 
up to <code>dt</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>
<p>A function that should be applied on the samples of predictors or
parameters, depending on argument <code>type</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>Specifies the number of cores that should be used for prediction. Note that
this functionality is based on the <code>parallel</code> package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chunks</code></td>
<td>
<p>Should computations be split into <code>chunks</code>? Prediction is then processed
sequentially.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>points</code></td>
<td>
<p>Should longitudinal observations be added to the plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rug</code></td>
<td>
<p>Should longitudinal observed time points be added on the x-axis to the plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Currently not used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>We refer to the papers of Koehler et al. (2017a, b) for details on the flexible
additive joint model. In short, we model the hazard of subject <code class="reqn">i</code> an event at time
<code class="reqn">t</code> as
</p>
<p style="text-align: center;"><code class="reqn">h_{i}(t)= \exp [\eta_{\lambda i}(t)+
\eta_{\gamma i}+\eta_{\alpha i}(\eta_{\mu i}(t), t) ]</code>
</p>

<p>with predictor <code class="reqn">\eta_{\lambda}</code> for all survival covariates that are time-varying or have a
time-varying coefficient (including the log baseline hazard), predictor <code class="reqn">\eta_{\gamma}</code> for
baseline survival covariates, predictor <code class="reqn">\eta_{\alpha}</code> representing the potentially
time-varying or nonlinear association between the longitudinal marker <code class="reqn">\eta_{\mu}</code> and the hazard. The
longitudinal response <code class="reqn">y_{ij}</code> at time points <code class="reqn">t_{ij}</code> is modeled as
</p>
<p style="text-align: center;"><code class="reqn">y_{ij}=\eta_{\mu i}(t_{ij})+e_{ij}</code>
</p>
<p> with independent normal errors <code class="reqn">N(0, \exp[\eta_{\sigma i}(t_{ij})]^2)</code>. 
</p>
<p>Each predictor <code class="reqn">\eta_{ki}</code> is a structured additive predictor, i.e. a sum of functions of
covariates <code class="reqn">\eta_{ki} =  \sum_{m=1}^{M_k} f_{km}(\bm{x}_{ki})</code>. Each of these functions can be
modeled parametrically or using basis function evaluations from the smooth constructors in
<span class="pkg">mgcv</span> such as <code>s</code>, <code>te</code> and <code>ti</code> and can
include smooth time-varying, random or spatial effects. For the Bayesian estimation of these effects
we specify corresponding priors: For linear or parametric terms we use vague normal priors, smooth
and random effect terms are regularized by placing generic multivariate normal priors on the
coefficients and for anisotropic smooths, when multiple smoothing variance parameters are involved,
more complex prior are in place (cf. Koehler et al., 2017a). We use inverse Gamma
hyper-priors, i.e. IG(0.001, 0.001) to obtain an inverse Gamma full conditional for the variance
parameters. We estimate the posterior mode by maximizing the log-posterior of the model using a
Newton-Raphson procedure, the posterior mean is obtained via derivative-based Metropolis-Hastings
sampling. We recommend to use posterior mode estimates for a quick model assessment. In order to
draw correct inferences from the model, posterior mean estimates should be computed. 
We approximate integration in the survival part of the likelihood using trapezoidal rule. For
posterior mode estimation.
</p>
<p>A variety specifications of the association <code class="reqn">\eta_{\alpha i}(\eta_{\mu i}(t), t)</code> are possible with an 
important distinction between associations which are nonlinear in <code class="reqn">\eta_{\mu}</code>  for <code>nonlinear = TRUE</code> (Koehler et al. 2017b) or linear where <code class="reqn">\eta_{\alpha i}(\eta_{\mu i}(t), t) = \eta_{\alpha i}(t)\eta_{\mu i}(t)</code> for <code>nonlinear = FALSE</code> (Koehler et al. 2017a).
</p>


<h3>Note</h3>

<p>The indicator <code>nonlinear</code> for associations with are linear or nonlinear in <code class="reqn">\eta_{\mu}</code> was named <code>interaction]</code> in earlier versions stages of the development.</p>


<h3>References</h3>

<p>Koehler M, Umlauf N, Beyerlein, A., Winkler, C. Ziegler, A.-G., Greven S (2017). Flexible
Bayesian Additive Joint Models with an Application to Type 1 Diabetes Research.
<em>Biometrical Journal</em>. <a href="https://doi.org/10.1002/bimj.201600224">doi:10.1002/bimj.201600224</a>
</p>
<p>Meike Koehler, Nikolaus Umlauf, and Sonja Greven (2018). Nonlinear association structures in
flexible Bayesian additive joint models. <em>Statistics in Medicine</em>.
<a href="https://doi.org/10.1002/sim.7967">doi:10.1002/sim.7967</a>
</p>


<h3>See Also</h3>

<p><code>bamlss</code>, <code>bamlss.frame</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

set.seed(123)
## Simulate survival data
## with random intercepts/slopes and a linear effect of time,
## constant association alpha and no effect of the derivative
d &lt;- simJM(nsub = 200, long_setting = "linear", 
  alpha_setting = "constant",
  dalpha_setting = "zero", full = FALSE)

## Formula of the according joint model
f &lt;- list(
  Surv2(survtime, event, obs = y) ~ s(survtime, bs = "ps"),
  gamma ~ s(x1, bs = "ps"),
  mu ~ obstime + s(id, bs = "re") + 
    s(id, obstime, bs = "re"),
  sigma ~ 1,
  alpha ~ 1,
  dalpha ~ -1
)

## Joint model estimation
## jm_bamlss() sets the default optimizer and sampler function.
## First, posterior mode estimates are computed using function
## opt_JM(), afterwards the sampler sam_JM() is started.
b &lt;- bamlss(f, data = d, family = "jm",
           timevar = "obstime", idvar = "id")

## Plot estimated effects.
plot(b)

## Predict event probabilities for two individuals
## at 12 time units after their last longitudinal measurement.
## The event probability is conditional on their survival
## up to their last observed measurement.
p &lt;- predict(b, type = "probabilities", id = c(1, 2), dt = 12, FUN = c95)
print(p)

## Plot of survival probabilities and
## corresponding longitudinal effects
## for individual id.
jm_survplot(b, id = 3)
jm_survplot(b, id = 30)


## Simulate survival data
## with functional random intercepts and a nonlinear effect 
## of time, time-varying association alpha and no effect 
## of the derivative.
## Note: This specification is the simJM default.
d &lt;- simJM(nsub = 200, full = FALSE)

## Formula of the according joint model
## number of knots for the smooth nonlinear effect of time
klong &lt;- 8
f &lt;- list(
  Surv2(survtime, event, obs = y) ~ s(survtime, bs = "ps"),
  gamma ~ s(x1, bs = "ps"),
  mu ~ ti(id, bs = "re") + 
    ti(obstime, bs = "ps", k = klong) + 
    ti(id, obstime, bs = c("re", "ps"), 
      k = c(nlevels(d$id), klong)) + 
    s(x2, bs = "ps"),
  sigma ~ 1,
  alpha ~ s(survtime, bs = "ps"),
  dalpha ~ -1
)

## Estimating posterior mode only using opt_JM()
b_mode &lt;- bamlss(f, data = d, family = "jm",
                 timevar = "obstime", idvar = "id", 
                 sampler = FALSE)

## Estimating posterior means using sam_JM() 
##  with starting values generated from posterior mode 
b_mean &lt;- bamlss(f, data = d, family = "jm",
                 timevar = "obstime", idvar = "id", optimizer = FALSE,
                 start = parameters(b_mode), results = FALSE)

## Plot effects.
plot(b_mean, model = "alpha")



## Simulate survival data
## with functional random intercepts and an association nonlinear in mu
set.seed(234)
d &lt;- simJM(nsub = 300, long_setting = "functional", alpha_setting = "nonlinear", 
           nonlinear = TRUE, full = FALSE, probmiss = 0.9)

## Calculate longitudinal model to obtain starting values for mu
long_df &lt;- 7
f_start &lt;- y ~ ti(id, bs = "re") + ti(obstime, bs = "ps", k = long_df) + 
               ti(id, obstime, bs = c("re", "ps"), k = c(nlevels(d$id), long_df)) + 
               s(x2, bs = "ps")
b_start &lt;- bamlss(f_start, data = d, sampler = FALSE)
mu &lt;- predict(b_start)$mu

## Fit joint model with nonlinear association (nonlinear = TRUE)
f &lt;- list(
  Surv2(survtime, event, obs = y) ~ s(survtime, bs = "ps"),
  gamma ~ x1,
  mu ~ ti(id, bs = "re") + ti(obstime, bs = "ps", k = long_df) + 
       ti(id, obstime, bs = c("re", "ps"), k = c(nlevels(d$id), long_df)) + 
       s(x2, bs = "ps"),
  sigma ~ 1,
  alpha ~ 1,
  dalpha ~ -1
)
b &lt;- bamlss(f, data = d, family = "jm", timevar = "obstime", idvar = "id", 
            nonlinear = TRUE, start_mu = mu, 
            n.iter = 6000, burnin = 2000, thin = 2)
plot(b)
samplestats(b$samples)

## End(Not run)
</code></pre>


</div>