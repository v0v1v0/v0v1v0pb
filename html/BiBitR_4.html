<div class="container">

<table style="width: 100%;"><tr>
<td>bibit3</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The BiBit Algorithm with Noise Allowance guided by Provided Patterns.</h2>

<h3>Description</h3>

<p>Same function as <code>bibit2</code> but only aims to discover biclusters containing the (sub) pattern of provided patterns or their combinations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bibit3(matrix = NULL, minr = 1, minc = 2, noise = 0,
  pattern_matrix = NULL, subpattern = TRUE, pattern_combinations = FALSE,
  arff_row_col = NULL, extend_columns = "none", extend_mincol = 1,
  extend_limitcol = 1, extend_noise = noise, extend_contained = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>matrix</code></td>
<td>
<p>The binary input matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minr</code></td>
<td>
<p>The minimum number of rows of the Biclusters. (Note that in contrast to <code>bibit</code> and <code>bibit2</code>, this can be be set to 1 since we are looking for additional rows to the provided pattern.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minc</code></td>
<td>
<p>The minimum number of columns of the Biclusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noise</code></td>
<td>
<p>Noise parameter which determines the amount of zero's allowed in the bicluster (i.e. in the extra added rows to the starting row pair).
</p>

<ul>
<li> <p><code>noise=0</code>: No noise allowed. This gives the same result as using the <code>bibit</code> function. (default)
</p>
</li>
<li> <p><code>0&lt;noise&lt;1</code>: The <code>noise</code> parameter will be a noise percentage. The number of allowed 0's in a (extra) row in the bicluster will depend on the column size of the bicluster. 
More specifically <code>zeros_allowed = ceiling(noise * columnsize)</code>. For example for <code>noise=0.10</code> and a bicluster column size of <code>5</code>, the number of allowed 0's would be <code>1</code>.
</p>
</li>
<li> <p><code>noise&gt;=1</code>: The <code>noise</code> parameter will be the number of allowed 0's in a (extra) row in the bicluster independent from the column size of the bicluster. In this noise option, the noise parameter should be an integer.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pattern_matrix</code></td>
<td>
<p>Matrix (Number of Patterns x Number of Data Columns) containing the patterns of interest.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subpattern</code></td>
<td>
<p>Boolean value if sub patterns are of interest as well (default=TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pattern_combinations</code></td>
<td>
<p>Boolean value if the pairwise combinations of patterns (the intersecting 1's) should also used as starting points (default=FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arff_row_col</code></td>
<td>
<p>Same argument as in <code>bibit</code> and <code>bibit2</code>. However you can only provide 1 pattern by using this option. For <code>bibit3</code> to work, the pattern has to be added 2 times on top of the matrix (= identical first 2 rows).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extend_columns</code></td>
<td>
<p><em>Column Extension Parameter</em><br> Can be one of the following: <code>"none"</code>, <code>"naive"</code>, <code>"recursive"</code> which will apply either a naive or recursive column extension procedure. (See Details Section for more information.)
<br> Based on the extension, additional biclusters will be created in the Biclust object which can be seen in the column and row names of the <code>RowxNumber</code> and <code>NumberxCol</code> slots (<code>"_Ext"</code> suffix).
<br> The <code>info</code> slot will also contain some additional information. Inside this slot, <code>BC.Extended</code> contains info on which original biclusters were extended, how many columns were added, and in how many extra extended biclusters this resulted.
<br><br><strong>Warning:</strong> Using a percentage-based <code>extend_noise</code> (or <code>noise</code> by default) in combination with the recursive procedure will result in a large amount of biclusters and increase the computation time a lot. Depending on the data when using recursive in combination with a noise percentage, it is advised to keep it reasonable small (e.g. 10%). Another remedy is to sufficiently increase the <code>extend_limitcol</code> either as a percentage or integer to limit the candidates of columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extend_mincol</code></td>
<td>
<p><em>Column Extension Parameter</em><br> A minimum number of columns that a bicluster should be able to be extended with before saving the result. (Default=1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extend_limitcol</code></td>
<td>
<p><em>Column Extension Parameter</em><br> The number (<code>extend_limitcol&gt;=1</code>) or percentage (<code>0&lt;extend_limitcol&lt;1</code>) of 1's that a column (subsetted on the BC rows) should at least contain for it to be a candidate to be added to the bicluster as an extension. (Default=1) (Increase this parameter if the recursive extension takes too long. Limiting the pool of candidates will decrease computation time, but restrict the results more.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extend_noise</code></td>
<td>
<p><em>Column Extension Parameter</em><br> The maximum allowed noise (in each row) when extending the columns of the bicluster. Can take the same as the <code>noise</code> parameter. By default this is the same value as <code>noise</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extend_contained</code></td>
<td>
<p><em>Column Extension Parameter</em><br> Logical value if extended results should be checked if they contain each other (and deleted if this is the case). Default = <code>FALSE</code>. This can be a lengthy procedure for a large amount of biclusters (&gt;1000).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The goal of the <code>bibit3</code> function is to provide one or multiple patterns in order to only find those biclusters exhibiting those patterns.
Multiple patterns can be given in matrix format, <code>pattern_matrix</code>, and their pairwise combinations can automatically be added to this matrix by setting <code>pattern_combinations=TRUE</code>.
All discovered biclusters are still subject to the provided <code>noise</code> level.
</p>
<p>Three types of Biclusters can be discovered:
</p>

<dl>
<dt><em>Full Pattern: </em></dt>
<dd>
<p>Bicluster which overlaps completely (within allowed noise levels) with the provided pattern. The column size of this bicluster is always equal to the number of 1's in the pattern.</p>
</dd>
<dt><em>Sub Pattern: </em></dt>
<dd>
<p>Biclusters which overlap with a part of the provided pattern within allowed noise levels. Will only be given if <code>subpattern=TRUE</code> (default). Setting this option to <code>FALSE</code> decreases computation time.</p>
</dd>
<dt><em>Extended: </em></dt>
<dd>
<p>Using the resulting biclusters from the full and sub patterns, other columns will be attempted to be added to the biclusters while keeping the noise as low as possible (the number of rows in the BC stays constant). 
This can be done either with <code>extend_columns</code> equal to <code>"naive"</code> or <code>"recursive"</code>. More info on the difference can be found in the Details Section of <code>bibit2</code>.
<br> Naturally the articially added pattern rows will not be taken into account with the noise levels as they are 0 in each other column.
<br> The question which is attempted to be answered here is <em>'Do the rows, which overlap partly or fully with the given pattern, have other similarities outside the given pattern?'</em>
</p>
</dd>
</dl>
<p><em>How?</em>
<br> The BiBit algorithm is applied to a data matrix that contains 2 identical artificial rows at the top which contain the given pattern. 
The default algorithm is then slightly altered to only start from this articial row pair (=Full Pattern) or from 1 artificial row and 1 other row (=Sub Pattern).
</p>
<p><em>Note 1 - Large Data:</em>
<br> The <code>arff_row_col</code> can still be provided in case of large data matrices, but the <code>.arff</code> file should already contain the pattern of interest in the first two rows. Consequently not more than 1 pattern at a time can be investigated with a single call of <code>bibit3</code>.
</p>
<p><em>Note 2 - Viewing Results:</em>
<br> A <code>print</code> and <code>summary</code> method has been implemented for the output object of <code>bibit3</code>. It gives an overview of the amount of discovered biclusters and their dimensions
<br> Additionally, the <code>bibit3_patternBC</code> function can extract a Bicluster and add the artificial pattern rows to investigate the results.
</p>


<h3>Value</h3>

<p>A S3 list object, <code>"bibit3"</code> in which each element (apart from the last one) corresponds with a provided pattern or combination thereof. <br>
Each element is a list containing:
</p>

<dl>
<dt>
<code>Number</code>: </dt>
<dd>
<p>Number of Initially found BC's by applying BiBit with the provided pattern.</p>
</dd> 
<dt>
<code>Number_Extended</code>: </dt>
<dd>
<p>Number of additional discovered BC's by extending the columns.</p>
</dd>
<dt>
<code>FullPattern</code>: </dt>
<dd>
<p>Biclust S4 Class Object containing the Bicluster with the Full Pattern.</p>
</dd>
<dt>
<code>SubPattern</code>: </dt>
<dd>
<p>Biclust S4 Class Object containing the Biclusters showing parts of the pattern.</p>
</dd>
<dt>
<code>Extended</code>: </dt>
<dd>
<p>Biclust S4 Class Object containing the additional Biclusters after extending the biclusters (column wise) of the full and sub patterns</p>
</dd>
<dt>
<code>info</code>: </dt>
<dd>
<p>Contains <code>Time_Min</code> element which includes the elapsed time of parts and the full analysis.</p>
</dd>
</dl>
<p>The last element in the list is a matrix containing all the investigated patterns.
</p>


<h3>Author(s)</h3>

<p>Ewoud De Troyer
</p>


<h3>References</h3>

<p>Domingo S. Rodriguez-Baena, Antonia J. Perez-Pulido and Jesus S. Aguilar-Ruiz (2011), "A biclustering algorithm for extracting bit-patterns from binary datasets", <em>Bioinformatics</em>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run:  
set.seed(1)
data &lt;- matrix(sample(c(0,1),100*100,replace=TRUE,prob=c(0.9,0.1)),nrow=100,ncol=100)
data[1:10,1:10] &lt;- 1 # BC1
data[11:20,11:20] &lt;- 1 # BC2
data[21:30,21:30] &lt;- 1 # BC3
colsel &lt;- sample(1:ncol(data),ncol(data))
data &lt;- data[sample(1:nrow(data),nrow(data)),colsel]

pattern_matrix &lt;- matrix(0,nrow=3,ncol=100)
pattern_matrix[1,1:7] &lt;- 1
pattern_matrix[2,11:15] &lt;- 1
pattern_matrix[3,13:20] &lt;- 1

pattern_matrix &lt;- pattern_matrix[,colsel]


out &lt;- bibit3(matrix=data,minr=2,minc=2,noise=0.1,pattern_matrix=pattern_matrix,
              subpattern=TRUE,extend_columns=TRUE,pattern_combinations=TRUE)
out  # OR print(out) OR summary(out)


bibit3_patternBC(result=out,matrix=data,pattern=c(1),type=c("full","sub","ext"),BC=c(1,2))

## End(Not run)
</code></pre>


</div>