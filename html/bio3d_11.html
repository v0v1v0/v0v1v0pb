<div class="container">

<table style="width: 100%;"><tr>
<td>aanma.pdbs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Ensemble Normal Mode Analysis with All-Atom ENM</h2>

<h3>Description</h3>

<p>Perform normal mode analysis (NMA) on an ensemble of aligned protein
structures using all-atom elastic network model (aaENM).
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'pdbs'
aanma(pdbs, fit = TRUE, full = FALSE, subspace = NULL,
  rm.gaps = TRUE, ligand = FALSE, outpath = NULL, gc.first = TRUE,
  ncore = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pdbs</code></td>
<td>
<p>an ‘pdbs’ object as obtained from <code>read.all</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>logical, if TRUE C-alpha coordinate based superposition is 
performed prior to normal mode calculations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>full</code></td>
<td>
<p>logical, if TRUE return the complete, full structure,
‘nma’ objects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subspace</code></td>
<td>
<p>number of eigenvectors to store for further analysis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rm.gaps</code></td>
<td>
<p>logical, if TRUE obtain the hessian matrices for only
atoms in the aligned positions (non-gap positions in all aligned
structures). Thus, gap positions are removed from output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ligand</code></td>
<td>
<p>logical, if TRUE ligand molecules are also included in the 
calculation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outpath</code></td>
<td>
<p>character string specifing the output directory to
which the PDB structures should be written.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gc.first</code></td>
<td>
<p>logical, if TRUE will call gc() first before mode calculation
for each structure. This is to avoid memory overload when 
<code>ncore &gt; 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncore</code></td>
<td>
<p>number of CPU cores used to do the calculation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments to <code>aanma</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function builds elastic network model (ENM) using all heavy 
atoms and performs subsequent normal mode analysis (NMA) on a set of 
aligned protein structures obtained with function <code>read.all</code>.
The main purpose is to automate ensemble normal mode analysis using 
all-atom ENMs.
</p>
<p>By default, the effective Hessian for all C-alpha atoms is calculated 
based on the Hessian built from all heavy atoms (including ligand atoms if 
<code>ligand=TRUE</code>). Returned values include aligned mode vectors and 
(when <code>full=TRUE</code>) a list containing the full ‘nma’ objects
one per each structure. When ‘rm.gaps=TRUE’ the unaligned atoms 
are ommited from output. With default arguments ‘rmsip’ provides 
RMSIP values for all pairwise structures.
</p>
<p>When <code>outmodes</code> is provided and is not ‘calpha’ 
(e.g. ‘noh’. See <code>aanma</code> for more details), the 
function simply returns a list of ‘nma’ objects, one per each 
structure, and no aligned mode vector is returned. In this case, the 
arguments <code>full</code>, <code>subspace</code>, and <code>rm.gaps</code> are ignored. 
This is equivalent to a wrapper function repeatedly calling 
<code>aanma</code>.
</p>


<h3>Value</h3>

<p>Returns a list of ‘nma’ objects (<code>outmodes</code> is provided 
and is not ‘calpha’) or an ‘enma’ object with the following 
components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>fluctuations </code></td>
<td>
<p> a numeric matrix containing aligned atomic
fluctuations with one row per input structure. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmsip </code></td>
<td>
<p> a numeric matrix of pair wise RMSIP values (only the ten
lowest frequency modes are included in the calculation). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>U.subspace </code></td>
<td>
<p> a three-dimensional array with aligned
eigenvectors  (corresponding to the subspace defined by the first N
non-trivial eigenvectors (‘U’) of the ‘nma’ object). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L </code></td>
<td>
<p> numeric matrix containing the raw eigenvalues with one row
per input structure. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>full.nma </code></td>
<td>
<p> a list with a <code>nma</code> object for each input
structure (available only when <code>full=TRUE</code>). </p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Xin-Qiu Yao &amp; Lars Skjaerven
</p>


<h3>See Also</h3>

<p>For normal mode analysis on single structure PDB:
<code>aanma</code>
</p>
<p>For conventional C-alpha based normal mode analysis:
<code>nma</code>, <code>nma.pdbs</code>.
</p>
<p>For the analysis of the resulting ‘eNMA’ object:
<code>mktrj.enma</code>, <code>dccm.enma</code>,
<code>plot.enma</code>, <code>cov.enma</code>.
</p>
<p>Similarity measures:
<code>sip</code>, <code>covsoverlap</code>,
<code>bhattacharyya</code>, <code>rmsip</code>.
</p>
<p>Related functionality:
<code>read.all</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
  # Needs MUSCLE installed - testing excluded
  if(check.utility("muscle")) {

    ## Fetch PDB files and split to chain A only PDB files
    ids &lt;- c("1a70_A", "1czp_A", "1frd_A", "1fxi_A", "1iue_A", "1pfd_A")
    files &lt;- get.pdb(ids, split = TRUE, path = tempdir())
    
    ## Sequence Alignement
    aln &lt;- pdbaln(files, outfile = tempfile())
    
    ## Read all pdb coordinates
    pdbs &lt;- read.all(aln)

    ## Normal mode analysis on aligned data
    modes &lt;- aanma(pdbs, rm.gaps=TRUE)
    
    ## Plot fluctuation data
    plot(modes, pdbs=pdbs)
    
    ## Cluster on Fluctuation similariy
    sip &lt;- sip(modes)
    hc &lt;- hclust(dist(sip))
    col &lt;- cutree(hc, k=3)
    
    ## Plot fluctuation data
    plot(modes, pdbs=pdbs, col=col)
    
    ## RMSIP is pre-calculated
    heatmap(1-modes$rmsip)
    
    ## Bhattacharyya coefficient
    bc &lt;- bhattacharyya(modes)
    heatmap(1-bc)

  }

</code></pre>


</div>