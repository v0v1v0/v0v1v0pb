<div class="container">

<table style="width: 100%;"><tr>
<td>bins.greedy</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Greedy binning algorithm.</h2>

<h3>Description</h3>

<p><code>bins.greedy</code> - Wrapper around <code>bins.greedy.impl</code>. Goes over the
sorted values of <code>x</code> left to right and fills the bins with the values until
they are about the right size.
</p>
<p><code>bins.greedy.impl</code> - Implementation of a single-pass binning algorithm that examines sorted data left to right
and builds bins of the target size. The <code>bins.greedy</code> wrapper around this function provides a less involved interface.
This is not symmetric wrt direction: symmetric distributions may not have symmetric bins if there are multiple points
with the same values. If a single value accounts for more than thresh * binsz points, it will be placed in
a new bin.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bins.greedy(x, nbins, minpts = floor(0.5 * length(x)/nbins), thresh = 0.8,
  naive = FALSE)

bins.greedy.impl(xval, xtbl, xstp, binsz, nbins, thresh, verbose = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Vector of numbers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nbins</code></td>
<td>
<p>Target number of bins.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minpts</code></td>
<td>
<p>Minimum number of points in a bin. Only used if <code>naive = FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresh</code></td>
<td>
<p>Threshold fraction of bin size for the greedy algorithm.
Suppose there's <code>n &lt; binsz</code> points in the current bin already.
Also suppose that the next value V is represented by <code>m</code> points, and <code>m + n &gt; binsz</code>.
Then the algorithm will check if <code>m &gt; thresh * binsz</code>, and if so, will place the value V into a new bin.
If <code>m</code> is below the threshold, the points having value V are added to the current bin.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>naive</code></td>
<td>
<p>When <code>TRUE</code>, simply calls <code>bins.greedy.impl</code> with data
derived from <code>x</code>. Otherwise, makes an extra step of marking the values that
by themselves take a whole bin to force the algorithm to place these values
in a bin separately.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xval</code></td>
<td>
<p>Sorted unique values of the data set x. This should be the numeric version of <code>names(xtbl)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xtbl</code></td>
<td>
<p>Result of a call to <code>table(x)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xstp</code></td>
<td>
<p>Stopping points; if <code>xstp[i] == TRUE</code>, the <code>i</code>-th value can't be merged to the <code>(i-1)</code>-th one.
<code>xstp[1]</code> value is ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>binsz</code></td>
<td>
<p>Target bin size, i.e., the number of points falling into each bin; for example, <code>floor(length(x) / nbins)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>When <code>TRUE</code>, prints the number of points falling into the bins.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list with the following items:
</p>

<ul>
<li>
<p>binlo - The "low" value falling into the bin.
</p>
</li>
<li>
<p>binhi - The "high" value falling into the bin.
</p>
</li>
<li>
<p>binct - The number of points falling into the bin.
</p>
</li>
<li>
<p>xtbl - The result of a call to <code>table(x)</code>.
</p>
</li>
<li>
<p>xval - The sorted unique values of the data points x. Essentially, a numeric version of <code>names(xtbl)</code>.
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>binr</code>, <code>bins</code>, <code>bins.quantiles</code> <code>bins.optimize</code>
</p>


</div>