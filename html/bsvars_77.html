<div class="container">

<table style="width: 100%;"><tr>
<td>specify_posterior_bsvar_mix</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>R6 Class Representing PosteriorBSVARMIX</h2>

<h3>Description</h3>

<p>The class PosteriorBSVARMIX contains posterior output and the specification including 
the last MCMC draw for the bsvar model with a zero-mean mixture of normals model for structural shocks.
Note that due to the thinning of the MCMC output the starting value in element <code>last_draw</code>
might not be equal to the last draw provided in element <code>posterior</code>.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>last_draw</code></dt>
<dd>
<p>an object of class BSVARMIX with the last draw of the current MCMC run as the starting value to be passed to the continuation of the MCMC estimation using <code>estimate()</code>.</p>
</dd>
<dt><code>posterior</code></dt>
<dd>
<p>a list containing Bayesian estimation output.</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PosteriorBSVARMIX-new"><code>specify_posterior_bsvar_mix$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PosteriorBSVARMIX-get_posterior"><code>specify_posterior_bsvar_mix$get_posterior()</code></a>
</p>
</li>
<li> <p><a href="#method-PosteriorBSVARMIX-get_last_draw"><code>specify_posterior_bsvar_mix$get_last_draw()</code></a>
</p>
</li>
<li> <p><a href="#method-PosteriorBSVARMIX-is_normalised"><code>specify_posterior_bsvar_mix$is_normalised()</code></a>
</p>
</li>
<li> <p><a href="#method-PosteriorBSVARMIX-set_normalised"><code>specify_posterior_bsvar_mix$set_normalised()</code></a>
</p>
</li>
<li> <p><a href="#method-PosteriorBSVARMIX-clone"><code>specify_posterior_bsvar_mix$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-PosteriorBSVARMIX-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create a new posterior output PosteriorBSVARMIX.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvar_mix$new(specification_bsvar, posterior_bsvar)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>specification_bsvar</code></dt>
<dd>
<p>an object of class BSVARMIX with the last draw of the current MCMC run as the starting value.</p>
</dd>
<dt><code>posterior_bsvar</code></dt>
<dd>
<p>a list containing Bayesian estimation output.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A posterior output PosteriorBSVARMIX.
</p>


<hr>
<a id="method-PosteriorBSVARMIX-get_posterior"></a>



<h4>Method <code>get_posterior()</code>
</h4>

<p>Returns a list containing Bayesian estimation output.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvar_mix$get_posterior()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(us_fiscal_lsuw)
specification  = specify_bsvar_mix$new(us_fiscal_lsuw, M = 2)
set.seed(123)
estimate       = estimate(specification, 10, thin = 1)
estimate$get_posterior()

</pre>
</div>


<hr>
<a id="method-PosteriorBSVARMIX-get_last_draw"></a>



<h4>Method <code>get_last_draw()</code>
</h4>

<p>Returns an object of class BSVARMIX with the last draw of the current MCMC run as the starting value to be passed to the continuation of the MCMC estimation using <code>estimate()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvar_mix$get_last_draw()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_mix$new(us_fiscal_lsuw, p = 4, M = 2)

# run the burn-in
set.seed(123)
burn_in        = estimate(specification, 10, thin = 2)

# estimate the model
posterior      = estimate(burn_in, 10, thin = 2)

</pre>
</div>


<hr>
<a id="method-PosteriorBSVARMIX-is_normalised"></a>



<h4>Method <code>is_normalised()</code>
</h4>

<p>Returns <code>TRUE</code> if the posterior has been normalised using <code>normalise_posterior()</code> and <code>FALSE</code> otherwise.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvar_mix$is_normalised()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_mix$new(us_fiscal_lsuw, p = 4, M = 2)

# estimate the model
set.seed(123)
posterior      = estimate(specification, 10, thin = 1)

# check normalisation status beforehand
posterior$is_normalised()

# normalise the posterior
BB            = posterior$last_draw$starting_values$B      # get the last draw of B
B_hat         = diag((-1) * sign(diag(BB))) %*% BB         # set negative diagonal elements
normalise_posterior(posterior, B_hat)                      # draws in posterior are normalised

# check normalisation status afterwards
posterior$is_normalised()

</pre>
</div>


<hr>
<a id="method-PosteriorBSVARMIX-set_normalised"></a>



<h4>Method <code>set_normalised()</code>
</h4>

<p>Sets the private indicator <code>normalised</code> to TRUE.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvar_mix$set_normalised(value)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>value</code></dt>
<dd>
<p>(optional) a logical value to be passed to indicator <code>normalised</code>.</p>
</dd>
</dl>
</div>



<h5>Examples</h5>

<div class="r example copy">
<pre># This is an internal function that is run while executing normalise_posterior()
# Observe its working by analysing the workflow:

# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_mix$new(us_fiscal_lsuw, p = 4, M = 2)
set.seed(123)

# estimate the model
posterior      = estimate(specification, 10, thin = 1)

# check normalisation status beforehand
posterior$is_normalised()

# normalise the posterior
BB            = posterior$last_draw$starting_values$B      # get the last draw of B
B_hat         = diag(sign(diag(BB))) %*% BB                # set positive diagonal elements
normalise_posterior(posterior, B_hat)                      # draws in posterior are normalised

# check normalisation status afterwards
posterior$is_normalised()

</pre>
</div>


<hr>
<a id="method-PosteriorBSVARMIX-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvar_mix$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>See Also</h3>

<p><code>estimate</code>, <code>specify_bsvar_mix</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># This is a function that is used within estimate()
data(us_fiscal_lsuw)
specification  = specify_bsvar_mix$new(us_fiscal_lsuw, p = 4, M = 2)
set.seed(123)
estimate       = estimate(specification, 10, thin = 1)
class(estimate)


## ------------------------------------------------
## Method `specify_posterior_bsvar_mix$get_posterior`
## ------------------------------------------------

data(us_fiscal_lsuw)
specification  = specify_bsvar_mix$new(us_fiscal_lsuw, M = 2)
set.seed(123)
estimate       = estimate(specification, 10, thin = 1)
estimate$get_posterior()


## ------------------------------------------------
## Method `specify_posterior_bsvar_mix$get_last_draw`
## ------------------------------------------------

data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_mix$new(us_fiscal_lsuw, p = 4, M = 2)

# run the burn-in
set.seed(123)
burn_in        = estimate(specification, 10, thin = 2)

# estimate the model
posterior      = estimate(burn_in, 10, thin = 2)


## ------------------------------------------------
## Method `specify_posterior_bsvar_mix$is_normalised`
## ------------------------------------------------

# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_mix$new(us_fiscal_lsuw, p = 4, M = 2)

# estimate the model
set.seed(123)
posterior      = estimate(specification, 10, thin = 1)

# check normalisation status beforehand
posterior$is_normalised()

# normalise the posterior
BB            = posterior$last_draw$starting_values$B      # get the last draw of B
B_hat         = diag((-1) * sign(diag(BB))) %*% BB         # set negative diagonal elements
normalise_posterior(posterior, B_hat)                      # draws in posterior are normalised

# check normalisation status afterwards
posterior$is_normalised()


## ------------------------------------------------
## Method `specify_posterior_bsvar_mix$set_normalised`
## ------------------------------------------------

# This is an internal function that is run while executing normalise_posterior()
# Observe its working by analysing the workflow:

# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_mix$new(us_fiscal_lsuw, p = 4, M = 2)
set.seed(123)

# estimate the model
posterior      = estimate(specification, 10, thin = 1)

# check normalisation status beforehand
posterior$is_normalised()

# normalise the posterior
BB            = posterior$last_draw$starting_values$B      # get the last draw of B
B_hat         = diag(sign(diag(BB))) %*% BB                # set positive diagonal elements
normalise_posterior(posterior, B_hat)                      # draws in posterior are normalised

# check normalisation status afterwards
posterior$is_normalised()

</code></pre>


</div>