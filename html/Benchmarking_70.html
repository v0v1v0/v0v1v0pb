<div class="container">

<table style="width: 100%;"><tr>
<td>cost.opt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>DEA optimal cost, revenue, and profit</h2>

<h3>Description</h3>

<p>Estimates the input and/or output vector(s) that minimize
cost, maximize revenue or maximize profit in the context of a DEA
technology</p>


<h3>Usage</h3>

<pre><code class="language-R">cost.opt(XREF, YREF, W, YOBS=NULL, RTS="vrs", param=NULL,
         TRANSPOSE=FALSE, LP=FALSE, CONTROL=NULL, LPK = NULL)  

revenue.opt(XREF, YREF, P, XOBS=NULL, RTS="vrs",  param=NULL,
            TRANSPOSE = FALSE, LP = FALSE, CONTROL=NULL, LPK = NULL)

profit.opt(XREF, YREF, W, P, RTS = "vrs",  param=NULL,
           TRANSPOSE = FALSE, LP = FALSE, CONTROL=NULL, LPK = NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>XREF</code></td>
<td>
<p>Input of the firms defining the technology, a K x m matrix
of observations of K firms with m inputs (firm x input).  In case
<code>TRANSPOSE=TRUE</code> the input matrix is transposed as input x
firm. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>YREF</code></td>
<td>
<p>output of the firms defining the technology, a K x n
matrix of observations of K firms with n outputs (firm x input).  In
case <code>TRANSPOSE=TRUE</code> the output matrix is transposed as output
x firm. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p>Input prices as a matrix. Either same prices for all firms or
individual prices for all firms, i.e. either a 1 x m or a K x m
matrix for K firms and m inputs </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>P</code></td>
<td>
<p>Output prices as a matrix. Either same prices for all firms
or individual prices for all firms, i.e. either a 1 x n or K x n
matrix for K firms and n outputs </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>XOBS</code></td>
<td>
<p>The input for which an optimal, revenue maximizing, output
vector is to be calculated. Defaults is <code>XREF</code>.  Same form as
<code>XREF</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>YOBS</code></td>
<td>
<p>The output for which an optimal, cost minimizing input
vector is to be calculated. Defaults is <code>YREF</code>.  Same form as
<code>YREF</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RTS</code></td>
<td>

<p>A text string or a number defining the underlying DEA technology /
returns to scale assumption.
</p>

<table>
<tr>
<td style="text-align: right;">
0 </td>
<td style="text-align: left;"> fdh </td>
<td style="text-align: left;"> Free disposability hull, no convexity assumption </td>
</tr>
<tr>
<td style="text-align: right;">
1 </td>
<td style="text-align: left;"> vrs </td>
<td style="text-align: left;"> Variable returns to scale, convexity and free disposability </td>
</tr>
<tr>
<td style="text-align: right;">
2 </td>
<td style="text-align: left;"> drs </td>
<td style="text-align: left;"> Decreasing returns to scale, convexity, downscaling and free disposability </td>
</tr>
<tr>
<td style="text-align: right;">
3 </td>
<td style="text-align: left;"> crs </td>
<td style="text-align: left;"> Constant returns to scale, convexity and free disposability </td>
</tr>
<tr>
<td style="text-align: right;">
4 </td>
<td style="text-align: left;"> irs </td>
<td style="text-align: left;"> Increasing returns to scale, (up-scaling, but not down-scaling), convexity and free disposability </td>
</tr>
<tr>
<td style="text-align: right;">
5 </td>
<td style="text-align: left;"> add </td>
<td style="text-align: left;"> Additivity (scaling up and down, but only with integers), and free disposability </td>
</tr>
<tr>
<td style="text-align: right;">
6 </td>
<td style="text-align: left;"> fdh+ </td>
<td style="text-align: left;"> A combination of free disposability and restricted
 or local constant return to scale
</td>
</tr>
</table>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param</code></td>
<td>
<p>Possible parameters. Now only used for
RTS="fdh+" to set low and high values for restrictions on lambda;
see the section details and examples in <code>dea</code> for its
use. Future versions might also use <code>param</code> for other
purposes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>TRANSPOSE</code></td>
<td>
<p>Input and output matrices are treated as firms times
goods for the default value <code>TRANSPOSE=FALSE</code> corresponding
to the standard in R for statistical models.  When <code>TRUE</code>
data matrices, quantities and prices, are transposed to goods times
firms matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LP</code></td>
<td>
<p>Only for debugging. If <code>LP=TRUE</code> then input and output
for the LP program are written to standard output for each unit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CONTROL</code></td>
<td>
<p>Possible controls to <span class="pkg">lpSolveAPI</span>, see the
documentation for that package. For examples of use see the
function <code>dea</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LPK</code></td>
<td>
<p>When <code>LPK=k</code> then a mps file is written for firm
<code>k</code>; it can be used as input to an alternative LP solver
to check the results.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p> Input and output matrices are in the same form as for the
method <code>dea</code>.
</p>
<p>The LP optimization problem is formulated in Bogetoft and
Otto (2011, pp 35 and 102) and is solved by the LP method in the
package <span class="pkg">lpSolveAPI</span>.
</p>
<p>The methods <code>print</code> and <code>summary</code> are working for
<code>cost.opt</code>, <code>revenue.opt</code>, and <code>profit.opt</code>
</p>


<h3>Value</h3>

<p> The values returned are the optimal input, and/or optimal
output. When saved in an object the following components are
available:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>xopt</code></td>
<td>
<p>The optimal input, returned as a matrix by
<code>cost.opt</code> and <code>profit.cost</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yopt</code></td>
<td>
<p>The optimal output, returned as a matrix by
<code>revenue.opt</code> and <code>profit.cost</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cost</code></td>
<td>
<p>The optimal/minimal cost.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>revenue</code></td>
<td>
<p>The optimal/maximal revenue</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>profit</code></td>
<td>
<p>The optimal/maximal profit</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The peer weights that determines the technology, a
matrix. Each row is the lambdas for the firm corresponding to that
row; for the vrs technology the rows sum to 1. A column shows for
a given firm how other firms are compared to this firm, i.e. peers
are firms with a positive element in their columns.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>The index for peer units can be returned by the method <code>peers</code>
and the weights are returned in <code>lambda</code>.  Note that the peers
now are the firms for the optimal input and/or output allocation, not
just the technical efficient firms.
</p>
<p>If a numerical problem occurs, status=5, or if no solution can be found,
the best solution is often to scale the input <code>X</code> and output
<code>Y</code> yourself or use the option <code>CONTROL</code> to change scaling in
the program itself, as described in the notes for <code>dea</code>.
</p>


<h3>Author(s)</h3>

<p> Peter Bogetoft and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a></p>


<h3>References</h3>

<p>Bogetoft and Otto; <em>Benchmarking with DEA, SFA, and R</em>; Springer
2011
</p>


<h3>See Also</h3>

<p>Paul W. Wilson (2008), “FEAR 1.0: A Software Package for Frontier
Efficiency Analysis with R,” <em>Socio-Economic Planning Sciences</em>
42, 247–254
</p>


<h3>Examples</h3>

<pre><code class="language-R">
x &lt;- matrix(c(2,12, 2,8, 5,5, 10,4, 10,6, 3,13), ncol=2, byrow=TRUE)
y &lt;- matrix(1,nrow=dim(x)[1],ncol=1)
w &lt;- matrix(c(1.5, 1),ncol=2)

txt &lt;- LETTERS[1:dim(x)[1]]
dea.plot(x[,1],x[,2], ORIENTATION="in",  cex=1.25)
text(x[,1],x[,2],txt,adj=c(-.7,-.2),cex=1.25)

# technical efficiency
te &lt;- dea(x,y,RTS="vrs")
xopt &lt;- cost.opt(x,y,w,RTS=1)
cobs &lt;- x %*% t(w)
copt &lt;- xopt$x %*% t(w)
# cost efficiency
ce &lt;- copt/cobs
# allocaltive efficiency
ae &lt;- ce/te$eff
data.frame("ce"=ce,"te"=te$eff,"ae"=ae)
print(cbind("ce"=c(ce),"te"=te$eff,"ae"=c(ae)),digits=2)

# isocost line in the technology plot
abline(a=copt[1]/w[2], b=-w[1]/w[2], lty="dashed")
</code></pre>


</div>