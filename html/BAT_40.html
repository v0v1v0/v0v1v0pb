<div class="container">

<table style="width: 100%;"><tr>
<td>kernel.build</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Build kernel hypervolumes.</h2>

<h3>Description</h3>

<p>Builds kernel density hypervolumes from trait data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">kernel.build(
  comm,
  trait,
  distance = "gower",
  method.hv = "gaussian",
  abund = TRUE,
  weight = NULL,
  axes = 0,
  convert = NULL,
  cores = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>comm</code></td>
<td>
<p>A sites x species matrix, data.frame or vector, with incidence or abundance data about the species in the community.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trait</code></td>
<td>
<p>A species x traits or axes matrix or data.frame (often from hyper.build) or, alternatively, a dist object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance</code></td>
<td>
<p>One of "gower" or "euclidean". Not used if trait is a dist object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.hv</code></td>
<td>
<p>Method for constructing the 'Hypervolume' object. One of "gaussian" (Gaussian kernel density estimation, default), "box" (box kernel density estimation), or "svm" (one-class support vector machine). See respective functions of the hypervolume R package for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>abund</code></td>
<td>
<p>A boolean (T/F) indicating whether abundance data should be used as weights in hypervolume construction. Only works if method.hv = "gaussian".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight</code></td>
<td>
<p>A vector of column numbers with weights for each variable. Its length must be equal to the number of columns in trait. Only used if axes &gt; 0 and if trait is not a dist object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>axes</code></td>
<td>
<p>If 0, no transformation of data is done.
If 0 &lt; axes &lt;= 1 a PCoA is done with Gower/euclidean distances and as many axes as needed to achieve this proportion of variance explained are selected.
If axes &gt; 1 these many axes are selected.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convert</code></td>
<td>
<p>A vector of column numbers, usually categorical variables, to be converted to dummy variables. Only used if axes &gt; 0 and if trait is not a dist object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>Number of cores to be used in parallel processing. If = 0 all available cores are used. Beware that multicore for Windows is not optimized yet and it often takes longer than single core.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to be passed to hypervolume::hypervolume</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The hypervolumes can be constructed with the given data or data can be transformed using PCoA after traits are dummyfied (if needed) and standardized (always).
Beware that if transformations are required, all communities to be compared should be built simultaneously to guarantee comparability. In such case, one might want to first run hyper.build and use the resulting data in different runs of kernel.build.
See function hyper.build for more details.
</p>


<h3>Value</h3>

<p>A 'Hypervolume' or 'HypervolumeList', representing the hypervolumes of each community.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
comm = rbind(c(1,1,0,5,1), c(3,2,5,0,0))
colnames(comm) = c("SpA", "SpB", "SpC", "SpD", "SpE")
rownames(comm) = c("Site1", "Site2")

trait = data.frame(body = c(1,2,3,1,2), beak = c(1,2,3,2,1))
rownames(trait) = colnames(comm)

hv = kernel.build(comm[1,], trait)
plot(hv)
hvlist = kernel.build(comm, trait, abund = FALSE, cores = 2)
plot(hvlist)
hvlist = kernel.build(comm, trait, method.hv = "box", weight = c(1,2), axes = 2)
plot(hvlist)

## End(Not run)
</code></pre>


</div>