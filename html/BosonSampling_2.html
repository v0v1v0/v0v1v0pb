<div class="container">

<table style="width: 100%;"><tr>
<td>bosonSampler</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function for independently sampling from the Boson Sampling distribution</h2>

<h3>Description</h3>

<p>The function implements the Boson Sampling algorithm defined in Clifford and Clifford (2017) <a href="https://arxiv.org/abs/1706.01260">https://arxiv.org/abs/1706.01260</a>
</p>


<h3>Usage</h3>

<pre><code class="language-R">bosonSampler(A, sampleSize, perm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>the first <code>n</code> columns of an <code>(m x m)</code> random unitary matrix, 
<br> see <code>randomUnitary</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sampleSize</code></td>
<td>
<p>the number of independent sample values required for given <code>A</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perm</code></td>
<td>
<p>TRUE if the permanents and pmfs of each sample value are required</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Let the matrix <code>A</code> be the first <code>n</code> columns of an <code>(m x m)</code> random unitary matrix, then 
<code>X &lt;- bosonSampler(A, sampleSize = N, perm = TRUE)</code> provides <code>X$values</code>, <code>X$perms</code> and <code>X$pmfs</code>, 
<br><br> The component <code>X$values</code> is an <code>(n x N)</code> matrix with columns that are 
independent sample values from the Boson Sampling distribution. 
Each sample value is a vector of <code>n</code> integer-valued output modes in random order. The elements of the vector can be sorted in 
increasing order to provide a multiset representation of the sample value. 
<br><br> The outputs <code>X$perms</code> and <code>X$pmfs</code> are 
vectors of the permanents and probability mass functions (pmfs) associated with the sample values.
The permanent associated with a sample value <code>v = (v_1,...,v_n)</code> is the permanent of an <code>(n x n)</code> matrix constructed with rows 
<code>v_1,...,v_n</code> of <code>A</code>. Note the constructed matrix, <code>M</code>, may have repeated rows since <code>v_1,...,v_n</code> 
are not necessarily distinct.  
The pmf is calculated as <code>Mod(pM)^2/prod(factorial(tabulate(c))</code> where <code>pM</code> is the permanent of <code>M</code>.
</p>


<h3>Value</h3>

<p><code>X = bosonSampler(A, sampleSize = N, perm = TRUE)</code> provides <code>X$values</code>, <code>X$perms</code> and <code>X$pmfs</code>. See Details.
</p>


<h3>References</h3>

<p>Clifford, P. and Clifford, R. (2017) The Classical Complexity of Boson Sampling, <a href="https://arxiv.org/abs/1706.01260">https://arxiv.org/abs/1706.01260</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(7)
n &lt;- 20  # number of photons
m &lt;- 200 # number of output modes
A &lt;- randomUnitary(m)[,1:n]
# sample of output vectors
valueList &lt;- bosonSampler(A, sampleSize = 10)$values 
valueList
# sample of output multisets 
apply(valueList,2, sort) 
#
set.seed(7)
n &lt;- 12  # number of photons
m &lt;- 30 # number of output modes
A &lt;- randomUnitary(m)[,1:n]
# sample of output vectors
valueList = bosonSampler(A, sampleSize = 1000)$values 
# Compare frequency of output modes at different
# positions in the output vectors 
matplot(1:m,apply(valueList,1,tabulate), pch =20, t = "p", 
xlab = "output modes", ylab = "frequency")
</code></pre>


</div>