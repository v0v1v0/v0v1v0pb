<div class="container">

<table style="width: 100%;"><tr>
<td>build_site</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Build a website</h2>

<h3>Description</h3>

<p>Build the site through Hugo, and optionally (re)build R Markdown files.
</p>


<h3>Usage</h3>

<pre><code class="language-R">build_site(local = FALSE, run_hugo = TRUE, build_rmd = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>local</code></td>
<td>
<p>Whether to build the website locally. This argument is passed to
<code>hugo_build()</code>, and <code>local = TRUE</code> is mainly for serving
the site locally via <code>serve_site()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>run_hugo</code></td>
<td>
<p>Whether to run <code>hugo_build()</code> after R Markdown files are
compiled.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>build_rmd</code></td>
<td>
<p>Whether to (re)build R Markdown files. By default, they are
not built. See ‘Details’ for how <code>build_rmd = TRUE</code> works.
Alternatively, it can take a vector of file paths, which means these files
are to be (re)built. Or you can provide a function that takes a vector of
paths of all R Markdown files under the ‘<span class="file">content/</span>’ directory, and
returns a vector of paths of files to be built, e.g., <code>build_rmd =
blogdown::filter_timestamp</code>. A few aliases are currently provided for such
functions: <code>build_rmd = 'newfile'</code> is equivalent to <code>build_rmd =
blogdown::filter_newfile</code>, <code>build_rmd = 'timestamp'</code> is equivalent to
<code>build_rmd = blogdown::filter_timestamp</code>, and <code>build_rmd =
'md5sum'</code> is equivalent to <code>build_rmd = blogdown::filter_md5sum</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments to be passed to <code>hugo_build()</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>You can use <code>serve_site()</code> to preview your website locally, and
<code>build_site()</code> to build the site for publishing. However, if you use a
web publishing service like Netlify, you do not need to build the site
locally, but can build it on the cloud. See Section 1.7 of the <span class="pkg">blogdown</span>
book for more information:
<a href="https://bookdown.org/yihui/blogdown/workflow.html">https://bookdown.org/yihui/blogdown/workflow.html</a>.
</p>
<p>For R Markdown posts, there are a few possible rendering methods: <code>html</code>
(the default), <code>markdown</code>, and <code>custom</code>. The method can be set in
the global option <code>blogdown.method</code> (usually in the
‘<span class="file">.Rprofile</span>’ file), e.g., <code>options(blogdown.method =
"custom")</code>.
</p>
<p>For the <code>html</code> method, ‘<span class="file">.Rmd</span>’ posts are rendered to ‘<span class="file">.html</span>’
via <code>rmarkdown::render()</code>, which means Markdown is
processed through Pandoc. For the <code>markdown</code> method, ‘<span class="file">.Rmd</span>’ is
rendered to ‘<span class="file">.md</span>’, which will typically be rendered to HTML later by the
site generator such as Hugo.
</p>
<p>For all rendering methods, a custom R script ‘<span class="file">R/build.R</span>’ will be
executed if you have provided it under the root directory of the website
(e.g. you can compile Rmd to Markdown through
<code>knitr::knit()</code> and build the site via
<code>hugo_cmd()</code>). The <code>custom</code> method means it is entirely up
to this R script how a website is rendered. The script is executed via
command line <code>Rscript "R/build.R"</code>, which means it is executed in a
separate R session. The value of the argument <code>local</code> is passed to the
command line (you can retrieve the command-line arguments via
<code>commandArgs(TRUE)</code>). For other rendering methods, the R script
‘<span class="file">R/build2.R</span>’ (if exists) will be executed after Hugo has built the site.
This can be useful if you want to post-process the site.
</p>
<p>When <code>build_rmd = TRUE</code>, all Rmd files will be (re)built. You can set
the global option <code>blogdown.files_filter</code> to a function to determine
which Rmd files to build when <code>build_rmd = TRUE</code>. This function takes a
vector of Rmd file paths, and should return a subset of these paths to be
built. By default, <code>options(blogdown.files_filter = identity</code>.
You can use <code>blogdown::filter_newfile</code>, which means to build new
Rmd files that have not been built before, or
<code>blogdown::filter_timestamp</code> to build Rmd files if their time
stamps (modification time) are newer than their output files, or
<code>blogdown::filter_md5sum</code>, which is more robust in determining if
an Rmd file has been modified (hence needs to be rebuilt).
</p>


</div>