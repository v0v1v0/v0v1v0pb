<div class="container">

<table style="width: 100%;"><tr>
<td>dirac_ss_sdf_pvalue</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Hypothesis testing for risk prices (Bayesian p-values) with Dirac spike-and-slab prior</h2>

<h3>Description</h3>

<p>This function tests the null hypothesis, <code class="reqn">H_0: \lambda = \lambda_0</code>, when <code class="reqn">\gamma=0</code>.
When <code class="reqn">\lambda_0 = 0</code>, we compare factor models using the algorithm in Proposition 1 of Bryzgalova et al. (2023).
When <code class="reqn">\lambda_0 \neq 0</code>, this function corresponds to Corollary 2 in Section II.A.2 of Bryzgalova et al. (2023).
The function can also be used to compute the posterior probabilities of all possible models with up to a
given maximum number of factors (see examples).
</p>


<h3>Usage</h3>

<pre><code class="language-R">dirac_ss_sdf_pvalue(f, R, sim_length, lambda0, psi0 = 1, max_k = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>A matrix of factors with dimension <code class="reqn">t \times k</code>, where <code class="reqn">k</code> is the number of factors
and <code class="reqn">t</code> is the number of periods;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>A matrix of test assets with dimension <code class="reqn">t \times N</code>, where <code class="reqn">t</code> is the number of periods
and <code class="reqn">N</code> is the number of test assets;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sim_length</code></td>
<td>
<p>The length of Monte-Carlo simulations;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda0</code></td>
<td>
<p>A <code class="reqn">k \times 1</code> vector of risk prices under the null hypothesis (<code class="reqn">\gamma=0</code>);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psi0</code></td>
<td>
<p>The hyper-parameter in the prior distribution of risk price <code class="reqn">\lambda</code> (see <b>Details</b>);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_k</code></td>
<td>
<p>The maximal number of factors in models (<code>max_k</code> is a positive integer or <code>NULL</code> if the user does not impose any restriction on the model dimension).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Let <code class="reqn">D</code> denote a diagonal matrix with elements <code class="reqn">c, \psi_1^{-1},..., \psi_K^{-1}</code>, and <code class="reqn">D_\gamma</code> the submatrix of <code class="reqn">D</code>
corresponding to model <code class="reqn">\gamma</code>, where <code class="reqn">c</code> is a small positive number corresponding to the common cross-sectional intercept
(<code class="reqn">\lambda_c</code>). The prior for the prices of risk (<code class="reqn">\lambda_\gamma</code>) of model <code class="reqn">\gamma</code> is then
</p>
<p style="text-align: center;"><code class="reqn"> \lambda_\gamma | \sigma^2, \gamma \sim N (0, \sigma^2, D_{\gamma}^{-1}). </code>
</p>

<p>We choose
<code class="reqn"> \psi_j =  \psi \tilde{\rho}_j^\top \tilde{\rho}_j  </code>, where <code class="reqn"> \tilde{\rho}_j = \rho_j - (\frac{1}{N} \Sigma_{i=1}^{N} \rho_{j,i}  ) \times 1_N </code> is the cross-sectionally
demeaned vector of factor <code class="reqn">j</code>'s correlations with asset returns. In the codes, <code class="reqn">\psi</code> is equal to the value of <code>psi0</code>.
</p>


<h3>Value</h3>

<p>The return of <code>dirac_ss_sdf_pvalue</code> is a list of the following elements:
</p>

<ul>
<li> <p><code>gamma_path</code>: A <code>sim_length</code><code class="reqn">\times k</code> matrix of the posterior draws of <code class="reqn">\gamma</code>. Each row represents
a draw. If <code class="reqn">\gamma_j = 1</code> in one draw, factor <code class="reqn">j</code> is included in the model in this draw and vice verse.
</p>
</li>
<li> <p><code>lambda_path</code>: A <code>sim_length</code><code class="reqn">\times (k+1)</code> matrix of the risk prices <code class="reqn">\lambda</code>. Each row represents
a draw. Note that the first column is <code class="reqn">\lambda_c</code> corresponding to the constant term. The next <code class="reqn">k</code> columns (i.e., the 2-th – <code class="reqn">(k+1)</code>-th columns) are the risk prices of the <code class="reqn">k</code> factors;
</p>
</li>
<li> <p><code>model_probs</code>: A <code class="reqn">2^k \times (k+1)</code> matrix of posterior model probabilities, where the first k columns are the model indices and the final column is a vector of model probabilities.
</p>
</li>
</ul>
<h3>References</h3>

<p>Bryzgalova S, Huang J, Julliard C (2023).
“Bayesian solutions for the factor zoo: We just ran two quadrillion models &lt;https://doi.org/10.1111/jofi.13197&gt;.”
<em>Journal of Finance</em>, <b>78</b>(1), 487–557.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## &lt;--------------------------------------------------------------------------------&gt;
## Example: Bayesian p-value (with the dirac spike-and-slab prior)
## &lt;--------------------------------------------------------------------------------&gt;

# Load the example data
data("BFactor_zoo_example")
HML &lt;- BFactor_zoo_example$HML
lambda_ols &lt;- BFactor_zoo_example$lambda_ols
R2.ols.true &lt;- BFactor_zoo_example$R2.ols.true
sim_f &lt;- BFactor_zoo_example$sim_f
sim_R &lt;- BFactor_zoo_example$sim_R
uf &lt;- BFactor_zoo_example$uf

### Now we estimate the Bayesian p-values defined in Corollary 2.

#
### Prior Sharpe ratio of factor model for different values of psi: see equation (27):
#
cat("--------------- Choose psi based on prior Sharpe ratio ----------------\n")
cat("if psi = 1, prior Sharpe ratio is", psi_to_priorSR(sim_R, sim_f, psi0=1), "\n")
cat("if psi = 2, prior Sharpe ratio is", psi_to_priorSR(sim_R, sim_f, psi0=2), "\n")
cat("if psi = 5, prior Sharpe ratio is", psi_to_priorSR(sim_R, sim_f, psi0=5), "\n")

## Test whether factors' risk prices equal 'matrix(lambda_ols[2]*sd(HML),ncol=1)'
## Bayesian p-value is given by mean(shrinkage$gamma_path)
shrinkage &lt;- dirac_ss_sdf_pvalue(sim_f, sim_R, 1000, matrix(lambda_ols[2]*sd(HML),ncol=1))
cat("Null hypothesis: lambda =", matrix(lambda_ols[2]*sd(HML)), "\n")
cat("Posterior probability of rejecting the above null hypothesis is:",
    mean(shrinkage$gamma_path), "\n")

## Test whether the risk price of factor 'sim_f' is equal to 0
shrinkage &lt;- dirac_ss_sdf_pvalue(sim_f, sim_R, 1000, 0, psi0=1)
cat("Null hypothesis: lambda =", 0, "\n")
cat("Posterior probability of rejecting the above null hypothesis is:",
    mean(shrinkage$gamma_path), "\n")


## One can also put more than one factor into the test
two_f = cbind(sim_f,uf) # sim_f is the strong factor while uf is the useless factor
# Test1: lambda of sim_f = 0, Test2: lambda of uf = 0
lambda0_null_vec = t(cbind(0,0)) # 2x1 vector
shrinkage &lt;- dirac_ss_sdf_pvalue(two_f, sim_R, 1000, lambda0_null_vec, psi0=1)
cat("Null hypothesis: lambda =", 0, "for each factor", "\n")
cat("Posterior probabilities of rejecting the above null hypothesis are:",
    colMeans(shrinkage$gamma_path), "\n")

## We can also print the posterior model probabilities:
cat('Posterior model probabilities are:\n')
print(shrinkage$model_probs)


## One can compute the posterior probabilities of all possible models with up to
## a given maximum number of factors. For example, we consider two factors, but
## the number of factors is restricted to be less than two.
lambda0_null_vec = t(cbind(0,0)) # 2x1 vector
shrinkage &lt;- dirac_ss_sdf_pvalue(two_f, sim_R, 1000, lambda0_null_vec, psi0=1, max_k=1)
cat('Posterior model probabilities are:\n')
print(shrinkage$model_probs)
## Comment: You may notice that the model with index (1, 1) has a posterior probability
##          of exactly zero since the maximal number of factors is one.

</code></pre>


</div>