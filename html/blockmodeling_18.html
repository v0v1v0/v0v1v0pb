<div class="container">

<table style="width: 100%;"><tr>
<td>funByBlocks.default</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Computation of function values by blocks</h2>

<h3>Description</h3>

<p>Computes a value of a function over blocks of a matrix, defined by a partition.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## Default S3 method:
funByBlocks(
  x = M,
  clu,
  M = x,
  ignore.diag = "default",
  sortNames = TRUE,
  FUN = "mean",
  ...
)

## S3 method for class 'optMorePar'
funByBlocks(x, which = 1, orderClu = FALSE, sortNames = NULL, ...)

## S3 method for class 'opt.more.par'
funByBlocks(x, which = 1, orderClu = FALSE, sortNames = NULL, ...)

funByBlocks(x, ...)

fun.by.blocks(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An object of suitable class or a matrix/array representing the (usually valued) network. For multi-relational networks, this should be an array with the third dimension representing the relation.
The network can have one or more modes (different kinds of units with no ties among themselves.
If the network is not two-mode, the matrix must be square.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clu</code></td>
<td>
<p>A partition. Each unique value represents one cluster.
If the network is one-mode, then this should be a vector, else a list of vectors, one for each mode.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>A matrix representing the (usually valued) network. For multi-relational networks, this should be an array with the third dimension representing the relation.
The network can have one or more modes (different  kinds of units with no ties among themselves.
If the network is not two-mode, the matrix must be square.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore.diag</code></td>
<td>
<p>Should the diagonal be ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sortNames</code></td>
<td>
<p>Should the rows and columns of the matrix be sorted based on their names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>
<p>The function to be computed over the blocks.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments to <code>funByBlocks.default</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which</code></td>
<td>
<p>Which (if several) of the "best" solutions should be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orderClu</code></td>
<td>
<p>Should the partition be ordered before computing. <code>FALSE</code> by default. If <code>TRUE</code>, <code>orderClu</code> is used (using default arguments) to order the clusters in a partition in "decearsing" (see <code>orderClu</code> for interpretation) order.  If <code>TRUE</code>, <code>sortNames</code> is set to <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A numerical matrix of <code>FUN</code> values by blocks, induced by a partition <code>clu</code>.
</p>


<h3>Author(s)</h3>

<p>Aleš Žiberna
</p>


<h3>References</h3>

<p>Žiberna, A. (2007). Generalized Blockmodeling of Valued Networks. Social Networks, 29(1), 105-126. doi: 10.1016/j.socnet.2006.04.002
</p>
<p>Žiberna, A. (2008). Direct and indirect approaches to blockmodeling of valued networks in terms of regular equivalence. Journal of Mathematical Sociology, 32(1), 57-84. doi: 10.1080/00222500701790207
</p>


<h3>See Also</h3>

<p><code>optRandomParC</code>, <code>optParC</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">n &lt;- 8 # If larger, the number of partitions increases dramatically,
# as does if we increase the number of clusters
net &lt;- matrix(NA, ncol = n, nrow = n)
clu &lt;- rep(1:2, times = c(3, 5))
tclu &lt;- table(clu)
net[clu == 1, clu == 1] &lt;- rnorm(n = tclu[1] * tclu[1], mean = 0, sd = 1)
net[clu == 1, clu == 2] &lt;- rnorm(n = tclu[1] * tclu[2], mean = 4, sd = 1)
net[clu == 2, clu == 1] &lt;- rnorm(n = tclu[2] * tclu[1], mean = 0, sd = 1)
net[clu == 2, clu == 2] &lt;- rnorm(n = tclu[2] * tclu[2], mean = 0, sd = 1)
# Optimizing 10 random partitions with optRandomParC
res &lt;- optRandomParC(M = net, k = 2, rep = 10, approaches = "hom", homFun = "ss", blocks = "com")
plot(res) # Hopefully we get the original partition
funByBlocks(res)
# Computing mean by blocks, ignoring the diagonal (default)

</code></pre>


</div>