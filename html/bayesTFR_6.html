<div class="container">

<table style="width: 100%;"><tr>
<td>bayesTFR.mcmc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
MCMC Simulation Object
</h2>

<h3>Description</h3>

<p>MCMC simulation object <code>bayesTFR.mcmc</code> containing information about one MCMC chain, either from Phase II or Phase III simulation. A set of such objects belonging to the same simulation together with a <code>bayesTFR.mcmc.meta</code> object constitute a <code>bayesTFR.mcmc.set</code> object. 
</p>


<h3>Details</h3>

<p>An object <code>bayesTFR.mcmc</code> points to a place on disk (element <code>output.dir</code>) where MCMC results from all iterations are stored. They can be retrieved to the memory using <code>get.tfr.mcmc(...)</code> (Phase II) or <code>get.tfr3.mcmc(...)</code> (Phase III), and <code>tfr.mcmc(...)</code>. 
</p>
<p>The object is in standard cases not to be manipulated by itself, but rather as part of a <code>bayesTFR.mcmc.set</code> object.
</p>


<h3>Value</h3>

<p>A <code>bayesTFR.mcmc</code> object contains parameters of the Bayesian hierarchical model, more specifically, their values from the last iteration.  If it is a <b>Phase II</b> object these parameters are: <br><code>psi, chi, a_sd, b_sd, const_sd, S_sd, sigma0, mean_eps_tau, sd_eps_tau, Triangle4</code> - non-country specific parameters, containing one value each.<br><code>alpha, delta</code> -  non-country specific parameters, containing three values each.<br><code>U_c, d_c, Triangle_c4</code> - country-specific parameters (1d array).<br><code>gamma_ci</code> - country-specific parameter with three values for each country, i.e. an <code class="reqn">n \times 3</code> matrix where <code class="reqn">n</code> is the number of countries.<br><b>Phase III</b> MCMC objects contain single-value parameters <code>mu</code>, <code>rho</code>, <code>sigma.mu</code>, <code>sigma.rho</code>, <code>sigma.eps</code> and <code class="reqn">n</code>-size vectors <code>mu.c</code> and <code>rho.c</code>.<br>
Furthermore, the object (independent of Phase) contains components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>Total number of iterations the simulation was started with.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>finished.iter</code></td>
<td>
<p>Number of iterations that were finished.  Results from the last finished iteration are stored in the parameters above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>length</code></td>
<td>
<p>Length of the MCMC stored on disk. It differs from <code>finished.iter</code> only if <code>thin</code> is larger than one.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>Thinning interval used when simulating the MCMCs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p>Identifier of this chain.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output.dir</code></td>
<td>
<p>Subdirectory (relative to <code>output.dir</code> in the <code>bayesTFR.mcmc.meta</code> object) where results of this chain are stored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>traces</code></td>
<td>
<p>This is a placeholder for keeping whole parameter traces in the memory.  If the processing operates in a low memory mode, it will be 0.  It can be filled in using the function <code>get.tfr.mcmc(..., low.memory=FALSE)</code>. In such a case, <code>traces</code> is a <code class="reqn">I \times J</code> array where <code class="reqn">I</code> is the MCMC <code>length</code> and <code class="reqn">J</code> is the number of parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>traces.burnin</code></td>
<td>
<p>Burnin used to retrieve the traces, i.e. how many stored iterations are missing from the beginning in the <code>traces</code> array comparing to the ‘raw’ traces on the disk.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rng.state</code></td>
<td>
<p>State of the random number generator at the end of the last finished interation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compression.type</code></td>
<td>
<p>Type of compression of the underlying files.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meta</code></td>
<td>
<p>Object of class <code>bayesTFR.mcmc.meta</code> used for simulation of this chain.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code>run.tfr.mcmc</code>, <code>get.tfr.mcmc</code>, <code>run.tfr3.mcmc</code>, <code>get.tfr3.mcmc</code>, <code>bayesTFR.mcmc.set</code>, <code>bayesTFR.mcmc.meta</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
sim.dir &lt;- file.path(find.package("bayesTFR"), "ex-data", "bayesTFR.output")
# loads traces from one chain
m &lt;- get.tfr.mcmc(sim.dir, low.memory=FALSE, burnin=35, chain.ids=1)
# should have 25 rows, since 60 iterations in total minus 35 burnin
dim(tfr.mcmc(m, 1)$traces)
summary(m, chain.id=1)
## End(Not run)
</code></pre>


</div>