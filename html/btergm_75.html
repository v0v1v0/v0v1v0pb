<div class="container">

<table style="width: 100%;"><tr>
<td>interpret</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Micro-Level Interpretation of (T)ERGMs</h2>

<h3>Description</h3>

<p>Micro-level interpretation of (T)ERGMs.
</p>


<h3>Usage</h3>

<pre><code class="language-R">interpret(object, ...)

## S4 method for signature 'ergm'
interpret(
  object,
  formula = getformula(object),
  coefficients = coef(object),
  target = NULL,
  type = "tie",
  i,
  j
)

## S4 method for signature 'btergm'
interpret(
  object,
  formula = getformula(object),
  coefficients = coef(object),
  target = NULL,
  type = "tie",
  i,
  j,
  t = 1:object@time.steps
)

## S4 method for signature 'mtergm'
interpret(
  object,
  formula = getformula(object),
  coefficients = coef(object),
  target = NULL,
  type = "tie",
  i,
  j,
  t = 1:object@time.steps
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An <code>ergm</code>, <code>btergm</code>, or <code>mtergm</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments to be passed on to subroutines.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>The formula to be used for computing probabilities. By
default, the formula embedded in the model object is retrieved and used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>The estimates on which probabilities should be based. By
default, the coefficients from the model object are retrieved and used.
Custom coefficients can be handed over, for example, in order to compare
versions of the model where the reciprocity term is fixed at <code>0</code>
versus versions of the model where the reciprocity term is left as in the
empirical result. This is one of the examples described in Desmarais and
Cranmer (2012).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target</code></td>
<td>
<p>The response network on which probabilities are based.
Depending on whether the function is applied to an <code>ergm</code> or
<code>btergm</code>/<code>mtergm</code> object, this can be either a single network or
a list of networks. By default, the (list of) network(s) provided as the
left-hand side of the (T)ERGM formula is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>If <code>type = "tie"</code> is used, probabilities at the edge level
are computed. For example, what is the probability of a specific node
<code>i</code> to be connected to a specific node <code>j</code> given the rest of the
network and given the model? If <code>type = "dyad"</code> is used, probabilities
at the dyad level are computed. For example, what is the probability that
node <code>i</code> is connected to node <code>j</code> but not vice-versa, or what is
the probability that nodes <code>i</code> and <code>j</code> and mutually connected in
a directed network? If <code>type = "node"</code> is used, probabilities at the
node level are computed. For example, what is the probability that node
<code>i</code> is connected to a set of three other <code>j</code> nodes given the rest
of the network and the model?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i</code></td>
<td>
<p>A single (sender) node <code>i</code> or a set of (sender) nodes <code>i</code>.
If <code>type = "node"</code> is used, this can be more than one node and should
be provided as a vector. The <code>i</code> argument can be either provided as
the index of the node in the sociomatrix (e.g., the fourth node would be
<code>i = 4</code>) or the row name of the node in the sociomatrix (e.g.,
<code>i = "Peter"</code>). If more than one node is provided and
<code>type = "node"</code>, there can be only one (receiver) node <code>j</code>. The
<code>i</code> and <code>j</code> arguments are used to specify for which nodes
probabilities should be computed. For example, what is the probability that
<code>i = 4</code> is connected to <code>j = 7</code>?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>j</code></td>
<td>
<p>A single (receiver) node <code>j</code> or a set of (receiver) nodes
<code>j</code>. If <code>type = "node"</code> is used, this can be more than one node
and should be provided as a vector. The <code>j</code> argument can be either
provided as the index of the node in the sociomatrix (e.g., the fourth node
would be <code>j = 4</code>) or the column name of the node in the sociomatrix
(e.g., <code>j = "Mary"</code>). If more than one node is provided and
<code>type = "node"</code>, there can be only one (sender) node <code>i</code>. The
<code>i</code> and <code>j</code> arguments are used to specify for which nodes
probabilities should be computed. For example, what is the probability that
<code>i = 4</code> is connected to <code>j = 7</code>?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>
<p>A vector of (numerical) time steps for which the probabilities
should be computed. This only applies to <code>btergm</code> amd <code>mtergm</code>
objects because <code>ergm</code> objects are by definition based on a single
time step. By default, all available time steps are used. It is, for
example, possible to compute probabilities only for a single time step by
specifying, e.g., <code>t = 5</code> in order to compute probabilities for the
fifth response network.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>interpret</code> function facilitates interpretation of ERGMs and TERGMs
at the micro level, as described in Desmarais and Cranmer (2012). There are
methods for <code>ergm</code> objects, <code>btergm</code> objects, and <code>mtergm</code>
objects. The function can be used to interpret these models at the tie or
edge level, dyad level, and block level. For example, what is the probability
that two specific nodes <code>i</code> (the sender) and <code>j</code> (the receiver) are
connected given the rest of the network and given the model? Or what is the
probability that any two nodes are tied at <code>t = 2</code> if they were tied (or
disconnected) at <code>t = 1</code> (i.e., what is the amount of tie stability)?
These tie- or edge-level questions can be answered if the <code>type = "tie"</code>
argument is used.
</p>
<p>Another example: What is the probability that node <code>i</code> has a tie to node
<code>j</code> but not vice-versa? Or that <code>i</code> and <code>j</code> maintain a
reciprocal tie? Or that they are disconnected? How much more or less likely
are <code>i</code> and <code>j</code> reciprocally connected if the <code>mutual</code> term in
the model is fixed at <code>0</code> (compared to the model that includes the
estimated parameter for reciprocity)? See example below. These dyad-level
questions can be answered if the <code>type = "dyad"</code> argument is used.
</p>
<p>Or what is the probability that a specific node <code>i</code> is connected to
nodes <code>j1</code> and <code>j2</code> but not to <code>j5</code> and <code>j7</code>? And how
likely is any node <code>i</code> to be connected to exactly four <code>j</code> nodes?
These node-level questions (focusing on the ties of node <code>i</code> or node
<code>j</code>) can be answered by using the <code>type = "node"</code> argument.
</p>
<p>The typical procedure is to manually enumerate all dyads or
sender-receiver-time combinations with certain properties and repeat the same
thing with some alternative properties for contrasting the two groups. Then
apply the <code>interpret</code> function to the two groups of dyads and compute a
measure of central tendency (e.g., mean or median) and possibly some
uncertainy measure (i.e., confidence intervals) from the distribution of
dyadic probabilities in each group. For example, if there is a gender
attribute, one can sample male-male or female-female dyads, compute the
distributions of edge probabilities for the two sets of dyads, and create
boxplots or barplots with confidence intervals for the two types of dyads in
order to contrast edge probabilities for male versus female same-sex dyads.
</p>
<p>See also the <code>edgeprob</code> function for automatic computation of all
dyadic edge probabilities.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>interpret(ergm)</code>: Interpret method for <code>ergm</code> objects
</p>
</li>
<li> <p><code>interpret(btergm)</code>: Interpret method for <code>btergm</code> objects
</p>
</li>
<li> <p><code>interpret(mtergm)</code>: Interpret method for <code>mtergm</code> objects
</p>
</li>
</ul>
<h3>References</h3>

<p>Desmarais, Bruce A. and Skyler J. Cranmer (2012): Micro-Level Interpretation
of Exponential Random Graph Models with Application to Estuary Networks.
<em>Policy Studies Journal</em> 40(3): 402–434.
<a href="https://doi.org/10.1111/j.1541-0072.2012.00459.x">doi:10.1111/j.1541-0072.2012.00459.x</a>.
</p>
<p>Leifeld, Philip, Skyler J. Cranmer and Bruce A. Desmarais (2017): Temporal
Exponential Random Graph Models with btergm: Estimation and Bootstrap
Confidence Intervals. <em>Journal of Statistical Software</em> 83(6): 1–36.
<a href="https://doi.org/10.18637/jss.v083.i06">doi:10.18637/jss.v083.i06</a>.
</p>
<p>Czarna, Anna Z., Philip Leifeld, Magdalena Smieja, Michael Dufner and Peter
Salovey (2016): Do Narcissism and Emotional Intelligence Win Us Friends?
Modeling Dynamics of Peer Popularity Using Inferential Network Analysis.
<em>Personality and Social Psychology Bulletin</em> 42(11): 1588–1599.
<a href="https://doi.org/10.1177/0146167216666265">doi:10.1177/0146167216666265</a>.
</p>


<h3>See Also</h3>

<p>Other interpretation: 
<code>edgeprob()</code>,
<code>marginalplot()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">##### The following example is a TERGM adaptation of the #####
##### dyad-level example provided in figure 5(c) on page #####
##### 424 of Desmarais and Cranmer (2012) in the PSJ. At #####
##### each time step, it compares dyadic probabilities   #####
##### (no tie, unidirectional tie, and reciprocal tie    #####
##### probability) between a fitted model and a model    #####
##### where the reciprocity effect is fixed at 0 based   #####
##### on 20 randomly selected dyads per time step. The   #####
##### results are visualized using a grouped bar plot.   #####

## Not run: 
  # create toy dataset and fit a model
  networks &lt;- list()
  for (i in 1:3) {           # create 3 random networks with 10 actors
    mat &lt;- matrix(rbinom(100, 1, 0.25), nrow = 10, ncol = 10)
    diag(mat) &lt;- 0           # loops are excluded
    nw &lt;- network(mat)       # create network object
    networks[[i]] &lt;- nw      # add network to the list
  }
  fit &lt;- btergm(networks ~ edges + istar(2) + mutual, R = 200)

  # extract coefficients and create null hypothesis vector
  null &lt;- coef(fit)  # estimated coefs
  null[3] &lt;- 0       # set mutual term = 0

  # sample 20 dyads per time step and compute probability ratios
  probabilities &lt;- matrix(nrow = 9, ncol = length(networks))
  # nrow = 9 because three probabilities + upper and lower CIs
  colnames(probabilities) &lt;- paste("t =", 1:length(networks))
  for (t in 1:length(networks)) {
    d &lt;- dim(as.matrix(networks[[t]]))  # how many row and column nodes?
    size &lt;- d[1] * d[2]                 # size of the matrix
    nw &lt;- matrix(1:size, nrow = d[1], ncol = d[2])
    nw &lt;- nw[lower.tri(nw)]             # sample only from lower triangle b/c
    samp &lt;- sample(nw, 20)              # dyadic probabilities are symmetric
    prob.est.00 &lt;- numeric(0)
    prob.est.01 &lt;- numeric(0)
    prob.est.11 &lt;- numeric(0)
    prob.null.00 &lt;- numeric(0)
    prob.null.01 &lt;- numeric(0)
    prob.null.11 &lt;- numeric(0)
    for (k in 1:20) {
      i &lt;- arrayInd(samp[k], d)[1, 1]   # recover 'i's and 'j's from sample
      j &lt;- arrayInd(samp[k], d)[1, 2]
      # run interpretation function with estimated coefs and mutual = 0:
      int.est &lt;- interpret(fit, type = "dyad", i = i, j = j, t = t)
      int.null &lt;- interpret(fit, coefficients = null, type = "dyad",
                            i = i, j = j, t = t)
      prob.est.00 &lt;- c(prob.est.00, int.est[[1]][1, 1])
      prob.est.11 &lt;- c(prob.est.11, int.est[[1]][2, 2])
      mean.est.01 &lt;- (int.est[[1]][1, 2] + int.est[[1]][2, 1]) / 2
      prob.est.01 &lt;- c(prob.est.01, mean.est.01)
      prob.null.00 &lt;- c(prob.null.00, int.null[[1]][1, 1])
      prob.null.11 &lt;- c(prob.null.11, int.null[[1]][2, 2])
      mean.null.01 &lt;- (int.null[[1]][1, 2] + int.null[[1]][2, 1]) / 2
      prob.null.01 &lt;- c(prob.null.01, mean.null.01)
    }
    prob.ratio.00 &lt;- prob.est.00 / prob.null.00  # ratio of est. and null hyp
    prob.ratio.01 &lt;- prob.est.01 / prob.null.01
    prob.ratio.11 &lt;- prob.est.11 / prob.null.11
    probabilities[1, t] &lt;- mean(prob.ratio.00)   # mean estimated 00 tie prob
    probabilities[2, t] &lt;- mean(prob.ratio.01)   # mean estimated 01 tie prob
    probabilities[3, t] &lt;- mean(prob.ratio.11)   # mean estimated 11 tie prob
    ci.00 &lt;- t.test(prob.ratio.00, conf.level = 0.99)$conf.int
    ci.01 &lt;- t.test(prob.ratio.01, conf.level = 0.99)$conf.int
    ci.11 &lt;- t.test(prob.ratio.11, conf.level = 0.99)$conf.int
    probabilities[4, t] &lt;- ci.00[1]              # lower 00 conf. interval
    probabilities[5, t] &lt;- ci.01[1]              # lower 01 conf. interval
    probabilities[6, t] &lt;- ci.11[1]              # lower 11 conf. interval
    probabilities[7, t] &lt;- ci.00[2]              # upper 00 conf. interval
    probabilities[8, t] &lt;- ci.01[2]              # upper 01 conf. interval
    probabilities[9, t] &lt;- ci.11[2]              # upper 11 conf. interval
  }

  # create barplots from probability ratios and CIs
  require("gplots")
  bp &lt;- barplot2(probabilities[1:3, ], beside = TRUE, plot.ci = TRUE,
                 ci.l = probabilities[4:6, ], ci.u = probabilities[7:9, ],
                 col = c("tan", "tan2", "tan3"), ci.col = "grey40",
                 xlab = "Dyadic tie values", ylab = "Estimated Prob./Null Prob.")
  mtext(1, at = bp, text = c("(0,0)", "(0,1)", "(1,1)"), line = 0, cex = 0.5)


  ##### The following examples illustrate the behavior of  #####
  ##### the interpret function with undirected and/or      #####
  ##### bipartite graphs with or without structural zeros. #####

  library("statnet")
  library("btergm")

  # micro-level interpretation for undirected network with structural zeros
  set.seed(12345)
  mat &lt;- matrix(rbinom(400, 1, 0.1), nrow = 20, ncol = 20)
  mat[1, 5] &lt;- 1
  mat[10, 7] &lt;- 1
  mat[15, 3] &lt;- 1
  mat[18, 4] &lt; 1
  nw &lt;- network(mat, directed = FALSE, bipartite = FALSE)
  cv &lt;- matrix(rnorm(400), nrow = 20, ncol = 20)
  offsetmat &lt;- matrix(rbinom(400, 1, 0.1), nrow = 20, ncol = 20)
  offsetmat[1, 5] &lt;- 1
  offsetmat[10, 7] &lt;- 1
  offsetmat[15, 3] &lt;- 1
  offsetmat[18, 4] &lt; 1
  model &lt;- ergm(nw ~ edges + kstar(2) + edgecov(cv) + offset(edgecov(offsetmat)),
                offset.coef = -Inf)
  summary(model)

  # tie-level interpretation (note that dyad interpretation would not make any
  # sense in an undirected network):
  interpret(model, type = "tie", i = 1, j = 2)  # 0.28 (= normal dyad)
  interpret(model, type = "tie", i = 1, j = 5)  # 0.00 (= structural zero)

  # node-level interpretation; note the many 0 probabilities due to the
  # structural zeros; also note the warning message that the probabilities may
  # be slightly imprecise because -Inf needs to be approximated by some large
  # negative number (-9e8):
  interpret(model, type = "node", i = 1, j = 3:5)

  # repeat the same exercise for a directed network
  nw &lt;- network(mat, directed = TRUE, bipartite = FALSE)
  model &lt;- ergm(nw ~ edges + istar(2) + edgecov(cv) + offset(edgecov(offsetmat)),
                offset.coef = -Inf)
  interpret(model, type = "tie", i = 1, j = 2)  # 0.13 (= normal dyad)
  interpret(model, type = "tie", i = 1, j = 5)  # 0.00 (= structural zero)
  interpret(model, type = "dyad", i = 1, j = 2)  # results for normal dyad
  interpret(model, type = "dyad", i = 1, j = 5)  # results for i-&gt;j struct. zero
  interpret(model, type = "node", i = 1, j = 3:5)

  # micro-level interpretation for bipartite graph with structural zeros
  set.seed(12345)
  mat &lt;- matrix(rbinom(200, 1, 0.1), nrow = 20, ncol = 10)
  mat[1, 5] &lt;- 1
  mat[10, 7] &lt;- 1
  mat[15, 3] &lt;- 1
  mat[18, 4] &lt; 1
  nw &lt;- network(mat, directed = FALSE, bipartite = TRUE)
  cv &lt;- matrix(rnorm(200), nrow = 20, ncol = 10)  # some covariate
  offsetmat &lt;- matrix(rbinom(200, 1, 0.1), nrow = 20, ncol = 10)
  offsetmat[1, 5] &lt;- 1
  offsetmat[10, 7] &lt;- 1
  offsetmat[15, 3] &lt;- 1
  offsetmat[18, 4] &lt; 1
  model &lt;- ergm(nw ~ edges + b1star(2) + edgecov(cv)
                + offset(edgecov(offsetmat)), offset.coef = -Inf)
  summary(model)

  # tie-level interpretation; note the index for the second mode starts with 21
  interpret(model, type = "tie", i = 1, j = 21)

  # dyad-level interpretation does not make sense because network is undirected;
  # node-level interpretation prints warning due to structural zeros, but
  # computes the correct probabilities (though slightly imprecise because -Inf
  # is approximated by some small number:
  interpret(model, type = "node", i = 1, j = 21:25)

  # compute all dyadic probabilities
  dyads &lt;- edgeprob(model)
  dyads

## End(Not run)

</code></pre>


</div>