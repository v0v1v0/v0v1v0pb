<div class="container">

<table style="width: 100%;"><tr>
<td>n</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Neural Networks for BAMLSS</h2>

<h3>Description</h3>

<p>This smooth constructor implements single hidden layer neural networks.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## The neural network smooth constructor.
n(..., k = 10, type = 2)

## Initialize weights.
n.weights(nodes, k, r = NULL, s = NULL,
  type = c("sigmoid", "gauss", "softplus", "cos", "sin"),
  x = NULL, ...)

## Second weights initializer, internally calls n.weights.
make_weights(object, data, dropout = 0.2)

## Boosted neural net predictions.
predictn(object, newdata, model = NULL,
  mstop = NULL, type = c("link", "parameter"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>For function <code>n()</code> a formula of the type <code>~x1+x2+x3</code> that specifies
the covariates that should be modeled by the neural network. For function <code>predictn()</code>,
arguments to be passed to <code>predict.bamlss</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>For function <code>n()</code>, the number of hidden nodes of the network. Note that one can set
an argument <code>split = TRUE</code> to split up the neural network into, e.g., <code>nsplit = 5</code>
parts with <code>k</code> nodes each. For function <code>n.weights()</code>, argument <code>k</code>
is the number of input variables of the network (number of covariates).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Integer. Type <code>1</code> fits a complete network in each boosting iteration, <code>type = 2</code> selects
the best fitting node in each boosting iteration. for function <code>n.weights()</code>, the type of
activation function that should be used. For function <code>predictn()</code>, the type of prediction
that should be computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nodes</code></td>
<td>
<p>Number of nodes for each layer, i.e., can also be a vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r, s</code></td>
<td>
<p>Parameters controlling the shape of the activation functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A scaled covariate matrix, the data will be used to identify the range of the weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object, data</code></td>
<td>
<p>See <code>smooth.construct</code>. For function <code>predictn()</code>,
a boosted <code>"bamlss"</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dropout</code></td>
<td>
<p>The fraction of inner weights that should be set to zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>The data frame that should be used for prediction.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>For which parameter of the distribution predictions should be computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mstop</code></td>
<td>
<p>The stopping iteration for which predictions should be computed. The default
is to return a matrix of predictions, each column represents the prediction of one
boosting iteration.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Function <code>n()</code>, similar to function <code>s</code> a simple smooth specification
object.
</p>


<h3>See Also</h3>

<p><code>bamlss</code>, <code>predict.bamlss</code>, <code>bfit</code>, <code>boost</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## ... coming soon ...!
</code></pre>


</div>