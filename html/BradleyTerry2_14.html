<div class="container">

<table style="width: 100%;"><tr>
<td>GenDavidson</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Specify a Generalised Davidson Term in a gnm Model Formula</h2>

<h3>Description</h3>

<p>GenDavidson is a function of class <code>"nonlin"</code> to specify a generalised
Davidson term in the formula argument to <code>gnm::gnm()</code>, providing a
model for paired comparison data where ties are a possible outcome.
</p>


<h3>Usage</h3>

<pre><code class="language-R">GenDavidson(
  win,
  tie,
  loss,
  player1,
  player2,
  home.adv = NULL,
  tie.max = ~1,
  tie.mode = NULL,
  tie.scale = NULL,
  at.home1 = NULL,
  at.home2 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>win</code></td>
<td>
<p>a logical vector: <code>TRUE</code> if player1 wins, <code>FALSE</code>
otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tie</code></td>
<td>
<p>a logical vector: <code>TRUE</code> if the outcome is a tie,
<code>FALSE</code> otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loss</code></td>
<td>
<p>a logical vector: <code>TRUE</code> if player1 loses, <code>FALSE</code>
otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>player1</code></td>
<td>
<p>an ID factor specifying the first player in each contest,
with the same set of levels as <code>player2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>player2</code></td>
<td>
<p>an ID factor specifying the second player in each contest,
with the same set of levels as <code>player2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>home.adv</code></td>
<td>
<p>a formula for the parameter corresponding to the home
advantage effect. If <code>NULL</code>, no home advantage effect is estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tie.max</code></td>
<td>
<p>a formula for the parameter corresponding to the maximum tie
probability.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tie.mode</code></td>
<td>
<p>a formula for the parameter corresponding to the location of
maximum tie probability, in terms of the probability that <code>player1</code>
wins, given the outcome is not a draw.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tie.scale</code></td>
<td>
<p>a formula for the parameter corresponding to the scale of
dependence of the tie probability on the probability that <code>player1</code>
wins, given the outcome is not a draw.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>at.home1</code></td>
<td>
<p>a logical vector: <code>TRUE</code> if <code>player1</code> is at home,
<code>FALSE</code> otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>at.home2</code></td>
<td>
<p>a logical vector: <code>TRUE</code> if <code>player2</code> is at home,
<code>FALSE</code> otherwise.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>GenDavidson</code> specifies a generalisation of the Davidson model (1970)
for paired comparisons where a tie is a possible outcome. It is designed for
modelling trinomial counts corresponding to the win/draw/loss outcome for
each contest, which are assumed Poisson conditional on the total count for
each match. Since this total must be one, the expected counts are
equivalently the probabilities for each possible outcome, which are modelled
on the log scale: </p>
<p style="text-align: center;"><code class="reqn">\log(p(i \textrm{beats} j)_k) = \theta_{ijk} +
\log(\mu\alpha_i</code>
</p>

<p style="text-align: center;"><code class="reqn">\log(p(draw)_k) = \theta_{ijk} + \delta + c + </code>
</p>
<p style="text-align: center;"><code class="reqn">
\sigma(\pi\log(\mu\alpha_i) - (1 - \pi)log(\alpha_j)) + </code>
</p>
<p style="text-align: center;"><code class="reqn"> (1 -
\sigma)(\log(\mu\alpha_i + \alpha_j))</code>
</p>
 <p style="text-align: center;"><code class="reqn">\log(p(j \textrm{beats}
i)_k) = \theta_{ijk} + </code>
</p>
<p style="text-align: center;"><code class="reqn"> log(\alpha_j)</code>
</p>
<p> Here <code class="reqn">\theta_{ijk}</code> is a structural parameter
to fix the trinomial totals; <code class="reqn">\mu</code> is the home advantage parameter;
<code class="reqn">\alpha_i</code> and <code class="reqn">\alpha_j</code> are the abilities of
players <code class="reqn">i</code> and <code class="reqn">j</code> respectively; <code class="reqn">c</code> is a function of the
parameters such that <code class="reqn">\textrm{expit}(\delta)</code> is the
maximum probability of a tie, <code class="reqn">\sigma</code> scales the dependence of
the probability of a tie on the relative abilities and <code class="reqn">\pi</code> allows
for asymmetry in this dependence.
</p>
<p>For parameters that must be positive (<code class="reqn">\alpha_i, \sigma, \mu</code>), the log is estimated, while for parameters that must be between
zero and one (<code class="reqn">\delta, \pi</code>), the logit is estimated, as illustrated in
the example.
</p>


<h3>Value</h3>

<p>A list with the anticipated components of a "nonlin" function:
</p>
<table>
<tr style="vertical-align: top;">
<td><code> predictors </code></td>
<td>
<p> the formulae for the different parameters and the ID
factors for player 1 and player 2. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> variables </code></td>
<td>
<p> the outcome
variables and the “at home” variables, if specified.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> common
</code></td>
<td>
<p> an index to specify that common effects are to be estimated for the
players. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> term </code></td>
<td>
<p> a function to create a deparsed mathematical
expression of the term, given labels for the predictors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> start </code></td>
<td>
<p> a
function to generate starting values for the parameters.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Heather Turner
</p>


<h3>References</h3>

<p>Davidson, R. R. (1970). On extending the Bradley-Terry model to
accommodate ties in paired comparison experiments. <em>Journal of the
American Statistical Association</em>, <strong>65</strong>, 317–328.
</p>


<h3>See Also</h3>

<p><code>football()</code>, <code>plotProportions()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
### example requires gnm
if (require(gnm)) {
    ### convert to trinomial counts
    football.tri &lt;- expandCategorical(football, "result", idvar = "match")
    head(football.tri)

    ### add variable to indicate whether team playing at home
    football.tri$at.home &lt;- !logical(nrow(football.tri))

    ### fit shifted &amp; scaled Davidson model
    ###  - subset to first and last season for illustration
    shifScalDav &lt;- gnm(count ~
        GenDavidson(result == 1, result == 0, result == -1,
                    home:season, away:season, home.adv = ~1,
                    tie.max = ~1, tie.scale = ~1, tie.mode = ~1,
                    at.home1 = at.home,
                    at.home2 = !at.home) - 1,
        eliminate = match, family = poisson, data = football.tri,
        subset = season %in% c("2008-9", "2012-13"))

    ### look at coefs
    coef &lt;- coef(shifScalDav)
    ## home advantage
    exp(coef["home.adv"])
    ## max p(tie)
    plogis(coef["tie.max"])
    ## mode p(tie)
    plogis(coef["tie.mode"])
    ## scale relative to Davidson of dependence of p(tie) on p(win|not a draw)
    exp(coef["tie.scale"])

    ### check model fit
    alpha &lt;- names(coef[-(1:4)])
    plotProportions(result == 1, result == 0, result == -1,
                    home:season, away:season,
                    abilities = coef[alpha], home.adv = coef["home.adv"],
                    tie.max = coef["tie.max"], tie.scale = coef["tie.scale"],
                    tie.mode = coef["tie.mode"],
                    at.home1 = at.home, at.home2 = !at.home,
                    data = football.tri, subset = count == 1)
}

### analyse all five seasons
### - takes a little while to run, particularly likelihood ratio tests
## Not run: 
### fit Davidson model
Dav &lt;- gnm(count ~ GenDavidson(result == 1, result == 0, result == -1,
                               home:season, away:season, home.adv = ~1,
                               tie.max = ~1,
                               at.home1 = at.home,
                               at.home2 = !at.home) - 1,
           eliminate = match, family = poisson, data = football.tri)

### fit scaled Davidson model
scalDav &lt;- gnm(count ~ GenDavidson(result == 1, result == 0, result == -1,
                                  home:season, away:season, home.adv = ~1,
                                  tie.max = ~1, tie.scale = ~1,
                                  at.home1 = at.home,
                                  at.home2 = !at.home) - 1,
               eliminate = match, family = poisson, data = football.tri)

### fit shifted &amp; scaled Davidson model
shifScalDav &lt;- gnm(count ~
    GenDavidson(result == 1, result == 0, result == -1,
                home:season, away:season, home.adv = ~1,
                tie.max = ~1, tie.scale = ~1, tie.mode = ~1,
                at.home1 = at.home,
                at.home2 = !at.home) - 1,
    eliminate = match, family = poisson, data = football.tri)

### compare models
anova(Dav, scalDav, shifScalDav, test = "Chisq")

### diagnostic plots
main &lt;- c("Davidson", "Scaled Davidson", "Shifted &amp; Scaled Davidson")
mod &lt;- list(Dav, scalDav, shifScalDav)
names(mod) &lt;- main

## use football.tri data so that at.home can be found,
## but restrict to actual match results
par(mfrow = c(2,2))
for (i in 1:3) {
    coef &lt;- parameters(mod[[i]])
    plotProportions(result == 1, result == 0, result == -1,
                    home:season, away:season,
                    abilities = coef[alpha],
                    home.adv = coef["home.adv"],
                    tie.max = coef["tie.max"],
                    tie.scale = coef["tie.scale"],
                    tie.mode = coef["tie.mode"],
                    at.home1 = at.home,
                    at.home2 = !at.home,
                    main = main[i],
                    data = football.tri, subset = count == 1)
}

## End(Not run)

</code></pre>


</div>