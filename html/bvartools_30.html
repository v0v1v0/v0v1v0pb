<div class="container">

<table style="width: 100%;"><tr>
<td>kalman_dk</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Durbin and Koopman Simulation Smoother</h2>

<h3>Description</h3>

<p>An implementation of the Kalman filter and backward smoothing
algorithm proposed by Durbin and Koopman (2002).
</p>


<h3>Usage</h3>

<pre><code class="language-R">kalman_dk(y, z, sigma_u, sigma_v, B, a_init, P_init)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a <code class="reqn">K \times T</code> matrix of endogenous variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>a <code class="reqn">KT \times M</code> matrix of explanatory variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma_u</code></td>
<td>
<p>the constant <code class="reqn">K \times K</code> error variance-covariance matrix.
For time varying variance-covariance matrices a <code class="reqn">KT \times K</code> can be specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma_v</code></td>
<td>
<p>the constant <code class="reqn">M \times M</code> coefficient variance-covariance matrix.
For time varying variance-covariance matrices a <code class="reqn">MT \times M</code> can be specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>an <code class="reqn">M \times M</code> autocorrelation matrix of the transition equation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a_init</code></td>
<td>
<p>an M-dimensional vector of initial states.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>P_init</code></td>
<td>
<p>an <code class="reqn">M \times M</code> variance-covariance matrix of the initial states.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function uses algorithm 2 from Durbin and Koopman (2002) to produce
a draw of the state vector <code class="reqn">a_t</code> for <code class="reqn">t = 1,...,T</code> for a state space model
with measurement equation
</p>
<p style="text-align: center;"><code class="reqn">y_t = Z_t a_t + u_t</code>
</p>

<p>and transition equation 
</p>
<p style="text-align: center;"><code class="reqn">a_{t + 1} = B_t a_{t} + v_t,</code>
</p>

<p>where <code class="reqn">u_t \sim N(0, \Sigma_{u,t})</code> and <code class="reqn">v_t \sim N(0, \Sigma_{v,t})</code>.
<code class="reqn">y_t</code> is a K-dimensional vector of endogenous variables and
<code class="reqn">Z_t = z_t^{\prime} \otimes I_K</code> is a <code class="reqn">K \times M</code> matrix of regressors with
<code class="reqn">z_t</code> as a vector of regressors.
</p>
<p>The algorithm takes into account Jarociński (2015), where a possible missunderstanding
in the implementation of the algorithm of Durbin and Koopman (2002) is pointed out. Following
that note the function sets the mean of the initial state to zero in the first step of the algorithm.
</p>


<h3>Value</h3>

<p>A <code class="reqn">M \times T+1</code> matrix of state vector draws.
</p>


<h3>References</h3>

<p>Durbin, J., &amp; Koopman, S. J. (2002). A simple and efficient simulation smoother for
state space time series analysis. <em>Biometrika, 89</em>(3), 603–615.
</p>
<p>Jarociński, M. (2015). A note on implementing the Durbin and Koopman simulation
smoother. <em>Computational Statistics and Data Analysis, 91</em>, 1–3.
<a href="https://doi.org/10.1016/j.csda.2015.05.001">doi:10.1016/j.csda.2015.05.001</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Load data
data("e1")
data &lt;- diff(log(e1))

# Generate model data
temp &lt;- gen_var(data, p = 2, deterministic = "const")
y &lt;- t(temp$data$Y)
z &lt;- temp$data$SUR
k &lt;- nrow(y)
tt &lt;- ncol(y)
m &lt;- ncol(z)

# Priors
a_mu_prior &lt;- matrix(0, m)
a_v_i_prior &lt;- diag(0.1, m)

a_Q &lt;- diag(.0001, m)

# Initial value of Sigma
sigma &lt;- tcrossprod(y) / tt
sigma_i &lt;- solve(sigma)

# Initial values for Kalman filter
y_init &lt;- y * 0
a_filter &lt;- matrix(0, m, tt + 1)

# Initialise the Kalman filter
for (i in 1:tt) {
  y_init[, i] &lt;- y[, i] - z[(i - 1) * k + 1:k,] %*% a_filter[, i]
}
a_init &lt;- post_normal_sur(y = y_init, z = z, sigma_i = sigma_i,
                          a_prior = a_mu_prior, v_i_prior = a_v_i_prior)
y_filter &lt;- matrix(y) - z %*% a_init
y_filter &lt;- matrix(y_filter, k) # Reshape

# Kalman filter and backward smoother
a_filter &lt;- kalman_dk(y = y_filter, z = z, sigma_u = sigma,
                      sigma_v = a_Q, B = diag(1, m),
                      a_init = matrix(0, m), P_init = a_Q)
                      
a &lt;- a_filter + matrix(a_init, m, tt + 1)

</code></pre>


</div>