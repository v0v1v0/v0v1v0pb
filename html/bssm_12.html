<div class="container">

<table style="width: 100%;"><tr>
<td>bootstrap_filter</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bootstrap Filtering</h2>

<h3>Description</h3>

<p>Function <code>bootstrap_filter</code> performs a bootstrap filtering with
stratification resampling.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bootstrap_filter(model, particles, ...)

## S3 method for class 'lineargaussian'
bootstrap_filter(
  model,
  particles,
  seed = sample(.Machine$integer.max, size = 1),
  ...
)

## S3 method for class 'nongaussian'
bootstrap_filter(
  model,
  particles,
  seed = sample(.Machine$integer.max, size = 1),
  ...
)

## S3 method for class 'ssm_nlg'
bootstrap_filter(
  model,
  particles,
  seed = sample(.Machine$integer.max, size = 1),
  ...
)

## S3 method for class 'ssm_sde'
bootstrap_filter(
  model,
  particles,
  L,
  seed = sample(.Machine$integer.max, size = 1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>A model object of class <code>bssm_model</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>particles</code></td>
<td>
<p>Number of particles as a positive integer. Suitable values
depend on the model and the data, and while larger values provide more
accurate estimates, the run time also increases with respect to the
number of particles, so it is generally a good idea to test the filter first
with a small number of particles, e.g., less than 100.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Seed for the C++ RNG (positive integer).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p>Positive integer defining the discretization level for SDE models.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>List with samples (<code>alpha</code>) from the filtering distribution and
corresponding weights (<code>weights</code>), as well as filtered and predicted
states and corresponding covariances (<code>at</code>, <code>att</code>, <code>Pt</code>,
<code>Ptt</code>), and estimated log-likelihood (<code>logLik</code>).
</p>


<h3>References</h3>

<p>Gordon, NJ, Salmond, DJ, Smith, AFM (1993) Novel approach to
nonlinear/non-Gaussian Bayesian state estimation. IEE Proceedings F,
140(2), p. 107-113.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1)
x &lt;- cumsum(rnorm(50))
y &lt;- rnorm(50, x, 0.5) 
model &lt;- bsm_lg(y, sd_y = 0.5, sd_level = 1, P1 = 1)
  
out &lt;- bootstrap_filter(model, particles = 1000)
ts.plot(cbind(y, x, out$att), col = 1:3)
ts.plot(cbind(kfilter(model)$att, out$att), col = 1:3)

data("poisson_series")
model &lt;- bsm_ng(poisson_series, sd_level = 0.1, sd_slope = 0.01, 
  P1 = diag(1, 2), distribution = "poisson")
  
out &lt;- bootstrap_filter(model, particles = 100)
ts.plot(cbind(poisson_series, exp(out$att[, 1])), col = 1:2)

</code></pre>


</div>