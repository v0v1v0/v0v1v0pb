<div class="container">

<table style="width: 100%;"><tr>
<td>predict.mcmc_output</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Predictions for State Space Models</h2>

<h3>Description</h3>

<p>Draw samples from the posterior predictive distribution for future
time points given the posterior draws of hyperparameters <code class="reqn">\theta</code> and
latent state <code class="reqn">alpha_{n+1}</code> returned by <code>run_mcmc</code>.
Function can also be used to draw samples from the posterior predictive
distribution <code class="reqn">p(\tilde y_1, \ldots, \tilde y_n | y_1,\ldots, y_n)</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'mcmc_output'
predict(
  object,
  model,
  nsim,
  type = "response",
  future = TRUE,
  seed = sample(.Machine$integer.max, size = 1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>Results object of class <code>mcmc_output</code> from
<code>run_mcmc</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>A <code>bssm_model</code> object.
Should have same structure and class as the original model which was used in
<code>run_mcmc</code>, in order to plug the posterior samples of the model
parameters to the right places.
It is also possible to input the original model for obtaining predictions
for past time points. In this case, set argument
<code>future</code> to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>
<p>Positive integer defining number of samples to draw. Should be
less than or equal to <code>sum(object$counts)</code> i.e. the number of samples
in the MCMC output. Default is to use all the samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Type of predictions. Possible choices are
<code>"mean"</code> <code>"response"</code>, or  <code>"state"</code> level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>future</code></td>
<td>
<p>Default is <code>TRUE</code>, in which case predictions are for the
future, using posterior samples of (theta, alpha_T+1) i.e. the
posterior samples of hyperparameters and latest states.
Otherwise it is assumed that <code>model</code> corresponds to the original model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Seed for the C++ RNG (positive integer). Note that this affects
only the C++ side, and <code>predict</code> also uses R side RNG for subsampling,
so for replicable results you should call <code>set.seed</code> before
<code>predict</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Ignored.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A data.frame consisting of samples from the predictive
posterior distribution.
</p>


<h3>See Also</h3>

<p><code>fitted</code> for in-sample predictions.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library("graphics")
y &lt;- log10(JohnsonJohnson)
prior &lt;- uniform(0.01, 0, 1)
model &lt;- bsm_lg(window(y, end = c(1974, 4)), sd_y = prior,
  sd_level = prior, sd_slope = prior, sd_seasonal = prior)

mcmc_results &lt;- run_mcmc(model, iter = 5000)
future_model &lt;- model
future_model$y &lt;- ts(rep(NA, 25), 
  start = tsp(model$y)[2] + 2 * deltat(model$y), 
  frequency = frequency(model$y))
# use "state" for illustrative purposes, we could use type = "mean" directly
pred &lt;- predict(mcmc_results, model = future_model, type = "state", 
  nsim = 1000)

library("dplyr")
sumr_fit &lt;- as.data.frame(mcmc_results, variable = "states") |&gt;
  group_by(time, iter) |&gt; 
  mutate(signal = 
      value[variable == "level"] + 
      value[variable == "seasonal_1"]) |&gt;
  group_by(time) |&gt;
  summarise(mean = mean(signal), 
    lwr = quantile(signal, 0.025), 
    upr = quantile(signal, 0.975))

sumr_pred &lt;- pred |&gt; 
  group_by(time, sample) |&gt;
  mutate(signal = 
      value[variable == "level"] + 
      value[variable == "seasonal_1"]) |&gt;
  group_by(time) |&gt;
  summarise(mean = mean(signal),
    lwr = quantile(signal, 0.025), 
    upr = quantile(signal, 0.975)) 
    
# If we used type = "mean", we could do
# sumr_pred &lt;- pred |&gt; 
#   group_by(time) |&gt;
#   summarise(mean = mean(value),
#     lwr = quantile(value, 0.025), 
#     upr = quantile(value, 0.975)) 
    
library("ggplot2")
rbind(sumr_fit, sumr_pred) |&gt; 
  ggplot(aes(x = time, y = mean)) + 
  geom_ribbon(aes(ymin = lwr, ymax = upr), 
   fill = "#92f0a8", alpha = 0.25) +
  geom_line(colour = "#92f0a8") +
  theme_bw() + 
  geom_point(data = data.frame(
    mean = log10(JohnsonJohnson), 
    time = time(JohnsonJohnson)))

# Posterior predictions for past observations:
yrep &lt;- predict(mcmc_results, model = model, type = "response", 
  future = FALSE, nsim = 1000)
meanrep &lt;- predict(mcmc_results, model = model, type = "mean", 
  future = FALSE, nsim = 1000)
  
sumr_yrep &lt;- yrep |&gt; 
  group_by(time) |&gt;
  summarise(earnings = mean(value),
    lwr = quantile(value, 0.025), 
    upr = quantile(value, 0.975)) |&gt;
  mutate(interval = "Observations")

sumr_meanrep &lt;- meanrep |&gt; 
  group_by(time) |&gt;
  summarise(earnings = mean(value),
    lwr = quantile(value, 0.025), 
    upr = quantile(value, 0.975)) |&gt;
  mutate(interval = "Mean")
    
rbind(sumr_meanrep, sumr_yrep) |&gt; 
  mutate(interval = 
    factor(interval, levels = c("Observations", "Mean"))) |&gt;
  ggplot(aes(x = time, y = earnings)) + 
  geom_ribbon(aes(ymin = lwr, ymax = upr, fill = interval), 
   alpha = 0.75) +
  theme_bw() + 
  geom_point(data = data.frame(
    earnings = model$y, 
    time = time(model$y)))    


</code></pre>


</div>