<div class="container">

<table style="width: 100%;"><tr>
<td>plotblock</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Factor Variable and Random Effects Plots
</h2>

<h3>Description</h3>

<p>Function to plot effects for model terms including factor, or group variables for random effects.
</p>


<h3>Usage</h3>

<pre><code class="language-R">plotblock(x, residuals = FALSE, range = c(0.3, 0.3), 
  col.residuals = "black", col.lines = "black", c.select = NULL, 
  fill.select = NULL , col.polygons = NULL, data = NULL,
  shift = NULL, trans = NULL, labels = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Either a <code>list</code> of length of the unique factors, where each <code>list</code> element 
contains the estimated effects for one factor as a matrix, or 
one data matrix with first column as the group or factor variable. Also formulas are accepted, 
e.g it is possible to specify the plot with <code>f ~ x</code> or <code>f1 + f2 ~ x</code>. By convention, 
the covariate for which effects should be plotted, is always in the first column in the 
resulting data matrix, that is used for plotting, i.e. in the second formula example, the data 
matrix is <code>cbind(x, f1, f2)</code>, also see argument <code>c.select</code> and <code>fill.select</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>If set to <code>TRUE</code>, residuals will be plotted if available. Residuals may be
set as an <code>attr</code>ibute of <code>x</code> named 
<code>"residuals"</code>, where the residuals must be a matrix with first column 
specifying the covariate, and second column the residuals that should be plotted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>range</code></td>
<td>
<p>Numeric vector, specifying the left and right bound of the block.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.residuals</code></td>
<td>
<p>The color of the partial residuals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.lines</code></td>
<td>
<p>Vector of maximum length of columns of <code>x</code> minus 1, specifying the color of 
the lines.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.select</code></td>
<td>
<p>Integer vector of maximum length of columns of <code>x</code>, selects the 
columns of the resulting data matrix that should be used for plotting. E.g. if <code>x</code> has 5 
columns, then <code>c.select = c(1, 2, 5)</code> will select column 1, 2 and 5 for plotting. Note that 
first element of <code>c.select</code> should always be 1, since this is the column of the covariate 
the effect is plotted for.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill.select</code></td>
<td>
<p>Integer vector, select pairwise the columns of the resulting data matrix 
that should form one polygon with a certain background color specified in argument <code>col</code>. 
E.g. <code>x</code> has three columns, or is specified with formula <code>f1 + f2 ~ x</code>, then setting 
<code>fill.select = c(0, 1, 1)</code> will draw a polygon with <code>f1</code> and <code>f2</code> as boundaries. 
If <code>x</code> has five columns or the formula is e.g. <code>f1 + f2 + f3 + f4 ~ x</code>, then setting
<code>fill.select = c(0, 1, 1, 2, 2)</code>, the pairs <code>f1</code>, <code>f2</code> and <code>f3</code>, <code>f4</code>
are selected to form two polygons.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.polygons</code></td>
<td>
<p>Specify the background color for the upper and lower confidence bands, e.g. 
<code>col = c("green", "red")</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>If <code>x</code> is a formula, a <code>data.frame</code> or <code>list</code>. By default the variables 
are taken from <code>environment(x)</code>: typically the environment from which <code>plotblock</code> is 
called.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shift</code></td>
<td>
<p>Numeric constant to be added to the smooth before plotting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trans</code></td>
<td>
<p>Function to be applied to the smooth before plotting, e.g., to transform the
plot to the response scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels</code></td>
<td>
<p>Character, labels for the factor levels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Graphical parameters, please see the details.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Function <code>plotblock</code> draws for every factor or group the effect as a "block" in one graphic, 
i.e., similar to boxplots, estimated fitted effects, e.g., containing quantiles of MCMC samples,
are drawn as one block, where the upper lines represent upper quantiles, the 
middle line the mean or median, and lower lines lower quantiles, also see the examples. The 
following graphical parameters may be supplied additionally:
</p>

<ul>
<li> <p><code>cex</code>: Specify the size of partial residuals,
</p>
</li>
<li> <p><code>lty</code>: The line type for each column that is plotted, e.g. <code>lty = c(1, 2)</code>,
</p>
</li>
<li> <p><code>lwd</code>: The line width for each column that is plotted, e.g. <code>lwd = c(1, 2)</code>,
</p>
</li>
<li> <p><code>poly.lty</code>: The line type to be used for the polygons,
</p>
</li>
<li> <p><code>poly.lwd</code>: The line width to be used for the polygons,
</p>
</li>
<li> <p><code>density</code> <code>angle</code>, <code>border</code>: See <code>polygon</code>,
</p>
</li>
<li> <p><code>...</code>: Other graphical parameters, see function <code>plot</code>.
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>plot2d</code>, <code>plot3d</code>,
<code>plotmap</code>, <code>sliceplot</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Generate some data.
set.seed(111)
n &lt;- 500

## Regressors.
d &lt;- data.frame(fac = factor(rep(1:10, n/10)))

## Response.
d$y &lt;- with(d, 1.5 + rnorm(10, sd = 0.6)[fac] + 
  rnorm(n, sd = 0.6))

## Not run: ## Estimate model.
b &lt;- bamlss(y ~ s(fac,bs="re"), data = d)
summary(b)

## Plot random effects.
plot(b)

## Extract fitted values.
f &lt;- fitted(b, model = "mu", term = "fac")
f &lt;- cbind(d["fac"], f)

## Now use plotblock.
plotblock(f)

## Variations.
plotblock(f, fill.select = c(0, 1, 0, 1), col.poly = "red")
plotblock(f, fill.select = c(0, 1, 0, 1), col.poly = "lightgray",
  lty = c(2, 1, 2), lwd = c(2, 1, 2))

## End(Not run)

## More examples.
plotblock(y ~ fac, data = d, range = c(0.45, 0.45))

d &lt;- data.frame(fac = factor(rep(1:10, n/10)))
d$y &lt;- with(d, c(2.67, 5, 6, 3, 4, 2, 6, 7, 9, 7.5)[fac])
plotblock(y ~ fac, data = d)
plotblock(cbind(y - 0.1, y + 0.1) ~ fac, data = d)
</code></pre>


</div>