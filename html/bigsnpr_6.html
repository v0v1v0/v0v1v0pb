<div class="container">

<table style="width: 100%;"><tr>
<td>snp_autoSVD</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Truncated SVD while limiting LD</h2>

<h3>Description</h3>

<p>Fast truncated SVD with initial pruning and that iteratively removes
long-range LD regions. Some variants are removing due to the initial clumping,
then more and more variants are removed at each iteration. You can access the
indices of the remaining variants with <code style="white-space: pre;">⁠attr(*, "subset")⁠</code>. If some of the
variants removed are contiguous, the regions are reported in <code style="white-space: pre;">⁠attr(*, "lrldr")⁠</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">snp_autoSVD(
  G,
  infos.chr,
  infos.pos = NULL,
  ind.row = rows_along(G),
  ind.col = cols_along(G),
  fun.scaling = snp_scaleBinom(),
  thr.r2 = 0.2,
  size = 100/thr.r2,
  k = 10,
  roll.size = 50,
  int.min.size = 20,
  alpha.tukey = 0.05,
  min.mac = 10,
  min.maf = 0.02,
  max.iter = 5,
  is.size.in.bp = NULL,
  ncores = 1,
  verbose = TRUE
)

bed_autoSVD(
  obj.bed,
  ind.row = rows_along(obj.bed),
  ind.col = cols_along(obj.bed),
  fun.scaling = bed_scaleBinom,
  thr.r2 = 0.2,
  size = 100/thr.r2,
  k = 10,
  roll.size = 50,
  int.min.size = 20,
  alpha.tukey = 0.05,
  min.mac = 10,
  min.maf = 0.02,
  max.iter = 5,
  ncores = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>
<p>A FBM.code256
(typically <code style="white-space: pre;">⁠&lt;bigSNP&gt;$genotypes⁠</code>).<br><strong>You shouldn't have missing values.</strong> Also, remember to do quality control,
e.g. some algorithms in this package won't work if you use SNPs with 0 MAF.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>infos.chr</code></td>
<td>
<p>Vector of integers specifying each SNP's chromosome.<br>
Typically <code style="white-space: pre;">⁠&lt;bigSNP&gt;$map$chromosome⁠</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>infos.pos</code></td>
<td>
<p>Vector of integers specifying the physical position
on a chromosome (in base pairs) of each SNP.<br>
Typically <code style="white-space: pre;">⁠&lt;bigSNP&gt;$map$physical.pos⁠</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ind.row</code></td>
<td>
<p>An optional vector of the row indices (individuals) that
are used. If not specified, all rows are used.<br><strong>Don't use negative indices.</strong></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ind.col</code></td>
<td>
<p>An optional vector of the column indices (SNPs) that are used.
If not specified, all columns are used.<br><strong>Don't use negative indices.</strong></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun.scaling</code></td>
<td>
<p>A function with parameters <code>X</code> (or <code>obj.bed</code>), <code>ind.row</code> and
<code>ind.col</code>, and that returns a data.frame with <code style="white-space: pre;">⁠$center⁠</code> and <code style="white-space: pre;">⁠$scale⁠</code> for the
columns corresponding to <code>ind.col</code>, to scale each of their elements such as followed:
</p>
<p style="text-align: center;"><code class="reqn">\frac{X_{i,j} - center_j}{scale_j}.</code>
</p>
<p> Default uses binomial scaling.
You can also provide your own <code>center</code> and <code>scale</code> by using <code>bigstatsr::as_scaling_fun()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thr.r2</code></td>
<td>
<p>Threshold over the squared correlation between two variants.
Default is <code>0.2</code>. Use <code>NA</code> if you want to skip the clumping step.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size</code></td>
<td>
<p>For one SNP, window size around this SNP to compute correlations.
Default is <code>100 / thr.r2</code> for clumping (0.2 -&gt; 500; 0.1 -&gt; 1000; 0.5 -&gt; 200).
If not providing <code>infos.pos</code> (<code>NULL</code>, the default), this is a window in
number of SNPs, otherwise it is a window in kb (genetic distance).
I recommend that you provide the positions if available.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>Number of singular vectors/values to compute. Default is <code>10</code>.
<strong>This algorithm should be used to compute a few singular vectors/values.</strong></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>roll.size</code></td>
<td>
<p>Radius of rolling windows to smooth log-p-values.
Default is <code>50</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>int.min.size</code></td>
<td>
<p>Minimum number of consecutive outlier variants
in order to be reported as long-range LD region. Default is <code>20</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.tukey</code></td>
<td>
<p>Default is <code>0.1</code>. The type-I error rate in outlier
detection (that is further corrected for multiple testing).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.mac</code></td>
<td>
<p>Minimum minor allele count (MAC) for variants to be included.
Default is <code>10</code>. Can actually be higher because of <code>min.maf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.maf</code></td>
<td>
<p>Minimum minor allele frequency (MAF) for variants to be included.
Default is <code>0.02</code>. Can actually be higher because of <code>min.mac</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.iter</code></td>
<td>
<p>Maximum number of iterations of outlier detection.
Default is <code>5</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is.size.in.bp</code></td>
<td>
<p>Deprecated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>Number of cores used. Default doesn't use parallelism.
You may use <code>bigstatsr::nb_cores()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Output some information on the iterations? Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obj.bed</code></td>
<td>
<p>Object of type bed, which is the mapping of some bed file.
Use <code>obj.bed &lt;- bed(bedfile)</code> to get this object.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If you don't have any information about variants, you can try using
</p>

<ul>
<li> <p><code>infos.chr = rep(1, ncol(G))</code>,
</p>
</li>
<li> <p><code>size = ncol(G)</code> (if variants are not sorted),
</p>
</li>
<li> <p><code>roll.size = 0</code> (if variants are not sorted).
</p>
</li>
</ul>
<h3>Value</h3>

<p>A named list (an S3 class "big_SVD") of
</p>

<ul>
<li> <p><code>d</code>, the singular values,
</p>
</li>
<li> <p><code>u</code>, the left singular vectors,
</p>
</li>
<li> <p><code>v</code>, the right singular vectors,
</p>
</li>
<li> <p><code>niter</code>, the number of the iteration of the algorithm,
</p>
</li>
<li> <p><code>nops</code>, number of Matrix-Vector multiplications used,
</p>
</li>
<li> <p><code>center</code>, the centering vector,
</p>
</li>
<li> <p><code>scale</code>, the scaling vector.
</p>
</li>
</ul>
<p>Note that to obtain the Principal Components, you must use
predict on the result. See examples.
</p>


<h3>Examples</h3>

<pre><code class="language-R">ex &lt;- snp_attachExtdata()
G &lt;- ex$genotypes

obj.svd &lt;- snp_autoSVD(G,
                       infos.chr = ex$map$chromosome,
                       infos.pos = ex$map$physical.position)

str(obj.svd)

</code></pre>


</div>