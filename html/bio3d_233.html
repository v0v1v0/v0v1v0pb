<div class="container">

<table style="width: 100%;"><tr>
<td>read.all</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Read Aligned Structure Data</h2>

<h3>Description</h3>

<p>Read aligned PDB structures and store their equalvalent atom data, including xyz
coordinates, residue numbers, residue type and B-factors.
</p>


<h3>Usage</h3>

<pre><code class="language-R">read.all(aln, prefix = "", pdbext = "", sel = NULL, rm.wat=TRUE, rm.ligand=FALSE,
         compact = TRUE, ncore = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>aln</code></td>
<td>
<p> an alignment data structure obtained with
<code>read.fasta</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prefix</code></td>
<td>
<p> prefix to aln$id to locate PDB files. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pdbext</code></td>
<td>
<p> the file name extention of the PDB files. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sel</code></td>
<td>
<p> a selection string detailing the atom type data to store
(see function store.atom) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rm.wat</code></td>
<td>
<p>logical, if TRUE water atoms are removed. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rm.ligand</code></td>
<td>
<p>logical, if TRUE ligand atoms are removed. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compact</code></td>
<td>
<p> logical, if TRUE the number of atoms stored for each aligned
residue varies according to the amino acid type. If FALSE, the constant 
maximum possible number of atoms are stored for all aligned residues. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncore </code></td>
<td>
<p> number of CPU cores used to do the calculation.
By default (<code>ncore=NULL</code>) use all detected CPU cores. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> other parameters for <code>read.pdb</code>. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The input <code>aln</code>, produced with <code>read.fasta</code>, must
have identifers (i.e. sequence names) that match the PDB file
names. For example the sequence corresponding to the structure
file “mypdbdir/1bg2.pdb” should have the identifer
‘mypdbdir/1bg2.pdb’ or ‘1bg2’ if input ‘prefix’
and ‘pdbext’ equal ‘mypdbdir/’ and ‘pdb’. See the
examples below.
</p>
<p>Sequence miss-matches will generate errors.  Thus, care should be taken
to ensure that the sequences in the alignment match the sequences in
their associated PDB files.
</p>


<h3>Value</h3>

<p>Returns a list of class <code>"pdbs"</code> with the following five
components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>xyz</code></td>
<td>
<p>numeric matrix of aligned C-alpha coordinates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resno</code></td>
<td>
<p>character matrix of aligned residue numbers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>numeric matrix of aligned B-factor values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chain</code></td>
<td>
<p>character matrix of aligned chain identifiers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p>character vector of PDB sequence/structure names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ali</code></td>
<td>
<p>character matrix of aligned sequences.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resid</code></td>
<td>
<p>character matrix of aligned 3-letter residue names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all </code></td>
<td>
<p>numeric matrix of aligned equalvelent atom coordinates. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all.elety</code></td>
<td>
<p>numeric matrix of aligned atom element types. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all.resid</code></td>
<td>
<p>numeric matrix of aligned three-letter residue codes. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all.resno</code></td>
<td>
<p>numeric matrix of aligned residue numbers. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all.grpby</code></td>
<td>
<p>numeric vector indicating the group of atoms belonging to
the same aligned residue. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all.hetatm</code></td>
<td>
<p>a list of ‘pdb’ objects for non-protein atoms. </p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>This function is still in development and is NOT part of the
offical bio3d package.
</p>
<p>The sequence character ‘X’ is useful for masking unusual
or unknown residues, as it can match any other residue type.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695–2696.
</p>


<h3>See Also</h3>

<p><code>read.fasta</code>, <code>read.pdb</code>,
<code>core.find</code>, <code>fit.xyz</code>  </p>


<h3>Examples</h3>

<pre><code class="language-R"># still working on speeding this guy up
## Not run: 
## Read sequence alignment
file &lt;- system.file("examples/kif1a.fa",package="bio3d")
aln  &lt;- read.fasta(file)

## Read aligned PDBs storing all data for 'sel'
sel &lt;- c("N", "CA", "C", "O", "CB", "*G", "*D",  "*E", "*Z")
pdbs &lt;- read.all(aln, sel=sel)

atm &lt;- colnames(pdbs$all)
ca.ind  &lt;- which(atm == "CA")
core &lt;- core.find(pdbs)
core.ind &lt;- c( matrix(ca.ind, nrow=3)[,core$c0.5A.atom] )

## Fit structures
nxyz &lt;- fit.xyz(pdbs$all[1,], pdbs$all,
               fixed.inds  = core.ind,
               mobile.inds = core.ind)

ngap.col &lt;- gap.inspect(nxyz)

#npc.xray &lt;- pca.xyz(nxyz[ ,ngap.col$f.inds])

#a &lt;- mktrj.pca(npc.xray, pc=1, file="pc1-all.pdb",
#               elety=pdbs$all.elety[1,unique( ceiling(ngap.col$f.inds/3) )],
#               resid=pdbs$all.resid[1,unique( ceiling(ngap.col$f.inds/3) )],
#               resno=pdbs$all.resno[1,unique( ceiling(ngap.col$f.inds/3) )] )


## End(Not run)

</code></pre>


</div>