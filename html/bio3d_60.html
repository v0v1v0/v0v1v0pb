<div class="container">

<table style="width: 100%;"><tr>
<td>cna</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Protein Dynamic Correlation Network Construction and Community Analysis.  </h2>

<h3>Description</h3>

<p>This function builds both residue-based and community-based undirected weighted
network graphs from an input correlation matrix, as obtained from the
functions ‘dccm’, ‘dccm.nma’, and ‘dccm.enma’. Community
detection/clustering is performed on the initial residue based 
network to determine the community organization and network structure
of the community based network.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  cna(cij, ...)
  ## S3 method for class 'dccm'
cna(cij, cutoff.cij=0.4, cm=NULL,  vnames=colnames(cij),
      cluster.method="btwn", collapse.method="max", 
      cols=vmd_colors(), minus.log=TRUE, ...)
  ## S3 method for class 'ensmb'
cna(cij, ..., ncore = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cij</code></td>
<td>
<p> A numeric array with 2 dimensions (nXn) containing atomic
correlation values, where "n" is the residue number. The matrix
elements should be in between 0 and 1 (atomic correlations). Can be
also a set of correlation matrices for ensemble network analysis. See
‘dccm’ function in bio3d package for further details. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>  Additional arguments passed to the methods
<code>cna.dccm</code> and <code>cna.ensmb</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff.cij</code></td>
<td>
<p> Numeric element specifying the cutoff on cij matrix
values. Coupling below cutoff.cij are set to 0. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cm</code></td>
<td>
<p> (optinal) A numeric array with 2 dimensions (nXn)
containing binary contact values, where "n" is the residue
number. The matrix elements should be 1 if two residues are in
contact and 0 if not in contact. See the  ‘cmap’ function in
bio3d package for further details. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vnames</code></td>
<td>
<p> A vector of names for each column in the input
cij. This will be used for referencing residues in a similar way
to residue numbers in later analysis. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster.method</code></td>
<td>
<p> A character string specifying the method for
community determination. Supported methods are:<br>
btwn="Girvan-Newman betweenness"<br>
walk="Random walk"<br>
greed="Greedy algorithm for modularity optimization"<br> 
infomap="Infomap algorithm for community detection"<br></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>collapse.method</code></td>
<td>
<p> A single element character vector specifing
the ‘cij’ collapse method, can be one of ‘max’, ‘median’,
‘mean’, or ‘trimmed’. By defualt the ‘max’ method is
used to collapse the input residue based ‘cij’ matrix into a smaller
community based network by taking the maximium ‘abs(cij)’ value between
communities as the comunity-to-community cij value for clustered
network construction. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cols</code></td>
<td>
<p> A vector of colors assigned to network nodes. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minus.log</code></td>
<td>
<p> Logical, indicating whether ‘-log(abs(cij))’
values should be used for network construction. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncore</code></td>
<td>
<p> Number of CPU cores used to do the calculation. By default,
use all available cores. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The input to this function should be a correlation matrix as
obtained from the  ‘dccm’, ‘dccm.mean’ or ‘dccm.nma’
and related functions. Optionally, a contact map ‘cm’ may also given 
as input to filter the correlation matrix resulting in the exclusion of  
network edges between non-contacting atom pairs (as defined in the contact map).
</p>
<p>Internally this function calls the igraph package
functions ‘graph.adjacency’,
‘edge.betweenness.community’, ‘walktrap.community’,
‘fastgreedy.community’, and ‘infomap.community’. The first constructs an undirected
weighted network graph. The second performs Girvan-Newman style clustering by
calculating the edge betweenness of the graph, removing the edge with
the highest edge betweenness score, calculates modularity (i.e. the difference between
the current graph partition and the partition of a random graph, see Newman and Girvan,
Physical Review E (2004), Vol 69, 026113), then recalculating edge betweenness
of the edges and again removing the one with the highest score, etc. 
The returned community partition is the one with the highest overall modularity value.
‘walktrap.community’ implements the Pons and Latapy algorithm based on the idea that
random walks on a graph tend to get "trapped" into densely connected parts of it,
i.e. a community. The random walk process is used to determine a distance
between nodes. Nodes with low distance values are joined in the same community.
‘fastgreedy.community’ instead determines the community structure based on the
optimization of the modularity. In the starting state each node is isolated and 
belongs to a separated community. Communities are then joined together (according to the
network edges) in pairs and the modularity is calculated. At each step the join resulting
in the highest increase of modularity is chosen. This process is repeated until a single
community is obtained, then the partitioning with the highest modularity score is selected.
‘infomap.community’ finds community structure that minimizes the expected description
length of a random walker trajectory.
</p>


<h3>Value</h3>

<p>Returns a list object that includes igraph network and community
objects with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>network</code></td>
<td>
<p> An igraph residue-wise graph object. See below
for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>communities</code></td>
<td>
<p> An igraph residue-wise community object. See
below for more details. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>communitiy.network</code></td>
<td>
<p> An igraph community-wise graph object. See
below for more details. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>community.cij</code></td>
<td>
<p> Numeric square matrix containing the absolute values of
the atomic correlation input matrix for each community as obtained
from ‘cij’ via application of  ‘collapse.method’. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cij</code></td>
<td>
<p> Numeric square matrix containing the absolute values of
the atomic correlation input matrix. </p>
</td>
</tr>
</table>
<p>If an ensemble of correlation matrices is provided, a list of ‘cna’ 
object, of the ‘ecna’ class, will be returned.
</p>


<h3>Author(s)</h3>

<p> Guido Scarabelli and Barry Grant </p>


<h3>See Also</h3>

<p><code>plot.cna</code>,  <code>summary.cna</code>,
<code>vmd.cna</code>, <code>graph.adjacency</code>,
<code>edge.betweenness.community</code>,
<code>walktrap.community</code>, 
<code>fastgreedy.community</code>,
<code>infomap.community</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# PDB server connection required - testing excluded

if (!requireNamespace("igraph", quietly = TRUE)) {
   message('Need igraph installed to run this example')
} else {

##-- Build a correlation network from NMA results
## Read example PDB
pdb &lt;- read.pdb("4Q21")

## Perform NMA
modes &lt;- nma(pdb)
#plot(modes, sse=pdb)

## Calculate correlations 
cij &lt;- dccm(modes)
#plot(cij, sse=pdb)

## Build, and betweenness cluster, a network graph
net &lt;- cna(cij, cutoff.cij=0.35)
#plot(net, pdb)

## within VMD set 'coloring method' to 'Chain' and 'Drawing method' to Tube
#vmd.cna(net, trim.pdb(pdb, atom.select(pdb,"calpha")), launch=TRUE )

##-- Build a correlation network from MD results
## Read example trajectory file
trtfile &lt;- system.file("examples/hivp.dcd", package="bio3d")
trj &lt;- read.dcd(trtfile)

## Read the starting PDB file to determine atom correspondence
pdbfile &lt;- system.file("examples/hivp.pdb", package="bio3d")
pdb &lt;- read.pdb(pdbfile)

## select residues 24 to 27 and 85 to 90 in both chains
inds &lt;- atom.select(pdb, resno=c(24:27,85:90), elety='CA')

## lsq fit of trj on pdb
xyz &lt;- fit.xyz(pdb$xyz, trj, fixed.inds=inds$xyz, mobile.inds=inds$xyz)

## calculate dynamical cross-correlation matrix
cij &lt;- dccm(xyz)

## Build, and betweenness cluster, a network graph
net &lt;- cna(cij)

# Plot coarse grained network based on dynamically coupled communities
xy &lt;- plot.cna(net)
plot.dccm(cij, margin.segments=net$communities$membership)


##-- Begin to examine network structure - see CNA vignette for more details
net
summary(net)
attributes(net)
table( net$communities$members )

}

</code></pre>


</div>