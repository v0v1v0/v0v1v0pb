<div class="container">

<table style="width: 100%;"><tr>
<td>bmerDist-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bayesian Linear Mixed-Effects Model Prior Representations and bmer*Dist Methods</h2>

<h3>Description</h3>

<p>Objects created in the initialization step of a <span class="pkg">blme</span>
model that represent the type of prior being applied.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the
form <code>new("bmerPrior", ...)</code>  or, more commonly, as side effects of the
<code>blmer</code> and <code>bglmer</code> functions.
</p>
<p>When using the main <code>blme</code> functions, the prior-related arguments can be
passed what essentially
are function calls with the distinction that they are delayed in evaluation
until information about the model is available. At that time, the functions
are <em>defined</em> in a special environment and then <em>evaluated</em> in an
environment that directly inherits from the one in which <code>blmer</code> or
<code>bglmer</code> was called. This is reflected in some of the
prototypes of various prior-creating functions which depend on parameters not
available in the top-level environment.
</p>
<p>Finally, if the trailing parentheses are omitted from a <code>blmer</code>/<code>bglmer</code>
prior argument, they are simply added as a form of “syntactic sugar”.
</p>


<h3>Prior Distributions</h3>

<p>This section lists the prototypes for the functions that are called to parse
a prior during a model fit.
</p>
<p><strong>Fixed Effect Priors</strong>
</p>

<ul>
<li> <p><code>normal(sd = c(10, 2.5), cov, common.scale = TRUE)</code>
</p>
<p>Applies a Gaussian prior to the fixed effects. Normal priors are constrained
to have a mean of 0 - non-zero priors are equivalent to shifting covariates.
</p>
<p>The covariance hyperparameter can be specified either as a vector of standard
deviations, using the <code>sd</code> argument, a vector of variances using the
<code>cov</code> argument, or the entire variance/covariance matrix itself. When
specifying standard deviations, a vector of length less than the number of fixed effects will
have its tail repeated, while the first element is assumed to apply only
to the intercept term. So in the default of <code>c(10, 2.5)</code>, the intercept
receives a standard deviation of 10 and the various slopes are all given
a standard deviation of 2.5.
</p>
<p>The <code>common.scale</code> argument specifies whether or not the
prior is to be interpretted as being on the same scale as the residuals.
To specify a prior in an absolute sense, set to <code>FALSE</code>. Argument
is only applicable to linear mixed models.
</p>
</li>
<li> <p><code>t(df = 3, mean = 0, scale = c(10^2, 2.5^2), common.scale = TRUE)</code>
</p>
<p>The degrees of freedom - <code>df</code> argument - must be positive. If <code>mean</code> is
of length 1, it is repeated for every fixed effect. Length 2 repeats just the second
element for all slopes. Otherwise, the length must be equal to that of the number of
fixed effects.
</p>
<p>If <code>scale</code> is of length 1, it is repeated along the diagonal for every
component. Length 2 repeats just the second element for all slopes. Length equal
to the number of fixed effects sees the vector simply turned into a diagonal matrix.
Finally, it can be a full scale matrix, so long as it is positive definite.
</p>
<p><code>t</code> priors for linear mixed models require that the fixed effects be added to
set of parameters that are numerically optimized, and thus can substantially
increase running time. In addition, when <code>common.scale</code> is <code>TRUE</code>, the
residual variance must be numerically optimized as well. <code>normal</code> priors
on the common scale can be fully profiled and do not suffer from this drawback.
</p>
<p>At present, <code>t</code> priors cannot be used with the <code>REML = TRUE</code> argument
as that implies an integral without a closed form solution.
</p>
</li>
<li> <p><code>horseshoe(mean = 0, global.shrinkage = 2.5, common.scale = TRUE)</code>
</p>
<p>The horseshoe shrinkage prior is implemented similarly to the <code>t</code> prior, in
that it requires adding the fixed effects to the parameter set for numeric optimization.
</p>
<p><code>global.shrinkage</code>, also referred to as <code class="reqn">\tau</code>, must be positive and
is on the scale of a standard deviation. Local shrinkage parameters are treated as
independent across all fixed effects and are integrated out. See
<cite>Carvalho et al. (2009)</cite> in the references.
</p>
</li>
</ul>
<p><strong>Covariance Priors</strong>
</p>

<ul>
<li> <p><code>gamma(shape = 2.5, rate = 0, common.scale = TRUE, posterior.scale = "sd")</code>
</p>
<p>Applicable only for univariate grouping factors. A
rate of <code>0</code> or a shape of <code>0</code> imposes an improper prior. The
posterior scale can be <code>"sd"</code> or <code>"var"</code> and determines the scale
on which the prior is meant to be applied.
</p>
</li>
<li> <p><code>invgamma(shape = 0.5, scale = 10^2, common.scale = TRUE, posterior.scale = "sd")</code>
</p>
<p>Applicable only for univariate grouping factors. A
scale of <code>0</code> or a shape of <code>0</code> imposes an improper prior. Options
are as above.
</p>
</li>
<li> <p><code>wishart(df = level.dim + 2.5, scale = Inf, common.scale = TRUE, posterior.scale = "cov")</code>
</p>
<p>A scale of <code>Inf</code> or a shape of <code>0</code> imposes an improper prior. The behavior
for singular matrices with only some infinite eigenvalues is undefined. Posterior scale
can be <code>"cov"</code> or <code>"sqrt"</code>,
the latter of which applies to the unique matrix root that is also a valid covariance
matrix.
</p>
</li>
<li> <p><code>invwishart(df = level.dim - 0.5, scale = diag(10^2 / (df + level.dim + 1), level.dim),
                        common.scale = TRUE, posterior.scale = "cov")</code>
</p>
<p>A scale of <code>0</code> or a shape of <code>0</code> imposes an improper prior. The behavior
for singular matrices with only some zero eigenvalues is undefined.
</p>
</li>
<li> <p><code>custom(fn, chol = FALSE, common.scale = TRUE, scale = "none")</code>
</p>
<p>Applies to the given function (<code>fn</code>). If <code>chol</code> is <code>TRUE</code>, <code>fn</code> is
passed a <em>right</em> factor of covariance matrix; <code>FALSE</code> results in the matrix being
passed directly. <code>scale</code> can be <code>"none"</code>, <code>"log"</code>, or <code>"dev"</code> corresponding to
<code class="reqn">p(\Sigma)</code>, <code class="reqn">\log p(\Sigma)</code>, and <code class="reqn">-2 \log p(\Sigma)</code>
respectively.
</p>
<p>Since the prior is may have an arbitrary form, setting <code>common.scale</code> to <code>FALSE</code>
for a linear mixed model means that full profiling may no longer be possible. As such,
that parameter is numerically optimized.
</p>
</li>
</ul>
<p><strong>Residual Variance Priors</strong>
</p>

<ul>
<li> <p><code>point(value = 1.0, posterior.scale = "sd")</code>
</p>
<p>Fixes the parameter to a specific value given as either an <code>"sd"</code> or a <code>"var"</code>.
</p>
</li>
<li> <p><code>gamma(shape = 0, rate = 0, posterior.scale = "var")</code>
</p>
<p>As above with different defaults.
</p>
</li>
<li> <p><code>invgamma(shape = 0, scale = 0, posterior.scale = "var")</code>
</p>
<p>As above with different defaults.
</p>
</li>
</ul>
<h3>Evaluating Environment</h3>

<p>The variables that the defining environment have populated are:
</p>

<ul>
<li> <p><code>p</code> aliased to <code>n.fixef</code> - the number of fixed effects
</p>
</li>
<li> <p><code>n</code> aliased to <code>n.obs</code> - the number of observations
</p>
</li>
<li> <p><code>q.k</code> aliased to <code>level.dim</code> - for covariance priors, the dimension of the grouping factor/grouping level
</p>
</li>
<li> <p><code>j.k</code> aliased to <code>n.grps</code> - also for covariance priors, the number of groups that comprise a specific grouping factor
</p>
</li>
</ul>
<h3>Methods</h3>


<dl>
<dt>toString</dt>
<dd>
<p>Pretty-prints the distribution and its parameters.</p>
</dd>
</dl>
<h3>References</h3>

<p>Carvalho, Carlos M., Nicholas G. Polson, and James G. Scott.
"Handling Sparsity via the Horseshoe."
AISTATS. Vol. 5. 2009.
</p>


<h3>See Also</h3>

<p><code>blmer()</code> and <code>bglmer()</code>,
which produce these objects, and <code>bmerMod-class</code> objects which contain them.
</p>


</div>