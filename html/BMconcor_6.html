<div class="container">

<table style="width: 100%;"><tr>
<td>concorgmreg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Regression of subsets Yj by subsets Xi</h2>

<h3>Description</h3>

<p>Regression of subsets Yj by subsets Xi for comparing all the explanatory-explained pairs (Xi,Yj). SUCCESSIVE SOLUTIONS
</p>


<h3>Usage</h3>

<pre><code class="language-R">concorgmreg(x, px, y, py, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>are the <code>n</code> times <code>p</code> and <code>n</code> times <code>q</code> matrices of <code>p</code> and <code>q</code> centered column</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>px</code></td>
<td>
<p>A row vector which contains the numbers pi, i = 1,...,kx, of the kx subsets xi of x : sum(pi)=sum(px)=p. px is the partition vector of x</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>See <code>x</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>py</code></td>
<td>
<p>The partition vector of y. A row vector containing the numbers <code>qi</code> for <code>i = 1,...,ky</code> of the <code>ky</code> subsets <code>yi</code> of <code>y : sum(qi)=sum(py)=q</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>The number of wanted successive solutions</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For the first solution, <code class="reqn">\sum_i \sum_j \mbox{rho2}(cx_i[,1],y_j*v_j[,1])
\mbox{var}(y_j*v_j[,1])</code> is the optimized criterion. The second solution is
calculated from the same criterion, but with <code class="reqn">y_j-y_j*v_j[,1]*v_j[,1]'</code>
instead of the matrices yj and with orthogonalities for having two by
two zero correlated the explanatory components defined for each matrix
xi. And so on for the other solutions. One solution k associates kx
explanatory components (in <code>cx[,k]</code>) to ky explained components. When
kx =1 (px = p), take concoreg function
This function uses the concorgm function
</p>


<h3>Value</h3>

<p>A <code>list</code> with following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>cx</code></td>
<td>
<p>a <code>n</code> times <code>r</code>matrix of the r explanatory components</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>is a <code class="reqn">q \times r</code> matrix of ky row blocks <code class="reqn">v_i</code> (<code class="reqn">q_i \times r</code>) of axes in Rqi relative to yi; <code class="reqn">v_i'*v_i = \mbox{Id}</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varexp</code></td>
<td>
<p>is a kx x ky x r array; for a fixed solution k, the matrix <code>varexp[,,k]</code> contains kxky explained variances obtained by a simultaneous regression of all the yj by all the xi, so the values <code class="reqn">\mbox{rho2}(cx[n*(i-1)+1:n*i,k],y_j*v_j[,k]) var(y_j*v_j[,k])</code></p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Lafosse, R.
</p>


<h3>References</h3>

<p>Hanafi &amp; Lafosse (2004) Regression of a multi-set by another based on an extension of the SVD. COMPSTAT'2004 Symposium
</p>


<h3>Examples</h3>

<pre><code class="language-R">
x &lt;- matrix(runif(50),10,5);y &lt;- matrix(runif(90),10,9)
x &lt;- scale(x);y &lt;- scale(y)
cr &lt;- concorgmreg(x,c(2,3),y,c(3,2,4),2)
cr$varexp[1,1,]

</code></pre>


</div>