<div class="container">

<table style="width: 100%;"><tr>
<td>stabsel.boostrq</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Stability Selection for boosting regression quantiles</h2>

<h3>Description</h3>

<p>Stability Selection for boosting regression quantiles
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'boostrq'
stabsel(
  x,
  cutoff,
  q,
  PFER,
  grid = 0:mstop(x),
  folds = stabs::subsample(x$weights, B = B),
  B = ifelse(sampling.type == "MB", 100, 50),
  assumption = "unimodal",
  sampling.type = "SS",
  papply = parallel::mclapply,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a fitted model of class "boostrq"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff</code></td>
<td>
<p>cutoff between 0.5 and 1. Preferably a value between 0.6 and 0.9 should be used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>number of (unique) selected componenents (base-learners) that are selected in each subsample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PFER</code></td>
<td>
<p>upper bound for the per-family error rate. This specifies the amount of falsely selected
base-learners, which is tolerated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>a numeric vector of the form 0:m.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>folds</code></td>
<td>
<p>a weight matrix with number of rows equal to the number of observations. Usually one should
not change the default here as subsampling with a fraction of 1/2 is needed for the error bounds to hold.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>umber of subsampling replicates. Per default, we use 50 complementary pairs for the
error bounds of Shah &amp; Samworth (2013) and 100 for the error bound derived in
Meinshausen &amp; Buehlmann (2010). As we use B complementray pairs in the former
case this leads to 2B subsamples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>assumption</code></td>
<td>
<p>Defines the type of assumptions on the distributions of the selection probabilities
and simultaneous selection probabilities. Only applicable for sampling.type = "SS". For
sampling.type = "MB" we always use code"none".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sampling.type</code></td>
<td>
<p>use sampling scheme of of Shah &amp; Samworth (2013), i.e., with complementarty pairs
(sampling.type = "SS"), or the original sampling scheme of Meinshausen &amp; Buehlmann (2010).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>papply</code></td>
<td>
<p>(parallel) apply function, defaults to mclapply. To run sequentially
(i.e. not in parallel), one can use lapply.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical (default: TRUE) that determines wether warnings should be issued.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to callies</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class stabsel.
</p>


<h3>Examples</h3>

<pre><code class="language-R">boosted.rq &lt;-
boostrq(
 formula = mpg ~ brq(cyl) + brq(hp) + brq(am) + brq(wt) + brq(drat),
 data = mtcars,
 mstop = 600,
 nu = 0.1,
 tau = 0.5
)

stabsel_parameters(
 q = 3,
 PFER = 1,
 p = 5,
 sampling.type = "SS",
 assumption = "unimodal"
)


set.seed(100)
brq.stabs &lt;-
stabsel(
 x = boosted.rq,
 q = 3,
 PFER = 1,
 sampling.type = "SS",
 assumption = "unimodal"
)

brq.stabs


</code></pre>


</div>