<div class="container">

<table style="width: 100%;"><tr>
<td>brif.trainpredict</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Train a model and use it to predict new cases</h2>

<h3>Description</h3>

<p>If the model is built to predict for just one test data set (newdata), then this function should be used instead of the <code>brif</code> and <code>predict.brif</code> pipeline. Transporting the model object between the training and prediction functions through saving and loading the <code>brif</code> object takes a subtantial amount of time, and using the <code>pred.trainpredict</code> function eliminates such time-consuming operations. This function will be automatically invoked by the <code>brif</code> function when the newdata argument is supplied there.
If GPU is used for training (GPU = 1 or 2), the total execution time of this function includes writing and reading temporary data files. To see timing of different steps, use verbose = 1. 
Note: Using GPU for training can improve training time only when the number of rows in the training data is extremely large, e.g., over 1 million. Even in such cases, GPU = 2 (hybrid mode) is recommended over GPU = 1 (force using GPU).
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'trainpredict'
brif(
  x,
  newdata,
  type = c("score", "class"),
  n_numeric_cuts = 31,
  n_integer_cuts = 31,
  max_integer_classes = 20,
  max_depth = 20,
  min_node_size = 1,
  ntrees = 200,
  ps = 0,
  max_factor_levels = 30,
  seed = 0,
  bagging_method = 0,
  bagging_proportion = 0.9,
  vote_method = 1,
  split_search = 4,
  search_radius = 5,
  verbose = 0,
  nthreads = 2,
  CUDA = 0,
  CUDA_blocksize = 128,
  CUDA_n_lb_GPU = 20480,
  cubrif_main = "cubrif_main.exe",
  tmp_file_prefix = "cbf",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a data frame containing the training data set. The first column is taken as the target variable and all other columns are used as predictors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>a data frame containing the new data to be predicted. All columns in x (except for the first column which is the target variable) must be present in newdata and the data types must match.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>a character string specifying the prediction format. Available values include "score" and "class". Default is "score".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_numeric_cuts</code></td>
<td>
<p>an integer value indicating the maximum number of split points to generate for each numeric variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_integer_cuts</code></td>
<td>
<p>an integer value indicating the maximum number of split points to generate for each integer variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_integer_classes</code></td>
<td>
<p>an integer value. If the target variable is integer and has more than max_integer_classes unique values in the training data, then the target variable will be grouped into max_integer_classes bins. If the target variable is numeric, then the smaller of max_integer_classes and the number of unique values number of bins will be created on the target variables and the regression problem will be solved as a classification problem.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_depth</code></td>
<td>
<p>an integer specifying the maximum depth of each tree. Maximum is 40.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_node_size</code></td>
<td>
<p>an integer specifying the minimum number of training cases a leaf node must contain.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ntrees</code></td>
<td>
<p>an integer specifying the number of trees in the forest.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ps</code></td>
<td>
<p>an integer indicating the number of predictors to sample at each node split. Default is 0, meaning to use sqrt(p), where p is the number of predictors in the input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_factor_levels</code></td>
<td>
<p>an integer. If any factor variables has more than max_factor_levels, the program stops and prompts the user to increase the value of this parameter if the too-many-level factor is indeed intended.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>an integer specifying the seed used by the internal random number generator. Default is 0, meaning not to set a seed but to accept the set seed from the calling environment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bagging_method</code></td>
<td>
<p>an integer indicating the bagging sampling method: 0 for sampling without replacement; 1 for sampling with replacement (bootstrapping).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bagging_proportion</code></td>
<td>
<p>a numeric scalar between 0 and 1, indicating the proportion of training observations to be used in each tree.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vote_method</code></td>
<td>
<p>an integer (0 or 1) specifying the voting method in prediction. 0: each leaf contributes the raw count and an average is taken on the sum over all leaves; 1: each leaf contributes an intra-node fraction which is then averaged over all leaves with equal weight.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>split_search</code></td>
<td>
<p>an integer indicating the choice of the split search method. 0: randomly pick a split point; 1: do a local search; 2: random pick subject to regulation; 3: local search subject to regulation; 4 or above: a mix of options 0 to 3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>search_radius</code></td>
<td>
<p>an positive integer indicating the split point search radius. This parameter takes effect only in regulated search (split_search = 2 or above).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>an integer (0 or 1) specifying the verbose level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nthreads</code></td>
<td>
<p>an integer specifying the number of threads used by the program. This parameter takes effect only on systems supporting OpenMP.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CUDA</code></td>
<td>
<p>an integer (0, 1 or 2). 0: Do not use GPU. 1: Use GPU to build the forest. 2: Hybrid mode: Use GPU to split a node only when the node size is greater than CUDA_n_lb_GPU.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CUDA_blocksize</code></td>
<td>
<p>a positive integer specifying the CUDA thread block size, must be a multiple of 64 up to 1024.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CUDA_n_lb_GPU</code></td>
<td>
<p>a positive integer. The number of training cases must be greater than this number to enable the GPU computing when GPU = 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cubrif_main</code></td>
<td>
<p>a string containing the path and name of the cubrif executable (see https://github.com/profyliu/cubrif for how to build it).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tmp_file_prefix</code></td>
<td>
<p>a string for the path and prefix of temporary files created when CUDA is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a data frame or a vector containing the prediction results. See <code>predict.brif</code> for details.
</p>


<h3>Examples</h3>

<pre><code class="language-R">trainset &lt;- sample(1:nrow(iris), 0.5*nrow(iris))
validset &lt;- setdiff(1:nrow(iris), trainset)

pred_score &lt;- brif.trainpredict(iris[trainset, c(5,1:4)], iris[validset, c(1:4)], type = 'score')
pred_label &lt;- colnames(pred_score)[apply(pred_score, 1, which.max)]

</code></pre>


</div>