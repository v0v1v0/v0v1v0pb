<div class="container">

<table style="width: 100%;"><tr>
<td>core.find</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Identification of Invariant Core Positions </h2>

<h3>Description</h3>

<p>Perform iterated rounds of structural superposition to identify the
most invariant region in an aligned set of protein structures.
</p>


<h3>Usage</h3>

<pre><code class="language-R">core.find(...)

## S3 method for class 'pdbs'
core.find(pdbs, shortcut = FALSE, rm.island = FALSE,
          verbose = TRUE, stop.at = 15, stop.vol = 0.5,
          write.pdbs = FALSE, outpath="core_pruned",
          ncore = 1, nseg.scale = 1, progress = NULL, ...)

## Default S3 method:
core.find(xyz, ...)

## S3 method for class 'pdb'
core.find(pdb, verbose=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pdbs</code></td>
<td>
<p> a numeric matrix of aligned C-alpha xyz Cartesian
coordinates. For example an alignment data structure obtained with
<code>read.fasta.pdb</code> or <code>pdbaln</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shortcut</code></td>
<td>
<p> if TRUE, remove more than one position at a time. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rm.island</code></td>
<td>
<p> remove isolated fragments of less than three
residues. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p> logical, if TRUE a “core_pruned” directory
containing ‘core structures’ for each iteraction is written 
to the current directory. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stop.at</code></td>
<td>
<p> minimal core size at which iterations should be
stopped. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stop.vol</code></td>
<td>
<p> minimal core volume at which iterations should be
stopped. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>write.pdbs</code></td>
<td>
<p> logical, if TRUE core coordinate files, containing
only core positions for each iteration, are written to a location
specified by <code>outpath</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outpath</code></td>
<td>
<p> character string specifying the output directory when
<code>write.pdbs</code> is TRUE. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncore </code></td>
<td>
<p> number of CPU cores used to do the calculation.
<code>ncore&gt;1</code> requires package ‘parallel’ installed. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nseg.scale </code></td>
<td>
<p> split input data into specified number of segments
prior to running multiple core calculation. See <code>fit.xyz</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress</code></td>
<td>
<p> progress bar for use with shiny web app. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xyz</code></td>
<td>
<p> a numeric matrix of xyz Cartesian coordinates,
e.g. obtained from <code>read.dcd</code> or <code>read.ncdf</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pdb</code></td>
<td>
<p> an object of type <code>pdb</code> as obtained from function
<code>read.pdb</code> with multiple frames (&gt;=4) stored in its
<code>xyz</code> component. Note that the function will attempt to
identify C-alpha and phosphate atoms (for protein and nucleic acids,
respectively) in which the calculation should be based. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> arguments passed to and from functions. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function attempts to iteratively refine an initial structural
superposition determined from a multiple alignment.
This involves iterated rounds of superposition, where at each round the
position(s) displaying the largest differences is(are) excluded from the
dataset. 
The spatial variation at each aligned position is determined from the
eigenvalues of their Cartesian coordinates (i.e. the variance of the
distribution along its three principal directions). Inspired by the
work of Gerstein <em>et al.</em> (1991, 1995), an ellipsoid of
variance is determined from the eigenvalues, and its volume is taken as
a measure of structural variation at a given position.
</p>
<p>Optional “core PDB files” containing core positions, upon which
superposition is based, can be written to a location specified by
<code>outpath</code> by setting <code>write.pdbs=TRUE</code>.  These files are
useful for examining the core filtering process by visualising them in a
graphics program.
</p>


<h3>Value</h3>

<p>Returns a list of class <code>"core"</code> with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>volume </code></td>
<td>
<p>total core volume at each fitting iteration/round.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>length </code></td>
<td>
<p>core length at each round.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resno </code></td>
<td>
<p>residue number of core residues at each round (taken
from the first aligned structure) or, alternatively, the numeric
index of core residues at each round.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>step.inds</code></td>
<td>
<p>atom indices of core atoms at each round.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>atom </code></td>
<td>
<p>atom indices of core positions in the last round.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xyz </code></td>
<td>
<p>xyz indices of core positions in the last round.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c1A.atom </code></td>
<td>
<p>atom indices of core positions with a total volume
under 1 Angstrom^3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c1A.xyz </code></td>
<td>
<p>xyz indices of core positions with a total volume
under 1 Angstrom^3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c1A.resno </code></td>
<td>
<p>residue numbers of core positions with a total volume
under 1 Angstrom^3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c0.5A.atom </code></td>
<td>
<p>atom indices of core positions with a total volume
under 0.5 Angstrom^3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c0.5A.xyz </code></td>
<td>
<p>xyz indices of core positions with a total volume
under 0.5 Angstrom^3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c0.5A.resno </code></td>
<td>
<p>residue numbers of core positions with a total volume
under 0.5 Angstrom^3.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>The relevance of the ‘core positions’ identified by this
procedure is dependent upon the number of input structures and their
diversity.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695–2696.
</p>
<p>Gerstein and Altman (1995) <em>J. Mol. Biol.</em>  <b>251</b>, 161–175.
</p>
<p>Gerstein and Chothia (1991) <em>J. Mol. Biol.</em> <b>220</b>, 133–149.
</p>


<h3>See Also</h3>

 <p><code>read.fasta.pdb</code>, <code>plot.core</code>,
<code>fit.xyz</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
##-- Generate a small kinesin alignment and read corresponding structures
pdbfiles &lt;- get.pdb(c("1bg2","2ncd","1i6i","1i5s"), URLonly=TRUE)
pdbs &lt;- pdbaln(pdbfiles)

##-- Find 'core' positions
core &lt;- core.find(pdbs)
plot(core)

##-- Fit on these relatively invarient subset of positions 
#core.inds &lt;- print(core, vol=1)
core.inds &lt;- print(core, vol=0.5)
xyz &lt;- pdbfit(pdbs, core.inds, outpath="corefit_structures")

##-- Compare to fitting on all equivalent positions
xyz2 &lt;- pdbfit(pdbs)

## Note that overall RMSD will be higher but RMSF will
##  be lower in core regions, which may equate to a
##  'better fit' for certain applications
gaps &lt;- gap.inspect(pdbs$xyz)
rmsd(xyz[,gaps$f.inds])
rmsd(xyz2[,gaps$f.inds])

plot(rmsf(xyz[,gaps$f.inds]), typ="l", col="blue", ylim=c(0,9))
points(rmsf(xyz2[,gaps$f.inds]), typ="l", col="red")

## End(Not run)

## Not run: 
##-- Run core.find() on a multimodel PDB file
pdb &lt;- read.pdb('1d1d', multi=TRUE)
core &lt;- core.find(pdb)

##-- Run core.find() on a trajectory
trtfile &lt;- system.file("examples/hivp.dcd", package="bio3d")
trj &lt;- read.dcd(trtfile)

## Read the starting PDB file to determine atom correspondence
pdbfile &lt;- system.file("examples/hivp.pdb", package="bio3d")
pdb &lt;- read.pdb(pdbfile)

## select calpha coords from a manageable number of frames
ca.ind &lt;- atom.select(pdb, "calpha")$xyz
frames &lt;- seq(1, nrow(trj), by=10)

core &lt;- core.find( trj[frames, ca.ind], write.pdbs=TRUE )

## have a look at the various cores "vmd -m core_pruned/*.pdb"

## Lets use a 6A^3 core cutoff
inds &lt;- print(core, vol=6)
write.pdb(xyz=pdb$xyz[inds$xyz],resno=pdb$atom[inds$atom,"resno"], file="core.pdb")


##- Fit trj onto starting structure based on core indices
xyz &lt;- fit.xyz( fixed = pdb$xyz,
               mobile = trj,
               fixed.inds  = inds$xyz,
               mobile.inds = inds$xyz)

##write.pdb(pdb=pdb, xyz=xyz, file="new_trj.pdb")
##write.ncdf(xyz, "new_trj.nc")


## End(Not run)

</code></pre>


</div>