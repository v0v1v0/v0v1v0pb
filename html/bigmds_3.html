<div class="container">

<table style="width: 100%;"><tr>
<td>interpolation_mds</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Interpolation MDS</h2>

<h3>Description</h3>

<p>Given that the size of the data set is too large, this algorithm
consists of taking a random sample from it of size
<code>l</code> <code class="reqn">\leq \bar{l}</code>, being <code class="reqn">\bar{l}</code> the limit size for which
classical MDS is applicable, to perform classical MDS to it, and to extend the
obtained results to the rest of the data set by using Gower's
interpolation formula, which allows to add a new set of points
to an existing MDS configuration.
</p>


<h3>Usage</h3>

<pre><code class="language-R">interpolation_mds(x, l, r, n_cores)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A matrix with <code class="reqn">n</code> individuals (rows) and <code class="reqn">k</code> variables (columns).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>l</code></td>
<td>
<p>The size for which classical MDS can be computed efficiently
(using <code>cmdscale</code> function). It means that if <code class="reqn">\bar{l}</code> is the limit
size for which classical MDS is applicable, then <code>l</code><code class="reqn">\leq \bar{l}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>Number of principal coordinates to be extracted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_cores</code></td>
<td>
<p>Number of cores wanted to use to run the algorithm.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><em>Gower's interpolation formula</em> is the central piece of this algorithm
since it allows to add a new set of points to an existing MDS configuration
so that the new one has the same coordinate system.
</p>
<p>Given the matrix <code>x</code> with <code class="reqn">n</code> points (rows) and
and <code class="reqn">k</code> variables (columns), a first data subsets (based on a random sample)
of size <code>l</code> is taken and it is used to compute a MDS configuration.
</p>
<p>The remaining part of <code>x</code> is divided into <code class="reqn">p=({n}-</code><code>l</code>)<code>/l</code>
data subsets (randomly). For every data subset, it is obtained a MDS
configuration by means of <em>Gower's interpolation formula</em> and the first
MDS configuration obtained previously. Every MDS configuration is appended
to the existing one so that, at the end of the process, a global MDS
configuration for <code>x</code> is obtained.
</p>
<p>This method is similar to <code>landmark_mds()</code> and <code>reduced_mds()</code>.
</p>


<h3>Value</h3>

<p>Returns a list containing the following elements:
</p>

<dl>
<dt>points</dt>
<dd>
<p>A matrix that consists of <code class="reqn">n</code> individuals (rows)
and <code>r</code> variables (columns) corresponding to the principal coordinates. Since
we are performing a dimensionality reduction, <code>r</code><code class="reqn">&lt;&lt;k</code></p>
</dd>
<dt>eigen</dt>
<dd>
<p>The first <code>r</code> largest eigenvalues:
<code class="reqn">\lambda_i, i \in  \{1, \dots, r\} </code>, where each <code class="reqn">\lambda_i</code> is obtained
from applying classical MDS to the first data subset.</p>
</dd>
</dl>
<h3>References</h3>

<p>Delicado P. and C. Pachón-García (2021). <em>Multidimensional Scaling for Big Data</em>.
<a href="https://arxiv.org/abs/2007.11919">https://arxiv.org/abs/2007.11919</a>.
</p>
<p>Borg, I. and P. Groenen (2005). <em>Modern Multidimensional Scaling: Theory and Applications</em>. Springer.
</p>
<p>Gower JC. (1968). <em>Adding a point to vector diagrams in multivariate analysis</em>. Biometrika.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(42)
x &lt;- matrix(data = rnorm(4 * 10000), nrow = 10000) %*% diag(c(9, 4, 1, 1))
mds &lt;- interpolation_mds(x = x, l = 200, r = 2, n_cores = 1)
head(mds$points)
mds$eigen

</code></pre>


</div>