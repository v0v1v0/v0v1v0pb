<div class="container">

<table style="width: 100%;"><tr>
<td>pwbart</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Predicting new observations with a previously fitted BART model</h2>

<h3>Description</h3>

<p>BART is a Bayesian “sum-of-trees” model.<br>
For a numeric response <code class="reqn">y</code>, we have
<code class="reqn">y = f(x) + \epsilon</code>,
where <code class="reqn">\epsilon \sim N(0,\sigma^2)</code>.<br></p>
<p><code class="reqn">f</code> is the sum of many tree models.
The goal is to have very flexible inference for the uknown
function <code class="reqn">f</code>.
</p>
<p>In the spirit of “ensemble models”,
each tree is constrained by a prior to be a weak learner
so that it contributes a
small amount to the overall fit.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pwbart( x.test, treedraws, mu=0, mc.cores=1L, transposed=FALSE,
        dodraws=TRUE,
        nice=19L ## mc.pwbart only
      )

mc.pwbart( x.test, treedraws, mu=0, mc.cores=2L, transposed=FALSE,
           dodraws=TRUE,
           nice=19L ## mc.pwbart only
         )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x.test</code></td>
<td>

<p>Matrix of covariates to predict <code class="reqn">y</code> for.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>treedraws</code></td>
<td>

<p><code>$treedraws</code> returned from <code>wbart</code> or <code>pbart</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>

<p>Mean to add on to <code class="reqn">y</code> prediction.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mc.cores</code></td>
<td>

<p>Number of threads to utilize.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transposed</code></td>
<td>

<p>When running <code>pwbart</code> or <code>mc.pwbart</code> in parallel, it is more memory-efficient
to transpose <code>x.test</code> prior to calling the internal versions of these functions.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dodraws</code></td>
<td>

<p>Whether to return the draws themselves (the default), or whether to
return the mean of the draws as specified by <code>dodraws=FALSE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nice</code></td>
<td>

<p>Set the job niceness.  The default
niceness is 19: niceness goes from 0 (highest) to 19 (lowest).
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>BART is an Bayesian MCMC method.
At each MCMC interation, we produce a draw from the joint posterior
<code class="reqn">(f,\sigma) | (x,y)</code> in the numeric <code class="reqn">y</code> case
and just <code class="reqn">f</code> in the binary <code class="reqn">y</code> case.
</p>
<p>Thus, unlike a lot of other modelling methods in R, we do not produce a single model object
from which fits and summaries may be extracted.  The output consists of values
<code class="reqn">f^*(x)</code> (and <code class="reqn">\sigma^*</code> in the numeric case) where * denotes a particular draw.
The <code class="reqn">x</code> is either a row from the training data (x.train) or the test data (x.test).
</p>


<h3>Value</h3>

<p>Returns a matrix of predictions corresponding to <code>x.test</code>.
</p>


<h3>See Also</h3>

<p><code>wbart</code>
<code>predict.wbart</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">##simulate data (example from Friedman MARS paper)
f = function(x){
10*sin(pi*x[,1]*x[,2]) + 20*(x[,3]-.5)^2+10*x[,4]+5*x[,5]
}
sigma = 1.0  #y = f(x) + sigma*z , z~N(0,1)
n = 100      #number of observations
set.seed(99)
x=matrix(runif(n*10),n,10) #10 variables, only first 5 matter
y=f(x)

##test BART with token run to ensure installation works
set.seed(99)
post = wbart(x,y,nskip=5,ndpost=5)
x.test = matrix(runif(500*10),500,10)

## Not run: 
##run BART
set.seed(99)
post = wbart(x,y)
x.test = matrix(runif(500*10),500,10)
pred = pwbart(post$treedraws, x.test, mu=mean(y))

plot(apply(pred, 2, mean), f(x.test))


## End(Not run)
</code></pre>


</div>