<div class="container">

<table style="width: 100%;"><tr>
<td>predict.bigssa</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Predicts for "bigssa" Objects
</h2>

<h3>Description</h3>

<p>Get fitted values and standard error estimates for smoothing spline anova models. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'bigssa'
predict(object,newdata=NULL,se.fit=FALSE,include=object$tnames,
        effect=c("all","0","lin","non"),includeint=FALSE,
        design=FALSE,smoothMatrix=FALSE,intercept=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>Object of class "bigssa", which is output from <code>bigssa</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>

<p>Data frame or list containing the new data points for prediction. Variable names must match those used in the <code>formula</code> input of <code>bigssa</code>. See Details and Example. Default of <code>newdata=NULL</code> uses original data in <code>object</code> input.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.fit</code></td>
<td>

<p>Logical indicating whether the standard errors of the fitted values should be estimated. Default is <code>se.fit=FALSE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include</code></td>
<td>

<p>Which terms to include in the estimate. You can get fitted values for any combination of terms in the <code>tnames</code> element of an "bigssa" object.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>effect</code></td>
<td>

<p>Which effect to estimate: <code>effect="all"</code> gives <code class="reqn">\hat{y}</code> for given terms in <code>include</code>, <code>effect="lin"</code> gives linear portion of <code class="reqn">\hat{y}</code> for given terms in <code>include</code>, and <code>effect="non"</code> gives nonlinear portion of <code class="reqn">\hat{y}</code> for given terms in <code>include</code>. Use <code>effect="0"</code> to return the intercept.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>includeint</code></td>
<td>

<p>Logical indicating whether the intercept should be included in the prediction. If <code>include=object$tnames</code> and <code>effect="all"</code> (default), then this input is ignored and the intercept is automatically included in the prediction.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>design</code></td>
<td>

<p>Logical indicating whether the design matrix should be returned.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smoothMatrix</code></td>
<td>

<p>Logical indicating whether the smoothing matrix should be returned.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>

<p>Logical indicating whether the intercept should be included in the prediction. When used, this input overrides the <code>includeint</code> input.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Ignored.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Uses the coefficient and smoothing parameter estimates from a fit smoothing spline anova (estimated by <code>bigssa</code>) to predict for new data.
</p>


<h3>Value</h3>

<p>If <code>se.fit=FALSE</code>, <code>design=FALSE</code>, and <code>smoothMatrix=FALSE</code>, returns vector of fitted values.
</p>
<p>Otherwise returns list with elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>Vector of fitted values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.fit</code></td>
<td>
<p>Vector of standard errors of fitted values (if <code>se.fit=TRUE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Design matrix used to create fitted values (if <code>design=TRUE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ix</code></td>
<td>
<p>Index vector such that <code>fit=X%*%object$modelspec$coef[ix]</code> (if <code>design=TRUE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>Smoothing matrix corresponding to fitted values (if <code>smoothMatrix=TRUE</code>)</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Gu, C. (2013). <em>Smoothing spline ANOVA models, 2nd edition</em>. New York: Springer.
</p>
<p>Helwig, N. E. (2013). <em>Fast and stable smoothing spline analysis of variance models for large samples with applications to electroencephalography data analysis</em>. Unpublished doctoral dissertation. University of Illinois at Urbana-Champaign.
</p>
<p>Helwig, N. E. (2016). Efficient estimation of variance components in nonparametric mixed-effects models with large samples. <em>Statistics and Computing, 26</em>, 1319-1336.
</p>
<p>Helwig, N. E. (2017). <a href="http://dx.doi.org/10.3389/fams.2017.00015">Regression with ordered predictors via ordinal smoothing splines</a>. Frontiers in Applied Mathematics and Statistics, 3(15), 1-13.
</p>
<p>Helwig, N. E. and Ma, P. (2015). Fast and stable multiple smoothing parameter selection in smoothing spline analysis of variance models with large samples. <em>Journal of Computational and Graphical Statistics, 24</em>, 715-732.
</p>
<p>Helwig, N. E. and Ma, P. (2016). Smoothing spline ANOVA for super-large samples: Scalable computation via rounding parameters. <em>Statistics and Its Interface, 9</em>, 433-444.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
##########   EXAMPLE 1   ##########

# define univariate function and data
set.seed(773)
myfun &lt;- function(x){ 2 + x + sin(2*pi*x) }
x &lt;- runif(500)
y &lt;- myfun(x) + rnorm(500)

# fit cubic spline model
cubmod &lt;- bigssa(y~x,type="cub",nknots=30)
crossprod( predict(cubmod) - myfun(x) )/500

# define new data for prediction
newdata &lt;- data.frame(x=seq(0,1,length.out=100))

# get fitted values and standard errors for new data
yc &lt;- predict(cubmod,newdata,se.fit=TRUE)

# plot results with 95% Bayesian confidence interval
plot(newdata$x,yc$fit,type="l")
lines(newdata$x,yc$fit+qnorm(.975)*yc$se.fit,lty=3)
lines(newdata$x,yc$fit-qnorm(.975)*yc$se.fit,lty=3)

# predict constant, linear, and nonlinear effects
yc0 &lt;- predict(cubmod,newdata,se.fit=TRUE,effect="0")
ycl &lt;- predict(cubmod,newdata,se.fit=TRUE,effect="lin")
ycn &lt;- predict(cubmod,newdata,se.fit=TRUE,effect="non")
crossprod( yc$fit - (yc0$fit + ycl$fit + ycn$fit) )

# plot results with 95% Bayesian confidence intervals
par(mfrow=c(1,2))
plot(newdata$x,ycl$fit,type="l",main="Linear effect")
lines(newdata$x,ycl$fit+qnorm(.975)*ycl$se.fit,lty=3)
lines(newdata$x,ycl$fit-qnorm(.975)*ycl$se.fit,lty=3)
plot(newdata$x,ycn$fit,type="l",main="Nonlinear effect")
lines(newdata$x,ycn$fit+qnorm(.975)*ycn$se.fit,lty=3)
lines(newdata$x,ycn$fit-qnorm(.975)*ycn$se.fit,lty=3)
         
         
##########   EXAMPLE 2   ##########

# define bivariate function and data
set.seed(773)
myfun&lt;-function(x){
  2 + x[,1]/10 - x[,2]/5 + 2*sin(sqrt(x[,1]^2+x[,2]^2+.1))/sqrt(x[,1]^2+x[,2]^2+.1)
}
x1v &lt;- runif(500)*16-8
x2v &lt;- runif(500)*16-8
y &lt;- myfun(cbind(x1v,x2v)) + rnorm(500)

# tensor product cubic splines with 50 knots
cubmod &lt;- bigssa(y~x1v*x2v,type=list(x1v="cub",x2v="cub"),nknots=50)
crossprod( predict(cubmod) - myfun(cbind(x1v,x2v)) )/500

# define new data for prediction
xnew &lt;- as.matrix(expand.grid(seq(-8,8,l=50),seq(-8,8,l=50)))
newdata &lt;- list(x1v=xnew[,1],x2v=xnew[,2])

# get fitted values for new data
yp &lt;- predict(cubmod,newdata)

# plot results
imagebar(seq(-8,8,l=50),seq(-8,8,l=50),matrix(yp,50,50),
         xlab=expression(italic(x)[1]),ylab=expression(italic(x)[2]),
         zlab=expression(hat(italic(y))))

# predict linear and nonlinear effects for x1v
newdata &lt;- list(x1v=seq(-8,8,length.out=100))
yl &lt;- predict(cubmod,newdata,include="x1v",effect="lin",se.fit=TRUE)
yn &lt;- predict(cubmod,newdata,include="x1v",effect="non",se.fit=TRUE)

# plot results with 95% Bayesian confidence intervals
par(mfrow=c(1,2))
plot(newdata$x1v,yl$fit,type="l",main="Linear effect")
lines(newdata$x1v,yl$fit+qnorm(.975)*yl$se.fit,lty=3)
lines(newdata$x1v,yl$fit-qnorm(.975)*yl$se.fit,lty=3)
plot(newdata$x1v,yn$fit,type="l",main="Nonlinear effect",ylim=c(-.3,.4))
lines(newdata$x1v,yn$fit+qnorm(.975)*yn$se.fit,lty=3)
lines(newdata$x1v,yn$fit-qnorm(.975)*yn$se.fit,lty=3)

</code></pre>


</div>