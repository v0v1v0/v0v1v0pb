<div class="container">

<table style="width: 100%;"><tr>
<td>simBuyseTest</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulation of data for the BuyseTest</h2>

<h3>Description</h3>

<p>Simulate categorical, continuous or time to event endpoints, possibly along with a strata variable.
Categorical endpoints are simulated by thresholding a latent Gaussian variable (tobit model),
continuous endpoints are simulated using a Gaussian distribution,
and time to event endpoints are simulated using Weibull distributions for the event of interest, competing events, and censoring.
This function is built upon the <code>lvm</code> and <code>sim</code> functions from the lava package.
</p>


<h3>Usage</h3>

<pre><code class="language-R">simBuyseTest(
  n.T,
  n.C = NULL,
  argsBin = list(),
  argsCont = list(),
  argsTTE = list(),
  names.strata = NULL,
  level.strata = NULL,
  n.strata = NULL,
  name.cluster = "id",
  prefix.cluster = NULL,
  name.treatment = "treatment",
  level.treatment = c("C", "T"),
  format = "data.table",
  latent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n.T</code></td>
<td>
<p>[integer, &gt;0] number of patients in the treatment arm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.C</code></td>
<td>
<p>[integer, &gt;0] number of patients in the control arm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>argsBin</code></td>
<td>
<p>[list] arguments to be passed to <code>simBuyseTest_bin</code>. They specify the distribution parameters of the categorical endpoints.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>argsCont</code></td>
<td>
<p>[list] arguments to be passed to <code>simBuyseTest_continuous</code>. They specify the distribution parameters of the continuous endpoints.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>argsTTE</code></td>
<td>
<p>[list]  arguments to be passed to <code>simBuyseTest_TTE</code>. They specify the distribution parameters of the time to event endpoints.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names.strata</code></td>
<td>
<p>[character vector] name of the strata variables. Must have same length as <code>n.strata</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level.strata</code></td>
<td>
<p>[list of character vector] value associated to each strata. Must have same length as <code>n.strata</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.strata</code></td>
<td>
<p>[integer, &gt;0] number of strata. <code>NULL</code> indicates no strata.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name.cluster</code></td>
<td>
<p>[character] name of the cluster variable. If <code>NULL</code> no cluster variable is created.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prefix.cluster</code></td>
<td>
<p>[character] character string to be added to the cluster index.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name.treatment</code></td>
<td>
<p>[character] name of the treatment variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level.treatment</code></td>
<td>
<p>[character vector of length 2] levels of the treatment variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>format</code></td>
<td>
<p>[character] the format of the output. Can be <code>"data.table"</code>, <code>"data.frame"</code>, <code>"matrix"</code> or <code>"function"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>latent</code></td>
<td>
<p>[logical] If <code>TRUE</code> also export the latent variables (e.g. censoring times or event times).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Endpoints are simulated independently of the strata variable and independently of each other,
with the exception of categorical endpoint and the time to event endpoints that can be correlated
by specifying a non-0 value for the <code>rho.T</code> and <code>rho.C</code> elements of the argument <code>argsBin</code>.
</p>
<p>Arguments in the list <code>argsBin</code>:
</p>

<ul>
<li>
<p><code>p.T</code> list of probabilities for the values taken by each endpoint (categorical endpoint, treatment group). 
</p>
</li>
<li>
<p><code>p.C</code> same as <code>p.T</code> but for the control group. 
</p>
</li>
<li>
<p><code>rho.T</code> value of the regression coefficient between the underlying latent variable and the survival time.
Only implemented for weibull distributed survival times.
</p>
</li>
<li>
<p><code>rho.C</code> same as <code>rho.T</code> but for the control group. 
</p>
</li>
<li>
<p><code>name</code> names of the binary variables.
</p>
</li>
</ul>
<p>Arguments in the list <code>argsCont</code>:
</p>

<ul>
<li>
<p><code>mu.T</code> expected value of each endpoint (continuous endpoint, treatment group). 
</p>
</li>
<li>
<p><code>mu.C</code> same as <code>mu.C</code> but for the control group. 
</p>
</li>
<li>
<p><code>sigma.T</code> standard deviation of the values of each endpoint (continuous endpoint, treatment group). 
</p>
</li>
<li>
<p><code>sigma.C</code> same as <code>sigma.T</code> but for the control group. 
</p>
</li>
<li>
<p><code>name</code> names of the continuous variables.
</p>
</li>
</ul>
<p>Arguments in the list <code>argsTTE</code>:
</p>

<ul>
<li>
<p><code>CR</code> should competing risks be simulated? 
</p>
</li>
<li>
<p><code>scale.T,scale.C,scale.CR,scale.censoring.T,scale.censoring.C</code> scale parameter of the Weibull distribution for, respectively,
the event of interest in the treatment group,
the event of interest in the control group,
the competing event in both groups,
the censoring mechanism in the treatment group,
the censoring mechanism in the control group
</p>
</li>
<li>
<p><code>shape.T,shape.C,shape.CR,shape.censoring.T,shape.censoring.C</code> shape parameter of the Weibull distribution for, respectively,
the event of interest in the treatment group,
the event of interest in the control group,
the competing event in both groups,
the censoring mechanism in the treatment group,
the censoring mechanism in the control group
</p>
</li>
<li>
<p><code>dist.T,dist.C,dist.CR,dist.censoring.T,dist.censoring.C</code> type of distribution (<code>"weibull"</code>, <code>"uniform"</code>, <code>"piecewiseExp"</code>) for, respectively,
the event of interest in the treatment group,
the event of interest in the control group,
the competing event in both groups,
the censoring mechanism in the treatment group,
the censoring mechanism in the control group.
For uniform distirbutions the (scale,shape) parameters becomes the support (min, max) of the censoring distribution.
For piecewise exponential distributions the (scale,shape) should be lists of numeric (see example)
and the shape parameters becomes the time parameters (first element should be 0).
</p>
</li>
<li>
<p><code>name</code> names of the time to event variables. 
</p>
</li>
<li>
<p><code>name.censoring</code> names of the event type indicators. #'      
</p>
</li>
</ul>
<h3>Value</h3>

<p>Depends on the argument <code>format</code>: either a data.frame, data.table, matrix containing the simulated data, 
or a function that can be used to simulate data.
</p>


<h3>Author(s)</h3>

<p>Brice Ozenne
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(data.table)

n &lt;- 1e2

#### by default ####
simBuyseTest(n)

## with a strata variable having 5 levels
simBuyseTest(n, n.strata = 5)
## with a strata variable named grade
simBuyseTest(n, n.strata = 5, names.strata = "grade")
## several strata variables
simBuyseTest(1e3, n.strata = c(2,4), names.strata = c("Gender","AgeCategory"))

#### only categorical endpoints ####
args &lt;- list(p.T = list(c(low=0.1,moderate=0.5,high=0.4)))
dt.bin &lt;- simBuyseTest(n, argsBin = args, argsCont = NULL, argsTTE = NULL)
table(dt.bin$toxicity)/NROW(dt.bin)

args &lt;- list(p.T = list(c(low=0.1,moderate=0.5,high=0.4), c(0.1,0.9)))
dt.bin &lt;- simBuyseTest(n, argsBin = args, argsCont = NULL, argsTTE = NULL)
table(dt.bin$toxicity1)/NROW(dt.bin)
table(dt.bin$toxicity2)/NROW(dt.bin)

#### only continuous endpoints ####
args &lt;- list(mu.T = c(3:5/10), sigma.T = rep(1,3))
dt.cont &lt;- simBuyseTest(n, argsBin = NULL, argsCont = args, argsTTE = NULL)
c(mean(dt.cont$score1), mean(dt.cont$score2), mean(dt.cont$score3))
c(sd(dt.cont$score1), sd(dt.cont$score2), sd(dt.cont$score3))

#### only TTE endpoints ####
## weibull distributed
args &lt;- list(scale.T = c(3:5/10), scale.censoring.T = rep(1,3))
dt.tte &lt;- simBuyseTest(n, argsBin = NULL, argsCont = NULL, argsTTE = args)
1/c(sum(dt.tte$eventtime1)/sum(dt.tte$status1),
  sum(dt.tte$eventtime2)/sum(dt.tte$status2),
  sum(dt.tte$eventtime3)/sum(dt.tte$status3))
        
1/c(sum(dt.tte$eventtime1)/sum(dt.tte$status1==0),
  sum(dt.tte$eventtime2)/sum(dt.tte$status2==0),
  sum(dt.tte$eventtime3)/sum(dt.tte$status3==0))

hist(dt.tte$eventtime1)

## uniform distributed
args &lt;- list(scale.T = 0, shape.T = 1, dist.T = "uniform", scale.censoring.T = 1e5,
             scale.C = 0, shape.C = 2, dist.C = "uniform", scale.censoring.C = 1e5)
dt.tte &lt;- simBuyseTest(n, argsBin = NULL, argsCont = NULL, argsTTE = args)

par(mfrow=c(1,2))
hist(dt.tte$eventtime[dt.tte$treatment=="C"])
hist(dt.tte$eventtime[dt.tte$treatment=="T"])

## piecewise constant exponential distributed
## time [0;4]: scale parameter 10
## time [4;12]: scale parameter 13
## time [12;18.]: scale parameter 18
## time [18.5;36]: scale parameter 31
## after that: scale parameter 37
vec.scale &lt;- list(c(10,13,18,31,100))
vec.time &lt;- list(c(0,4,12,18.5,36))
args &lt;- list(scale.T = vec.scale, shape.T = vec.time, dist.T = "piecewiseExp",
             scale.C = 10, shape.C = 1, dist.C = "weibull",
             scale.censoring.T = 1e5)
dt.tte &lt;- simBuyseTest(n, argsBin = NULL, argsCont = NULL, argsTTE = args)

if(require(prodlim)){
plot(prodlim(Hist(eventtime,status)~treatment, data = dt.tte))
}

#### correlated categorical / time to event endpoint ####
## WARNING: only for weibull distributed time to event endpoint
args.bin &lt;- list(p.T = list(c(low=0.1,moderate=0.5,high=0.4)), rho.T = 1)
args.tte &lt;- list(scale.T = 2, scale.censoring.T = 1)
dt.corr &lt;- simBuyseTest(n, argsBin = args.bin, argsCont = NULL, argsTTE = args.tte)

1/(sum(dt.corr$eventtime)/sum(dt.corr$status))
1/(sum(dt.corr$eventtime)/sum(dt.corr$status==0))
table(dt.corr$toxicity)/NROW(dt.corr)

boxplot(eventtime ~ toxicity, data = dt.corr)

#### pre-computation ####
library(lava)
mySimulator &lt;- simBuyseTest(n, format = "function") ## creates lvm object once for all
set.seed(1)
sim(mySimulator)
set.seed(2)
sim(mySimulator) 

</code></pre>


</div>