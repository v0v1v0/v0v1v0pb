<div class="container">

<table style="width: 100%;"><tr>
<td>predict.lbart</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Predicting new observations with a previously fitted BART model</h2>

<h3>Description</h3>

<p>BART is a Bayesian “sum-of-trees” model.<br>
For a numeric response <code class="reqn">y</code>, we have
<code class="reqn">y = f(x) + \epsilon</code>,
where <code class="reqn">\epsilon \sim N(0,\sigma^2)</code>.<br></p>
<p><code class="reqn">f</code> is the sum of many tree models.
The goal is to have very flexible inference for the uknown
function <code class="reqn">f</code>.
</p>
<p>In the spirit of “ensemble models”,
each tree is constrained by a prior to be a weak learner
so that it contributes a
small amount to the overall fit.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'lbart'
predict(object, newdata, mc.cores=1, openmp=(mc.cores.openmp()&gt;0), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p><code>object</code> returned from previous BART fit with <code>surv.bart</code>
or <code>mc.surv.bart</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>

<p>Matrix of covariates to predict the distribution of <code class="reqn">t</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mc.cores</code></td>
<td>

<p>Number of threads to utilize.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>openmp</code></td>
<td>

<p>Logical value dictating whether OpenMP is utilized for parallel
processing.  Of course, this depends on whether OpenMP is available
on your system which, by default, is verified with <code>mc.cores.openmp</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Other arguments which will be passed on to <code>pwbart</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>BART is an Bayesian MCMC method.
At each MCMC interation, we produce a draw from the joint posterior
<code class="reqn">(f,\sigma) | (x,y)</code> in the numeric <code class="reqn">y</code> case
and just <code class="reqn">f</code> in the binary <code class="reqn">y</code> case.
</p>
<p>Thus, unlike a lot of other modelling methods in R, we do not produce a single model object
from which fits and summaries may be extracted.  The output consists of values
<code class="reqn">f^*(x)</code> (and <code class="reqn">\sigma^*</code> in the numeric case) where * denotes a particular draw.
The <code class="reqn">x</code> is either a row from the training data (x.train) or the test data (x.test).
</p>


<h3>Value</h3>

<p>Returns an object of type <code>lbart</code> with predictions corresponding to <code>newdata</code>.
</p>


<h3>See Also</h3>

<p><code>surv.bart</code>, <code>mc.surv.bart</code>, <code>surv.pwbart</code>, <code>mc.surv.pwbart</code>, <code>mc.cores.openmp</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## load the advanced lung cancer example
data(lung)

group &lt;- -which(is.na(lung[ , 7])) ## remove missing row for ph.karno
times &lt;- lung[group, 2]   ##lung$time
delta &lt;- lung[group, 3]-1 ##lung$status: 1=censored, 2=dead
                          ##delta: 0=censored, 1=dead

## this study reports time in days rather than months like other studies
## coarsening from days to months will reduce the computational burden
times &lt;- ceiling(times/30)

summary(times)
table(delta)

x.train &lt;- as.matrix(lung[group, c(4, 5, 7)]) ## matrix of observed covariates

## lung$age:        Age in years
## lung$sex:        Male=1 Female=2
## lung$ph.karno:   Karnofsky performance score (dead=0:normal=100:by=10)
##                  rated by physician

dimnames(x.train)[[2]] &lt;- c('age(yr)', 'M(1):F(2)', 'ph.karno(0:100:10)')

summary(x.train[ , 1])
table(x.train[ , 2])
table(x.train[ , 3])

x.test &lt;- matrix(nrow=84, ncol=3) ## matrix of covariate scenarios

dimnames(x.test)[[2]] &lt;- dimnames(x.train)[[2]]

i &lt;- 1

for(age in 5*(9:15)) for(sex in 1:2) for(ph.karno in 10*(5:10)) {
    x.test[i, ] &lt;- c(age, sex, ph.karno)
    i &lt;- i+1
}

## this x.test is relatively small, but often you will want to
## predict for a large x.test matrix which may cause problems
## due to consumption of RAM so we can predict separately

## mcparallel/mccollect do not exist on windows
if(.Platform$OS.type=='unix') {
##test BART with token run to ensure installation works
    set.seed(99)
    post &lt;- surv.bart(x.train=x.train, times=times, delta=delta, nskip=5, ndpost=5, keepevery=1)

    pre &lt;- surv.pre.bart(x.train=x.train, times=times, delta=delta, x.test=x.test)

    pred &lt;- predict(post, pre$tx.test)
    ##pred. &lt;- surv.pwbart(pre$tx.test, post$treedraws, post$binaryOffset)
}

## Not run: 
## run one long MCMC chain in one process
set.seed(99)
post &lt;- surv.bart(x.train=x.train, times=times, delta=delta)

## run "mc.cores" number of shorter MCMC chains in parallel processes
## post &lt;- mc.surv.bart(x.train=x.train, times=times, delta=delta,
##                      mc.cores=5, seed=99)

pre &lt;- surv.pre.bart(x.train=x.train, times=times, delta=delta, x.test=x.test)

pred &lt;- predict(post, pre$tx.test)

## let's look at some survival curves
## first, a younger group with a healthier KPS
## age 50 with KPS=90: males and females
## males: row 17, females: row 23
x.test[c(17, 23), ]

low.risk.males &lt;- 16*post$K+1:post$K ## K=unique times including censoring
low.risk.females &lt;- 22*post$K+1:post$K

plot(post$times, pred$surv.test.mean[low.risk.males], type='s', col='blue',
     main='Age 50 with KPS=90', xlab='t', ylab='S(t)', ylim=c(0, 1))
points(post$times, pred$surv.test.mean[low.risk.females], type='s', col='red')


## End(Not run)
</code></pre>


</div>