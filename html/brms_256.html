<div class="container">

<table style="width: 100%;"><tr>
<td>mm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Set up multi-membership grouping terms in <span class="pkg">brms</span>
</h2>

<h3>Description</h3>

<p>Function to set up a multi-membership grouping term in <span class="pkg">brms</span>.
The function does not evaluate its arguments â€“
it exists purely to help set up a model with grouping terms.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mm(
  ...,
  weights = NULL,
  scale = TRUE,
  by = NULL,
  cor = TRUE,
  id = NA,
  cov = NULL,
  dist = "gaussian"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>One or more terms containing grouping factors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>A matrix specifying the weights of each member.
It should have as many columns as grouping terms specified in <code>...</code>.
If <code>NULL</code> (the default), equally weights are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>Logical; if <code>TRUE</code> (the default),
weights are standardized in order to sum to one per row.
If negative weights are specified, <code>scale</code> needs
to be set to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>
<p>An optional factor matrix, specifying sub-populations of the
groups. It should have as many columns as grouping terms specified in
<code>...</code>. For each level of the <code>by</code> variable, a separate
variance-covariance matrix will be fitted. Levels of the grouping factor
must be nested in levels of the <code>by</code> variable matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cor</code></td>
<td>
<p>Logical. If <code>TRUE</code> (the default), group-level terms will be
modelled as correlated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p>Optional character string. All group-level terms across the model
with the same <code>id</code> will be modeled as correlated (if <code>cor</code> is
<code>TRUE</code>). See <code>brmsformula</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov</code></td>
<td>
<p>An optional matrix which is proportional to the withon-group
covariance matrix of the group-level effects. All levels of the grouping
factor should appear as rownames of the corresponding matrix. This argument
can be used, among others, to model pedigrees and phylogenetic effects. See
<code>vignette("brms_phylogenetics")</code> for more details. By default, levels
of the same grouping factor are modeled as independent of each other.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist</code></td>
<td>
<p>Name of the distribution of the group-level effects.
Currently <code>"gaussian"</code> is the only option.</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>brmsformula</code>, <code>mmc</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# simulate some data
dat &lt;- data.frame(
 y = rnorm(100), x1 = rnorm(100), x2 = rnorm(100),
 g1 = sample(1:10, 100, TRUE), g2 = sample(1:10, 100, TRUE)
)

# multi-membership model with two members per group and equal weights
fit1 &lt;- brm(y ~ x1 + (1|mm(g1, g2)), data = dat)
summary(fit1)

# weight the first member two times for than the second member
dat$w1 &lt;- rep(2, 100)
dat$w2 &lt;- rep(1, 100)
fit2 &lt;- brm(y ~ x1 + (1|mm(g1, g2, weights = cbind(w1, w2))), data = dat)
summary(fit2)

# multi-membership model with level specific covariate values
dat$xc &lt;- (dat$x1 + dat$x2) / 2
fit3 &lt;- brm(y ~ xc + (1 + mmc(x1, x2) | mm(g1, g2)), data = dat)
summary(fit3)

## End(Not run)

</code></pre>


</div>