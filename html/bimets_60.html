<div class="container">

<table style="width: 100%;"><tr>
<td>SIMULATE</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Simulation of a BIMETS model
</h2>

<h3>Description</h3>

<p>The simulation of an econometric model basically consists in solving the system of the equations describing the model for each time period in the specified time interval. Since the equations may not be linear in the variables, and since the graph derived from the "incidence matrix" may be cyclic, the usual methods based on linear algebra are not applicable. The simulation must be solved by using an iterative algorithm (Users can find the "indicence matrix" definition in the following section "The Optimal Reordering").<br><br>
BIMETS simulation capabilities support:<br><br>
- <em>Static simulations</em>: a static multiple equation simulation, in which the historical values for the lagged endogenous variables are used in the solutions of subsequent periods; <br><br>
- <em>Dynamic simulations</em>: a dynamic simulation, in which the simulated values for the lagged endogenous variables are used in the solutions of subsequent periods;<br><br>
- <em>Residuals check</em>: a single period, single equation simulation; simulated time series in output are just the computation of the RHS (right-hand-side) of their equation, by using the historical values of the involved time series and by accounting for error autocorrelation and PDLs, if any;<br><br>
- <em>Forecast simulations</em>: similar to dynamic simulation, but during the initialization of the iterative algorithm the starting values of endogenous variables in a period are set equal to the simulated values of the previous period. This allows the simulation of future endogenous observations, i.e. the forecast;  <br><br>
- <em>Stochastic Simulation</em>: see <code>STOCHSIMULATE</code>;<br><br>
- <em>Partial or total exogenization of endogenous variables</em>: in the provided time interval (i.e. partial exog.) or in whole simulation time range (i.e. total exog.), the values of the selected endogenous variables can be definitely set equal to their historical values, by excluding their equations from the iterative algorithm of simulation;<br><br>
- <em>Constant adjustment of endogenous variables (add-factors)</em>: adds up a new exogenous time series - the "constant adjustment" - in the equation of the selected endogenous variables.<br><br>
- <em>Gauss-Seidel</em> and <em>Newton-Raphson</em> simulation algorithms: the Gauss-Seidel algorithm is simple, robust, and works well for many backward-looking macro-econometric models. Equations are evaluated as-is in a proper order until the convergence, if any, is verified on the so called "feedback variables" (Users can find the "feedback variable" definition in the next section "The Optimal Reordering"). It is slower than Newton-Raphson algorithms for a very low convergence criterion, and fails to find a convergence for a small set of econometric models, even when a convergence exists. The Newton-Raphson algorithm allows users to solve a broader set of macro-econometric models than the Gauss-Seidel algorithm. Moreover, it is usually faster than the Gauss-Seidel algorithm (on modern computers, users must simulate an extensive econometric model with a low convergence criterion to appreciate the speedup). This type of algorithm requires the construction and the inversion of the Jacobian matrix for the feedback variables; thus, in some scenarios, numerical issues can arise, and users are required to manually exclude some feedback variables from the Jacobian matrix by using the <code>JacobianDrop</code> argument of the <code>SIMULATE</code> procedure.<br><br>
In details, the generic model suitable for simulation in BIMETS can be written as: <br></p>
<p><code class="reqn">y_1=f_1(\bar{x},\bar{y}) </code> <br><code class="reqn">...</code> <br><code class="reqn">y_n=f_n(\bar{x},\bar{y}) </code> <br></p>
<p>being: <br><br><code class="reqn">n</code> the number of equations in the model; <br><code class="reqn">\bar{y}=[y_1, ... , y_n]</code> the <code>n</code>-dimensional vector of the endogenous variables;<br><code class="reqn">\bar{x}=[x_1, ... , x_m]</code> the <code>m</code>-dimensional vector of the exogenous variables;<br><code class="reqn">f_i(...), i=1..n</code> any kind of functional expression able to be written by using the <code>MDL</code> syntax;<br><br>
As described later on, in BIMETS a modified Gauss-Seidel iterative algorithm, or a Newton-Raphson algorithm, can solve the system of equations. The convergence properties may vary depending on the model specifications. In some conditions, the algorithm may not converge for a specific model or a specific set of data.<br><br>
A convergence criterion and a maximum number of iterations to be performed are provided by default. Users can change these criteria by using the <code>simConvergence</code> and <code>simIterLimit</code> arguments of the <code>SIMULATE</code> function.<br><br>
The general conceptual scheme of the simulation process (for each time period) is the following:<br><br>
1. initialize the solution for the current simulation period;<br>
2. iteratively solve the system of equations;<br>
3. save the solution, if any;<br><br>
Step 2 means that for each iteration, the operations are: <br><br>
2.1 update the values of the current endogenous variables;<br>
2.2 verify that the convergence criterion is satisfied or that the maximum number of allowed iterations has been reached;<br><br>
The initial solution for the iterative process (step 1) can be given alternatively by:<br><br>
- the historical value of the endogenous variables for the current simulation period (the default);<br>
- the simulated value of the endogenous variables from the previous simulation period (this alternative is driven by the <code>simType='FORECAST'</code> argument of the <code>SIMULATE</code> function);<br><br>
In the "dynamic" simulations (i.e. simulations performed by using either the default <code>simType='DYNAMIC'</code> or the <code>simType='FORECAST'</code>), whenever lagged endogenous variables are needed in the computation, the simulated values of the endogenous variables <code class="reqn">\bar{y}</code> assessed in the previous time periods are used. In this case, the simulation results in a given time period depend on the simulation results in the previous time periods. This kind of simulation is defined as "multiple equation, multiple period".<br><br>
As an alternative, the actual historical values can be used in the "static" simulations (i.e. simulations performed by using <code>simType='STATIC'</code>) rather than simulated values whenever lagged endogenous variables are needed in the computations. In this case, the simulation results in a given time period do not depend on the simulation results in the previous time periods. This kind of simulation is defined as "multiple equation, single period".<br><br>
The last simulation type available is the residual check (<code>simType='RESCHECK'</code>). With this option, a "single equation, single period" simulation is performed. In this case, no iteration must be carried out. The endogenous variables are assessed for each time period by using historical values for each variable on the right-hand side of the equation, for both lagged and current periods. This kind of simulation helps debug and check of the logical coherence of the equations and the data, and can be used as a simple tool to compute the add-factors.<br><br> The debugging of the logical coherence of equations and data is carried out through a <em>Residual Check</em> procedure.<br><br>
It consists of the following steps:<br><br>
1. add another exogenous variable - the constant adjustment - to every equation of the model, both behavioral and technical identity: that can be done in BIMETS by using the <code>ConstantAdjustment</code> argument of the <code>SIMULATE</code> function, as in step 3;<br>
2. fill in with the estimated residuals all the constant adjustments for the behavioral equations, and fill in with zeroes the constant adjustments for the technical identities: that can be done in BIMETS by using the <code>SIMULATE</code> procedure with the option <code>simType='RESCHECK'</code>, then by analyzing and using the <br><code>ConstantAdjustmentRESCHECK</code> attribute of the simulated model, as in the following simulation in step 3.<br>
3. perform a simulation of the model: that can be done in BIMETS by using the <code>SIMULATE</code> procedure with the option <br><code>ConstantAdjustment=ConstantAdjustmentRESCHECK</code>;<br>
4. compute the difference between the historical and the simulated values for all the endogenous variables;<br>
5. check whether all the differences assessed in step 4 are zero in whole time range, eventually accounting for the error autocorrelation in behaviorals.<br><br>
An example on <code>ConstantAdjustmentRESCHECK</code> usage is available at the end of the <code>SIMULATE</code> help page;<br><br>
If a perfect tracking of the history is obtained, then the equations have been written coherently with the data, otherwise a simulated equation not tracking the historical values is an unambiguous symptom of data inconsistent with the model definition.<br><br>
Aside from the residual check, the add-factors constitute an important tool to significantly improve the accuracy of forecasts made through an econometric model. Considering the following model: <br><br><code class="reqn">y_1=f_1(\bar{x},\bar{y}) + z_1</code> <br><code class="reqn">...</code> <br><code class="reqn">y_n=f_n(\bar{x},\bar{y}) + z_n</code> <br><br>
the add-factors <code class="reqn">\bar{z}=[z_1, ... ,z_n]</code> can be interpreted as estimates of the disturbance terms' future values or as adjustments of the intercepts in each equation. These add-factors round out the forecasts, by summarizing the effects of all the systematic factors not included in the model. One choice for the computation of the add-factors is given by past estimation residuals and past forecast errors or by an average of these errors. <br><br>
Please note that, in the case of equation that presents an LHS function, the add-factor will be added before the application of the inverse function, i.e., during the simulation, the following:<br><br><code class="reqn">g_1(y_1)=f_1(\bar{x},\bar{y}) + z_1</code> <br><code class="reqn">...</code> <br><code class="reqn">g_n(y_n)=f_n(\bar{x},\bar{y}) + z_n</code> <br><br>
will be solved as:<br><br><code class="reqn">y_1=g_{1}^{-1}(f_1(\bar{x},\bar{y}) + z_1)</code> <br><code class="reqn">...</code> <br><code class="reqn">y_n=g_{n}^{-1}(f_n(\bar{x},\bar{y}) + z_n)</code> <br><br>
If a linear dependence between the simulated endogenous and the add-factor is preferred, users can manually insert an auxiliary equation <code class="reqn">w_i</code> into the model definition, e.g. the following:<br><br><code class="reqn">g_i(y_i)=f_i(\bar{x},\bar{y})</code> <br><br>
can be replaced by:<br><br><code class="reqn">w_i=f_i(\bar{x},\bar{y})</code> <br><code class="reqn">y_i=g_{i}^{-1}(w_i)</code> <br><br>
During the simulation, the add-factors (if requested by the user) will be applied as in the following:<br><br><code class="reqn">w_i=f_i(\bar{x},\bar{y}) + v_i</code> <br><code class="reqn">y_i=g_{i}^{-1}(w_i) + z_i</code> <br><br>
given <code class="reqn">v_i, z_i</code> as add-factors and the linear dependence from <code class="reqn">z_i</code> and <code class="reqn">y_i</code>. 
</p>

<table><tr>
<td style="text-align: center;">RATIONAL EXPECTATIONS MODELS</td>
</tr></table>
<p>BIMETS classifies a model as a forward-looking model if any model equation contains the <code>TSLEAD</code> time series function. Forward-looking models assume that economic agents have complete knowledge of an economic system and calculate the future value of economic variables correctly according to that knowledge. Thus, forward-looking models are called also rational expectations models and, in macro-econometric models, model-consistent expectations.<br><br>
In forward-looking models, simulation complexity arises, and all simulation periods must be solved simultaneously because equations can contain references to past and future values. Thus, given <code>N</code> simulation periods requested by the user, each model equation must be replicated <code>N-1</code> times and modified before the simulation takes place, accounting for lead transformations. Finally, the extended model must be simulated as a single block of equations. <br><br>
Internal data structures too, such as the incidence and the Jacobian matrix, and the reordering arrays <code>vpre</code> and <code>vblocks</code> (described later in the "The Optimal Reordering" section), grow with the number of simulation periods requested by the user. Therefore, they can only be calculated when a new simulation is requested rather than when the model <code>MDL</code> definition is parsed, further extending computational time in simulation.<br><br>
A simulation that spans several decades in a forward-looking models with hundreds of equations is not feasible in BIMETS. For a real scenario in a rational expectations model, see "Computational details and capabilities" section in the <a href="https://cran.r-project.org/package=bimets/vignettes/frb2bimets.pdf">"US Federal Reserve quarterly model (FRB/US) in R with bimets"</a> vignette.<br><br>
To understand BIMETS internals when dealing with forward-looking models, please consider the following simple example of a forward-looking model having a single identity:
</p>
<pre>
IDENTITY&gt; Y
EQ&gt; Y = TSLEAD(Y) - TSLAG(Y) + X
</pre>
<p>Given <code>X</code> as an exogenous variable, if the requested simulation has a <code>TSRANGE</code> that spans two periods, then the model will be internally transformed into something like:
</p>
<pre>
IDENTITY&gt; Y
EQ&gt; Y = Y__LEAD__1 - TSLAG(Y) + X

IDENTITY&gt; Y__LEAD__1
EQ&gt; Y__LEAD__1 = TSLEAD(Y,2) - Y + TSLEAD(X)
</pre>
<p>Accordingly, the model will be simulated only on the first period of the <code>TSRANGE</code>. Please note that <code>TSLAG(Y)</code> in the first equation, and <code>TSLEAD(Y,2)</code> in the second equation, are a kind of exogenous variables and must be defined in order for the simulation to be completed. Moreover, <code>Y</code> and <code>Y__LEAD__1</code> are simultaneously involved in the iterative simulation algorithm, and both depend on each other, as also stated in the incidence matrix for the extended model:
</p>
<pre>
$incidence_matrix

           Y Y__LEAD__1
Y          0          1
Y__LEAD__1 1          0
</pre>
<p>Due to the mechanism described above, only <code>DYNAMIC</code> simulations are allowed in forward-looking models. See examples below, for a Klein-like forward-looking model simulation.
</p>

<table><tr>
<td style="text-align: center;">THE OPTIMAL REORDERING</td>
</tr></table>
<p>In fact, the simulation process takes advantage of an appropriate equations reordering to increase the performances by iteratively solving only one subset of equations, while the others are solved straightforwardly. <em>"...a different ordering of the equations can substantially affect the speed of convergence of the algorithm; indeed some orderings may produce divergence. The less feedback there is, the better the chances for fast convergence..."</em> - Don, Gallo - Solving large sparse systems of equations in econometric models - Journal of Forecasting 1987.<br><br>
For backward-looking models, the <code>LOAD_MODEL</code> function builds the model's incidence matrix, then defines the proper equations reordering. The incidence matrix is built from the equations of the model; it is a square matrix in which each row and each column represent an endogenous variable. If the <code>(i,j)</code> element is equal to 1 then in the model definition the current value of the endogenous variable referred by the <code>i</code>-row depends directly from the current value of the endogenous variable referred by the <code>j</code>-column. The reader can see an incidence matrix example in the section <code>"BIMETS package"</code> of this manual wherein the content of the <code>kleinModel$incidence_matrix</code> variable is printed out.<br><br>
In econometric models, the incidence matrix is usually very sparse. Only a few of the total set of endogenous variables are used in each equation. In this situation, ordering the equation in a particular sequence will lead to a sensible reduction of the number of iterations needed to achieve convergence. Reordering the equations is equivalent to rearranging rows and columns of the incidence matrix. In this way, the incidence matrix might be made lower triangular for a subset of the equations.
For this subset, an endogenous variable determined in a specific equation has no <em>incidence</em> in any equation above it, although the same variable might have incidence in equations below it. Such a subset of equations is called recursive. Recursive systems are easy to solve. It is only necessary to solve each equation once if this is done in the proper order. On the other hand, it is unlikely for whole model to be recursive. Indeed the incidence graph is often cyclic, as in the Klein's model that presents the following circular dependecies in the incidence matrix: <code>p &lt;- w1 &lt;- y &lt;- i &lt;- p</code> as shown in the <code>"BIMETS package"</code> section figure.<br><br>
For some subsets of the equations, some 1's will occur in the upper triangle of the incidence matrix for all possible orderings. Such subsets of equations are called <em>simultaneous</em>. To solve the endogenous variables in the simultaneous subset of equations, an iterative algorithm has to be used. Nevertheless, the equations in a simultaneous subset may be ordered so that the pattern of the 1's in the upper triangle forms a spike. The variables corresponding to the 1's in the upper triangle are called <em>feedback</em> variables.<br><br>
A qualitative graphical example of an ordered incidence matrix is given in the following figure. The white areas are all 0's, the gray areas contain 0's and 1's. The 1's in the light gray areas refer to variables already evaluated in previous subset of equations, therefore they are known terms within the current subset. The 1's in the dark gray areas refer to variables evaluated within the subset.<br><br></p>
<p><img src="../help/figures/Reordering.png" alt="Reordering.png"></p>
<p>In BIMETS, the final pattern of an incidence matrix after the equations reordering generally features <code>N+1</code> blocks: <br><br>
- One recursive subset of equation, i.e. the pre-recursive <code>VPRE</code> in image;<br>
- <code>N</code> blocks of equations, <code>VBLOCK</code> in image, each built with a simultaneous <code>VSIM</code> and a post-recursive <code>VPOST</code> subset of equations;<br><br>
As said, the pre-recursive and the post-recursive subsets are lower triangular. Therefore the corresponding equations are solvable with a cascade substitution with no iteration. Only the simultaneous subsets need an iterative algorithm to be solved. It is important to say that the convergence criterion may also be applied to feedback variables only: when the feedback variables converge, the rest of the simultaneous variables also do.<br><br> BIMETS builds and analyzes the model's incidence matrix, and then it i) computes the strongly connected component of the related incidence graph by using the Tarjan algorithm (Ref: Tarjan, Robert - <em>Depth-first search and linear graph algorithms</em> - SIAM Journal on Computing - June 1972), and ii) orders the equations in pre-recursive and, for each block of equations, in simultaneous and post-recursive subsets. The simultaneous subsets are then analyzed in order to find a minimal set of feedback variables. This last problem is known to be NP-complete (Ref: Garey, Johnson - <em>Computers and Intractability: a Guide to the Theory of NP-completeness</em> - San Francisco, Freeman 1979).<br><br>
The optimal reordering of the model equations is programmatically achieved through the use of an iterative algorithm applied to the incidence matrix that can produce <code>1+3*N</code> ordered lists of endogenous variables, respectively:<br><br>
1. One  list <code>vpre</code> that is the ordered list containing the names of the endogenous pre-recursive variables to be sequentially computed (once per simulation period) before the simulation iterative algorithm takes place;<br>
2. For each of the <code>N</code> elements in the <code>vblocks</code> list: <br>
2.1 One list <code>vsim</code> (the simultaneous subset) that is the ordered list containing the names of the endogenous variables to be sequentially computed during each iteration of the simulation iterative algorithm;<br>
2.2 One list <code>vfeed</code> that is the list containing the names of the endogenous feedback variables; generally <code>vfeed</code> are the last variables in the ordered <code>vsim</code> list in the sambe block; <br>
2.3. One list <code>vpost</code> that is the ordered list containing the names of the endogenous post-recursive variables to be sequentially computed (once per simulation period) after the simulation iterative algorithm has found a solution in the previous simultaneous subset in the same block;<br><br>
Once equations are reordered, the previous conceptual scheme is modified as follows:<br><br>
1. initialize the solution for the current simulation period;<br>
2. compute the pre-recursive equations (i.e. the equation of the endogenous variables in the <code>vpre</code> ordered list);<br>
For each block in <code>vblocks</code>:<br>
3.1 iteratively compute the system of simultaneous equations (i.e. the equation of the endogenous variables in the <code>vsim</code> ordered list): for each iteration: i) update the values of the current endogenous variables, ii) update the feedback variables accordingly to the simulation algorithm in use (see next section for details on simulation algorithms) and iii) verify that the convergence criterion is satisfied on the feedback variables <code>vfeed</code> or that the maximum number of iterations has been reached;<br>
3.2 compute the post-recursive equations (i.e. the equation of the endogenous variables in the <code>vpost</code> ordered list);<br>
Finally:<br>
4. save the solutions;<br><br>
Clearly, each endogenous variable is updated accordingly to its related equation <code>EQ&gt;</code> in the <code>MDL</code> model definition.<br><br>
In forward-looking models, the incidence matrix and the equations reordering depend on the simulation periods count, therefore the model attributes <code>incidence_matrix</code>, <code>vblocks</code>, and <code>vpre</code> are calculated only after a simulation has been initialized, and will be available to users in the <code>model$simulation[['__SIM_PARAMETERS__']]</code> lists.<br><br>
The reader can see an equations reordering example in the section <code>"BIMETS package"</code> of this manual wherein the content of the <code>kleinModel$vpre</code> and <code>kleinModel$vblocks</code> variables are printed out.<br><br></p>

<table><tr>
<td style="text-align: center;">THE SIMULATION ALGORITHMS</td>
</tr></table>
<p>Given <code class="reqn">x_{j}</code> the <code class="reqn">j</code>-exogenous variable, <code class="reqn">j=1..m</code>, and <code class="reqn">y_{i,k}</code>  the <code class="reqn">i</code>-endogenous variable in a simultaneous subset, at the iteration <code class="reqn">k</code>, with <code class="reqn">i=1..n</code> the position of the equation in a reordered model, the modified Gauss-Seidel method takes for the approximation of the endogenous variable <code class="reqn">y_{i,k}</code> the solution of the following:<br><br><code class="reqn">y_{i,k}=f_i(x_1, ..., x_m, y_{1,k}, ..., y_{i-1,k}, y_{i,k-1},..., y_{n,k-1})</code><br><br>
Newton-Raphson's methods can be seen as an extension of the modified Gauss-Seidel algorithm, and a further step is required: in Newton-Raphson, feedback variables are updated not by using their model equations, but by using the inverse of the Jacobian matrix and the following assignment:<br><br><code class="reqn">\bar{y}^F_{k} \leftarrow \bar{y}^F_{k-1}+(I-J)^{-1}[\bar{y}^F_{k}-\bar{y}^F_{k-1}]</code><br><br>
given the vector of feedback variables values  <code class="reqn">\bar{y}^F_{k}=[y_{n-F+1,k},...,y_{n,k}]</code> at iteration <code class="reqn">k</code>, the identity matrix <code class="reqn">I</code>, and the Jacobian matrix <code class="reqn">J</code>, with <code class="reqn">I,J \in R^{F,F}</code> and <code class="reqn">F</code> equal to the number of feedback variables for the given block of equations. Please note that the modified Gauss-Seidel algorithm can be seen as a reduced form of a Netwotn algorithm, given <code class="reqn">J=0</code>.<br><br> In Newton-Raphson methods, the Jacobian matrix <code class="reqn">J</code> is calculated as follows:<br>
1 - shock the feedback variables one at a time by a small amount;<br>
2 - for each shocked feedback variable, evaluate the shocked solution of the simultaneous subset in the current block;<br>
3 - calculate the derivatives (i.e. the column in the Jacobian matrix related to the shocked feedback variable) using the difference quotients between the shocked and the base solution of the simultaneous subset.
<br><br>
As said, the convergence is always tested at each iteration's end on the feedback variables.<br><br>
Newton-Raphson methods on a reordered model require the calculation of the Jacobian matrix on the feedback endogenous variables, i.e. at least <code class="reqn">F+2</code> iterations per simulation period, with <code class="reqn">F</code> as the number of feedback variables. For large models (i.e. more than 30 feedback variables) if the overall required convergence is greater than <code class="reqn">10^{-6} \%</code> the speedup over the Gauss-Seidel method is small or negative, if the Jacobian matrix is recalculated at each iteration. Moreover, the Gauss-Seidel method does not require a matrix inversion; therefore, it is more robust against algebraical and numerical issues. For small models, both methods are fast on modern computers. On the other hand, Gausse-Seidel fails to find a convergence for a small set of econometric models, even when a convergence exists. In general, given a system of equations <code class="reqn">Ax=b</code>, with <code class="reqn">x,b \in R^n, n&gt;0</code> and <code class="reqn">A \in R^{n, n}</code>, the Gauss-Seidel algorithm is known to converge if either:<br>
- <code class="reqn">A</code> is symmetric positive-definite;<br>
- <code class="reqn">A</code> is strictly or irreducibly diagonally dominant. <br><br>
To improve simulation speed, BIMETS evaluates the Newton-Raphson algorithm's performance during simulation, and, at each iteration, a new Jacobian matrix is calculated <em>only if</em> the convergence speed is slower than a predefined threshold. In a vectorized simulation (e.g., <code>STOCHSIMULATE</code>,  <code>OPTIMIZE</code>,  <code>RENORM</code>), if <code>simAlgo="NEWTON"</code> the Jacobian matrix is calculated only on the unperturbed model, then applied to all realizations; if <code>simAlgo="FULLNEWTON"</code> a new Jacobian matrix is calculated for each realization.<br><br> The simulation of a non-trivial model, if computed by using the same data but on different hardware, software or numerical libraries, produces numerical differences. Therefore a convergence criterion smaller than <code class="reqn">10^{-7} \%</code> frequently leads to a local solution.<br><br> See <em>Numerical methods for simulation and optimal control of large-scale macroeconomic models - Gabay, Nepomiastchy, Rachidi, Ravelli - 1980</em> for further information. <br><br></p>
<p>For more realistic scenarios, several advanced econometric exercises on the US Federal Reserve FRB/US econometric model (e.g., dynamic simulation in a monetary policy shock, rational expectations, endogenous targeting, stochastic simulation, etc.) are available in the <a href="https://cran.r-project.org/package=bimets/vignettes/frb2bimets.pdf">"US Federal Reserve quarterly model (FRB/US) in R with bimets"</a> vignette. <br><br></p>


<h3>Usage</h3>

<pre><code class="language-R">SIMULATE( model=NULL,
          simAlgo='GAUSS-SEIDEL',
          TSRANGE=NULL,
          simType='DYNAMIC',
          simConvergence=0.01,
          simIterLimit=100,
          ZeroErrorAC=FALSE,
          BackFill=0,
          Exogenize=NULL,
          ConstantAdjustment=NULL,
          verbose=FALSE,
          verboseSincePeriod=0,
          verboseVars=NULL,
          MULTMATRIX=FALSE,
          RENORM=FALSE,
          TARGET=NULL,
          INSTRUMENT=NULL,
          MM_SHOCK=0.00001,
          STOCHSIMULATE=FALSE,
          StochStructure=NULL,
          StochReplica=100,
          StochSeed=NULL,
          OPTIMIZE=FALSE,
          OptimizeBounds=NULL,
          OptimizeRestrictions=NULL,
          OptimizeFunctions=NULL,
          quietly=FALSE,
          RESCHECKeqList=NULL,
          JACOBIAN_SHOCK=1e-4,
          JacobianDrop=NULL,
          forceForwardLooking=FALSE,
          avoidCompliance=FALSE,
          ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>

<p>The BIMETS model object to be simulated. The simulation requires that all the model behaviorals, if any, have been previously estimated: all the behavioral coefficients (i.e. the regression coefficients and the autoregression coefficients for the errors, if any) must be numerically defined in the model object. (see also <code>ESTIMATE</code>)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simAlgo</code></td>
<td>

<p>The simulation algorithm to be used to solve the system of model equations for each time period in the simulation <code>TSRANGE</code>.<br>
The options are:<br><b>GAUSS-SEIDEL</b>: (default) the Gauss-Seidel algorithm is simple, robust, and works well for many backward-looking macro-econometric models. Equations are evaluated as-is in a proper order until the convergence, if any, is verified on feedback variables (see "The Simulation Algorithms") section up here). It is slower than Newton-Raphson algorithms for a very low convergence criterion, and fails to find a convergence for a small set of econometric models, even when a convergence exists. In general, given a system of equations <code class="reqn">Ax=b</code>, with <code class="reqn">x,b \in R^n, n&gt;0</code> and <code class="reqn">A \in R^{n, n}</code>, the Gauss-Seidel algorithm is known to converge if either:<br>
- <code class="reqn">A</code> is symmetric positive-definite;<br>
- <code class="reqn">A</code> is strictly or irreducibly diagonally dominant. <br><b>NEWTON</b>: the Newton-Raphson algorithm allows users to solve a broader set of macro-econometric models than the Gauss-Seidel algorithm. Moreover, it is faster than the Gauss-Seidel algorithm in most cases (on modern computers, users must simulate an extensive econometric model with a low convergence criterion to appreciate the speedup). This type of algorithm requires the construction and the inversion of the Jacobian matrix for the feedback variables; thus, in some scenarios (e.g., equations with unverified <code>IF&gt;</code> condition, implicit exogenizations, etc.), numerical issues can arise, and users are required to manually exclude some feedback variables from the Jacobian matrix by using the <code>JacobianDrop</code> argument.  To improve simulation speed, BIMETS evaluates the Newton-Raphson algorithm performance during simulation, and, at each iteration, a new Jacobian matrix is calculated <em>only if</em> the convergence speed is slower than a predefined threshold. In a vectorized simulation (e.g., <code>STOCHSIMULATE</code>,  <code>OPTIMIZE</code>,  <code>RENORM</code>), if <code>simAlgo="NEWTON"</code> the Jacobian matrix is calculated only on the unperturbed model, then applied to all realizations; if <code>simAlgo="FULLNEWTON"</code> a new Jacobian matrix is calculated for each realization. As in the Gauss-Seidel algorithm, the convergence is evaluated on feedback variables.<br><b>FULLNEWTON</b>: similar to the "base" Newton case, but when using this option, a different Jacobian matrix is calculated for each stochastic realization in a vectorized simulation (e.g., <code>STOCHSIMULATE</code>,  <code>OPTIMIZE</code>,  <code>RENORM</code>). The collection of all the Jacobian matrices is referred to as the 3-dimensional "Jacobian array". Generally, a "full" Newton simulation requires more computational time, mainly due to the increased number of Jacobian matrices to be calculated. However, the "base" Newton algorithm fails to converge when the model is highly non-linear and perturbances are significant (see examples in <code>STOCHSIMULATE</code> help page). Therefore, a "full" Newton algorithm is required in these cases. <br></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>TSRANGE</code></td>
<td>

<p>The time range of the simulation, as a four dimensional numerical array, <br> i.e. <code>TSRANGE=c(start_year, start_period, end_year, end_period)</code> 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simType</code></td>
<td>

<p>The simulation type requested:<br><b>DYNAMIC</b>: the default, whenever lagged endogenous variables are needed in the computations, the simulated values of the endogenous variables evaluated in the previous time periods are used;<br><b>STATIC</b>: rather than the simulated values, the actual historical values are used whenever lagged endogenous variables are needed in the computations;<br><b>FORECAST</b>: similar to the <code>'DYNAMIC'</code> option, but the initial solutions for the iterative process are given by the simulated values of the endogenous variables in the previous period. In this case there is no need for historical values of the endogenous variables in whole provided <code>TSRANGE</code>;<br><b>RESCHECK</b>: in this case there is no iteration to carry out. The endogenous variables are evaluated for each single time period by using the historical values for all the variables on the right-hand side of the equation, both lagged and current period;
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simConvergence</code></td>
<td>

<p>The percentage convergence value requested for the iterative process, which stops when the percentage difference of all the feedback variables between iterations is less than <code>simConvergence</code> in absolute value
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simIterLimit</code></td>
<td>

<p>The value representing the maximum number of iterations to be performed. The iterative procedure will stop when <code>simIterLimit</code> is reached or the feedback variables satisfy the <code>simConvergence</code> criterion
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ZeroErrorAC</code></td>
<td>

<p>If <code>TRUE</code> it zeroes out all the autoregressive terms, if any, in the behavioral equations
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BackFill</code></td>
<td>

<p>Defined as an <code>integer</code>, it is the length of historical data prior to the simulation <code>TSRANGE</code> to be saved along with the solutions
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Exogenize</code></td>
<td>

<p>A named list that specifies the endogenous variables to be exogenized. During the simulation and inside the provided time range, the exogenized endogenous variables will be assigned to their historical values. List names must be the names of the endogenous variables to be exogenized; each element of this list contains the time range of the exogenization for the related endogenous variable, in the form of a 4-dimensional integer array, i.e. start_year, start_period, end_year, end_period. A list element can also be assigned <code>TRUE</code>: in this case the related endogenous variable will be exogenized in whole simulation <code>TSRANGE</code> (see example)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ConstantAdjustment</code></td>
<td>

<p>A named list that specifies the constant adjustments (i.e. add-factors) to be added to the selected equations of the model. Each constant adjustment can be see as a new exogenous variable added to the equation of the specified endogenous variable. The list names are the names of the involved endogenous variables; each element of this is list contains the time series to be added to the equation of the related endogenous variable. Each provided time series must verify the compliance control check defined in <code>is.bimets</code> (see example)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>If <code>TRUE</code> some verbose output will be activated. Moreover the values of all endogenous variables will be printed out during each iteration of the convergence algorithm for all time periods in the simulation <code>TSRANGE</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verboseSincePeriod</code></td>
<td>

<p>An integer that activates the verbose output, during the iterative process, only after the provided number of simulation periods
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verboseVars</code></td>
<td>

<p>A <code>character</code> array with the names of the endogenous variables for which the verbose output will be activated in the iterative process
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MULTMATRIX</code></td>
<td>
<p>It is <code>TRUE</code> when the parent call is a multiplier matrix operation requested by a <code>MULTMATRIX</code> procedure</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RENORM</code></td>
<td>
<p>It is <code>TRUE</code> when the parent call is an endogenous targeting operation requested by a <code>RENORM</code> procedure</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>TARGET</code></td>
<td>
<p>see <code>MULTMATRIX</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>INSTRUMENT</code></td>
<td>
<p>see <code>MULTMATRIX</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MM_SHOCK</code></td>
<td>
<p>see <code>MULTMATRIX</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>STOCHSIMULATE</code></td>
<td>
<p>It is <code>TRUE</code> when the parent call is a stochastic simulation requested by a <code>STOCHSIMULATE</code> operation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>StochStructure</code></td>
<td>
<p>The <code>list()</code> that defines the disturbance structure applied to the model. See <code>STOCHSIMULATE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>StochReplica</code></td>
<td>
<p>An integer value that sets the number of stochastic simulation replications to be performed. See <code>STOCHSIMULATE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>StochSeed</code></td>
<td>
<p>A number used to initialize the pseudo-random number generator. It can be useful in order to replicate stochastic results. See <code>STOCHSIMULATE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>OPTIMIZE</code></td>
<td>
<p>It is <code>TRUE</code> when the parent call is an optimize operation requested by a  procedure</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>OptimizeBounds</code></td>
<td>
<p>see <code>OPTIMIZE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>OptimizeRestrictions</code></td>
<td>
<p>see <code>OPTIMIZE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>OptimizeFunctions</code></td>
<td>
<p>see <code>OPTIMIZE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quietly</code></td>
<td>
<p> If <code>TRUE</code>, information messages will be suppressed, e.g. an information message will be printed out if any time series has a missing value in the extended <code>TSRANGE</code>, that is the simulation <code>TSRANGE</code> backward extended by <code>model$max_lag</code> periods (See <code>LOAD_MODEL</code> for info on model max lag)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RESCHECKeqList</code></td>
<td>
<p> If <code>simType=RESCHECK</code>, by using this argument users can select a subset of target endogenous variables: the simulation will be performed only for the selected variables. It must be provided as an array of endogenous names, e.g. <code>c('endo1','endo2',...)</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>JACOBIAN_SHOCK</code></td>
<td>

<p>The value of the shock added to feedback variables in the derivative calculation of the Jacobian matrix. The default value is <code>1e-4</code> times the value of the feedback variable
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>JacobianDrop</code></td>
<td>

<p>The array built with feedback variables names to be excluded from the Jacobian matrix calulation
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>forceForwardLooking</code></td>
<td>
<p>If <code>TRUE</code>, a backward-looking model will be simulated considering it such as a forward-looking model. This argument is for internal testing purposes, and there is no advantage for users to use it. See the "Rational expectations models" section here above in the <code>SIMULATE</code> help page.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of model time series will be skipped. See <code>is.bimets</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Backward compatibility
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>This function will add a new named element <code>simulation</code> into the output BIMETS model object.<br><br>
The new <code>simulation</code> element is a named list; the names of the <code>simulation</code> list are the names of the endogenous variables of the model; each element of the <code>simulation</code> list contains the simulated time series of the related endogenous variable (see example). <br><br> The <code>simulation</code> list also contains the <code>'__SIM_PARAMETERS__'</code> element that contains the arguments passed to the function call during the latest <code>SIMULATE</code> run, e.g. <code>TSRANGE</code>, <code>symType</code>, <code>simConvergence</code>, <code>symIterLimit</code>, <code>Exogenize</code>, etc.: this data can be helpful in order to replicate the simulation results. <br><br>
In case of a <code>simType='RESCHECK'</code> simulation, a new named element <code>ConstantAdjustmentRESCHECK</code> will be added to the output model. This new element is populated with a list of time series that contains, for each endogenous variable, the tracking residuals time series such that, when using this tracking residuals as add-factors in simulation, the related equation will solve to the trajectory given, for that variable, by its historical data (see example).
</p>


<h3>See Also</h3>

<p><code>MDL</code><br><code>LOAD_MODEL</code><br><code>ESTIMATE</code><br><code>STOCHSIMULATE</code><br><code>MULTMATRIX</code><br><code>RENORM</code><br><code>OPTIMIZE</code><br><code>TIMESERIES</code><br><code>BIMETS indexing</code><br><code>BIMETS configuration</code><br></p>


<h3>Examples</h3>

<pre><code class="language-R">

#define model
myModelDefinition&lt;-
"MODEL 
COMMENT&gt; Klein Model 1 of the U.S. Economy 

COMMENT&gt; Consumption
BEHAVIORAL&gt; cn
TSRANGE 1921 1 1941 1
EQ&gt; cn =  a1 + a2*p + a3*TSLAG(p,1) + a4*(w1+w2) 
COEFF&gt; a1 a2 a3 a4

COMMENT&gt; Investment
BEHAVIORAL&gt; i
TSRANGE 1921 1 1941 1
EQ&gt; i = b1 + b2*p + b3*TSLAG(p,1) + b4*TSLAG(k,1)
COEFF&gt; b1 b2 b3 b4

COMMENT&gt; Demand for Labor
BEHAVIORAL&gt; w1 
TSRANGE 1921 1 1941 1
EQ&gt; w1 = c1 + c2*(y+t-w2) + c3*TSLAG(y+t-w2,1) + c4*time
COEFF&gt; c1 c2 c3 c4

COMMENT&gt; Gross National Product
IDENTITY&gt; y
EQ&gt; y = cn + i + g - t

COMMENT&gt; Profits
IDENTITY&gt; p
EQ&gt; p = y - (w1+w2)

COMMENT&gt; Capital Stock
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1) + i

END"

#define model data
myModelData&lt;-list(
   cn
   =TIMESERIES(39.8,41.9,45,49.2,50.6,52.6,55.1,56.2,57.3,57.8,55,50.9,
               45.6,46.5,48.7,51.3,57.7,58.7,57.5,61.6,65,69.7,
               START=c(1920,1),FREQ=1),
   g
   =TIMESERIES(4.6,6.6,6.1,5.7,6.6,6.5,6.6,7.6,7.9,8.1,9.4,10.7,10.2,9.3,10,
               10.5,10.3,11,13,14.4,15.4,22.3,
               START=c(1920,1),FREQ=1),
   i
   =TIMESERIES(2.7,-.2,1.9,5.2,3,5.1,5.6,4.2,3,5.1,1,-3.4,-6.2,-5.1,-3,-1.3,
               2.1,2,-1.9,1.3,3.3,4.9,
               START=c(1920,1),FREQ=1),
   k
   =TIMESERIES(182.8,182.6,184.5,189.7,192.7,197.8,203.4,207.6,210.6,215.7,
               216.7,213.3,207.1,202,199,197.7,199.8,201.8,199.9,
               201.2,204.5,209.4,
               START=c(1920,1),FREQ=1),
   p
   =TIMESERIES(12.7,12.4,16.9,18.4,19.4,20.1,19.6,19.8,21.1,21.7,15.6,11.4,
               7,11.2,12.3,14,17.6,17.3,15.3,19,21.1,23.5,
               START=c(1920,1),FREQ=1),
   w1
   =TIMESERIES(28.8,25.5,29.3,34.1,33.9,35.4,37.4,37.9,39.2,41.3,37.9,34.5,
               29,28.5,30.6,33.2,36.8,41,38.2,41.6,45,53.3,
               START=c(1920,1),FREQ=1),
   y
   =TIMESERIES(43.7,40.6,49.1,55.4,56.4,58.7,60.3,61.3,64,67,57.7,50.7,41.3,
               45.3,48.9,53.3,61.8,65,61.2,68.4,74.1,85.3,
               START=c(1920,1),FREQ=1),
   t
   =TIMESERIES(3.4,7.7,3.9,4.7,3.8,5.5,7,6.7,4.2,4,7.7,7.5,8.3,5.4,6.8,7.2,
               8.3,6.7,7.4,8.9,9.6,11.6,
               START=c(1920,1),FREQ=1),
   time 
   =TIMESERIES(NA,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,
               START=c(1920,1),FREQ=1),
   w2
   =TIMESERIES(2.2,2.7,2.9,2.9,3.1,3.2,3.3,3.6,3.7,4,4.2,4.8,5.3,5.6,6,6.1,
               7.4,6.7,7.7,7.8,8,8.5,
               START=c(1920,1),FREQ=1)
 )
 
#load model and model data
myModel&lt;-LOAD_MODEL(modelText=myModelDefinition)
myModel&lt;-LOAD_MODEL_DATA(myModel,myModelData)

#estimate model
myModel&lt;-ESTIMATE(myModel, quietly = TRUE)
 
#DYNAMIC SIMULATION
 
#simulate model 
myModel&lt;-SIMULATE(myModel
                 ,TSRANGE=c(1923,1,1941,1)
                 ,simConvergence=0.00001
                 ,simIterLimit=100
  )
#
#Simulation:    100.00%
#...SIMULATE OK
 
#get simulated time series "cn" and "y"
TABIT(myModel$simulation$cn)
#
#      Date, Prd., myModel$simulation$cn
#
#      1923, 1   ,     50.338
#      1924, 1   ,    55.6994
#      1925, 1   ,    56.7111
#      ...
#      1940, 1   ,    66.7799
#      1941, 1   ,     75.451
#

TABIT(myModel$simulation$y)
#
#      Date, Prd., myModel$simulation$y
#
#      1923, 1   ,    56.0305
#      1924, 1   ,    65.8526
#      1925, 1   ,     64.265
#      ...
#      1940, 1   ,    76.8049
#      1941, 1   ,    93.4459
#
 
#get latest simulation parameters
print(myModel$simulation$'__SIM_PARAMETERS__')
#$TSRANGE
#[1] 1923    1 1941    1
#
#$simType
#[1] "DYNAMIC"
#
#$simConvergence
#[1] 1e-05
#
#$simIterLimit
#[1] 100
#
#$ZeroErrorAC
#[1] FALSE
#
#...etc etc
 
 
########################################################
#RESCHECK SIMULATION
 
#simulate model
myModel&lt;-SIMULATE(myModel
                  ,simType='RESCHECK'
                  ,TSRANGE=c(1923,1,1941,1)
                  ,simConvergence=0.00001
                  ,simIterLimit=100
 )
#
#Simulation:    100.00%
#...SIMULATE OK
 
#get consumption simulated vs historical differences
TABIT(myModel$simulation$cn-myModel$modelData$cn)
#
#      Date, Prd., myModel$simulation$cn - myModel$modelData$cn
#
#      1923, 1   ,    1.56574
#      1924, 1   ,   0.493503
#      1925, 1   , -0.0076079
#      ... 
#      1939, 1   ,  -0.989201
#      1940, 1   ,  -0.785077
#      1941, 1   ,    2.17345
#
 
########################################################
#FORECAST GNP in 1942 and 1943 
 
#we need to extend exogenous variables in 1942 and 1943
myModel$modelData$w2   &lt;- TSEXTEND(myModel$modelData$w2,  UPTO=c(1943,1))
myModel$modelData$t    &lt;- TSEXTEND(myModel$modelData$t,   UPTO=c(1943,1))
myModel$modelData$g    &lt;- TSEXTEND(myModel$modelData$g,   UPTO=c(1943,1))
myModel$modelData$time &lt;- TSEXTEND(myModel$modelData$time,UPTO=c(1943,1)
                                     ,EXTMODE='LINEAR')
 
#simulate model
myModel&lt;-SIMULATE(myModel
                  ,simType='FORECAST'
                  ,TSRANGE=c(1940,1,1943,1)
                  ,simConvergence=0.00001
                  ,simIterLimit=100
)
#
#Simulation:    100.00%
#...SIMULATE OK
 
#get forecasted GNP
TABIT(myModel$simulation$y)
#
#      Date, Prd., myModel$simulation$y
#
#      1940, 1   ,    74.5781
#      1941, 1   ,    94.0153
#      1942, 1   ,    133.969
#      1943, 1   ,    199.913
#

########################################################
#VERBOSE SIMULATION
 
myModel&lt;-SIMULATE(myModel
                  ,TSRANGE=c(1923,1,1941,1)
                  ,simConvergence=0.00001
                  ,simIterLimit=100
                  ,verbose=TRUE
                  ,verboseSincePeriod=19
                  ,verboseVars=c('cn')
 )


########################################################
#DYNAMIC NEWTON SIMULATION 
#WITH EXOGENIZATION AND CONSTANT ADJUSTMENTS
 
#define exogenization list
#'cn' exogenized in 1923-1925
#'i' exogenized in whole TSRANGE
exogenizeList&lt;-list(
                cn = c(1923,1,1925,1),
                i  = TRUE
)
 
#define add-factors list
constantAdjList&lt;-list(
               cn = TIMESERIES(1,-1,START=c(1923,1),FREQ='A'),
               y  = TIMESERIES(0.1,-0.1,-0.5,START=c(1926,1),FREQ='A')
)
 
#simulate model
myModel&lt;-SIMULATE(myModel
                  ,simAlgo='NEWTON'
                  ,simType='DYNAMIC'
                  ,TSRANGE=c(1923,1,1941,1)
                  ,simConvergence=0.00001
                  ,simIterLimit=100
                  ,Exogenize=exogenizeList
                  ,ConstantAdjustment=constantAdjList 
 )
#SIMULATE(): endogenous variable "cn" has been exogenized from (trunc) ...
#SIMULATE(): endogenous variable "i" has been exogenized from (trunc) ...
#SIMULATE(): endogenous variable "cn" has a constant adjustment from (trunc) ...
#SIMULATE(): endogenous variable "y" has a constant adjustment from (trunc) ...
#
#Simulation:    100.00%
#...SIMULATE OK

########################################################
#EXAMPLE OF MODEL THAT FAILS GAUSS CONVERGENCE

#define model
myNewtonModelDefinition&lt;-
"
MODEL 
 
COMMENT&gt; Consumption
BEHAVIORAL&gt; cn
TSRANGE 1922 1 1931 1
EQ&gt; cn =  a1 + a2*p + a3*LAG(p,1) + a4*(w1+w2) 
COEFF&gt; a1 a2 a3 a4 

COMMENT&gt; Investment
BEHAVIORAL&gt; i
TSRANGE 1922 1 1931 1
EQ&gt; i = b1 + b2*p + b3*LAG(p,1) + b4*LAG(k,1)
COEFF&gt; b1 b2 b3 b4 

COMMENT&gt; Demand for Labor
BEHAVIORAL&gt; w1 
TSRANGE 1922 1 1931 1
EQ&gt; w1 = c1 + c2*(z+y+t-w2) + c3*LAG(z+y+t-w2,1) + c4*time
COEFF&gt; c1 c2 c3 c4 

COMMENT&gt; Gross National Product
IDENTITY&gt; y
EQ&gt; y = cn + i + g - t 

COMMENT&gt; Simple copy of y in z
IDENTITY&gt; z
EQ&gt; z = cn + i + g - t 

COMMENT&gt; Profits
IDENTITY&gt; p
EQ&gt; p = z + y - (w1+w2)

COMMENT&gt; Capital Stock
IDENTITY&gt; k
EQ&gt; k = LAG(k,1) + i

END
"

#add data to model
myModelData$z &lt;- myModelData$y
myNewtonModel&lt;-LOAD_MODEL(modelText=myNewtonModelDefinition)
myNewtonModel&lt;-LOAD_MODEL_DATA(myNewtonModel,myModelData)

#estimate model
myNewtonModel&lt;-ESTIMATE(myNewtonModel, quietly = TRUE)

#GAUSS simulation fails to converge...
myNewtonModel &lt;- SIMULATE(myNewtonModel,
                       TSRANGE = c(1921, 1, 1930, 1),
                       simConvergence = 1e-7)
                       
#...while NEWTON converges
myNewtonModel &lt;- SIMULATE(myNewtonModel,
                       simAlgo='NEWTON',
                       TSRANGE = c(1921, 1, 1930, 1),
                       simConvergence = 1e-7)
                       
########################################################
#EXAMPLE OF MODEL THAT REQUIRES 
#A VARIABLE EXCLUSION FROM JACOBIAN MATRIX

#define model
myNewtonWithDropModelDefinition&lt;-
"
MODEL 
 
COMMENT&gt; Consumption
BEHAVIORAL&gt; cn
TSRANGE 1922 1 1931 1
EQ&gt; cn =  a1 + a2*p + a3*LAG(p,1) + a4*(w1+w2) 
COEFF&gt; a1 a2 a3 a4 

COMMENT&gt; Investment
BEHAVIORAL&gt; i
TSRANGE 1922 1 1931 1
EQ&gt; i = b1 + b2*p + b3*LAG(p,1) + b4*LAG(k,1)
COEFF&gt; b1 b2 b3 b4 

COMMENT&gt; Demand for Labor
BEHAVIORAL&gt; w1 
TSRANGE 1922 1 1931 1
EQ&gt; w1 = c1 + c2*(z+y+t-w2) + c3*LAG(z+y+t-w2,1) + c4*time
COEFF&gt; c1 c2 c3 c4 

COMMENT&gt; Gross National Product
IDENTITY&gt; y
EQ&gt; y = cn + i + g - t 

COMMENT&gt; Simple copy of y in z
IDENTITY&gt; z
EQ&gt; z = cn + i + g - t 

COMMENT&gt; Profits
IDENTITY&gt; p
EQ&gt; p = z + y - (w1+w2)
IF&gt; y &lt; 0

COMMENT&gt; Capital Stock
IDENTITY&gt; k
EQ&gt; k = LAG(k,1) + i

END
"

#add data to model
myModelData$z &lt;- myModelData$y
myNewtonModel &lt;- LOAD_MODEL(modelText=myNewtonWithDropModelDefinition)
myNewtonModel &lt;- LOAD_MODEL_DATA(myNewtonModel,myModelData)

#estimate model
myNewtonModel &lt;- ESTIMATE(myNewtonModel, quietly = TRUE)

#"p" variable must be removed from Jacobian because of unverified IF&gt;
myNewtonModel &lt;- SIMULATE(myNewtonModel,
                       simAlgo='NEWTON',
                       JacobianDrop='p',
                       TSRANGE = c(1921, 1, 1930, 1),
                       simConvergence = 1e-7)
    

########################################################
#COMPARE FORECAST IN 3 ALTERNATIVE 
#EXOGENOUS SCENARIOS

#define model
myModelDefinition &lt;-
"MODEL 
COMMENT&gt; Klein Model 1 of the U.S. Economy 

COMMENT&gt; Consumption
BEHAVIORAL&gt; cn
TSRANGE 1921 1 1941 1
EQ&gt; cn =  a1 + a2*p + a3*TSLAG(p,1) + a4*(w1+w2) 
COEFF&gt; a1 a2 a3 a4

COMMENT&gt; Investment
BEHAVIORAL&gt; i
TSRANGE 1921 1 1941 1
EQ&gt; i = b1 + b2*p + b3*TSLAG(p,1) + b4*TSLAG(k,1)
COEFF&gt; b1 b2 b3 b4

COMMENT&gt; Demand for Labor
BEHAVIORAL&gt; w1 
TSRANGE 1921 1 1941 1
EQ&gt; w1 = c1 + c2*(y+t-w2) + c3*TSLAG(y+t-w2,1) + c4*time
COEFF&gt; c1 c2 c3 c4

COMMENT&gt; Gross National Product
IDENTITY&gt; y
EQ&gt; y = cn + i + g - t

COMMENT&gt; Profits
IDENTITY&gt; p
EQ&gt; p = y - (w1+w2)

COMMENT&gt; Capital Stock
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1) + i

END"

#define model data
myModelData&lt;-list(
  cn
  =TIMESERIES(39.8,41.9,45,49.2,50.6,52.6,55.1,56.2,57.3,57.8,55,50.9,
              45.6,46.5,48.7,51.3,57.7,58.7,57.5,61.6,65,69.7,
              START=c(1920,1),FREQ=1),
  g
  =TIMESERIES(4.6,6.6,6.1,5.7,6.6,6.5,6.6,7.6,7.9,8.1,9.4,10.7,10.2,9.3,10,
              10.5,10.3,11,13,14.4,15.4,22.3,
              START=c(1920,1),FREQ=1),
  i
  =TIMESERIES(2.7,-.2,1.9,5.2,3,5.1,5.6,4.2,3,5.1,1,-3.4,-6.2,-5.1,-3,-1.3,
              2.1,2,-1.9,1.3,3.3,4.9,
              START=c(1920,1),FREQ=1),
  k
  =TIMESERIES(182.8,182.6,184.5,189.7,192.7,197.8,203.4,207.6,210.6,215.7,
              216.7,213.3,207.1,202,199,197.7,199.8,201.8,199.9,
              201.2,204.5,209.4,
              START=c(1920,1),FREQ=1),
  p
  =TIMESERIES(12.7,12.4,16.9,18.4,19.4,20.1,19.6,19.8,21.1,21.7,15.6,11.4,
              7,11.2,12.3,14,17.6,17.3,15.3,19,21.1,23.5,
              START=c(1920,1),FREQ=1),
  w1
  =TIMESERIES(28.8,25.5,29.3,34.1,33.9,35.4,37.4,37.9,39.2,41.3,37.9,34.5,
              29,28.5,30.6,33.2,36.8,41,38.2,41.6,45,53.3,
              START=c(1920,1),FREQ=1),
  y
  =TIMESERIES(43.7,40.6,49.1,55.4,56.4,58.7,60.3,61.3,64,67,57.7,50.7,41.3,
              45.3,48.9,53.3,61.8,65,61.2,68.4,74.1,85.3,
              START=c(1920,1),FREQ=1),
  t
  =TIMESERIES(3.4,7.7,3.9,4.7,3.8,5.5,7,6.7,4.2,4,7.7,7.5,8.3,5.4,6.8,7.2,
              8.3,6.7,7.4,8.9,9.6,11.6,
              START=c(1920,1),FREQ=1),
  time 
  =TIMESERIES(NA,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,
              START=c(1920,1),FREQ=1),
  w2
  =TIMESERIES(2.2,2.7,2.9,2.9,3.1,3.2,3.3,3.6,3.7,4,4.2,4.8,5.3,5.6,6,6.1,
              7.4,6.7,7.7,7.8,8,8.5,
              START=c(1920,1),FREQ=1)
)

#load model and model data
myModel &lt;- LOAD_MODEL(modelText=myModelDefinition)
myModel &lt;- LOAD_MODEL_DATA(myModel,myModelData)

#estimate model
myModel &lt;- ESTIMATE(myModel, quietly = TRUE)

#create 3 new models for the 3 scenarios
modelScenario1 &lt;- myModel
modelScenario2 &lt;- myModel
modelScenario3 &lt;- myModel

#scenario 1, define exogenous paths
modelScenario1$modelData &lt;- within(modelScenario1$modelData,{
              w2   = TSEXTEND(w2,  UPTO=c(1943,1))
              t    = TSEXTEND(t,   UPTO=c(1943,1))
              g    = TSEXTEND(g,   UPTO=c(1943,1))
              time = TSEXTEND(time,UPTO=c(1943,1)
                                  ,EXTMODE='LINEAR')
})

#scenario 2, define exogenous paths
modelScenario2$modelData &lt;- within(modelScenario2$modelData,{
              w2   = TSEXTEND(w2,  UPTO=c(1943,1))
              t    = TSEXTEND(t,   UPTO=c(1943,1))
              g    = TSEXTEND(g,   UPTO=c(1943,1)
                            ,EXTMODE='LINEAR')
              time = TSEXTEND(time,UPTO=c(1943,1)
                            ,EXTMODE='LINEAR')
})

#scenario 3, define exogenous paths
#we also change consumption cn add-factor
modelScenario3$modelData &lt;- within(modelScenario3$modelData,{
              w2   = TSEXTEND(w2,  UPTO=c(1943,1)
                              ,EXTMODE='MEAN4')
              t    = TSEXTEND(t,   UPTO=c(1943,1))
              g    = TSEXTEND(g,   UPTO=c(1943,1)
                              ,EXTMODE='LINEAR')
              time = TSEXTEND(time,UPTO=c(1943,1)
                              ,EXTMODE='LINEAR')
})
constantAdjListScenario3 &lt;- constantAdjList
constantAdjListScenario3$cn[[1941,1]] &lt;- c(1,2,3)

#simulate the 3 models
modelScenario1 &lt;- SIMULATE(modelScenario1
                            ,simAlgo='NEWTON'
                            ,simType='FORECAST'
                            ,TSRANGE=c(1940,1,1943,1)
                            ,simConvergence=1e-5
                            ,simIterLimit=20)

modelScenario2 &lt;- SIMULATE(modelScenario2
                            ,simAlgo='NEWTON'
                            ,simType='FORECAST'
                            ,TSRANGE=c(1940,1,1943,1)
                            ,simConvergence=1e-5
                            ,simIterLimit=20)

modelScenario3 &lt;- SIMULATE(modelScenario3
                            ,simAlgo='NEWTON'
                            ,simType='FORECAST'
                            ,TSRANGE=c(1940,1,1943,1)
                            ,simConvergence=1e-5
                            ,simIterLimit=20
                            ,ConstantAdjustment = constantAdjListScenario3
                            )

#compare results on GNP
TABIT(modelScenario1$simulation$y, 
      modelScenario2$simulation$y, 
      modelScenario3$simulation$y)
      
########################################################
#EXAMPLE OF MODEL'S TRACKING RESIDUALS INITIALIZATION BY USING 
#THE RESCHECK SIMULATION'S OUTPUT VALUE "ConstantAdjusmentRESCHECK"

#define the model with LHS funs
myModel&lt;-'MODEL

COMMENT&gt; Modified Klein Model 1 of the U.S. Economy with PDL,
COMMENT&gt; autocorrelation on errors, restrictions and conditional evaluations
COMMENT&gt; LHS functions on EQ

COMMENT&gt; Exp Consumption
BEHAVIORAL&gt; cn
TSRANGE 1925 1 1941 1
EQ&gt; EXP(cn) = a1 + a2*p + a3*TSLAG(p,1) + a4*(w1+w2)
COEFF&gt; a1 a2 a3 a4
ERROR&gt; AUTO(2)

COMMENT&gt; Log Investment
BEHAVIORAL&gt; i
TSRANGE 1925 1 1941 1
EQ&gt; LOG(i) = b1 + b2*p + b3*TSLAG(p,1) + b4*TSLAG(k,1)
COEFF&gt; b1 b2 b3 b4
RESTRICT&gt; b2 + b3 = 1

COMMENT&gt; Demand for Labor
BEHAVIORAL&gt; w1
TSRANGE 1925 1 1941 1
EQ&gt; w1 = c1 + c2*(TSDELTA(y)+t-w2) + c3*TSLAG(TSDELTA(y)+t-w2,1)+c4*time
COEFF&gt; c1 c2 c3 c4
PDL&gt; c3 1 3

COMMENT&gt; Delta Gross National Product
IDENTITY&gt; y
EQ&gt; TSDELTA(y) = EXP(cn) + LOG(i) + g - t

COMMENT&gt; Profits
IDENTITY&gt; p
EQ&gt; p = TSDELTA(y) - (w1+w2)

COMMENT&gt; Capital Stock with switches
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1) + LOG(i)
IF&gt; LOG(i) &gt; 0
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1)
IF&gt; LOG(i) &lt;= 0

END'


#define model data
modelData&lt;-list(
  cn=TSERIES(39.8,41.9,45,49.2,50.6,52.6,55.1,56.2,57.3,
             57.8,55,50.9,45.6,46.5,48.7,51.3,57.7,58.7,57.5,61.6,65,69.7,
             START=c(1920,1),FREQ=1),
  g=TSERIES(4.6,6.6,6.1,5.7,6.6,6.5,6.6,7.6,7.9,8.1,9.4,
            10.7,10.2,9.3,10,10.5,10.3,11,13,14.4,15.4,22.3,
            START=c(1920,1),FREQ=1),
  i=TSERIES(2.7,-.2,1.9,5.2,3,5.1,5.6,4.2,3,5.1,1,-3.4,
            -6.2,-5.1,-3,-1.3,2.1,2,-1.9,1.3,3.3,4.9,
            START=c(1920,1),FREQ=1),
  k=TSERIES(182.8,182.6,184.5,189.7,192.7,197.8,203.4,
            207.6,210.6,215.7,216.7,213.3,207.1,202,
            199,197.7,199.8,201.8,199.9,201.2,204.5,209.4,
            START=c(1920,1),FREQ=1),
  p=TSERIES(12.7,12.4,16.9,18.4,19.4,20.1,19.6,19.8,21.1,
            21.7,15.6,11.4,7,11.2,12.3,14,17.6,17.3,15.3,19,21.1,23.5,
            START=c(1920,1),FREQ=1),
  w1=TSERIES(28.8,25.5,29.3,34.1,33.9,35.4,37.4,37.9,39.2,
             41.3,37.9,34.5,29,28.5,30.6,33.2,36.8,41,38.2,41.6,45,53.3,
             START=c(1920,1),FREQ=1),
  y=TSERIES(43.7,40.6,49.1,55.4,56.4,58.7,60.3,61.3,64,67,
            57.7,50.7,41.3,45.3,48.9,53.3,61.8,65,61.2,68.4,74.1,85.3,
            START=c(1920,1),FREQ=1),
  t=TSERIES(3.4,7.7,3.9,4.7,3.8,5.5,7,6.7,4.2,4,7.7,7.5,
            8.3,5.4,6.8,7.2,8.3,6.7,7.4,8.9,9.6,11.6,
            START=c(1920,1),FREQ=1),
  time=TSERIES(NA,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,
               3,4,5,6,7,8,9,10,  
               START=c(1920,1),FREQ=1),   
  w2=TSERIES(2.2,2.7,2.9,2.9,3.1,3.2,3.3,3.6,3.7,4,4.2,
             4.8,5.3,5.6,6,6.1,7.4,6.7,7.7,7.8,8,8.5,
             START=c(1920,1),FREQ=1)
)


#example data transformation
modelData&lt;-within(modelData,{
  i=exp(i);     #we have LOG(i)     in the model MDL definition
  cn=log(cn);   #we have EXP(cn)    in the model MDL definition
  y=CUMSUM(y)   #we have TSDELTA(y) in the model MDL definition
})

#load model and model data
model&lt;-LOAD_MODEL(modelText=myModel)
model&lt;-LOAD_MODEL_DATA(model,modelData)

#estimate model
model&lt;-ESTIMATE(model)

#get initial tracking residuals in range 1925-1935
#we need to set ZeroErrorAC to TRUE due to error autocorrelation 
#in Consumption MDL definition
model&lt;-SIMULATE(model,
                TSRANGE=c(1925,1,1935,1),
                simType='RESCHECK',
                ZeroErrorAC=TRUE)

#get init trac
initTrac&lt;-model$ConstantAdjustmentRESCHECK

#dynamic simulation using initTrac as constant adjustments
#we remove first two periods from simulation range
#due to error autocorrelation in Consumption MDL equation
model&lt;-SIMULATE(model,
                TSRANGE=c(1927,1,1935,1),
                ConstantAdjustment=initTrac)

#check simulated values are equals to historical ones in simulation range
for (idxV in model$vendog)
{
  print(max(abs(model$simulation[[idxV]]-
                  TSPROJECT(model$modelData[[idxV]],TSRANGE=c(1927,1,1935,1)))))
}

########################################################
#EXAMPLE OF FORWARD-LOOKING KLEIN-LIKE MODEL 
#HAVING RATIONAL EXPECTATION ON INVESTMENTS

#define model
kleinLeadModelDefinition&lt;-
"MODEL 
COMMENT&gt; Klein Model 1 of the U.S. Economy 

COMMENT&gt; Consumption
BEHAVIORAL&gt; cn
TSRANGE 1921 1 1941 1
EQ&gt; cn =  a1 + a2*p + a3*TSLAG(p,1) + a4*(w1+w2) 
COEFF&gt; a1 a2 a3 a4

COMMENT&gt; Investment with TSLEAD
IDENTITY&gt; i
EQ&gt; i = (MOVAVG(i,2)+TSLEAD(i))/2

COMMENT&gt; Demand for Labor
BEHAVIORAL&gt; w1 
TSRANGE 1921 1 1941 1
EQ&gt; w1 = c1 + c2*(y+t-w2) + c3*TSLAG(y+t-w2,1) + c4*time
COEFF&gt; c1 c2 c3 c4

COMMENT&gt; Gross National Product
IDENTITY&gt; y
EQ&gt; y = cn + i + g - t

COMMENT&gt; Profits
IDENTITY&gt; p
EQ&gt; p = y - (w1+w2)

COMMENT&gt; Capital Stock
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1) + i

END"

#define model data
kleinLeadModelData&lt;-list(
  cn
  =TIMESERIES(39.8,41.9,45,49.2,50.6,52.6,55.1,56.2,57.3,57.8,55,50.9,
              45.6,46.5,48.7,51.3,57.7,58.7,57.5,61.6,65,69.7,
              START=c(1920,1),FREQ=1),
  g
  =TIMESERIES(4.6,6.6,6.1,5.7,6.6,6.5,6.6,7.6,7.9,8.1,9.4,10.7,10.2,9.3,10,
              10.5,10.3,11,13,14.4,15.4,22.3,
              START=c(1920,1),FREQ=1),
  i
  =TIMESERIES(2.7,-.2,1.9,5.2,3,5.1,5.6,4.2,3,5.1,1,-3.4,-6.2,-5.1,-3,-1.3,
              2.1,2,-1.9,1.3,3.3,4.9,
              START=c(1920,1),FREQ=1),
  k
  =TIMESERIES(182.8,182.6,184.5,189.7,192.7,197.8,203.4,207.6,210.6,215.7,
              216.7,213.3,207.1,202,199,197.7,199.8,201.8,199.9,
              201.2,204.5,209.4,
              START=c(1920,1),FREQ=1),
  p
  =TIMESERIES(12.7,12.4,16.9,18.4,19.4,20.1,19.6,19.8,21.1,21.7,15.6,11.4,
              7,11.2,12.3,14,17.6,17.3,15.3,19,21.1,23.5,
              START=c(1920,1),FREQ=1),
  w1
  =TIMESERIES(28.8,25.5,29.3,34.1,33.9,35.4,37.4,37.9,39.2,41.3,37.9,34.5,
              29,28.5,30.6,33.2,36.8,41,38.2,41.6,45,53.3,
              START=c(1920,1),FREQ=1),
  y
  =TIMESERIES(43.7,40.6,49.1,55.4,56.4,58.7,60.3,61.3,64,67,57.7,50.7,41.3,
              45.3,48.9,53.3,61.8,65,61.2,68.4,74.1,85.3,
              START=c(1920,1),FREQ=1),
  t
  =TIMESERIES(3.4,7.7,3.9,4.7,3.8,5.5,7,6.7,4.2,4,7.7,7.5,8.3,5.4,6.8,7.2,
              8.3,6.7,7.4,8.9,9.6,11.6,
              START=c(1920,1),FREQ=1),
  time 
  =TIMESERIES(NA,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,
              START=c(1920,1),FREQ=1),
  w2
  =TIMESERIES(2.2,2.7,2.9,2.9,3.1,3.2,3.3,3.6,3.7,4,4.2,4.8,5.3,5.6,6,6.1,
              7.4,6.7,7.7,7.8,8,8.5,
              START=c(1920,1),FREQ=1)
)

#load model and model data
kleinLeadModel&lt;-LOAD_MODEL(modelText=kleinLeadModelDefinition)
kleinLeadModel&lt;-LOAD_MODEL_DATA(kleinLeadModel,kleinLeadModelData)

#estimate model
kleinLeadModel&lt;-ESTIMATE(kleinLeadModel, quietly = TRUE)

#set expected value of 2 for Investment in 1931
#(note that simulation TSRANGE spans up to 1930)
kleinLeadModel$modelData$i[[1931,1]]&lt;-2 

#simulate model
kleinLeadModel&lt;-SIMULATE(kleinLeadModel
                  ,TSRANGE=c(1924,1,1930,1))
                  
#print simulated investments
TABIT(kleinLeadModel$simulation$i)

</code></pre>


</div>