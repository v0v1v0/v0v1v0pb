<div class="container">

<table style="width: 100%;"><tr>
<td>plotResponseSurface</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plot response surface</h2>

<h3>Description</h3>

<p>Plot the 3-dimensional response surface predicted by one of the null
models. This plot allows for a visual comparison between the null
model prediction and observed points. This function is mainly used
as the workhorse of <code>plot.ResponseSurface</code> method.
</p>


<h3>Usage</h3>

<pre><code class="language-R">plotResponseSurface(
  data,
  fitResult = NULL,
  transforms = fitResult$transforms,
  predSurface = NULL,
  null_model = c("loewe", "hsa", "bliss", "loewe2"),
  colorPalette = c("red", "grey70", "blue"),
  colorPaletteNA = "grey70",
  colorBy = "none",
  addPoints = TRUE,
  colorPoints = c("black", "sandybrown", "brown", "white"),
  breaks,
  radius = 4,
  logScale = TRUE,
  colorfun = median,
  zTransform = function(x) x,
  add = FALSE,
  main = "",
  legend = FALSE,
  xat = "actual",
  yat = "actual",
  plotfun = NULL,
  gradient = TRUE,
  width = 800,
  height = 800,
  title = "",
  digitsFunc = function(x) {
     x
 },
  reverse = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Object "data" from the output of <code>fitSurface</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitResult</code></td>
<td>
<p>Object "fitResult" from the output of <code>fitSurface</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transforms</code></td>
<td>
<p>Object "transforms" from the output of <code>fitSurface</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predSurface</code></td>
<td>
<p>Vector of all predicted responses based on
<code>expand.grid(uniqueDoses)</code>. If not supplied, it will be computed
with <code>predictOffAxis</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>null_model</code></td>
<td>
<p>If <code>predSurface</code> is not supplied, it is computed using
one of the available null models, i.e. <code>"loewe"</code>, <code>"hsa"</code>, 
<code>"bliss"</code> and <code>"loewe2"</code>. See also <code>fitSurface</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colorPalette</code></td>
<td>
<p>Vector of color names for surface</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colorPaletteNA</code></td>
<td>
<p>Color used in the matrix of colours when the combination of doses doesn't exist (NA)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colorBy</code></td>
<td>
<p>This parameter determines values on which coloring is based
for the 3-dimensional surface. If matrix or a data frame with <code>d1</code> and
<code>d2</code> columns is supplied, dose combinations from <code>colorBy</code> will be
matched automatically to the appropriate dose combinations in <code>data</code>.
Unmatched dose combinations will be set to 0. This is especially useful for
plotting results for off-axis estimates only, e.g. off-axis Z-scores or
maxR test statistics. If <code>colorBy = "colors"</code>, surface will be colored
using colors in <code>colorPalette</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>addPoints</code></td>
<td>
<p>Boolean whether the dose points should be included</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colorPoints</code></td>
<td>
<p>Colors for off-axis and on-axis points. Character vector
of length four with colors for 1) off-axis points; 2) on-axis points of the
first drug (i.e. second drug is dosed at zero); 3) on-axis points of the
second drug; 4) on-axis points where both drugs are dosed at zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>breaks</code></td>
<td>
<p>Numeric vector with numerical breaks. To be used in conjunction
with <code>colorPalette</code> argument. If named, the labels will be displayed in the legend</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>radius</code></td>
<td>
<p>Size of spheres (default is 4)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logScale</code></td>
<td>
<p>Draw doses on log-scale (setting zeroes to be finite constant)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colorfun</code></td>
<td>
<p>If replicates in <code>colorBy</code> variable are present, these
will be aggregated using <code>colorfun</code> function. This can also be a
custom function returning a scalar.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zTransform</code></td>
<td>
<p>Optional transformation function for z-axis. By default,
identity function is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add</code></td>
<td>
<p>(deprecated) Add the predicted response surface to an existing plot. Will not
draw any points, just the surface. Must be called after another call to
<code>plotResponseSurface</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main</code></td>
<td>
<p>Fixed non-moving title for the 3D plot</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legend</code></td>
<td>
<p>Whether legend should be added (default FALSE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xat</code></td>
<td>
<p>x-axis ticks: "pretty", "actual" or a numeric vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yat</code></td>
<td>
<p>y-axis ticks: "pretty", "actual" or a numeric vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plotfun</code></td>
<td>
<p>If replicates for dose combinations in <code>data</code> are
available, points can be aggregated using <code>plotfun</code> function.
Typically, it will be <code>mean</code>, <code>median</code>,
<code>min</code> or <code>max</code> but a custom-defined function
returning a scalar from a vector is also possible.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gradient</code></td>
<td>
<p>Boolean indicating whether colours should be interpolated between breaks (default TRUE). 
If FALSE, <code>colorPalette</code> must contain length(breaks)-1 colours</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>width</code></td>
<td>
<p>Width in pixels (optional, defaults to 800px).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>height</code></td>
<td>
<p>Height in pixels (optional, defaults to 800px).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>title</code></td>
<td>
<p>String title (default "")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digitsFunc</code></td>
<td>
<p>Function to be applied to the axis values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reverse</code></td>
<td>
<p>Boolean indicating whether colours should be reversed (default FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments to format axis labels</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Plotly plot
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
  data &lt;- subset(directAntivirals, experiment == 1)
  ## Data must contain d1, d2 and effect columns
  fitResult &lt;- fitMarginals(data)
  data_mean &lt;- aggregate(effect ~ d1 + d2, data = data[, c("d1", "d2", "effect")],
                         FUN = mean)

  ## Construct the surface from marginal fit estimates based on HSA
  ## model and color it by mean effect level
  plotResponseSurface(data, fitResult, null_model = "hsa",
                      colorBy = data_mean, breaks = 10^(c(0, 3, 4, 6)),
                      colorPalette = c("grey", "blue", "green"))

  ## Response surface based on Loewe additivity model and colored with
  ## rainbow colors.
  plotResponseSurface(data, fitResult, null_model = "loewe", breaks = c(-Inf, 0, Inf),
                      colorBy = "colors", colorPalette = rainbow(6))

## End(Not run)
</code></pre>


</div>