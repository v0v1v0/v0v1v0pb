<div class="container">

<table style="width: 100%;"><tr>
<td>big_univLogReg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Column-wise logistic regression</h2>

<h3>Description</h3>

<p>Slopes of column-wise logistic regressions of each column
of a Filebacked Big Matrix, with some other associated statistics.
Covariates can be added to correct for confounders.
</p>


<h3>Usage</h3>

<pre><code class="language-R">big_univLogReg(
  X,
  y01.train,
  ind.train = rows_along(X),
  ind.col = cols_along(X),
  covar.train = NULL,
  tol = 1e-08,
  maxiter = 20,
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>An object of class FBM.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y01.train</code></td>
<td>
<p>Vector of responses, corresponding to <code>ind.train</code>.
<strong>Must be only 0s and 1s.</strong></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ind.train</code></td>
<td>
<p>An optional vector of the row indices that are used,
for the training part. If not specified, all rows are used.
<strong>Don't use negative indices.</strong></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ind.col</code></td>
<td>
<p>An optional vector of the column indices that are used.
If not specified, all columns are used. <strong>Don't use negative indices.</strong></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covar.train</code></td>
<td>
<p>Matrix of covariables to be added in each model to correct
for confounders (e.g. the scores of PCA), corresponding to <code>ind.train</code>.
Default is <code>NULL</code> and corresponds to only adding an intercept to each model.
You can use <code>covar_from_df()</code> to convert from a data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Relative tolerance to assess convergence of the coefficient.
Default is <code>1e-8</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>Maximum number of iterations before giving up.
Default is <code>20</code>. Usually, convergence is reached within 3 or 4 iterations.
If there is not convergence,
glm is used instead for the corresponding column.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>Number of cores used. Default doesn't use parallelism.
You may use nb_cores.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If convergence is not reached by the main algorithm for some columns,
the corresponding <code>niter</code> element is set to <code>NA</code> and a message is given.
Then, glm is used instead for the corresponding column.
If it can't converge either, all corresponding estimations are set to <code>NA</code>.
</p>


<h3>Value</h3>

<p>A data.frame with 4 elements:
</p>

<ol>
<li>
<p> the slopes of each regression,
</p>
</li>
<li>
<p> the standard errors of each slope,
</p>
</li>
<li>
<p> the number of iteration for each slope. If is <code>NA</code>, this means that the
algorithm didn't converge, and glm was used instead.
</p>
</li>
<li>
<p> the z-scores associated with each slope.
This is also an object of class <code>mhtest</code>. See <code>methods(class = "mhtest")</code>.
</p>
</li>
</ol>
<h3>See Also</h3>

<p>glm
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1)

X &lt;- big_attachExtdata()
n &lt;- nrow(X)
y01 &lt;- sample(0:1, size = n, replace = TRUE)
covar &lt;- matrix(rnorm(n * 3), n)

X1 &lt;- X[, 1] # only first column of the Filebacked Big Matrix

# Without covar
test &lt;- big_univLogReg(X, y01)
## new class `mhtest`
class(test)
attr(test, "transfo")
attr(test, "predict")
## plot results
plot(test)
plot(test, type = "Volcano")
## To get p-values associated with the test
test$p.value &lt;- predict(test, log10 = FALSE)
str(test)
summary(glm(y01 ~ X1, family = "binomial"))$coefficients[2, ]

# With all data
str(big_univLogReg(X, y01, covar.train = covar))
summary(glm(y01 ~ X1 + covar, family = "binomial"))$coefficients[2, ]

# With only half of the data
ind.train &lt;- sort(sample(n, n/2))
str(big_univLogReg(X, y01[ind.train],
                   covar.train = covar[ind.train, ],
                   ind.train = ind.train))
summary(glm(y01 ~ X1 + covar, family = "binomial",
            subset = ind.train))$coefficients[2, ]
</code></pre>


</div>