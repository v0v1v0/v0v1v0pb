<div class="container">

<table style="width: 100%;"><tr>
<td>BGWM.covar</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Variances and covariances of a multi-type Bienayme - Galton -
Watson process</h2>

<h3>Description</h3>

<p>Calculates the covariance matrices of a multi-type Bienayme
- Galton - Watson process from its offspring distributions,
additionally, it could be obtained the covariance matrices in a
specific time <code class="reqn">n</code> and the covariance matrix of the population in
the nth generation, if it is providesd the initial population vector.</p>


<h3>Usage</h3>

<pre><code class="language-R">BGWM.covar(dists, type=c("general","multinomial","independents"),
           d, n=1, z0=NULL, maxiter = 1e5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dists </code></td>
<td>
<p>offspring distributions. Its structure depends on the class
of the Bienayme - Galton - Watson process (See details and examples).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type </code></td>
<td>
<p>Class or family of the Bienayme - Galton - Watson process
(See details and examples).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d </code></td>
<td>
<p>positive integer, number of types.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n </code></td>
<td>
<p>positive integer, nth generation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z0 </code></td>
<td>
<p>nonnegative integer vector of size d; initial population by type.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter </code></td>
<td>
<p>positive integer, size of the simulated sample used to
estimate the parameters of univariate distributions that do not have
an analytical formula for their exact calculation.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function calculates the covariance matrices of a multi-type
Bienayme - Galton - Watson (BGWM) process from its offspring
distributions.
</p>
<p>From particular offspring distributions and taking into
account a differentiated algorithmic approach, we propose the
following classes or types for these processes: 
</p>
<p><code>general</code> This option is for BGWM processes without conditions over
the offspring distributions, in this case, it is required as
input data for each distribution, all d-dimensional vectors with their
respective, greater than zero, probability.
</p>
<p><code>multinomial</code> This option is for BGMW processes where each offspring
distribution is a multinomial distribution with a random number of
trials, in this case, it is required as input data, <code class="reqn">d</code> univariate
distributions related to the random number of trials for each
multinomial distribution and a <code class="reqn">d \times d</code> matrix where each row
contains probabilities of the <code class="reqn">d</code> possible outcomes for each multinomial
distribution.
</p>
<p><code>independents</code> This option is for BGMW processes where each offspring
distribution is a joint distribution of <code class="reqn">d</code> combined independent
discrete random variables, one for each type of individuals, in this
case, it is required as input data <code class="reqn">d^2</code> univariate distributions.
</p>
<p>The structure need it for each classification is illustrated in the examples.
</p>
<p>These are the univariate distributions available:
</p>
<p><em>unif</em> Discrete uniform distribution, parameters <code class="reqn">min</code> and
<code class="reqn">max</code>. All the non-negative integers between <code class="reqn">min</code> y <code class="reqn">max</code> have the same
probability. 
</p>
<p><em>binom</em> Binomial distribution, parameters <code class="reqn">n</code> and <code class="reqn">p</code>.
</p>
<p style="text-align: center;"><code class="reqn">p(x) = {n \choose x} {p}^{x} {(1-p)}^{n-x}</code>
</p>

<p>for x = 0, <code class="reqn">\dots</code>, n.
</p>
<p><em>hyper</em> Hypergeometric distribution, parameters <code class="reqn">m</code> (the
number of white balls in the urn), <code class="reqn">n</code> (the number of white balls
in the urn), <code class="reqn">k</code> (the number of balls drawn from the urn). 
</p>
<p style="text-align: center;"><code class="reqn">
    p(x) = \left. {m \choose x}{n \choose k-x} \right/ {m+n \choose k}%
  </code>
</p>

<p>for x = 0, ..., k.
</p>
<p><em>geom</em> Geometric distribution, parameter <code class="reqn">p</code>.
</p>
<p style="text-align: center;"><code class="reqn">
    p(x) = p {(1-p)}^{x}
  </code>
</p>

<p>for x = 0, 1, 2, <code class="reqn">\dots</code>
</p>
<p><em>nbinom</em> Negative binomial distribution, parameters <code class="reqn">n</code> and
<code class="reqn">p</code>.
</p>
<p style="text-align: center;"><code class="reqn">
    p(x) = \frac{\Gamma(x+n)}{\Gamma(n) x!} p^n (1-p)^x
  </code>
</p>

<p>for x = 0, 1, 2, <code class="reqn">\dots</code>
</p>
<p><em>pois</em> Poisson distribution, parameter <code class="reqn">\lambda</code>.
</p>
<p style="text-align: center;"><code class="reqn">p(x) = \frac{\lambda^x e^{-\lambda}}{x!}</code>
</p>

<p>for x = 0, 1, 2, <code class="reqn">\dots</code>
</p>
<p><em>norm</em> Normal distribution rounded to integer values and negative
values become 0, parameters <code class="reqn">\mu</code> and
<code class="reqn">\sigma</code>.
</p>
<p style="text-align: center;"><code class="reqn">
    p(x) = \int_{x-0.5}^{x+0.5} \frac{1}{\sqrt{2\pi}\sigma} e^{-(t-\mu)^2/2\sigma^2}dt%
  </code>
</p>

<p>for x = 1, 2, <code class="reqn">\dots</code>
</p>
<p style="text-align: center;"><code class="reqn">p(x) = \int_{-\infty}^{0.5} \frac{1}{\sqrt{2\pi}\sigma} e^{-(t-\mu)^2/2\sigma^2}dt%
  </code>
</p>

<p>for x = 0
</p>
<p><em>lnorm</em> Lognormal distribution rounded to integer values,
parameters <code>logmean</code> <code class="reqn">=\mu</code> y <code>logsd</code> <code class="reqn">=\sigma</code>.
</p>
<p style="text-align: center;"><code class="reqn">
    p(x) = \int_{x-0.5}^{x+0.5} \frac{1}{\sqrt{2\pi}\sigma t} e^{-(\log(t) - \mu)^2/2 \sigma^2 }dt%
  </code>
</p>

<p>for x = 1, 2, <code class="reqn">\dots</code>
</p>
<p style="text-align: center;"><code class="reqn">
    p(x) = \int_{0}^{0.5} \frac{1}{\sqrt{2\pi}\sigma t} e^{-(\log(t) - \mu)^2/2 \sigma^2 }dt%
  </code>
</p>

<p>for x = 0
</p>
<p><em>gamma</em> Gamma distribution rounded to integer values,
parameters <code>shape</code> <code class="reqn">=\alpha</code> y <code>scale</code> <code class="reqn">=\sigma</code>.
</p>
<p style="text-align: center;"><code class="reqn">
    p(x)= \int_{x-0.5}^{x+0.5} \frac{1}{{\sigma}^{\alpha}\Gamma(\alpha)}{t}^{\alpha-1} e^{-t/\sigma} dt%
  </code>
</p>

<p>para x = 1, 2, <code class="reqn">\dots</code>
</p>
<p style="text-align: center;"><code class="reqn">
    p(x)= \int_{0}^{0.5} \frac{1}{{\sigma}^{\alpha}\Gamma(\alpha)}{t}^{\alpha-1} e^{-t/\sigma} dt%
  </code>
</p>

<p>for x = 0
</p>
<p>When the offspring distributions used <code>norm</code>, <code>lnorm</code> or
<code>gamma</code>, mean and variance related to these univariate
distributions is estimated by calculating sample mean and sample variance
of <code>maxiter</code> random values generated from the corresponding distribution.
</p>


<h3>Value</h3>

<p>A <code>matrix</code> object with the covariance matrices of the process in
the nth generation, combined by rows, or, a <code>matrix</code> object with
the covariace matrix of the population in the nth generation, in case
of provide the initial population vector (z0).
</p>


<h3>Author(s)</h3>

<p>Camilo Jose Torres-Jimenez <a href="mailto:cjtorresj@unal.edu.co">cjtorresj@unal.edu.co</a>
</p>


<h3>References</h3>

<p>Torres-Jimenez, C. J. (2010), Relative frequencies and parameter 
estimation in multi-type Bienayme - Galton - Watson processes, 
Master's Thesis, Master of Science in Statistics.
Universidad Nacional de Colombia. Bogota, Colombia.
</p>
<p>Stefanescu, C. (1998), 'Simulation of a multitype Galton-Watson
chain', Simulation Practice and Theory 6(7), 657-663.
</p>
<p>Athreya, K. &amp; Ney, P. (1972), Branching Processes, Springer-Verlag.
</p>
<p>Harris, T. E. (1963), The Theory of Branching Processes, Courier Dover
Publications. 
</p>


<h3>See Also</h3>

<p><code>BGWM.mean</code>, <code>rBGWM</code>, <code>BGWM.mean.estim</code>, <code>BGWM.covar.estim</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
## Variances and covariances of a BGWM process based on a model analyzed
## in Stefanescu (1998) 

# Variables and parameters
d &lt;- 2
n &lt;- 30
N &lt;- c(90, 10)
a &lt;- c(0.2, 0.3)

# with independent distributions
Dists.i &lt;- data.frame( name=rep( "pois", d*d ),
                       param1=rep( a, rep(d,d) ),
                       stringsAsFactors=FALSE )

# covariance matrices of the process
I.matriz.V &lt;- BGWM.covar(Dists.i, "independents", d)

# covariance matrix of the population in the nth generation
# from vector N representing the initial population
I.matrix.V.n_N &lt;- BGWM.covar(Dists.i, "independents", d, n, N)

# with multinomial distributions
dist &lt;- data.frame( name=rep( "pois", d ),
                    param1=a*d,
                    stringsAsFactors=FALSE )
matrix.b &lt;- matrix( rep(0.5, 4), nrow=2 )
Dists.m &lt;- list( dists.eta=dist, matrix.B=matrix.b )

# covariance matrices of the process
M.matrix.V &lt;- BGWM.covar(Dists.m, "multinomial", d)

# covariance matrix of the population in the nth generation
# from vector N representing the initial population
M.matrix.V.n_N &lt;- BGWM.covar(Dists.m, "multinomial", d, n, N)

# with general distributions (approximation)
max &lt;- 30
A &lt;- t(expand.grid(c(0:max),c(0:max)))
aux1 &lt;- factorial(A)
aux1 &lt;- apply(aux1,2,prod)
aux2 &lt;- apply(A,2,sum)
distp &lt;- function(x,y,z){ exp(-d*x)*(x^y)/z }
p &lt;- sapply( a, distp, aux2, aux1 )
prob &lt;- list( dist1=p[,1], dist2=p[,2] )
size &lt;- list( dist1=ncol(A), dist2=ncol(A) )
vect &lt;- list( dist1=t(A), dist2=t(A) )
Dists.g &lt;- list( sizes=size, probs=prob, vects=vect )

# covariance matrices of the process
G.matrix.V &lt;- BGWM.covar(Dists.g, "general", d)

# covariance matrix of the population in the nth generation
# from vector N representing the initial population
G.matrix.V.n_N &lt;- BGWM.covar(Dists.g, "general", d, n, N)

# Comparison of results
I.matrix.V.n_N
I.matrix.V.n_N - M.matrix.V.n_N
M.matrix.V.n_N - G.matrix.V.n_N
G.matrix.V.n_N - I.matrix.V.n_N

## End(Not run)
</code></pre>


</div>