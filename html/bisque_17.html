<div class="container">

<table style="width: 100%;"><tr>
<td>wMix</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Construct a weighted mixture object</h2>

<h3>Description</h3>

<p>For a Bayesian model
</p>
<p style="text-align: center;"><code class="reqn"> X ~ f(X | \theta_1, \theta_2)</code>
</p>

<p style="text-align: center;"><code class="reqn"> (\theta_1, \theta_2) ~ f(\theta_1, \theta_2),</code>
</p>

<p>the marginal  posterior <code class="reqn">f(\theta_1 | X)</code> distribution can be
approximated via weighted mixtures via
</p>
<p style="text-align: center;"><code class="reqn"> f(\theta_1 | X) \approx \sum_{j=1}^K f(\theta_1 | X, \theta_2) w_j </code>
</p>

<p>where <code class="reqn">w_j</code> is based on <code class="reqn">f(\theta_2^{(j)} | X)</code> and weights
<code class="reqn">\tilde w_j</code>, where <code class="reqn">\theta_2^{(j)}</code> and <code class="reqn">\tilde w_j</code> are
nodes and weights for a sparse-grid quadrature integration scheme.
The quadrature rule is developed by finding the posterior mode of
<code class="reqn">f(\theta_2|X)</code>, after transforming <code class="reqn">\theta_2</code> to an unconstrained
support.  For best results, <code class="reqn">\theta_2</code> should be a continuous random
variable, or be able to be approximated by one.
</p>


<h3>Usage</h3>

<pre><code class="language-R">wMix(
  f1,
  f2,
  w,
  f1.precompute = function(x, ...) {     x },
  spec = "ff",
  level = 2,
  c.int = NULL,
  c.level = 2,
  c.init = NULL,
  c.link = rep("identity", length(c.init)),
  c.link.params = rep(list(NA), length(c.init)),
  c.optim.control = list(maxit = 5000, method = "BFGS"),
  ncores = 1,
  quadError = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f1</code></td>
<td>
<p>evaluates <code class="reqn">f(\theta_1 | X, \theta_2)</code>.  <code>f1</code> must be able
to be called via <code>f1(theta1, params, log, ...)</code>.
</p>

<dl>
<dt><code>theta1</code></dt>
<dd>
<p>a matrix of parameters at which to evaluate
<code class="reqn">f(\theta_1 | X, \theta_2)</code>. each row should be one set of values
at which the density should be evaluated</p>
</dd>
<dt>params</dt>
<dd>
<p>a vector of parameters needed to evaluate
<code class="reqn">f(\theta_1 | X, \theta_2)</code>.  In most cases <code>params</code> will
equal <code class="reqn">theta_2</code>, but in some cases, <code class="reqn">f(\theta_1 | X, \theta_2)</code>
depends on functions of <code class="reqn">\theta_2</code>, which can be pre-evaluated
as the weighted mixture approximation is constructed.</p>
</dd>
<dt>log</dt>
<dd>
<p>TRUE to return <code class="reqn">ln(f(\theta_1 | X, \theta_2))</code></p>
</dd>
<dt>...</dt>
<dd>
<p>additional arguments needed for function evaluation</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f2</code></td>
<td>
<p>evaluates <code class="reqn">f(theta_2 | X)</code>.  <code>f2</code> must be able to be
called via <code>f2(theta2, log, ...)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p><code>wBuild</code> object created by <code>wBuild</code> function.  <code>w</code> 
contains posterior mode of <code class="reqn">f(\theta_2| X)</code> and wrapper functions to 
generate quadrature grid.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f1.precompute</code></td>
<td>
<p>function that pre-computes parameters for evaluating
<code class="reqn">f(\theta_1 | X, \theta_2)</code>.  <code>f1.precompute</code> must be able to
be called via <code>f1.precompute(theta2, ...)</code> and return the argument
<code>params</code> for the function <code>f1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spec</code></td>
<td>
<p>Specification of whether <code>f1</code> and <code>f2</code> are known 
exactly, or need numerical approximation to determine integration constants.
<code>'ff'</code> if both functions are known, <code>'gg'</code> if <code>f1</code> is 
proportional to the full conditional distribution 
<code class="reqn">f(\theta_1|\theta_2,X)</code>, but needs the integration constant computed,
and if the marginal posterior <code class="reqn">f(theta_2|X)</code> is equal to <code>f2</code> times
the integration constant that needs to be numerically approximated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>accuracy level of the numerical approximation
(typically number of grid points for the
underlying 1D quadrature rule) [description from mvQuad::createNIGrid]</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.int</code></td>
<td>
<p>If <code>spec=='gg'</code>, then <code>c.int</code> specifies the function
that can be integrated in order to yield the missing integration constant.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.level</code></td>
<td>
<p>accuracy level of the numerical approximation for <code>c.int</code> 
(typically number of grid points for the
underlying 1D quadrature rule) [description from mvQuad::createNIGrid]</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.init</code></td>
<td>
<p>initial guess for mode of <code>c.int</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.link</code></td>
<td>
<p>character vector that specifies transformations used during
optimization and integration of <code>c.int</code>.  See corresponding 
documentation in <code>wBuild</code> function for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.link.params</code></td>
<td>
<p>Optional list of additional parameters for link
functions used with <code>c.int</code>.   See corresponding 
documentation in <code>wBuild</code> function for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.optim.control</code></td>
<td>
<p>Arguments used to find mode of <code>c.int</code>.   See 
corresponding  documentation in <code>wBuild</code> function for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>number of cores used to parallelize computation of parameters
for <code class="reqn">f(\theta_1 | \theta_2, X)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quadError</code></td>
<td>
<p>TRUE if integration nodes and weight should be computed for
the <code>level-1</code> integration grid, so that quadrature approximation
error can be estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to pass to <code>f1</code>, <code>f1.precompute</code>,
<code>f12</code>, and <code>f2</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list with class <code>wMix</code>, which contains the following items.
</p>

<dl>
<dt><code>f</code></dt>
<dd>
<p>Function for evaluating the posterior density
<code class="reqn">f(\theta_1|X)</code>.  <code>f</code> is callable  via
<code>f(theta1, log, ...)</code>.</p>
</dd>
<dt><code>mix</code></dt>
<dd>
<p>A matrix containing the pre-computed parameters for
evaluating the mixture components <code class="reqn">f(\theta_1 | \theta_2, X)</code>.
Each row of the matrix contains parameters for one of the <code class="reqn">K</code>
mixture components.</p>
</dd>
<dt><code>wts</code></dt>
<dd>
<p>Integration weights for each of the mixture components.
Some of the weights may be negative.</p>
</dd>
<dt><code>expectation</code></dt>
<dd>
<p>List containing additional tools for computing
posterior expectations of <code class="reqn">f(\theta_2|X)</code>.  However, posterior
expectations of <code class="reqn">f(\theta_1|X)</code> can also be computed when
expectations of <code class="reqn">f(\theta_1|\theta_2, X)</code> are known.  The elements
of <code>expectation</code> are
</p>

<dl>
<dt><code>Eh</code></dt>
<dd>
<p>Function to compute <code class="reqn">E[h(\theta_2)|X]</code>.
<code>Eh</code> is callable via <code>Eh(h, ...)</code>, where <code>h</code> is a
function callable via <code>h(theta2, ...)</code> and <code>...</code> are
additional arguments to the function.  The function <code>h</code> is
evaluated at the quadrature nodes <code class="reqn">\theta_2^{(j)}</code>.</p>
</dd>
<dt><code>Eh.precompute</code></dt>
<dd>
<p>Exactly the same idea as <code>Eh</code>, but
the function <code>h</code> is evalauted at the quadrature nodes after
being passed through the function <code>f1.precompute</code>.</p>
</dd>
<dt><code>grid</code></dt>
<dd>
<p>The sparse-quadrature integration grid used.
Helpful for seeing the quadrature nodes <code class="reqn">\theta_2^{(j)}</code>.</p>
</dd>
<dt><code>wts</code></dt>
<dd>
<p>The integration weights for approximating the
expectation <code class="reqn">E[h]</code>.  Note that these integration weights may
differ from the main integration weights for evaluating the
posterior density <code class="reqn">f(\theta_1|X)</code>.</p>
</dd>
</dl>
</dd>
</dl>
<h3>Examples</h3>

<pre><code class="language-R"># Use BISQuE to approximate the marginal posterior distribution for unknown
# population f(N|c, r) for the fur seals capture-recapture data example in 
# Givens and Hoeting (2013), example 7.10.

data('furseals')

# define theta transformation and jacobian
tx.theta = function(theta) { 
  c(log(theta[1]/theta[2]), log(sum(theta[1:2]))) 
}
itx.theta = function(u) { 
  c(exp(sum(u[1:2])), exp(u[2])) / (1 + exp(u[1])) 
}
lJ.tx.theta = function(u) {
  log(exp(u[1] + 2*u[2]) + exp(2*sum(u[1:2]))) - 3 * log(1 + exp(u[1]))
}

# compute constants
r = sum(furseals$m)
nC = nrow(furseals)

# set basic initialization for parameters
init = list(U = c(-.7, 5.5))
init = c(init, list(
  alpha = rep(.5, nC),
  theta = itx.theta(init$U),
  N = r + 1
))


post.alpha_theta = function(theta2, log = TRUE, ...) {
  # Function proportional to f(alpha, U1, U2 | c, r) 
  
  alpha = theta2[1:nC]
  u = theta2[-(1:nC)]
  theta = itx.theta(u)
  p = 1 - prod(1-alpha)
  
  res = - sum(theta)/1e3 - r * log(p) + lJ.tx.theta(u) - 
    nC * lbeta(theta[1], theta[2])
  for(i in 1:nC) {
    res = res + (theta[1] + furseals$c[i] - 1)*log(alpha[i]) + 
      (theta[2] + r - furseals$c[i] - 1)*log(1-alpha[i])
  }
  
  if(log) { res } else { exp(res) }
}

post.N.mixtures = function(N, params, log = TRUE, ...) {
  # The mixture component of the weighted mixtures for f(N | c, r)
  dnbinom(x = N-r, size = r, prob = params, log = log)
}

mixparams.N = function(theta2, ...) {
  # compute parameters for post.N.mixtures
  1 - prod(1 - theta2[1:nC])
}


w.N = wBuild(f = post.alpha_theta, init = c(init$alpha, init$U), 
             approx = 'gauss', link = c(rep('logit', nC), rep('identity', 2)))

m.N = wMix(f1 = post.N.mixtures, f1.precompute = mixparams.N, 
           f2 = post.alpha_theta, w = w.N)



# compute posterior mean
m.N$expectation$Eh.precompute(h = function(p) ((1-p)*r/p + r), 
                                   quadError = TRUE)

# compute posterior density
post.N.dens = data.frame(N = r:105)
post.N.dens$d = m.N$f(post.N.dens$N)

# plot posterior density
plot(d~N, post.N.dens, ylab = expression(f(N~'|'~bold(c),r)))

</code></pre>


</div>