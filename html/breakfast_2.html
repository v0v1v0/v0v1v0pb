<div class="container">

<table style="width: 100%;"><tr>
<td>breakfast</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Methods for fast detection of multiple change-points</h2>

<h3>Description</h3>

<p>This function estimates the number and locations of change-points in a univariate data sequence,
which is modelled as (i) a piecewise-constant function plus i.i.d. Gaussian noise, 
(ii) a piecewise-constant function plus autoregressive time series,  
(iii) a piecewise-linear and continuous function plus i.i.d. Gaussian noise, or
(iv) a piecewise-linear and discontinuous function plus i.i.d. Gaussian noise.
This is carried out via a two-stage procedure combining solution path generation and model selection methodologies.
</p>


<h3>Usage</h3>

<pre><code class="language-R">breakfast(
  x,
  type = c("const", "lin.cont", "lin.discont"),
  solution.path = NULL,
  model.selection = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A numeric vector containing the data to be processed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>The type of change-point models fitted to the data; currently supported models are: piecewise constant signals (<code>type = "const"</code>, chosen by default), piecewise linear and continuous signals (<code>type = "lin.cont"</code>) and piecewise linear and discontinuous signals (<code>type = "lin.discont"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solution.path</code></td>
<td>
<p>A string or a vector of strings containing the name(s) of solution path generating method(s);
if individual methods are accessed via this option, default tuning parameters are used. 
Alternatively, you can directly access each solution path generating method via <code>sol.[method]</code>.
If both <code>solution.path</code> and <code>model.selection</code> are unspecified, we return the output from the suggested combinations based on their performance, which depends on <code>type</code> as below:
</p>
<p>When <code>type = "const"</code>: <code>("idetect", "ic")</code>, <code>("idetect_seq", "thresh")</code>, 
<code>("not", "ic")</code>, <code>("tguh", "lp")</code>, <code>("wbs", "ic")</code>, <code>("wbs2", "sdll")</code> and <code>("wcm", "gsa")</code>.
</p>
<p>When <code>type = "lin.cont"</code> or <code>type = "lin.discont"</code>: <code>("idetect_seq", "thresh")</code>, 
<code>("not", "ic")</code> and <code>("idetect", "sdll")</code>.
</p>
<p>If <code>solution.path</code> is specified but <code>model.selection</code> is not, we return the output from the specified <code>solution.path</code> methods combined with the suggested model selection methods (respectively) as above.
</p>

<dl>
<dt>"idetect"</dt>
<dd>
<p> IDetect, supporting <code>type = "const", "lin.cont", "lin.discont"</code>, see sol.idetect</p>
</dd> 
<dt>"idetect_seq"</dt>
<dd>
<p> Sequential IDetect, supporting <code>type = "const", "lin.cont", "lin.discont"</code>, see sol.idetect_seq</p>
</dd> 
<dt>"not"</dt>
<dd>
<p> Narrowest-Over-Threshold, supporting <code>type = "const", "lin.cont", "lin.discont"</code>, see sol.not</p>
</dd>
<dt>"tguh"</dt>
<dd>
<p> Tail-Greedy Unbalanced Haar, supporting <code>type = "const"</code>, see sol.tguh</p>
</dd>
<dt>"wbs"</dt>
<dd>
<p> Wild Binary Segmentation, supporting <code>type = "const"</code>, see sol.wbs</p>
</dd>
<dt>"wbs2"</dt>
<dd>
<p> Wild Binary Segmentation 2, supporting <code>type = "const"</code>, see sol.wbs2</p>
</dd>
<dt>"wcm"</dt>
<dd>
<p> Wild Contrast Maximisation, supporting <code>type = "const"</code> in combination with model.gsa handling model (ii), see sol.wcm</p>
</dd>
<dt>"all"</dt>
<dd>
<p> All of the above that support the <code>type</code> </p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model.selection</code></td>
<td>
<p>A string or a vector of strings containing the name(s) of model selection method(s);
if individual methods are accessed via this option, default tuning parameters are used. 
Alternatively, you can directly access each model selection method via <code>model.[method]</code>.
If both <code>solution.path</code> and <code>model.selection</code> are unspecified, we return the output from the suggested combinations based on their performance, see <code>solution.path</code>.
If <code>model.selection</code> is specified but <code>solution.path</code> is not, we return the output from the specified <code>model.selection</code> methods combined with the suggested solution path methods (respectively).
Not all <code>solution.path</code> methods are supported by all <code>model.selection</code> methods; check the individual functions for more information.
</p>

<dl>
<dt>"ic"</dt>
<dd>
<p> Strengthened Schwarz information criterion, supporting <code>type = "const", "lin.cont", "lin.discont"</code>, see model.ic</p>
</dd>
<dt>"lp"</dt>
<dd>
<p> Localised pruning, supporting <code>type = "const"</code>, see model.lp</p>
</dd>
<dt>"sdll"</dt>
<dd>
<p> Steepest Drop to Low Levels method, supporting <code>type = "const", "lin.cont", "lin.discont"</code>, see model.sdll</p>
</dd>
<dt>"thresh"</dt>
<dd>
<p> Thresholding, supporting <code>type = "const", "lin.cont", "lin.discont"</code>, see model.thresh</p>
</dd>
<dt>"gsa"</dt>
<dd>
<p> gappy Schwarz algorithm, supporting <code>type = "const"</code> in combination with sol.wcm handling model (ii), see model.gsa</p>
</dd>
<dt>"all"</dt>
<dd>
<p> All of the above that support the given <code>type</code></p>
</dd>
</dl>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Please also take a look at the vignette for tips/suggestions/examples of using the breakfast package.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>breakfast.cpts</code>, which contains the following fields:
</p>

<dl>
<dt>x</dt>
<dd>
<p> Input vector <code>x</code></p>
</dd>
<dt>cptmodel.list</dt>
<dd>
<p> A list containing S3 objects of class <code>cptmodel</code>; each contains the following fields:</p>
</dd>
</dl>
<dl>
<dt>solution.path</dt>
<dd>
<p> The solution path method used</p>
</dd>
<dt>model.selection</dt>
<dd>
<p> The model selection method used to return the final change-point estimators object</p>
</dd>
<dt>no.of.cpt</dt>
<dd>
<p> The number of estimated change-points in the piecewise-constant mean of the vector <code>cptpath.object$x</code></p>
</dd>
<dt>cpts</dt>
<dd>
<p> The locations of estimated change-points in the piecewise-constant mean of the vector <code>cptpath.object$x</code>. These are the end-points of the corresponding constant-mean intervals</p>
</dd>
<dt>est</dt>
<dd>
<p> An estimate of the piecewise-constant mean of the vector <code>cptpath.object$x</code>; the values are the sample means of the data (replicated a suitable number of times) between each pair of consecutive detected change-points</p>
</dd>
</dl>
<h3>References</h3>

<p>A. Anastasiou &amp; P. Fryzlewicz (2022) Detecting multiple generalized change-points by isolating single ones. <em>Metrika</em>, 85(2), 141–174.
</p>
<p>R. Baranowski, Y. Chen &amp; P. Fryzlewicz (2019) Narrowest-over-threshold detection of multiple change points and change-point-like features. <em>Journal of the Royal Statistical Society: Series B</em>, 81(3), 649–672.
</p>
<p>H. Cho &amp; C. Kirch (2022) Two-stage data segmentation permitting multiscale change points, heavy tails and dependence. <em>Annals of the Institute of Statistical Mathematics</em>, 74(4), 653–684.
</p>
<p>H. Cho &amp; P. Fryzlewicz (2024) Multiple change point detection under serial dependence: Wild contrast maximisation and gappy Schwarz algorithm. <em>Journal of Time Series Analysis</em>, 45(3): 479–494.
</p>
<p>P. Fryzlewicz (2014) Wild binary segmentation for multiple change-point detection. <em>The Annals of Statistics</em>, 42(6), 2243–2281.
</p>
<p>P. Fryzlewicz (2018) Tail-greedy bottom-up data decompositions and fast multiple change-point detection. <em>The Annals of Statistics</em>, 46(6B), 3390–3421.
</p>
<p>P. Fryzlewicz (2020) Detecting possibly frequent change-points: Wild Binary Segmentation 2 and steepest-drop model selection. <em>Journal of the Korean Statistical Society</em>, 49(4), 1027–1070.
</p>


<h3>Examples</h3>

<pre><code class="language-R">f &lt;- rep(rep(c(0, 1), each = 50), 10)
x &lt;- f + rnorm(length(f)) * .5
breakfast(x)
</code></pre>


</div>