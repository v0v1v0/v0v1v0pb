<div class="container">

<table style="width: 100%;"><tr>
<td>bartc-generics</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generic Methods for <code>bartcFit</code> Objects</h2>

<h3>Description</h3>

<p>Visual exploratory data analysis and model fitting diagnostics for causal inference models fit
using the <code>bartc</code> function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'bartcFit'
fitted(object,
       type = c("pate", "sate", "cate", "mu.obs", "mu.cf", "mu.0",
                "mu.1", "y.cf", "y.0", "y.1", "icate", "ite",
                "p.score", "p.weights"),
       sample = c("inferential", "all"),
       ...)

extract(object, ...)

## S3 method for class 'bartcFit'
extract(object,
        type = c("pate", "sate", "cate", "mu.obs", "mu.cf", "mu.0",
                 "mu.1", "y.cf", "y.0", "y.1", "icate", "ite",
                 "p.score", "p.weights", "sigma"),
        sample = c("inferential", "all"),
        combineChains = TRUE,
        ...)

## S3 method for class 'bartcFit'
predict(object, newdata,
        group.by,
        type = c("mu", "y", "mu.0", "mu.1", "y.0", "y.1", "icate", "ite",
                 "p.score"),
        combineChains = TRUE,
        ...)

refit(object, newresp, ...)

## S3 method for class 'bartcFit'
refit(object,
      newresp = NULL,
      commonSup.rule = c("none", "sd", "chisq"),
      commonSup.cut  = c(NA_real_, 1, 0.05),
      ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>Object of class <code>bartcFit</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>

<p>Which quantity to return. See details for a description of possible values.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample</code></td>
<td>

<p>Return information for either the <code>"inferential"</code> (e.g. treated observations when the estimand is
<code>att</code>) or <code>"all"</code> observations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>combineChains</code></td>
<td>

<p>If the models were fit with more than one chain, results retain the chain structure unless
<code>combineChains</code> is <code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newresp</code></td>
<td>

<p>Not presently used, but provided for compatibility with other definitions of the <code>refit</code> generic.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>

<p>Data corresponding to the confounders in a <code>bartc</code> fit.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group.by</code></td>
<td>

<p>Optional grouping variable. See definition of <code>group.by</code> in <code>bartc</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>commonSup.rule, commonSup.cut</code></td>
<td>
<p>As in <code>bartc</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Additional parameters passed up the generic method chain.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>fitted</code> returns the values that would serve as predictions for an object returned by the
<code>bartc</code> function, while <code>extract</code> instead returns the full matrix or array of posterior
samples. The possible options are:
</p>

<ul>
<li> <p><code>"pate", "sate", "cate"</code> - various target quantities; see <code>summary</code>
</p>
</li>
<li> <p><code>"mu"</code> - predict only: expected value; requires user-supplied treatment variable in
<code>newdata</code>
</p>
</li>
<li> <p><code>"y"</code> - predict only: sample of the response; requires user-supplied treatment variable in
<code>newdata</code>
</p>
</li>
<li> <p><code>"mu.obs"</code> - (samples from the posterior of) the expected value under the observed
treatment condition, i.e.
<code class="reqn">\hat{mu}_i(1) * z_i + \hat{mu}_i(0) * (1 - z_i)</code>
</p>
</li>
<li> <p><code>"mu.cf"</code> - the expected value under the counterfactual treatment condition, i.e.
<code class="reqn">\hat{mu}_i(1) * (1 - z_i) + \hat{mu}_i(0) * z_i)</code>
</p>
</li>
<li> <p><code>"mu.0"</code> - the expected value under the control condition
</p>
</li>
<li> <p><code>"mu.1"</code> - the expected value under the treated condition
</p>
</li>
<li> <p><code>"y.cf"</code> - samples of the response under the the counterfactual treatment condition, i.e.
<code class="reqn">\hat{y}_i(1 - z_i))</code>; values are obtained by adding noise to <code>mu.cf</code>
using the posterior predictive distribution
</p>
</li>
<li> <p><code>"y.0"</code> - observed responses under the control together with predicted under the treated, i.e.
<code class="reqn">\hat{y}_i(1) * z_i + y(0) * (1 - z_i)</code>
</p>
</li>
<li> <p><code>"y.1"</code> - observed responses under the treatment together with predicted under the control, i.e.
<code class="reqn">y_i(1) * z_i + \hat{y}(0) * (1 - z_i)</code>
</p>
</li>
<li> <p><code>"ite"</code> - (sample) individual treatment effect estimates, i.e.
<code class="reqn">(y_i(z_i) - y_i(1 - z_i)) * (2z_i - 1)</code>; uses observed responses and posterior
predicted counterfactuals
</p>
</li>
<li> <p><code>"icate"</code> - individual conditional average treatment effect estimates, i.e.
<code class="reqn">\hat{mu}_i(1) - \hat{mu}_i(0)</code>
</p>
</li>
<li> <p><code>"p.score"</code> - probability that each observation is assigned to the treatment group
</p>
</li>
<li> <p><code>"p.weights"</code> - weights assigned to each individual difference if the response method
is <code>"p.weight"</code>
</p>
</li>
<li> <p><code>"sigma"</code> - residual standard deviation from continuous response models
</p>
</li>
</ul>
<p><code>refit</code> exists to allow the same regressions to be used to calculate estimates under different
common support rules. To refit those models on a subset, see the examples in <code>bartc</code>.
</p>
<p><code>predict</code> allows the fitted model to be used to make predictions on an out-of-sample set.
Requires model to be fit with <code>keepTrees</code> equal to <code>TRUE</code>. As ‘<code>y</code>’ values are
all considered out of sample, the posterior predictive distribution is always used when relevant.
</p>


<h3>Value</h3>

<p>For <code>fitted</code>, <code>extract</code>, and <code>predict</code>, a matrix, array, or vector depending on the
dimensions of the result and the number of chains. For the following, when <code>n.chains</code> is one
the dimension is dropped.
</p>

<ul>
<li> <p><code>"pate"</code>, <code>"sate"</code>, or <code>"cate"</code> - with <code>fitted</code>, a scalar; with
<code>extract</code>, <code>n.chains x n.samples</code>
</p>
</li>
<li> <p><code>"p.score"</code> - depending on the fitting method, samples may or not be present; when samples
are absent, a vector is returned for both functions; when present, the same as <code>"y"</code>.
</p>
</li>
<li>
<p> all other types - with <code>fitted</code>, a vector of length equal to the number of
observations (<code>n.obs</code>); with <code>extract</code> or <code>predict</code>, a matrix or array of
dimensions <code>n.chains x n.samples x n.obs</code>.
</p>
</li>
</ul>
<p>For <code>refit</code>, an object of class <code>bartcFit</code>.
</p>


<h3>Author(s)</h3>

<p>Vincent Dorie: <a href="mailto:vdorie@gmail.com">vdorie@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code>bartc</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## fit a simple linear model
n &lt;- 100L
beta.z &lt;- c(.75, -0.5,  0.25)
beta.y &lt;- c(.5,   1.0, -1.5)
sigma &lt;- 2

set.seed(725)
x &lt;- matrix(rnorm(3 * n), n, 3)
tau &lt;- rgamma(1L, 0.25 * 16 * rgamma(1L, 1 * 32, 32), 16)

p.score &lt;- pnorm(x %*% beta.z)
z &lt;- rbinom(n, 1, p.score)

mu.0 &lt;- x %*% beta.y
mu.1 &lt;- x %*% beta.y + tau

y &lt;- mu.0 * (1 - z) + mu.1 * z + rnorm(n, 0, sigma)

# low parameters only for example
fit &lt;- bartc(y, z, x, n.samples = 100L, n.burn = 15L, n.chains = 2L)

# compare fit to linear model
lm.fit &lt;- lm(y ~ z + x)

plot(fitted(fit, type = "mu.obs"), fitted(lm.fit))

# rank order sample individual treatment effect estimates and plot
ites   &lt;- extract(fit, type = "ite")
ite.m  &lt;- apply(ites, 2, mean)
ite.sd &lt;- apply(ites, 2, sd)
ite.lb &lt;- ite.m - 2 * ite.sd
ite.ub &lt;- ite.m + 2 * ite.sd

ite.o &lt;- order(ite.m)

plot(NULL, type = "n",
     xlim = c(1, length(ite.m)), ylim = range(ite.lb, ite.ub),
     xlab = "effect order", ylab = "individual treatment effect")
lines(rbind(seq_along(ite.m), seq_along(ite.m), NA),
      rbind(ite.lb[ite.o], ite.ub[ite.o], NA), lwd = 0.5)
points(seq_along(ite.m), ite.m[ite.o], pch = 20)

</code></pre>


</div>