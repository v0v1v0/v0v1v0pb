<div class="container">

<table style="width: 100%;"><tr>
<td>tree_additive</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate additive edges for a coancestry tree, or viceversa</h2>

<h3>Description</h3>

<p>A coancestry tree has IBD probabilities as edge values, which describe how each child and parent subpopulation in the tree is related.
This means that each parameter is relative to its parent subpopulation (varies per edge), and they are not in general IBD probabilities from the root.
This function computes "additive" edges that corresponds more closely with the coancestry matrix of this tree, which gives parameters relative to the root (ancestral) population (see details below).
The additive edges are computed on a new element of the tree <code>phylo</code> object, so they do not overwrite the probabilistic edges.
The reverse option assumes that the main edges of the <code>phylo</code> object are additive edges, then calculates the probabilistic edges and stores as the main edges and moves the original additive edges on the new element.
</p>


<h3>Usage</h3>

<pre><code class="language-R">tree_additive(tree, rev = FALSE, force = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>tree</code></td>
<td>
<p>The coancestry tree with either probabilistic edges (if <code>rev = FALSE</code>) or additive edges (if <code>rev = TRUE</code>) as the main edges (stored in <code>tree$edge.length</code>).
Must be a <code>phylo</code> object from the <code>ape</code> package (see <code>ape::read.tree()</code>).
This tree may have a valid root edge (non-NULL <code>tree$root.edge</code> between 0 and 1), which is incorporated in the output calculations.
Function stops if the input data is not valid.
Probabilistic edges are valid if and only if they are all between zero and one.
Additive edges are valid if and only if they are all non-negative and the sum of edges between the root and each tip (leaf node) does not exceed 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rev</code></td>
<td>
<p>If <code>FALSE</code> (default), assumes the main edges are probabilistic values, and calculates additive values.
If <code>TRUE</code>, assumes main edges are additive values, and calculates probabilistic values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>force</code></td>
<td>
<p>If <code>FALSE</code> (default), function stops if input tree already has additive edges (if <code>tree$edge.length.add</code> is not <code>NULL</code>).
If <code>TRUE</code>, these values are ignored and overwritten.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The calculation takes into account that total coancestries are non-linear combinations of the per-edge coancestries.
For example, if the root node is <code>A</code>, and subpopulation <code>C</code> is connected to <code>A</code> only through an internal node <code>B</code>, then its total self-coancestry <code>coanc_A_C</code> relative to <code>A</code> is given by <code>coanc_A_B</code> (the coancestry between <code>A</code> and <code>B</code>) and <code>coanc_B_C</code> (the coancestry between <code>B</code> and <code>C</code>) by
<code>coanc_A_C = coanc_A_B + coanc_B_C * ( 1 - coanc_A_B )</code>.
This transformation ensures that the total coancestry is a probability that does not exceed one even when the per-edge coancestries sum to a value greater than one.
The "additive" edge for <code>B</code> and <code>C</code> is <code>coanc_B_C * ( 1 - coanc_A_B )</code>, so it is the probabilistic edge <code>coanc_B_C</code> shrunk by <code>1 - coanc_A_B</code>, which can then just be added to the parent edge <code>coanc_A_B</code> to give the total coancestry <code>coanc_A_C</code>.
This transformation is iterated for all nodes in the tree, noting that roots <code>B</code> connected to the root node <code>A</code> have equal probabilistic and additive edges <code>coanc_A_B</code> (unless the tree has a root edge, in which case that one is used to transform as above), and the edge of a node <code>C</code> not directly connected to a root uses the calculated edge <code>coanc_A_C</code> as above to shrink its children's edges into the additive scale.
</p>


<h3>Value</h3>

<p>The input <code>phylo</code> object extended so that the main edges (<code>tree$edge.length</code>) are probabilistic edges, and the additive edges are stored in <code>tree$edge.length.add</code>.
This is so for both values of <code>rev</code>
</p>


<h3>See Also</h3>

<p><code>coanc_tree()</code>, the key application facilitated by additive edges.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># for simulating a tree with `rtree`
library(ape)

# SETUP: number of tip subpopulations
k &lt;- 5
# simulate a random tree
# edges are drawn from Uniform(0, 1), so these are valid probabilistic edges
tree &lt;- rtree( k )
# inspect edges
tree$edge.length

# RUN calculate additive edges (safe to overwrite object)
tree &lt;- tree_additive( tree )
# inspect edges again
# probabilistic edges are still main edges:
tree$edge.length
# additive edges are here
tree$edge.length.add


# let's go backwards now, starting from the additive edges
# SETUP
# these are harder to simulate, so let's copy the previous value to the main edges
tree$edge.length &lt;- tree$edge.length.add
# and delete the extra entry (if it's present, function stops)
tree$edge.length.add &lt;- NULL
# inspect before
tree$edge.length

# RUN reverse version (safe to overwrite object again)
tree &lt;- tree_additive( tree, rev = TRUE )
# inspect after
# probabilistic edges are main edges:
tree$edge.length
# additive edges (previously main edges) were moved here
tree$edge.length.add

</code></pre>


</div>