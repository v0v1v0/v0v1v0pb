<div class="container">

<table style="width: 100%;"><tr>
<td>geostas</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> GeoStaS Domain Finder </h2>

<h3>Description</h3>

<p>Identifies geometrically stable domains in biomolecules
</p>


<h3>Usage</h3>

<pre><code class="language-R">geostas(...)

## Default S3 method:
geostas(...)

## S3 method for class 'xyz'
geostas(xyz, amsm = NULL, k = 3, pairwise = TRUE,
      clustalg = "kmeans", fit = TRUE, ncore = NULL, verbose=TRUE, ...)

## S3 method for class 'nma'
geostas(nma, m.inds = 7:11, verbose=TRUE, ...)

## S3 method for class 'enma'
geostas(enma, pdbs = NULL, m.inds = 1:5, verbose=TRUE, ...)

## S3 method for class 'pdb'
geostas(pdb, inds = NULL, verbose=TRUE, ...)

## S3 method for class 'pdbs'
geostas(pdbs, verbose=TRUE, ...)

amsm.xyz(xyz, ncore = NULL)

## S3 method for class 'geostas'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> arguments passed to and from functions, such as
<code>kmeans</code>, and <code>hclust</code> which are called
internally in <code>geostas.xyz</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xyz</code></td>
<td>
<p> numeric matrix of xyz coordinates as obtained e.g. by
<code>read.ncdf</code>, <code>read.dcd</code>, or
<code>mktrj</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>amsm</code></td>
<td>
<p> a numeric matrix as obtained by
<code>amsm.xyz</code> (convenient e.g. for re-doing only the
clustering analysis of the ‘AMSM’ matrix). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k </code></td>
<td>
<p> an integer scalar or vector with the desired number of
groups. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pairwise </code></td>
<td>
<p> logical, if TRUE use pairwise clustering of the atomic
movement similarity matrix (AMSM), else columnwise. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clustalg</code></td>
<td>
<p> a character string specifing the clustering
algorithm. Allowed values are ‘kmeans’ and ‘hclust’. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p> logical, if TRUE coordinate superposition on identified
core atoms is performed prior to the calculation of the AMS
matrix. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncore </code></td>
<td>
<p> number of CPU cores used to do the calculation.
<code>ncore&gt;1</code> requires package ‘parallel’ installed. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p> logical, if TRUE details of the geostas calculations
are printed to screen. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nma</code></td>
<td>
<p> an ‘nma’ object as obtained from function
<code>nma</code>. Function <code>mktrj</code> is used internally
to generate a trajectory based on the normal modes. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m.inds</code></td>
<td>
<p> the mode number(s) along which trajectory should be
made (see function <code>mktrj</code>). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>enma</code></td>
<td>
<p> an ‘enma’ object as obtained from function
<code>nma.pdbs</code>. Function <code>mktrj</code> is used internally
to generate a trajectory based on the normal modes. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pdbs</code></td>
<td>
<p> a ‘pdbs’ object as obtained from function
<code>pdbaln</code> or <code>read.fasta.pdb</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pdb</code></td>
<td>
<p> a ‘pdb’ object as obtained from function
<code>read.pdb</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inds</code></td>
<td>
<p> a ‘select’ object as obtained from function
<code>atom.select</code> giving the atomic indices at which the
calculation should be based. By default the function will attempt to
locate C-alpha atoms using function <code>atom.select</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> a ‘geostas’ object as obtained from function
<code>geostas</code>. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function attempts to identify rigid domains in a protein (or
nucleic acid) structure based on an structural ensemble, e.g. obtained
from NMR experiments, molecular dynamics simulations, or normal mode
analysis.
</p>
<p>The algorithm is based on a geometric approach for comparing pairwise
traces of atomic motion and the search for their best superposition
using a quaternion representation of rotation. The result is stored in
a NxN atomic movement similarity matrix (AMSM) describing the
correspondence between all pairs of atom motion. Rigid domains are
obtained by clustering the elements of the AMS matrix
(<code>pairwise=TRUE</code>), or alternatively, the columns similarity
(<code>pairwise=FALSE</code>), using either K-means (<code>kmeans</code>)
or hierarchical (<code>hclust</code>) clustering.
</p>
<p>Compared to the conventional cross-correlation matrix (see function
<code>dccm</code>) the “geostas” approach provide
functionality to also detect domains involved in rotational
motions (i.e. two  atoms located on opposite sides of a rotating
domain will appear as anti-correlated in the cross-correlation matrix,
but should obtain a high similarity coefficient in the AMS matrix).
</p>
<p>See examples for more details.
</p>


<h3>Value</h3>

<p>Returns a list object of type ‘geostas’ with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>amsm </code></td>
<td>
<p> a numeric matrix of atomic movement similarity (AMSM). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit.inds </code></td>
<td>
<p> a numeric vector of xyz indices used for fitting. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grps </code></td>
<td>
<p> a numeric vector containing the domain assignment per
residue. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>atomgrps </code></td>
<td>
<p> a numeric vector containing the domain assignment per
atom (only provided for <code>geostas.pdb</code>). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inds </code></td>
<td>
<p> a list of atom ‘select’ objects with indices to
corresponding to the identified domains. </p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>The current implementation in Bio3D uses a different fitting and
clustering approach than the original Java implementation. The results
will therefore differ.
</p>


<h3>Author(s)</h3>

<p> Julia Romanowska and Lars Skjaerven </p>


<h3>References</h3>

<p>Romanowska, J. et al. (2012) <em>JCTC</em> <b>8</b>, 2588–2599.
Skjaerven, L. et al. (2014) <em>BMC Bioinformatics</em> <b>15</b>, 399.
Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695–2696.
</p>


<h3>See Also</h3>

<p><code>plot.geostas</code>, 
<code>read.pdb</code>, <code>mktrj</code>,
<code>read.ncdf</code>, <code>read.dcd</code>,
<code>nma</code>, <code>dccm</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# PDB server connection required - testing excluded

#### NMR-ensemble example
## Read a multi-model PDB file 
pdb &lt;- read.pdb("1d1d", multi=TRUE)

## Find domains and write PDB
gs  &lt;- geostas(pdb, fit=TRUE)

## Plot a atomic movement similarity matrix
plot.geostas(gs, contour=FALSE)

## Fit all frames to the 'first' domain
domain.inds &lt;- gs$inds[[1]]

xyz &lt;- pdbfit(pdb, inds=domain.inds)

#write.pdb(pdb, xyz=xyz, chain=gs$atomgrps)



## Not run: 
#### NMA example
## Fetch stucture
pdb &lt;- read.pdb("1crn")

## Calculate (vibrational) normal modes
modes &lt;- nma(pdb)

## Find domains
gs &lt;- geostas(modes, k=2)

## Write NMA trajectory with domain assignment
mktrj(modes, mode=7, chain=gs$grps)

## Redo geostas domain clustering 
gs &lt;- geostas(modes, amsm=gs$amsm, k=5)




#### Trajectory example
## Read inn DCD trajectory file, fit coordinates
dcdfile &lt;- system.file("examples/hivp.dcd", package = "bio3d")
trj &lt;- read.dcd(dcdfile)
xyz &lt;- fit.xyz(trj[1,], trj)

## Find domains
gs &lt;- geostas(xyz, k=3, fit=FALSE)

## Principal component analysis 
pc.md &lt;- pca.xyz(xyz)

## Visualize PCs with colored domains (chain ID)
mktrj(pc.md, pc=1, chain=gs$grps)




#### X-ray ensemble GroEL subunits
# Define the ensemble PDB-ids
ids &lt;- c("1sx4_[A,B,H,I]", "1xck_[A-B]", "1sx3_[A-B]", "4ab3_[A-B]")

# Download and split PDBs by chain ID
raw.files &lt;- get.pdb(ids, path = "raw_pdbs", gzip = TRUE)
files &lt;- pdbsplit(raw.files, ids, path = "raw_pdbs/split_chain/")

# Align structures
pdbs &lt;- pdbaln(files)

# Find domains
gs &lt;- geostas(pdbs, k=4, fit=TRUE)

# Superimpose to core region
pdbs$xyz &lt;- pdbfit(pdbs, inds=gs$fit.inds)

# Principal component analysis 
pc.xray &lt;- pca(pdbs)

# Visualize PCs with colored domains (chain ID)
mktrj(pc.xray, pc=1, chain=gs$grps)


##- Same, but more manual approach 
gaps.pos &lt;- gap.inspect(pdbs$xyz)

# Find core region
core &lt;- core.find(pdbs)

# Fit to core region
xyz &lt;- fit.xyz(pdbs$xyz[1, gaps.pos$f.inds],
               pdbs$xyz[, gaps.pos$f.inds],
               fixed.inds=core$xyz,
               mobile.inds=core$xyz)

# Find domains
gs &lt;- geostas(xyz, k=4, fit=FALSE)

# Perform PCA
pc.xray &lt;- pca.xyz(xyz)

# Make trajectory
mktrj(pc.xray, pc=1, chain=gs$grps)


## End(Not run)
</code></pre>


</div>