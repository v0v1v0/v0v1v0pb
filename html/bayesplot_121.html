<div class="container">

<table style="width: 100%;"><tr>
<td>PPC-distributions</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>PPC distributions</h2>

<h3>Description</h3>

<p>Compare the empirical distribution of the data <code>y</code> to the distributions of
simulated/replicated data <code>yrep</code> from the posterior predictive distribution.
See the <strong>Plot Descriptions</strong> section, below, for details.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ppc_data(y, yrep, group = NULL)

ppc_dens_overlay(
  y,
  yrep,
  ...,
  size = 0.25,
  alpha = 0.7,
  trim = FALSE,
  bw = "nrd0",
  adjust = 1,
  kernel = "gaussian",
  n_dens = 1024
)

ppc_dens_overlay_grouped(
  y,
  yrep,
  group,
  ...,
  size = 0.25,
  alpha = 0.7,
  trim = FALSE,
  bw = "nrd0",
  adjust = 1,
  kernel = "gaussian",
  n_dens = 1024
)

ppc_ecdf_overlay(
  y,
  yrep,
  ...,
  discrete = FALSE,
  pad = TRUE,
  size = 0.25,
  alpha = 0.7
)

ppc_ecdf_overlay_grouped(
  y,
  yrep,
  group,
  ...,
  discrete = FALSE,
  pad = TRUE,
  size = 0.25,
  alpha = 0.7
)

ppc_dens(y, yrep, ..., trim = FALSE, size = 0.5, alpha = 1)

ppc_hist(
  y,
  yrep,
  ...,
  binwidth = NULL,
  bins = NULL,
  breaks = NULL,
  freq = TRUE
)

ppc_freqpoly(
  y,
  yrep,
  ...,
  binwidth = NULL,
  bins = NULL,
  freq = TRUE,
  size = 0.5,
  alpha = 1
)

ppc_freqpoly_grouped(
  y,
  yrep,
  group,
  ...,
  binwidth = NULL,
  bins = NULL,
  freq = TRUE,
  size = 0.5,
  alpha = 1
)

ppc_boxplot(y, yrep, ..., notch = TRUE, size = 0.5, alpha = 1)

ppc_violin_grouped(
  y,
  yrep,
  group,
  ...,
  probs = c(0.1, 0.5, 0.9),
  size = 1,
  alpha = 1,
  y_draw = c("violin", "points", "both"),
  y_size = 1,
  y_alpha = 1,
  y_jitter = 0.1
)

ppc_pit_ecdf(
  y,
  yrep,
  ...,
  pit = NULL,
  K = NULL,
  prob = 0.99,
  plot_diff = FALSE,
  interpolate_adj = NULL
)

ppc_pit_ecdf_grouped(
  y,
  yrep,
  group,
  ...,
  K = NULL,
  pit = NULL,
  prob = 0.99,
  plot_diff = FALSE,
  interpolate_adj = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>A vector of observations. See <strong>Details</strong>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yrep</code></td>
<td>
<p>An <code>S</code> by <code>N</code> matrix of draws from the posterior (or prior)
predictive distribution. The number of rows, <code>S</code>, is the size of the
posterior (or prior) sample used to generate <code>yrep</code>. The number of columns,
<code>N</code> is the number of predicted observations (<code>length(y)</code>). The columns of
<code>yrep</code> should be in the same order as the data points in <code>y</code> for the plots
to make sense. See the <strong>Details</strong> and <strong>Plot Descriptions</strong> sections for
additional advice specific to particular plots.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>A grouping variable of the same length as <code>y</code>.
Will be coerced to factor if not already a factor.
Each value in <code>group</code> is interpreted as the group level pertaining
to the corresponding observation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Currently unused.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size, alpha</code></td>
<td>
<p>Passed to the appropriate geom to control the appearance of
the predictive distributions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trim</code></td>
<td>
<p>A logical scalar passed to <code>ggplot2::geom_density()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bw, adjust, kernel, n_dens</code></td>
<td>
<p>Optional arguments passed to
<code>stats::density()</code> to override default kernel density estimation
parameters. <code>n_dens</code> defaults to <code>1024</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>discrete</code></td>
<td>
<p>For <code>ppc_ecdf_overlay()</code>, should the data be treated as
discrete? The default is <code>FALSE</code>, in which case <code>geom="line"</code> is
passed to <code>ggplot2::stat_ecdf()</code>. If <code>discrete</code> is set to
<code>TRUE</code> then <code>geom="step"</code> is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pad</code></td>
<td>
<p>A logical scalar passed to <code>ggplot2::stat_ecdf()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>binwidth</code></td>
<td>
<p>Passed to <code>ggplot2::geom_histogram()</code> to override
the default binwidth.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bins</code></td>
<td>
<p>Passed to <code>ggplot2::geom_histogram()</code> to override
the default binwidth.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>breaks</code></td>
<td>
<p>Passed to <code>ggplot2::geom_histogram()</code> as an
alternative to <code>binwidth</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>freq</code></td>
<td>
<p>For histograms, <code>freq=TRUE</code> (the default) puts count on the
y-axis. Setting <code>freq=FALSE</code> puts density on the y-axis. (For many
plots the y-axis text is off by default. To view the count or density
labels on the y-axis see the <code>yaxis_text()</code> convenience
function.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>notch</code></td>
<td>
<p>For the box plot, a logical scalar passed to
<code>ggplot2::geom_boxplot()</code>. Note: unlike <code>geom_boxplot()</code>, the default is
<code>notch=TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>probs</code></td>
<td>
<p>A numeric vector passed to <code>ggplot2::geom_violin()</code>'s
<code>draw_quantiles</code> argument to specify at which quantiles to draw
horizontal lines. Set to <code>NULL</code> to remove the lines.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y_draw</code></td>
<td>
<p>For <code>ppc_violin_grouped()</code>, a string specifying how to draw
<code>y</code>: <code>"violin"</code> (default), <code>"points"</code> (jittered points), or <code>"both"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y_jitter, y_size, y_alpha</code></td>
<td>
<p>For <code>ppc_violin_grouped()</code>, if <code>y_draw</code> is
<code>"points"</code> or <code>"both"</code> then <code>y_size</code>, <code>y_alpha</code>, and <code>y_jitter</code> are passed
to to the <code>size</code>, <code>alpha</code>, and <code>width</code> arguments of <code>ggplot2::geom_jitter()</code>
to control the appearance of <code>y</code> points. The default of <code>y_jitter=NULL</code>
will let <strong>ggplot2</strong> determine the amount of jitter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pit</code></td>
<td>
<p>An optional vector of probability integral transformed values for
which the ECDF is to be drawn. If NULL, PIT values are computed to <code>y</code> with
respect to the corresponding values in <code>yrep</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>An optional integer defining the number of equally spaced evaluation
points for the PIT-ECDF. Reducing K when using <code>interpolate_adj = FALSE</code>
makes computing the confidence bands faster. For <code>ppc_pit_ecdf</code> and
<code>ppc_pit_ecdf_grouped</code>, if PIT values are supplied, defaults to
<code>length(pit)</code>, otherwise yrep determines the maximum accuracy of the
estimated PIT values and <code>K</code> is set to <code>min(nrow(yrep) + 1, 1000)</code>. For
<code>mcmc_rank_ecdf</code>, defaults to the number of iterations per chain in <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prob</code></td>
<td>
<p>The desired simultaneous coverage level of the bands around the
ECDF. A value in (0,1).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot_diff</code></td>
<td>
<p>A boolean defining whether to plot the difference between
the observed PIT- ECDF and the theoretical expectation for uniform PIT
values rather than plotting the regular ECDF. The default is <code>FALSE</code>, but
for large samples we recommend setting <code>plot_diff=TRUE</code> as the difference
plot will visually show a more dynamic range.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interpolate_adj</code></td>
<td>
<p>A boolean defining if the simultaneous confidence
bands should be interpolated based on precomputed values rather than
computed exactly. Computing the bands may be computationally intensive and
the approximation gives a fast method for assessing the ECDF trajectory.
The default is to use interpolation if <code>K</code> is greater than 200.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For Binomial data, the plots may be more useful if
the input contains the "success" <em>proportions</em> (not discrete
"success" or "failure" counts).
</p>


<h3>Value</h3>

<p>The plotting functions return a ggplot object that can be further
customized using the <strong>ggplot2</strong> package. The functions with suffix
<code style="white-space: pre;">⁠_data()⁠</code> return the data that would have been drawn by the plotting
function.
</p>


<h3>Plot Descriptions</h3>


<dl>
<dt><code style="white-space: pre;">⁠ppc_hist(), ppc_freqpoly(), ppc_dens(), ppc_boxplot()⁠</code></dt>
<dd>
<p>A separate histogram, shaded frequency polygon, smoothed kernel density
estimate, or box and whiskers plot is displayed for <code>y</code> and each
dataset (row) in <code>yrep</code>. For these plots <code>yrep</code> should therefore
contain only a small number of rows. See the <strong>Examples</strong> section.
</p>
</dd>
<dt><code>ppc_freqpoly_grouped()</code></dt>
<dd>
<p>A separate frequency polygon is plotted for each level of a grouping
variable for <code>y</code> and each dataset (row) in <code>yrep</code>. For this plot
<code>yrep</code> should therefore contain only a small number of rows. See the
<strong>Examples</strong> section.
</p>
</dd>
<dt><code style="white-space: pre;">⁠ppc_ecdf_overlay(), ppc_dens_overlay(), ppc_ecdf_overlay_grouped(), ppc_dens_overlay_grouped()⁠</code></dt>
<dd>
<p>Kernel density or empirical CDF estimates of each dataset (row) in
<code>yrep</code> are overlaid, with the distribution of <code>y</code> itself on top
(and in a darker shade). When using <code>ppc_ecdf_overlay()</code> with discrete
data, set the <code>discrete</code> argument to <code>TRUE</code> for better results.
For an example of <code>ppc_dens_overlay()</code> also see Gabry et al. (2019).
</p>
</dd>
<dt><code>ppc_violin_grouped()</code></dt>
<dd>
<p>The density estimate of <code>yrep</code> within each level of a grouping
variable is plotted as a violin with horizontal lines at notable
quantiles. <code>y</code> is overlaid on the plot either as a violin, points, or
both, depending on the <code>y_draw</code> argument.
</p>
</dd>
<dt>
<code>ppc_pit_ecdf()</code>, <code>ppc_pit_ecdf_grouped()</code>
</dt>
<dd>
<p>The PIT-ECDF of the empirical PIT values of <code>y</code> computed with respect to
the corresponding <code>yrep</code> values. <code>100 * prob</code>% central simultaneous
confidence intervals are provided to asses if <code>y</code> and <code>yrep</code> originate
from the same distribution. The PIT values can also be provided directly
as <code>pit</code>.
See Säilynoja et al. (2021) for more details.</p>
</dd>
</dl>
<h3>References</h3>

<p>Gabry, J. , Simpson, D. , Vehtari, A. , Betancourt, M. and
Gelman, A. (2019), Visualization in Bayesian workflow.
<em>J. R. Stat. Soc. A</em>, 182: 389-402. doi:10.1111/rssa.12378.
(<a href="https://rss.onlinelibrary.wiley.com/doi/full/10.1111/rssa.12378">journal version</a>,
<a href="https://arxiv.org/abs/1709.01449">arXiv preprint</a>,
<a href="https://github.com/jgabry/bayes-vis-paper">code on GitHub</a>)
</p>
<p>Säilynoja, T., Bürkner, P., Vehtari, A.
(2021). Graphical Test for Discrete Uniformity and its Applications in
Goodness of Fit Evaluation and Multiple Sample Comparison <a href="https://arxiv.org/abs/2103.10522">arXiv preprint</a>.
</p>
<p>Gelman, A., Carlin, J. B., Stern, H. S., Dunson, D. B., Vehtari,
A., and Rubin, D. B. (2013). <em>Bayesian Data Analysis.</em> Chapman &amp; Hall/CRC
Press, London, third edition. (Ch. 6)
</p>


<h3>See Also</h3>

<p>Other PPCs: 
<code>PPC-censoring</code>,
<code>PPC-discrete</code>,
<code>PPC-errors</code>,
<code>PPC-intervals</code>,
<code>PPC-loo</code>,
<code>PPC-overview</code>,
<code>PPC-scatterplots</code>,
<code>PPC-test-statistics</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">color_scheme_set("brightblue")
y &lt;- example_y_data()
yrep &lt;- example_yrep_draws()
group &lt;- example_group_data()
dim(yrep)

ppc_dens_overlay(y, yrep[1:25, ])

# ppc_ecdf_overlay with continuous data (set discrete=TRUE if discrete data)
ppc_ecdf_overlay(y, yrep[sample(nrow(yrep), 25), ])

# PIT-ECDF and PIT-ECDF difference plot of the PIT values of y compared to
# yrep with 99% simultaneous confidence bands.
ppc_pit_ecdf(y, yrep, prob = 0.99, plot_diff = FALSE)
ppc_pit_ecdf(y, yrep, prob = 0.99, plot_diff = TRUE)


# for ppc_hist,dens,freqpoly,boxplot definitely use a subset yrep rows so
# only a few (instead of nrow(yrep)) histograms are plotted
ppc_hist(y, yrep[1:8, ])

color_scheme_set("red")
ppc_boxplot(y, yrep[1:8, ])

# wizard hat plot
color_scheme_set("blue")
ppc_dens(y, yrep[200:202, ])



# frequency polygons
ppc_freqpoly(y, yrep[1:3, ], alpha = 0.1, size = 1, binwidth = 5)

ppc_freqpoly_grouped(y, yrep[1:3, ], group) + yaxis_text()

# if groups are different sizes then the 'freq' argument can be useful
ppc_freqpoly_grouped(y, yrep[1:3, ], group, freq = FALSE) + yaxis_text()


# density and distribution overlays by group
ppc_dens_overlay_grouped(y, yrep[1:25, ], group = group)

ppc_ecdf_overlay_grouped(y, yrep[1:25, ], group = group)


# PIT-ECDF plots of the PIT values by group
# with 99% simultaneous confidence bands.
ppc_pit_ecdf_grouped(y, yrep, group=group, prob=0.99)



# don't need to only use small number of rows for ppc_violin_grouped
# (as it pools yrep draws within groups)
color_scheme_set("gray")
ppc_violin_grouped(y, yrep, group, size = 1.5)
ppc_violin_grouped(y, yrep, group, alpha = 0)

# change how y is drawn
ppc_violin_grouped(y, yrep, group, alpha = 0, y_draw = "points", y_size = 1.5)
ppc_violin_grouped(y, yrep, group,
  alpha = 0, y_draw = "both",
  y_size = 1.5, y_alpha = 0.5, y_jitter = 0.33
)

</code></pre>


</div>