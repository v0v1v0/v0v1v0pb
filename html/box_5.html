<div class="container">

<table style="width: 100%;"><tr>
<td>mod-hooks</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Hooks for module events</h2>

<h3>Description</h3>

<p>Modules can declare functions to be called when a module is first loaded.
</p>


<h3>Usage</h3>

<pre><code class="language-R">.on_load(ns)

.on_unload(ns)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>ns</code></td>
<td>
<p>the module namespace environment</p>
</td>
</tr></table>
<h3>Details</h3>

<p>To create module hooks, modules should define a function with the specified
name and signature. Module hooks should <em>not</em> be exported.
</p>
<p>When <code>.on_load</code> is called, the unlocked module namespace environment is
passed to it via its parameter <code>ns</code>. This means that code in
<code>.on_load</code> is permitted to modify the namespace by adding names to,
replacing names in, or removing names from the namespace.
</p>
<p><code>.on_unload</code> is called when modules are unloaded. The (locked) module
namespace is passed as an argument. It is primarily useful to clean up
resources used by the module. Note that, as for packages, <code>.on_unload</code>
is <em>not</em> necessarily called when R is shut down.
</p>
<p><em>Legacy modules</em> cannot use hooks. To use hooks, the module needs to
contain an export specification (if the module should not export any names,
specify an explicit, empty export list via
<code>box::export()</code>.
</p>


<h3>Value</h3>

<p>Any return values of the hook functions are ignored.
</p>


<h3>Note</h3>

<p>The API for hook functions is still subject to change. In particular,
there might in the future be a way to subscribe to module events of other
modules and packages, equivalently to R package userhooks.
</p>


</div>