<div class="container">

<table style="width: 100%;"><tr>
<td>bass</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bayesian Adaptive Spline Surfaces (BASS)</h2>

<h3>Description</h3>

<p>Fits a BASS model using RJMCMC.  Optionally uses parallel tempering to improve mixing.  Can be used with scalar or functional response.  Also can use categorical inputs.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bass(
  xx,
  y,
  maxInt = 3,
  maxInt.func = 3,
  maxInt.cat = 3,
  xx.func = NULL,
  degree = 1,
  maxBasis = 1000,
  npart = NULL,
  npart.func = NULL,
  nmcmc = 10000,
  nburn = 9000,
  thin = 1,
  g1 = 0,
  g2 = 0,
  s2.lower = 0,
  h1 = 10,
  h2 = 10,
  a.tau = 0.5,
  b.tau = NULL,
  w1 = 5,
  w2 = 5,
  beta.prior = "g",
  temp.ladder = NULL,
  start.temper = NULL,
  curr.list = NULL,
  save.yhat = TRUE,
  small = FALSE,
  verbose = TRUE,
  ret.str = F
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>xx</code></td>
<td>
<p>a data frame or matrix of predictors.  Categorical predictors should be included as factors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a response vector (scalar response) or matrix (functional response).  Note: If <code>sum(y^2)</code> is large (i.e. <code>1e10</code>), please center/rescale (and rescale <code>g1</code> and <code>g2</code> if necessary).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxInt</code></td>
<td>
<p>integer for maximum degree of interaction in spline basis functions.  Defaults to the number of predictors, which could result in overfitting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxInt.func</code></td>
<td>
<p>(functional response only) integer for maximum degree of interaction in spline basis functions describing the functional response.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxInt.cat</code></td>
<td>
<p>(categorical input only) integer for maximum degree of interaction of categorical inputs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xx.func</code></td>
<td>
<p>a vector, matrix or data frame of functional variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degree</code></td>
<td>
<p>degree of splines.  Stability should be examined for anything other than 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxBasis</code></td>
<td>
<p>maximum number of basis functions.  This should probably only be altered if you run out of memory.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npart</code></td>
<td>
<p>minimum number of non-zero points in a basis function.  If the response is functional, this refers only to the portion of the basis function coming from the non-functional predictors. Defaults to 20 or 0.1 times the number of observations, whichever is smaller.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npart.func</code></td>
<td>
<p>same as npart, but for functional portion of basis function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nmcmc</code></td>
<td>
<p>number of RJMCMC iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nburn</code></td>
<td>
<p>number of the <code>nmcmc</code> iterations to disregard.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>keep every <code>thin</code> samples</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g1</code></td>
<td>
<p>shape for IG prior on <code class="reqn">\sigma^2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g2</code></td>
<td>
<p>scale for IG prior on <code class="reqn">\sigma^2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s2.lower</code></td>
<td>
<p>lower bound for s2. Turns IG prior for s2 into a truncated IG.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h1</code></td>
<td>
<p>shape for gamma prior on <code class="reqn">\lambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h2</code></td>
<td>
<p>rate for gamma prior on <code class="reqn">\lambda</code>.  This is the primary way to control overfitting.  A large value of <code>h2</code> favors fewer basis functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a.tau</code></td>
<td>
<p>shape for gamma prior on <code class="reqn">\tau</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.tau</code></td>
<td>
<p>rate for gamma prior on <code class="reqn">\tau</code>. Defaults to one over the number of observations, which centers the prior for the basis function weights on the unit information prior.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w1</code></td>
<td>
<p>nominal weight for degree of interaction, used in generating candidate basis functions.  Should be greater than 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w2</code></td>
<td>
<p>nominal weight for variables, used in generating candidate basis functions.  Should be greater than 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta.prior</code></td>
<td>
<p>what type of prior to use for basis coefficients, "g" or "jeffreys"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>temp.ladder</code></td>
<td>
<p>temperature ladder used for parallel tempering.  The first value should be 1 and the values should increase.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start.temper</code></td>
<td>
<p>when to start tempering (after how many MCMC iterations). Defaults to 1000 or half of burn-in, whichever is smaller.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>curr.list</code></td>
<td>
<p>list of starting models (one element for each temperature), could be output from a previous run under the same model setup.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>save.yhat</code></td>
<td>
<p>logical; should predictions of training data be saved?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>small</code></td>
<td>
<p>logical; if true, returns a smaller object by leaving out <code>curr.list</code> and other unnecessary objects.  Use in combination with <code>save.yhat</code> to get smaller memory footprint for very large models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical; should progress be displayed?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ret.str</code></td>
<td>
<p>logical; return data and prior structures</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Explores BASS model space by RJMCMC.  The BASS model has </p>
<p style="text-align: center;"><code class="reqn">y = f(x) + \epsilon,  ~~\epsilon \sim N(0,\sigma^2)</code>
</p>
 <p style="text-align: center;"><code class="reqn">f(x) = a_0 + \sum_{m=1}^M a_m B_m(x)</code>
</p>
<p> and <code class="reqn">B_m(x)</code> is a BASS basis function (tensor product of spline basis functions). We use priors </p>
<p style="text-align: center;"><code class="reqn">a \sim N(0,\sigma^2/\tau (B'B)^{-1})</code>
</p>
 <p style="text-align: center;"><code class="reqn">M \sim Poisson(\lambda)</code>
</p>
<p> as well as the priors mentioned in the arguments above.
</p>


<h3>Value</h3>

<p>An object of class 'bass'.  The other output will only be useful to the advanced user.  Rather, users may be interested in prediction and sensitivity analysis, which are obtained by passing the entire object to the predict.bass or sobol functions.
</p>


<h3>See Also</h3>

<p>predict.bass for prediction and sobol for sensitivity analysis.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
####################################################################################################
### univariate example
####################################################################################################
## simulate data (Friedman function)
f&lt;-function(x){
  10*sin(pi*x[,1]*x[,2])+20*(x[,3]-.5)^2+10*x[,4]+5*x[,5]
}
sigma&lt;-1 # noise sd
n&lt;-500 # number of observations
x&lt;-matrix(runif(n*10),n,10) #10 variables, only first 5 matter
y&lt;-rnorm(n,f(x),sigma)

## fit BASS, no tempering
mod&lt;-bass(x,y)
plot(mod)
## fit BASS, tempering
mod&lt;-bass(x,y,temp.ladder=1.3^(0:8),start.temper=1000)
plot(mod)

## prediction
npred&lt;-1000
xpred&lt;-matrix(runif(npred*10),npred,10)
pred&lt;-predict(mod,xpred,verbose=TRUE) # posterior predictive samples
true.y&lt;-f(xpred)
plot(true.y,colMeans(pred),xlab='true values',ylab='posterior predictive means')
abline(a=0,b=1,col=2)

## sensitivity
sens&lt;-sobol(mod)
plot(sens,cex.axis=.5)

####################################################################################################
### functional example
####################################################################################################
## simulate data (Friedman function with first variable as functional)
sigma&lt;-1 # noise sd
n&lt;-500 # number of observations
nfunc&lt;-50 # size of functional variable grid
xfunc&lt;-seq(0,1,length.out=nfunc) # functional grid
x&lt;-matrix(runif(n*9),n,9) # 9 non-functional variables, only first 4 matter
X&lt;-cbind(rep(xfunc,each=n),kronecker(rep(1,nfunc),x)) # to get y
y&lt;-matrix(f(X),nrow=n)+rnorm(n*nfunc,0,sigma)

## fit BASS
mod&lt;-bass(x,y,xx.func=xfunc)
plot(mod)

## prediction
npred&lt;-100
xpred&lt;-matrix(runif(npred*9),npred,9)
Xpred&lt;-cbind(rep(xfunc,each=npred),kronecker(rep(1,nfunc),xpred))
ypred&lt;-matrix(f(Xpred),nrow=npred)
pred&lt;-predict(mod,xpred) # posterior predictive samples (each is a curve)
matplot(ypred,apply(pred,2:3,mean),type='l',xlab='observed',ylab='mean prediction')
abline(a=0,b=1,col=2)
matplot(t(ypred),type='l') # actual
matplot(t(apply(pred,2:3,mean)),type='l') # mean prediction

## sensitivity
sens&lt;-sobol(mod,mcmc.use=1:10) # for speed, only use a few samples
plot(sens) # functional variable labelled "a"

sens.func&lt;-sobol(mod,mcmc.use=1:10,func.var=1)
plot(sens.func)

## End(Not run)

## minimal example for CRAN testing
mod&lt;-bass(1:2,1:2,nmcmc=2,nburn=1)
</code></pre>


</div>