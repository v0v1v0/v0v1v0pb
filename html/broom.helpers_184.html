<div class="container">

<table style="width: 100%;"><tr>
<td>tidy_marginal_predictions</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Marginal Predictions with <code>marginaleffects::avg_predictions()</code>
</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt="[Experimental]"></a>
Use <code>marginaleffects::avg_predictions()</code> to estimate marginal predictions for
each variable of a model and return a tibble tidied in a way that it could
be used by <code>broom.helpers</code> functions.
See <code>marginaleffects::avg_predictions()</code> for a list of supported models.
</p>


<h3>Usage</h3>

<pre><code class="language-R">tidy_marginal_predictions(
  x,
  variables_list = "auto",
  conf.int = TRUE,
  conf.level = 0.95,
  ...
)

variables_to_predict(
  model,
  interactions = TRUE,
  categorical = unique,
  continuous = stats::fivenum
)

plot_marginal_predictions(x, variables_list = "auto", conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>(a model object, e.g. <code>glm</code>)<br>
A model to be tidied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variables_list</code></td>
<td>
<p>(<code>list</code> or <code>string</code>)<br>
A list whose elements will be sequentially passed to
<code>variables</code> in <code>marginaleffects::avg_predictions()</code> (see details below);
alternatively, it could also be the string <code>"auto"</code> (default) or
<code>"no_interaction"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.int</code></td>
<td>
<p>(<code>logical</code>)<br>
Whether or not to include a confidence interval in the tidied output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.level</code></td>
<td>
<p>(<code>numeric</code>)<br>
The confidence level to use for the confidence interval (between <code>0</code> ans <code>1</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional parameters passed to
<code>marginaleffects::avg_predictions()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>(a model object, e.g. <code>glm</code>)<br>
A model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interactions</code></td>
<td>
<p>(<code>logical</code>)<br>
Should combinations of variables corresponding to
interactions be returned?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>categorical</code></td>
<td>
<p>(<code>predictor values</code>)<br>
Default values for categorical variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>continuous</code></td>
<td>
<p>(<code>predictor values</code>)<br>
Default values for continuous variables.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Marginal predictions are obtained by calling, for each variable,
<code>marginaleffects::avg_predictions()</code> with the same variable being used for
the <code>variables</code> and the <code>by</code> argument.
</p>
<p>Considering a categorical variable named <code>cat</code>, <code>tidy_marginal_predictions()</code>
will call <code>avg_predictions(model, variables = list(cat = unique), by = "cat")</code>
to obtain average marginal predictions for this variable.
</p>
<p>Considering a continuous variable named <code>cont</code>, <code>tidy_marginal_predictions()</code>
will call <code>avg_predictions(model, variables = list(cont = "fivenum"), by = "cont")</code>
to obtain average marginal predictions for this variable at the minimum, the
first quartile, the median, the third quartile and the maximum of the observed
values of <code>cont</code>.
</p>
<p>By default, <em>average marginal predictions</em> are computed: predictions are made
using a counterfactual grid for each value of the variable of interest,
before averaging the results. <em>Marginal predictions at the mean</em> could be
obtained by indicating <code>newdata = "mean"</code>. Other assumptions are possible,
see the help file of <code>marginaleffects::avg_predictions()</code>.
</p>
<p><code>tidy_marginal_predictions()</code> will compute marginal predictions for each
variable or combination of variables, before stacking the results in a unique
tibble. This is why <code>tidy_marginal_predictions()</code> has a <code>variables_list</code>
argument consisting of a list of specifications that will be passed
sequentially to the <code>variables</code> argument of <code>marginaleffects::avg_predictions()</code>.
</p>
<p>The helper function <code>variables_to_predict()</code> could be used to automatically
generate a suitable list to be used with <code>variables_list</code>. By default, all
unique values are retained for categorical variables and <code>fivenum</code> (i.e.
Tukey's five numbers, minimum, quartiles and maximum) for continuous variables.
When <code>interactions = FALSE</code>, <code>variables_to_predict()</code> will return a list of
all individual variables used in the model. If <code>interactions = FALSE</code>, it
will search for higher order combinations of variables (see
<code>model_list_higher_order_variables()</code>).
</p>
<p><code>variables_list</code>'s default value, <code>"auto"</code>, calls
<code>variables_to_predict(interactions = TRUE)</code> while <code>"no_interaction"</code> is a
shortcut for <code>variables_to_predict(interactions = FALSE)</code>.
</p>
<p>You can also provide custom specifications (see examples).
</p>
<p><code>plot_marginal_predictions()</code> works in a similar way and returns a list of
plots that could be combined with <code>patchwork::wrap_plots()</code> (see examples).
</p>
<p>For more information, see <code>vignette("marginal_tidiers", "broom.helpers")</code>.
</p>


<h3>See Also</h3>

<p><code>marginaleffects::avg_predictions()</code>
</p>
<p>Other marginal_tieders: 
<code>tidy_all_effects()</code>,
<code>tidy_avg_comparisons()</code>,
<code>tidy_avg_slopes()</code>,
<code>tidy_ggpredict()</code>,
<code>tidy_marginal_contrasts()</code>,
<code>tidy_marginal_means()</code>,
<code>tidy_margins()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Average Marginal Predictions
df &lt;- Titanic |&gt;
  dplyr::as_tibble() |&gt;
  tidyr::uncount(n) |&gt;
  dplyr::mutate(Survived = factor(Survived, c("No", "Yes")))
mod &lt;- glm(
  Survived ~ Class + Age + Sex,
  data = df, family = binomial
)
tidy_marginal_predictions(mod)
tidy_plus_plus(mod, tidy_fun = tidy_marginal_predictions)
if (require("patchwork")) {
  plot_marginal_predictions(mod) |&gt; patchwork::wrap_plots()
  plot_marginal_predictions(mod) |&gt;
    patchwork::wrap_plots() &amp;
    ggplot2::scale_y_continuous(limits = c(0, 1), label = scales::percent)
}

mod2 &lt;- lm(Petal.Length ~ poly(Petal.Width, 2) + Species, data = iris)
tidy_marginal_predictions(mod2)
if (require("patchwork")) {
  plot_marginal_predictions(mod2) |&gt; patchwork::wrap_plots()
}
tidy_marginal_predictions(
  mod2,
  variables_list = variables_to_predict(mod2, continuous = "threenum")
)
tidy_marginal_predictions(
  mod2,
  variables_list = list(
    list(Petal.Width = c(0, 1, 2, 3)),
    list(Species = unique)
  )
)
tidy_marginal_predictions(
  mod2,
  variables_list = list(list(Species = unique, Petal.Width = 1:3))
)

# Model with interactions
mod3 &lt;- glm(
  Survived ~ Sex * Age + Class,
  data = df, family = binomial
)
tidy_marginal_predictions(mod3)
tidy_marginal_predictions(mod3, "no_interaction")
if (require("patchwork")) {
  plot_marginal_predictions(mod3) |&gt;
    patchwork::wrap_plots()
  plot_marginal_predictions(mod3, "no_interaction") |&gt;
    patchwork::wrap_plots()
}
tidy_marginal_predictions(
  mod3,
  variables_list = list(
    list(Class = unique, Sex = "Female"),
    list(Age = unique)
  )
)

# Marginal Predictions at the Mean
tidy_marginal_predictions(mod, newdata = "mean")
if (require("patchwork")) {
  plot_marginal_predictions(mod, newdata = "mean") |&gt;
    patchwork::wrap_plots()
}

</code></pre>


</div>