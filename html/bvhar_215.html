<div class="container">

<table style="width: 100%;"><tr>
<td>bvhar_minnesota</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fitting Bayesian VHAR of Minnesota Prior</h2>

<h3>Description</h3>

<p>This function fits BVHAR with Minnesota prior.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bvhar_minnesota(
  y,
  har = c(5, 22),
  num_chains = 1,
  num_iter = 1000,
  num_burn = floor(num_iter/2),
  thinning = 1,
  bayes_spec = set_bvhar(),
  scale_variance = 0.05,
  include_mean = TRUE,
  parallel = list(),
  verbose = FALSE,
  num_thread = 1
)

## S3 method for class 'bvharmn'
print(x, digits = max(3L, getOption("digits") - 3L), ...)

## S3 method for class 'bvharhm'
print(x, digits = max(3L, getOption("digits") - 3L), ...)

## S3 method for class 'bvharmn'
logLik(object, ...)

## S3 method for class 'bvharmn'
AIC(object, ...)

## S3 method for class 'bvharmn'
BIC(object, ...)

is.bvharmn(x)

## S3 method for class 'bvharmn'
knit_print(x, ...)

## S3 method for class 'bvharhm'
knit_print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Time series data of which columns indicate the variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>har</code></td>
<td>
<p>Numeric vector for weekly and monthly order. By default, <code>c(5, 22)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_chains</code></td>
<td>
<p>Number of MCMC chains</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_iter</code></td>
<td>
<p>MCMC iteration number</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_burn</code></td>
<td>
<p>Number of burn-in (warm-up). Half of the iteration is the default choice.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thinning</code></td>
<td>
<p>Thinning every thinning-th iteration</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bayes_spec</code></td>
<td>
<p>A BVHAR model specification by <code>set_bvhar()</code> (default) or <code>set_weight_bvhar()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale_variance</code></td>
<td>
<p>Proposal distribution scaling constant to adjust an acceptance rate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include_mean</code></td>
<td>
<p>Add constant term (Default: <code>TRUE</code>) or not (<code>FALSE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>List the same argument of <code>optimParallel::optimParallel()</code>. By default, this is empty, and the function does not execute parallel computation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Print the progress bar in the console. By default, <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_thread</code></td>
<td>
<p>Number of threads</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code>bvharhm</code> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>digit option to print</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>not used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A <code>bvharmn</code> object</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Apply Minnesota prior to Vector HAR: <code class="reqn">\Phi</code> (VHAR matrices) and <code class="reqn">\Sigma_e</code> (residual covariance).
</p>
<p style="text-align: center;"><code class="reqn">\Phi \mid \Sigma_e \sim MN(M_0, \Omega_0, \Sigma_e)</code>
</p>

<p style="text-align: center;"><code class="reqn">\Sigma_e \sim IW(\Psi_0, \nu_0)</code>
</p>

<p>(MN: <a href="https://en.wikipedia.org/wiki/Matrix_normal_distribution">matrix normal</a>, IW: <a href="https://en.wikipedia.org/wiki/Inverse-Wishart_distribution">inverse-wishart</a>)
</p>
<p>There are two types of Minnesota priors for BVHAR:
</p>

<ul>
<li>
<p> VAR-type Minnesota prior specified by <code>set_bvhar()</code>, so-called BVHAR-S model.
</p>
</li>
<li>
<p> VHAR-type Minnesota prior specified by <code>set_weight_bvhar()</code>, so-called BVHAR-L model.
</p>
</li>
</ul>
<h3>Value</h3>

<p><code>bvhar_minnesota()</code> returns an object <code>bvharmn</code> class.
It is a list with the following components:
</p>

<dl>
<dt>coefficients</dt>
<dd>
<p>Posterior Mean</p>
</dd>
<dt>fitted.values</dt>
<dd>
<p>Fitted values</p>
</dd>
<dt>residuals</dt>
<dd>
<p>Residuals</p>
</dd>
<dt>mn_mean</dt>
<dd>
<p>Posterior mean matrix of Matrix Normal distribution</p>
</dd>
<dt>mn_prec</dt>
<dd>
<p>Posterior precision matrix of Matrix Normal distribution</p>
</dd>
<dt>iw_scale</dt>
<dd>
<p>Posterior scale matrix of posterior inverse-wishart distribution</p>
</dd>
<dt>iw_shape</dt>
<dd>
<p>Posterior shape of inverse-Wishart distribution (<code class="reqn">\nu_0</code> - obs + 2). <code class="reqn">\nu_0</code>: nrow(Dummy observation) - k</p>
</dd>
<dt>df</dt>
<dd>
<p>Numer of Coefficients: 3m + 1 or 3m</p>
</dd>
<dt>m</dt>
<dd>
<p>Dimension of the time series</p>
</dd>
<dt>obs</dt>
<dd>
<p>Sample size used when training = <code>totobs</code> - 22</p>
</dd>
<dt>prior_mean</dt>
<dd>
<p>Prior mean matrix of Matrix Normal distribution: <code class="reqn">M_0</code></p>
</dd>
<dt>prior_precision</dt>
<dd>
<p>Prior precision matrix of Matrix Normal distribution: <code class="reqn">\Omega_0^{-1}</code></p>
</dd>
<dt>prior_scale</dt>
<dd>
<p>Prior scale matrix of inverse-Wishart distribution: <code class="reqn">\Psi_0</code></p>
</dd>
<dt>prior_shape</dt>
<dd>
<p>Prior shape of inverse-Wishart distribution: <code class="reqn">\nu_0</code></p>
</dd>
<dt>y0</dt>
<dd>
<p><code class="reqn">Y_0</code></p>
</dd>
<dt>design</dt>
<dd>
<p><code class="reqn">X_0</code></p>
</dd>
<dt>p</dt>
<dd>
<p>3, this element exists to run the other functions</p>
</dd>
<dt>week</dt>
<dd>
<p>Order for weekly term</p>
</dd>
<dt>month</dt>
<dd>
<p>Order for monthly term</p>
</dd>
<dt>totobs</dt>
<dd>
<p>Total number of the observation</p>
</dd>
<dt>type</dt>
<dd>
<p>include constant term (<code>const</code>) or not (<code>none</code>)</p>
</dd>
<dt>HARtrans</dt>
<dd>
<p>VHAR linear transformation matrix: <code class="reqn">C_{HAR}</code></p>
</dd>
<dt>y</dt>
<dd>
<p>Raw input (<code>matrix</code>)</p>
</dd>
<dt>call</dt>
<dd>
<p>Matched call</p>
</dd>
<dt>process</dt>
<dd>
<p>Process string in the <code>bayes_spec</code>: <code>BVHAR_MN_VAR</code> (BVHAR-S) or <code>BVHAR_MN_VHAR</code> (BVHAR-L)</p>
</dd>
<dt>spec</dt>
<dd>
<p>Model specification (<code>bvharspec</code>)</p>
</dd>
</dl>
<p>It is also <code>normaliw</code> and <code>bvharmod</code> class.
</p>


<h3>References</h3>

<p>Kim, Y. G., and Baek, C. (2024). <em>Bayesian vector heterogeneous autoregressive modeling</em>. Journal of Statistical Computation and Simulation, 94(6), 1139-1157.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code>set_bvhar()</code> to specify the hyperparameters of BVHAR-S
</p>
</li>
<li> <p><code>set_weight_bvhar()</code> to specify the hyperparameters of BVHAR-L
</p>
</li>
<li> <p><code>summary.normaliw()</code> to summarize BVHAR model
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R"># Perform the function using etf_vix dataset
fit &lt;- bvhar_minnesota(y = etf_vix[,1:3])
class(fit)

# Extract coef, fitted values, and residuals
coef(fit)
head(residuals(fit))
head(fitted(fit))
</code></pre>


</div>