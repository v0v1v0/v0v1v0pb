<div class="container">

<table style="width: 100%;"><tr>
<td>mig.diagnose</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>MCMC convergence diagnostics</h2>

<h3>Description</h3>

<p>Runs convergence diagnostics of existing migration Markov chains 
using the <code>raftery.diag</code> function from the <code>coda</code> package.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mig.diagnose(
  sim.dir,
  thin = 80,
  burnin = 2000,
  express = FALSE,
  country.sampling.prop = NULL,
  keep.thin.mcmc = FALSE,
  verbose = TRUE
)

mig.raftery.diag(
  mcmc = NULL,
  sim.dir = NULL,
  burnin = 0,
  country = NULL,
  par.names = NULL,
  par.names.cs = NULL,
  country.sampling.prop = 1,
  verbose = TRUE,
  ...
)

estimate.a.hw(mcmc, burnin = 0, thin = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sim.dir</code></td>
<td>
<p>Directory with MCMC simulation results.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>Thinning interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>Number of iterations to discard from the beginning of the parameter traces.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>express</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the convergence diagnostic is run only on the country-independent
parameters. If <code>FALSE</code>, the country-specific parameters are included in the diagnostics. The number of
countries can be controlled by <code>country.sampling.prop</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>country.sampling.prop</code></td>
<td>
<p>Proportion of countries to include in the diagnostics. If it is <code>NULL</code> and
<code>express=FALSE</code>, all countries are included. Setting a number between 0 and 1 will determine the proportion of countries
to be randomly sampled. For long Markov chains, this argument may significantly influence the runtime of this function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.thin.mcmc</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the thinned traces used for computing the diagnostics are stored on disk.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical value. Switches log messages on and off.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mcmc</code></td>
<td>
<p>A <code>bayesMig.mcmc</code> or <code>bayesMig.mcmc.set</code> object. 
If not given, the object is loaded from the simulation directory given by 
<code>sim.dir</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>country</code></td>
<td>
<p>Name or code of a country. If it is given, only country-specific 
parameters parameters of that country are considered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par.names</code></td>
<td>
<p>Names of country-independent parameters for which the Raftery 
diagnostics should be computed. By default all parameters are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par.names.cs</code></td>
<td>
<p>Names of country-specific parameters for which the Raftery 
diagnostics should be computed. By default all parameters are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed to the <code>mig.coda.list.mcmc</code> function.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>mig.diagnose</code> function invokes the <code>mig.raftery.diag</code> 
function separately for country-independent parameters and for country-specific 
parameters. It results in two possible states: red, i.e. it did not converge, and green, 
i.e. it converged. The resulting object is stored in 
‘<span class="file">{sim.dir}/diagnostics/bayesMig.convergence_{thin}_{burnin}.rda</span>’ 
and can be accessed using the function <code>get.mig.convergence</code>.
</p>
<p>Function <code>has.mcmc.converged</code> from the <span class="pkg">bayesTFR</span> package 
can be used to check if the existing diagnostics converged.
</p>
<p>For details on the <code>mig.raftery.diag</code> function, see <code>tfr.raftery.diag</code>.
</p>
<p>The <code>estimate.a.hw</code> function estimates an optimal value for the <code>a.half.width</code>
argument in <code>run.mig.mcmc</code>.
</p>


<h3>Value</h3>

<p><code>mig.diagnose</code> returns an object of class <code>bayesMig.convergence</code> 
containing summaries of the convergence check inputs and outputs. It has the 
same structure as <code>bayesTFR.convergence</code>. 
In addition it has an element <code>a.hw.est</code> which is the estimated value for 
the <code>a.half.width</code> argument in <code>run.mig.mcmc</code>.
</p>


<h3>See Also</h3>

<p><code>tfr.raftery.diag</code>, <code>raftery.diag</code>, <code>get.mig.convergence</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># See examples in ?bayesMig and ?get.mig.convergence

</code></pre>


</div>