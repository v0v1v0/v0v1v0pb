<div class="container">

<table style="width: 100%;"><tr>
<td>community.tree</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Reconstruction of the Girvan-Newman Community Tree for a CNA Class Object.  </h2>

<h3>Description</h3>

<p>This function reconstructs the community tree of the community
clustering analysis performed by the ‘cna’ function. 
It allows the user to explore different network community partitions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  community.tree(x, rescale=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>  A protein network graph object as obtained from the
‘cna’ function. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rescale</code></td>
<td>
<p> Logical, indicating whether to rescale the community
names starting from 1. If FALSE, the community names will start from
N+1, where N is the number of nodes. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The input of this function should be a ‘cna’ class object
containing ‘network’ and ‘communities’ attributes.
</p>
<p>This function reconstructs the community residue memberships for each
modularity value. The purpose is to facilitate inspection of alternate 
community partitioning points, which in practice often corresponds to a value 
close to the maximum of the modularity, but not the maximum value itself.
</p>


<h3>Value</h3>

<p>Returns a list object that includes the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>modularity</code></td>
<td>
<p> A numeric vector containing the modularity values. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tree</code></td>
<td>
<p> A numeric matrix containing in each row the
community residue memberships corresponding to a modularity
value. The rows are ordered according to the ‘modularity’ object. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.of.comms</code></td>
<td>
<p> A numeric vector containing the number of
communities per modularity value. The vector elements are ordered according
to the ‘modularity’ object. </p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p> Guido Scarabelli </p>


<h3>See Also</h3>

<p><code>cna</code>, <code>network.amendment</code>, <code>summary.cna</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# PDB server connection required - testing excluded

if (!requireNamespace("igraph", quietly = TRUE)) {
   message('Need igraph installed to run this example')
} else {

###-- Build a CNA object
pdb &lt;- read.pdb("4Q21")
modes &lt;- nma(pdb)
cij &lt;- dccm(modes)
net &lt;- cna(cij, cutoff.cij=0.2)


##-- Reconstruct the community membership vector for each clustering step.
tree &lt;- community.tree(net, rescale=TRUE)

## Plot modularity vs number of communities
plot( tree$num.of.comms, tree$modularity )

## Inspect the maximum modularity value partitioning
max.mod.ind &lt;- which.max(tree$modularity)

## Number of communities (k) at max modularity
tree$num.of.comms[ max.mod.ind ]

## Membership vector at this partition point 
tree$tree[max.mod.ind,]

# Should be the same as that contained in the original CNA network object
net$communities$membership == tree$tree[max.mod.ind,]

# Inspect a new membership partitioning (at k=7)
memb.k7 &lt;- tree$tree[ tree$num.of.comms == 7, ]

## Produce a new k=7 community network  
net.7 &lt;- network.amendment(net, memb.k7)
plot(net.7, pdb)
#view.cna(net.7, trim.pdb(pdb, atom.select(pdb,"calpha")), launch=TRUE )

}

</code></pre>


</div>