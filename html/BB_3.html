<div class="container">

<table style="width: 100%;"><tr>
<td>BBoptim</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Large=Scale Nonlinear Optimization - A Wrapper for spg()</h2>

<h3>Description</h3>

<p>A strategy using different Barzilai-Borwein steplengths to 
optimize a nonlinear objective function subject to box constraints.</p>


<h3>Usage</h3>

<pre><code class="language-R">  BBoptim(par, fn, gr=NULL, method=c(2,3,1), lower=-Inf, upper=Inf, 
  	project=NULL, projectArgs=NULL,
	control=list(), quiet=FALSE, ...) 
  </code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p>A real vector argument to <code>fn</code>, indicating the initial 
guess for the root of the nonliinear system of equations <code>fn</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fn</code></td>
<td>
<p>Nonlinear objective function that is to be optimized.  A scalar 
function that takes a real vector as argument and returns a scalar 
that is the value of the function at that point (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gr</code></td>
<td>
<p>The gradient of the objective function <code>fn</code> evaluated at the 
argument.  This is a vector-function that takes a real vector as argument 
and returns a real vector of the same length.  It defaults to 
<code>NULL</code>, which means that gradient is evaluated numerically.
Computations are dramatically faster in high-dimensional problems when 
the exact gradient is provided.  See *Example*.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>A vector of integers specifying which Barzilai-Borwein 
steplengths should be used in a consecutive manner.  The methods will 
be used in the order specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p>An upper bound for box constraints. See <code>spg</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>An lower bound for box constraints. See <code>spg</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>project</code></td>
<td>
<p>The projection function that takes a point in $R^n$ and 
projects it onto a region that defines the constraints of the problem.
This is a vector-function that takes a real vector as argument and 
returns a real vector of the same length. 
See <code>spg</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>projectArgs</code></td>
<td>
<p>list of arguments to <code>project</code>. See <code>spg()</code> 
for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>A list of parameters governing the algorithm behaviour.  
This list is the same as that for <code>spg</code> (excepting 
the default for <code>trace</code>).  See <code>details</code> for 
important special features of control parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quiet</code></td>
<td>
<p>logical indicating if messages about convergence success or
failure should be suppressed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed fn (via the optimization algorithm).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This wrapper is especially useful in problems where (<code>spg</code> is likely 
to experience convergence difficulties.  When <code>spg()</code> fails, i.e. 
when <code>convergence &gt; 0</code> is obtained, a user might attempt various strategies
to find a local optimizer. The function <code>BBoptim</code> tries the following 
sequential strategy:
</p>

<ol>
<li>
<p> Try a different BB steplength.  Since the default is <code>method = 2</code> 
for <code>dfsane</code>, BBoptim wrapper tries <code>method = c(2, 3, 1)</code>.
</p>
</li>
<li>
<p> Try a different non-monotonicity parameter <code>M</code> for each method, 
i.e. BBoptim wrapper tries <code>M = c(50, 10)</code> for each BB steplength.
</p>
</li>
</ol>
<p>The argument <code>control</code> defaults to a list with values 
<code>maxit = 1500, M = c(50, 10), ftol=1.e-10, gtol = 1e-05, maxfeval = 10000, 
  maximize = FALSE, trace = FALSE, triter = 10, eps = 1e-07, checkGrad=NULL</code>.  
It is recommended that <code>checkGrad</code> be set to FALSE for high-dimensional 
problems, after making sure that the gradient is correctly specified. See 
<code>spg</code> for additional details about the default.
</p>
<p>If <code>control</code> is specified as an argument, only values which are different
need to be given in the list. See <code>spg</code> for more details.
</p>


<h3>Value</h3>

<p>A list with the same elements as returned by <code>spg</code>.  One additional 
element returned is <code>cpar</code> which contains the control parameter settings
used to obtain successful convergence, or to obtain the best solution in 
case of failure.</p>


<h3>References</h3>

 
<p>R Varadhan and PD Gilbert (2009),  BB: An R Package for Solving a Large 
System of Nonlinear Equations and for Optimizing a High-Dimensional 
Nonlinear Objective Function, <em>J. Statistical Software</em>, 32:4, 
<a href="http://www.jstatsoft.org/v32/i04/">http://www.jstatsoft.org/v32/i04/</a>
</p>


<h3>See Also</h3>

<p><code>BBsolve</code>,
<code>spg</code>,
<code>multiStart</code>
<code>optim</code>
<code>grad</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Use a preset seed so test values are reproducable. 
require("setRNG")
old.seed &lt;- setRNG(list(kind="Mersenne-Twister", normal.kind="Inversion",
    seed=1234))

rosbkext &lt;- function(x){
# Extended Rosenbrock function
n &lt;- length(x)
j &lt;- 2 * (1:(n/2))
jm1 &lt;- j - 1
sum(100 * (x[j] - x[jm1]^2)^2 + (1 - x[jm1])^2)
}

p0 &lt;- rnorm(50)
spg(par=p0, fn=rosbkext)
BBoptim(par=p0, fn=rosbkext)

# compare the improvement in convergence when bounds are specified
BBoptim(par=p0, fn=rosbkext, lower=0) 

# identical to spg() with defaults
BBoptim(par=p0, fn=rosbkext, method=3, control=list(M=10, trace=TRUE))  
</code></pre>


</div>