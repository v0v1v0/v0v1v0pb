<div class="container">

<table style="width: 100%;"><tr>
<td>bcrypt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bcrypt password hashing</h2>

<h3>Description</h3>

<p>Bcrypt is used for secure password hashing. The main difference with
regular digest algorithms such as MD5 or SHA256 is that the bcrypt
algorithm is specifically designed to be CPU intensive in order to
protect against brute force attacks. The exact complexity of the
algorithm is configurable via the <code>log_rounds</code> parameter. The
interface is fully compatible with the Python one.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gensalt(log_rounds = 12, iv = openssl::rand_bytes(16))

hashpw(password, salt = gensalt())

checkpw(password, hash)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>log_rounds</code></td>
<td>
<p>integer between 4 and 31 that defines the complexity of
the hashing, increasing the cost as <code>2^log_rounds</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iv</code></td>
<td>
<p>init vector to randomize the salt</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>password</code></td>
<td>
<p>the message (password) to encrypt</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>salt</code></td>
<td>
<p>a salt generated with <code>gensalt</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hash</code></td>
<td>
<p>the previously generated bcrypt hash to verify</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>hashpw</code> function calculates a hash from a password using
a random salt. Validating the hash is done by rehashing the password
using the hash as a salt. The <code>checkpw</code> function is a simple
wrapper that does exactly this.
</p>
<p><code>gensalt</code> generates a random text salt for use with <code>hashpw</code>.
The first few characters in the salt string hold the bcrypt version number
and value for <code>log_rounds</code>. The remainder stores 16 bytes of base64
encoded randomness for seeding the hashing algorithm.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Secret message as a string
passwd &lt;- "supersecret"

# Create the hash
hash &lt;- hashpw(passwd)
hash

# To validate the hash
identical(hash, hashpw(passwd, hash))

# Or use the wrapper
checkpw(passwd, hash)

# Use varying complexity:
hash11 &lt;- hashpw(passwd, gensalt(11))
hash12 &lt;- hashpw(passwd, gensalt(12))
hash13 &lt;- hashpw(passwd, gensalt(13))

# Takes longer to verify (or crack)
system.time(checkpw(passwd, hash11))
system.time(checkpw(passwd, hash12))
system.time(checkpw(passwd, hash13))
</code></pre>


</div>