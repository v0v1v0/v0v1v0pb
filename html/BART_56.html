<div class="container">

<table style="width: 100%;"><tr>
<td>rs.pbart</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>BART for dichotomous outcomes with parallel computation and
stratified random sampling</h2>

<h3>Description</h3>

<p>BART is a Bayesian “sum-of-trees” model.<br>
For numeric response <code class="reqn">y</code>, we have
<code class="reqn">y = f(x) + \epsilon</code>,
where <code class="reqn">\epsilon \sim N(0,\sigma^2)</code>.<br>
For a binary response <code class="reqn">y</code>, <code class="reqn">P(Y=1 | x) = F(f(x))</code>, where <code class="reqn">F</code>
denotes the standard normal cdf (probit link).
</p>
<p>In both cases, <code class="reqn">f</code> is the sum of many tree models.
The goal is to have very flexible inference for the uknown
function <code class="reqn">f</code>.
</p>
<p>In the spirit of “ensemble models”,
each tree is constrained by a prior to be a weak learner
so that it contributes a
small amount to the overall fit.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rs.pbart(
   x.train, y.train, x.test=matrix(0.0,0,0),
   C=floor(length(y.train)/2000),
   k=2.0, power=2.0, base=.95,
   binaryOffset=0,
   ntree=50L, numcut=100L,
   ndpost=1000L, nskip=100L,
   keepevery=1L, printevery=100,
   keeptrainfits=FALSE, transposed=FALSE,
   
   mc.cores = 2L, nice = 19L,
   seed = 99L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x.train</code></td>
<td>

<p>Explanatory variables for training (in sample) data.<br>
May be a matrix or a data frame,
with (as usual) rows corresponding to observations and columns to variables.<br>
If a variable is a factor in a data frame, it is replaced with dummies.
Note that q dummies are created if q&gt;2 and
one dummy is created if q=2, where q is the number of levels of the factor.
<code>pbart</code> will generate draws of <code class="reqn">f(x)</code> for each <code class="reqn">x</code>
which is a row of x.train.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y.train</code></td>
<td>

<p>Dependent variable for training (in sample) data.<br>
If y is numeric a continous response model is fit (normal errors).<br>
If y is a factor (or just has values 0 and 1) then a binary response model
with a probit link is fit.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.test</code></td>
<td>

<p>Explanatory variables for test (out of sample) data.<br>
Should have same structure as x.train.<br><code>pbart</code> will generate draws of <code class="reqn">f(x)</code> for each <code class="reqn">x</code> which is a row of x.test.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>

<p>The number of shards to break the data into and analyze separately.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>

<p>For binary y,
k is the number of prior standard deviations <code class="reqn">f(x)</code> is away from +/-3.
In both cases, the bigger k is, the more conservative the fitting will be.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>power</code></td>
<td>

<p>Power parameter for tree prior.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>base</code></td>
<td>

<p>Base parameter for tree prior.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>binaryOffset</code></td>
<td>

<p>Used for binary <code class="reqn">y</code>.<br>
The model is <code class="reqn">P(Y=1 | x) = F(f(x) + binaryOffset)</code>.<br>
The idea is that <code class="reqn">f</code> is shrunk towards 0, so the offset allows you to shrink towards
a probability other than .5.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ntree</code></td>
<td>

<p>The number of trees in the sum.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numcut</code></td>
<td>

<p>The number of possible values of c (see usequants).
If a single number if given, this is used for all variables.
Otherwise a vector with length equal to ncol(x.train) is required,
where the <code class="reqn">i^{th}</code> element gives the number of c used for
the <code class="reqn">i^{th}</code> variable in x.train.
If usequants is false, numcut equally spaced cutoffs
are used covering the range of values in the corresponding
column of x.train.  If usequants is true, then  min(numcut, the number of unique values in the
corresponding columns of x.train - 1) c values are used.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ndpost</code></td>
<td>

<p>The number of posterior draws returned.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nskip</code></td>
<td>

<p>Number of MCMC iterations to be treated as burn in.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keepevery</code></td>
<td>

<p>Every keepevery draw is kept to be returned to the user.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>printevery</code></td>
<td>

<p>As the MCMC runs, a message is printed every printevery draws.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keeptrainfits</code></td>
<td>

<p>Whether to keep <code>yhat.train</code> or not.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transposed</code></td>
<td>

<p>When running <code>pbart</code> in parallel, it is more memory-efficient
to transpose <code>x.train</code> and <code>x.test</code>, if any, prior to
calling <code>mc.pbart</code>.
</p>
</td>
</tr>
</table>
<table>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>

<p>Setting the seed required for reproducible MCMC.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mc.cores</code></td>
<td>

<p>Number of cores to employ in parallel.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nice</code></td>
<td>

<p>Set the job niceness.  The default
niceness is 19: niceness goes from 0 (highest) to 19 (lowest).
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>BART is an Bayesian MCMC method.
At each MCMC interation, we produce a draw from the joint posterior
<code class="reqn">(f,\sigma) | (x,y)</code> in the numeric <code class="reqn">y</code> case
and just <code class="reqn">f</code> in the binary <code class="reqn">y</code> case.
</p>
<p>Thus, unlike a lot of other modelling methods in R, we do not produce a single model object
from which fits and summaries may be extracted.  The output consists of values
<code class="reqn">f^*(x)</code> (and <code class="reqn">\sigma^*</code> in the numeric case) where * denotes a particular draw.
The <code class="reqn">x</code> is either a row from the training data (x.train) or the test data (x.test).
</p>


<h3>Value</h3>

<p><code>rs.pbart</code> returns an object of type <code>pbart</code> which is
essentially a list. 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>yhat.shard</code></td>
<td>

<p>Estimates generated from the individual shards rather than from the
whole.  This object is only useful for assessing convergence.
</p>
<p>A matrix with ndpost rows and nrow(x.train) columns.
Each row corresponds to a draw <code class="reqn">f^*</code> from the posterior of <code class="reqn">f</code>
and each column corresponds to a row of x.train.
The <code class="reqn">(i,j)</code> value is <code class="reqn">f^*(x)</code> for the <code class="reqn">i^{th}</code> kept draw of <code class="reqn">f</code>
and the <code class="reqn">j^{th}</code> row of x.train.<br>
Burn-in is dropped.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yhat.train</code></td>
<td>

<p>Estimates generated from the whole if <code>keeptrainfits=TRUE</code>.
</p>
<p>A matrix with ndpost rows and nrow(x.train) columns.
Each row corresponds to a draw <code class="reqn">f^*</code> from the posterior of <code class="reqn">f</code>
and each column corresponds to a row of x.train.
The <code class="reqn">(i,j)</code> value is <code class="reqn">f^*(x)</code> for the <code class="reqn">i^{th}</code> kept draw of <code class="reqn">f</code>
and the <code class="reqn">j^{th}</code> row of x.train.<br>
Burn-in is dropped.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yhat.test</code></td>
<td>

<p>Estimates generated from the whole if <code>x.test</code> is provided.
</p>
<p>Same as yhat.train but now the x's are the rows of the test data.</p>
</td>
</tr>
</table>
<table><tr style="vertical-align: top;">
<td><code>varcount</code></td>
<td>
<p>a matrix with ndpost rows and nrow(x.train) columns.
Each row is for a draw. For each variable (corresponding to the columns),
the total count of the number of times
that variable is used in a tree decision rule (over all trees) is given.</p>
</td>
</tr></table>
<p>In addition the list
has a binaryOffset component giving the value used.
</p>
<p>Note that in the binary <code class="reqn">y</code>, case yhat.train and yhat.test are
<code class="reqn">f(x)</code> + binaryOffset.  If you want draws of the probability
<code class="reqn">P(Y=1 | x)</code> you need to apply the normal cdf (<code>pnorm</code>)
to these values.
</p>


<h3>See Also</h3>

<p><code>mc.pbart</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
##simulate from Friedman's five-dimensional test function
##Friedman JH. Multivariate adaptive regression splines
##(with discussion and a rejoinder by the author).
##Annals of Statistics 1991; 19:1-67.

f = function(x) #only the first 5 matter
    sin(pi*x[ , 1]*x[ , 2]) + 2*(x[ , 3]-.5)^2+x[ , 4]+0.5*x[ , 5]-1.5

sigma = 1.0  #y = f(x) + sigma*z where z~N(0, 1)
k = 50       #number of covariates
thin = 25
ndpost = 2500
nskip = 100
C = 10
m = 10
n = 10000

set.seed(12)
x.train=matrix(runif(n*k), n, k)
Ey.train = f(x.train)
y.train=(Ey.train+sigma*rnorm(n)&gt;0)*1
table(y.train)/n

x &lt;- x.train
x4 &lt;- seq(0, 1, length.out=m)

for(i in 1:m) {
    x[ , 4] &lt;- x4[i]

    if(i==1) x.test &lt;- x
    else x.test &lt;- rbind(x.test, x)
}

## parallel::mcparallel/mccollect do not exist on windows
if(.Platform$OS.type=='unix') {
##test BART with token run to ensure installation works
    post = rs.pbart(x.train, y.train, 
                C=C, mc.cores=4, keepevery=1,
                seed=99, ndpost=1, nskip=1)
}

## Not run: 
post = rs.pbart(x.train, y.train, x.test=x.test,
                C=C, mc.cores=8, keepevery=thin,
                seed=99, ndpost=ndpost, nskip=nskip)
str(post)

par(mfrow=c(2, 2))

M &lt;- nrow(post$yhat.test)
pred &lt;- matrix(nrow=M, ncol=10)

for(i in 1:m) {
    h &lt;- (i-1)*n+1:n
    pred[ , i] &lt;- apply(pnorm(post$yhat.test[ , h]), 1, mean)
}

pred &lt;- apply(pred, 2, mean)

plot(x4, qnorm(pred), xlab=expression(x[4]),
     ylab='partial dependence function', type='l')

i &lt;- floor(seq(1, n, length.out=10))
j &lt;- seq(-0.5, 0.4, length.out=10)
for(h in 1:10) {
    auto.corr &lt;- acf(post$yhat.shard[ , i[h]], plot=FALSE)
    if(h==1) {
        max.lag &lt;- max(auto.corr$lag[ , 1, 1])
        plot(1:max.lag+j[h], auto.corr$acf[1+(1:max.lag), 1, 1],
             type='h', xlim=c(0, max.lag+1), ylim=c(-1, 1),
             ylab='auto-correlation', xlab='lag')
    }
    else 
        lines(1:max.lag+j[h], auto.corr$acf[1+(1:max.lag), 1, 1],
              type='h', col=h)
}

for(j in 1:10) {
    if(j==1)
        plot(pnorm(post$yhat.shard[ , i[j]]),
             type='l', ylim=c(0, 1),
             sub=paste0('N:', n, ', k:', k),
             ylab=expression(Phi(f(x))), xlab='m')
    else
        lines(pnorm(post$yhat.shard[ , i[j]]),
              type='l', col=j)
}

geweke &lt;- gewekediag(post$yhat.shard)

j &lt;- -10^(log10(n)-1)
plot(geweke$z, pch='.', cex=2, ylab='z', xlab='i',
     sub=paste0('N:', n, ', k:', k),
     xlim=c(j, n), ylim=c(-5, 5))
lines(1:n, rep(-1.96, n), type='l', col=6)
lines(1:n, rep(+1.96, n), type='l', col=6)
lines(1:n, rep(-2.576, n), type='l', col=5)
lines(1:n, rep(+2.576, n), type='l', col=5)
lines(1:n, rep(-3.291, n), type='l', col=4)
lines(1:n, rep(+3.291, n), type='l', col=4)
lines(1:n, rep(-3.891, n), type='l', col=3)
lines(1:n, rep(+3.891, n), type='l', col=3)
lines(1:n, rep(-4.417, n), type='l', col=2)
lines(1:n, rep(+4.417, n), type='l', col=2)
text(c(1, 1), c(-1.96, 1.96), pos=2, cex=0.6, labels='0.95')
text(c(1, 1), c(-2.576, 2.576), pos=2, cex=0.6, labels='0.99')
text(c(1, 1), c(-3.291, 3.291), pos=2, cex=0.6, labels='0.999')
text(c(1, 1), c(-3.891, 3.891), pos=2, cex=0.6, labels='0.9999')
text(c(1, 1), c(-4.417, 4.417), pos=2, cex=0.6, labels='0.99999')

par(mfrow=c(1, 1))

##dev.copy2pdf(file='geweke.rs.pbart.pdf')

## End(Not run)
</code></pre>


</div>