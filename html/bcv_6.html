<div class="container">

<table style="width: 100%;"><tr>
<td>impute.svd</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Missing value imputation via the SVDImpute algorithm</h2>

<h3>Description</h3>

<p>Given a matrix with missing values, impute the missing entries using a
low-rank SVD approximation estimated by the EM algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">impute.svd(x, k = min(n, p), tol = max(n, p) * 1e-10, maxiter = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a matrix to impute the missing entries of.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>the rank of the SVD approximation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>the convergence tolerance for the EM algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>the maximum number of EM steps to take.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Impute the missing values of <code>x</code> as follows: First, initialize all
<code>NA</code> values to the column means, or <code>0</code> if all entries in the
column are missing.  Then, until convergence, compute the first <code>k</code>
terms of the SVD of the completed matrix.  Replace the previously missing
values with their approximations from the SVD, and compute the RSS between
the <em>non-missing</em> values and the SVD.
</p>
<p>Declare convergence if <code> abs(rss0 - rss1) / (.Machine$double.eps +
rss1) &lt; tol </code>, where <code>rss0</code> and <code>rss1</code> are the RSS values computed
from successive iterations.  Stop early after <code>maxiter</code> iterations and
issue a warning.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>the completed version of the matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rss</code></td>
<td>
<p>the sum of
squares between the SVD approximation and the non-missing values in
<code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>the number of EM iterations before algorithm
stopped.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Patrick O. Perry
</p>


<h3>References</h3>

<p>Troyanskaya, O., Cantor, M., Sherlock, G., Brown, P., Hastie,
T., Tibshirani, R., Botstein, D. and Altman, R.B. (2001).  Missing value
estimation methods for DNA microarrays.  <em>Bioinformatics</em> <b>17</b>(6),
520â€“525.
</p>


<h3>See Also</h3>

<p><code>cv.svd.wold</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
  # Generate a matrix with missing entries    
  n &lt;- 20
  p &lt;- 10
  u &lt;- rnorm( n )
  v &lt;- rnorm( p )
  xfull &lt;- u %*% rbind( v ) + rnorm( n*p )
  miss  &lt;- sample( seq_len( n*p ), n )
  x       &lt;- xfull
  x[miss] &lt;- NA
      
  # impute the missing entries with a rank-1 SVD approximation
  xhat &lt;- impute.svd( x, 1 )$x   
  
  # compute the prediction error for the missing entries
  sum( ( xfull-xhat )^2 )

</code></pre>


</div>