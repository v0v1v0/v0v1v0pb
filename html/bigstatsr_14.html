<div class="container">

<table style="width: 100%;"><tr>
<td>big_colstats</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Standard univariate statistics</h2>

<h3>Description</h3>

<p>Standard <strong>univariate statistics</strong> for columns of a Filebacked Big Matrix.
For now, the <code>sum</code> and <code>var</code> are implemented
(the <code>mean</code> and <code>sd</code> can easily be deduced, see examples).
</p>


<h3>Usage</h3>

<pre><code class="language-R">big_colstats(X, ind.row = rows_along(X), ind.col = cols_along(X), ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>An object of class FBM.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ind.row</code></td>
<td>
<p>An optional vector of the row indices that are used.
If not specified, all rows are used. <strong>Don't use negative indices.</strong></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ind.col</code></td>
<td>
<p>An optional vector of the column indices that are used.
If not specified, all columns are used. <strong>Don't use negative indices.</strong></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>Number of cores used. Default doesn't use parallelism.
You may use nb_cores.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Data.frame of two numeric vectors <code>sum</code> and <code>var</code> with the
corresponding column statistics.
</p>


<h3>See Also</h3>

<p>colSums apply
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1)

X &lt;- big_attachExtdata()

# Check the results
str(test &lt;- big_colstats(X))

# Only with the first 100 rows
ind &lt;- 1:100
str(test2 &lt;- big_colstats(X, ind.row = ind))
plot(test$sum, test2$sum)
abline(lm(test2$sum ~ test$sum), col = "red", lwd = 2)

X.ind &lt;- X[ind, ]
all.equal(test2$sum, colSums(X.ind))
all.equal(test2$var, apply(X.ind, 2, var))

# deduce mean and sd
# note that the are also implemented in big_scale()
means &lt;- test2$sum / length(ind) # if using all rows,
                                 # divide by nrow(X) instead
all.equal(means, colMeans(X.ind))
sds &lt;- sqrt(test2$var)
all.equal(sds, apply(X.ind, 2, sd))
</code></pre>


</div>