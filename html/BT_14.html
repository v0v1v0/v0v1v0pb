<div class="container">

<table style="width: 100%;"><tr>
<td>predict.BTFit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Predict method for BT Model fits.</h2>

<h3>Description</h3>

<p>Predicted values based on a boosting tree model object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'BTFit'
predict(object, newdata, n.iter, type = "link", single.iter = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>a <code>BTFit</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>data frame of observations for which to make predictions. If missing or not a data frame, if <code>keep.data=TRUE</code> in the initial fit then the original training set will be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.iter</code></td>
<td>
<p>number of boosting iterations used for the prediction. This parameter can be a vector in which case predictions are returned for each iteration specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>the scale on which the BT makes the predictions. Can either be "link" or "response". Note that, by construction, a log-link function is used during the fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>single.iter</code></td>
<td>
<p>if <code>single.iter=TRUE</code> then <code>predict.BTFit</code> returns the predictions from the single tree <code>n.iter</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>not currently used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>predict.BTFit</code> produces a predicted values for each observation in <code>newdata</code> using the first <code>n.iter</code> boosting iterations.
If <code>n.iter</code> is a vector then the result is a matrix with each column corresponding to the <code>BT</code> predictions with <code>n.iter[1]</code> boosting iterations, <code>n.iter[2]</code> boosting
iterations, and so on.
</p>
<p>As for the fit, the predictions do not include any offset term.
In the Poisson case, please remind that a weighted approach is initially favored.
</p>


<h3>Value</h3>

<p>Returns a vector of predictions. By default, the predictions are on the score scale.
If <code>type = "response"</code>, then <code>BT</code> converts back to the same scale as the outcome. Note that, a log-link is supposed by construction.
</p>


<h3>Author(s)</h3>

<p>Gireg Willame <a href="mailto:gireg.willame@gmail.com">gireg.willame@gmail.com</a>
</p>
<p><em>This package is inspired by the <code>gbm3</code> package. For more details, see <a href="https://github.com/gbm-developers/gbm3/">https://github.com/gbm-developers/gbm3/</a></em>.
</p>


<h3>References</h3>

<p>M. Denuit, D. Hainaut and J. Trufin (2019). <strong>Effective Statistical Learning Methods for Actuaries |: GLMs and Extensions</strong>, <em>Springer Actuarial</em>.
</p>
<p>M. Denuit, D. Hainaut and J. Trufin (2019). <strong>Effective Statistical Learning Methods for Actuaries ||: Tree-Based Methods and Extensions</strong>, <em>Springer Actuarial</em>.
</p>
<p>M. Denuit, D. Hainaut and J. Trufin (2019). <strong>Effective Statistical Learning Methods for Actuaries |||: Neural Networks and Extensions</strong>, <em>Springer Actuarial</em>.
</p>
<p>M. Denuit, D. Hainaut and J. Trufin (2022). <strong>Response versus gradient boosting trees, GLMs and neural networks under Tweedie loss and log-link</strong>.
Accepted for publication in <em>Scandinavian Actuarial Journal</em>.
</p>
<p>M. Denuit, J. Huyghe and J. Trufin (2022). <strong>Boosting cost-complexity pruned trees on Tweedie responses: The ABT machine for insurance ratemaking</strong>.
Paper submitted for publication.
</p>
<p>M. Denuit, J. Trufin and T. Verdebout (2022). <strong>Boosting on the responses with Tweedie loss functions</strong>. Paper submitted for publication.
</p>


<h3>See Also</h3>

<p><code>BT</code>, <code>BTFit</code>.
</p>


</div>