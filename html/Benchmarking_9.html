<div class="container">

<table style="width: 100%;"><tr>
<td>dea.add</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Additive DEA model</h2>

<h3>Description</h3>

<p> Calculates additive efficiency as sum of input and
output slacks within different DEA models </p>


<h3>Usage</h3>

<pre><code class="language-R">
dea.add(X, Y, RTS="vrs", XREF=NULL, YREF=NULL, 
        FRONT.IDX=NULL, param=NULL, TRANSPOSE=FALSE, LP=FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Inputs of firms to be evaluated, a K x m matrix
of observations of K firms with m inputs (firm x input).  In case
<code>TRANSPOSE=TRUE</code> the input matrix is transposed to input x
firm. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>Outputs of firms to be evaluated, a K x n matrix
of observations of K firms with n outputs (firm x input).  In case
<code>TRANSPOSE=TRUE</code> the output matrix is transposed to output x
firm. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RTS</code></td>
<td>
<p> Text string or a number defining the underlying DEA
technology / returns to scale assumption.
</p>

<table>
<tr>
<td style="text-align: right;">
0 </td>
<td style="text-align: left;"> fdh </td>
<td style="text-align: left;"> Free disposability hull, no convexity assumption </td>
</tr>
<tr>
<td style="text-align: right;">
1 </td>
<td style="text-align: left;"> vrs </td>
<td style="text-align: left;"> Variable returns to scale, convexity and free disposability </td>
</tr>
<tr>
<td style="text-align: right;">
2 </td>
<td style="text-align: left;"> drs </td>
<td style="text-align: left;"> Decreasing returns to scale, convexity, down-scaling and free disposability </td>
</tr>
<tr>
<td style="text-align: right;">
3 </td>
<td style="text-align: left;"> crs </td>
<td style="text-align: left;"> Constant returns to scale, convexity and free disposability </td>
</tr>
<tr>
<td style="text-align: right;">
4 </td>
<td style="text-align: left;"> irs </td>
<td style="text-align: left;"> Increasing returns to scale, (up-scaling, but not down-scaling), convexity and free disposability </td>
</tr>
<tr>
<td style="text-align: right;">
5 </td>
<td style="text-align: left;"> add </td>
<td style="text-align: left;"> Additivity (scaling up and down, but only with integers), and free disposability
</td>
</tr>
</table>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>XREF</code></td>
<td>
<p>Inputs of the firms determining the technology, defaults
to <code>X</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>YREF</code></td>
<td>
<p>Outputs of the firms determining the technology, defaults
to <code>Y</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FRONT.IDX</code></td>
<td>
<p>Index for firms determining the technology</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param</code></td>
<td>
<p>Possible parameters. At the moment only used for
RTS="fdh+" to set low and high values for restrictions on lambda;
see the section details and examples for its use. Future versions
might also use <code>param</code> for other purposes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>TRANSPOSE</code></td>
<td>
<p>Input and output matrices are treated as firms
times goods matrices for the default value <code>TRANSPOSE=FALSE</code>
corresponding to the standard in R for statistical models.  When
<code>TRUE</code> data matrices are transposed to good times firms
matrices as is normally used in LP formulation of the problem.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LP</code></td>
<td>
<p>Only for debugging. If <code>LP=TRUE</code> then input and output
for the LP program are written to standard output for each unit.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p> The sum of the slacks is maximized in a LP formulation of
the DEA technology. The sum of the slacks can be seen as distance to
the frontier when you only move parallel to the axes of inputs and
outputs, i.e. not a usual Euclidean distance, but what is also known
as an L1 norm.
</p>
<p>Since it is the sum of slacks that is calculated, there is no
exogenous ORIENTATION in the problem. Rather, there is generally
both an input and an output direction in the slacks. The model
considers the input excess and output shortfall simultaneously and
finds a point on the frontier that is most distant to the point
being evaluated.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sum</code></td>
<td>
<p>Sum of all slacks for each firm,
<code>sum=sum(sx)+sum(sy)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>slack</code></td>
<td>
<p>A non-NULL vector of logical variables, <code>TRUE</code> if
there is slack for the corresponding firm, and <code>FALSE</code> if
the there is no slack, i.e. the sum of slacks is zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sx</code></td>
<td>
<p>A matrix of input slacks for each firm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sy</code></td>
<td>
<p>A matrix of output slack for each firm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The lambdas, i.e. the weights of the peers for each firm</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p> This is neither a Farrell nor a Shephard like efficiency.
</p>
<p>The value of the slacks depends on the scaling of the different
inputs and outputs.  Therefore the values are not independent of how
the input and output are measured.</p>


<h3>Author(s)</h3>

<p> Peter Bogetoft and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a></p>


<h3>Source</h3>

<p>Corresponds to Eqs. 4.34-4.38 in Cooper et al. (2007)
</p>


<h3>References</h3>

<p>Bogetoft and Otto; <em>Benchmarking with DEA, SFA, and R</em>; Springer
2011
</p>
<p>Cooper, Seiford, and Tone; <em>Data Envelopment Analysis: A
Comprehensive Text with Models, Applications, References and
DEA-Solver Software</em>; Second edition, Springer 2007
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- matrix(c(2,3,2,4,6,5,6,8),ncol=1)
y &lt;- matrix(c(1,3,2,3,5,2,3,5),ncol=1)
dea.plot.frontier(x,y,txt=1:dim(x)[1])

sb &lt;- dea.add(x,y,RTS="vrs")
data.frame("sx"=sb$sx,"sy"=sb$sy,"sum"=sb$sum,"slack"=sb$slack)
</code></pre>


</div>