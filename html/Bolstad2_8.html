<div class="container">

<table style="width: 100%;"><tr>
<td>credInt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate a credible interval from a numerically specified posterior CDF or
from a sample from the posterior</h2>

<h3>Description</h3>

<p>Calculates a lower, upper, or two-sided credible interval from the numerical
posterior CDF or from a sample from the posterior.
</p>


<h3>Usage</h3>

<pre><code class="language-R">credInt(theta, cdf = NULL, conf = 0.95, type = "twosided")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>either a sample from the posterior density or the values over
which the the posterior CDF is specified</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cdf</code></td>
<td>
<p>the values of the CDF, <code class="reqn">F(\theta) =
\int_{-\infty}^{\theta}f(t).df</code> where <code class="reqn">f(t)</code> is the PDF. This only needs
to be specified if a numerically specified posterior is being used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf</code></td>
<td>
<p>the desired 'confidence' level</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>the type of interval to return, 'lower' = one sided lower bound,
'two-sided' = two - sided, or 'upper' = one sided upper bound. It is
sufficient to use 'l','t' or 'u'</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function uses linear interpolation to calculate bounds for points that
may not be specified by CDF
</p>


<h3>Value</h3>

<p>a list containing the elements lower.bound, uppper.bound or both
depending on type
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## commands for calculating a numerical posterior CDF.
## In this example, the likelihood is proportional to
## \eqn{\theta^{3/2}\times \exp(-\theta/4)} and a N(6, 9) prior is used.
theta = seq(from = 0.001, to = 40, by = 0.001)
prior = dnorm(theta,6,3)
ppnLike = theta^1.5*exp(-theta/4)
ppnPost = prior*ppnLike
scaleFactor = sintegral(theta, ppnPost)$int
posterior = ppnPost/scaleFactor
cdf = sintegral(theta, posterior)$y
ci = credInt(theta, cdf)
par(mfrow=c(2,2))
plot(prior ~ theta, type = 'l',  main = 'Prior N(6, 9)')
plot(ppnLike ~ theta, type = 'l', main = 'Proportional likelihood')
plot(posterior ~ theta, type = 'l', main = 'Posterior')
abline(v=c(unlist(ci)))

## Use an inverse method to take a random sample of size 1000
## from the posterior
suppressWarnings({Finv = approxfun(cdf,theta)})
thetaSample = Finv(runif(1000))
ci = credInt(thetaSample)

</code></pre>


</div>