<div class="container">

<table style="width: 100%;"><tr>
<td>hef</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Hierarchical Exponential Family Model</h2>

<h3>Description</h3>

<p>Produces random samples from the posterior distribution of the parameters
of certain hierarchical exponential family models.
</p>


<h3>Usage</h3>

<pre><code class="language-R">hef(
  n = 1000,
  model = c("beta_binom", "gamma_pois"),
  data,
  ...,
  prior = "default",
  hpars = NULL,
  param = c("trans", "original"),
  init = NULL,
  nrep = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>An integer scalar.  The size of the posterior sample required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>A character string.  Abbreviated name for the
response-population distribution combination.
For a hierarchical normal model see <code>hanova1</code>
(hierarchical one-way analysis of variance (ANOVA)).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A numeric matrix.  The format depends on <code>model</code>.
See <strong>Details</strong>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Optional further arguments to be passed to
<code>ru</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>
<p>The log-prior for the parameters of the hyperprior
distribution.  If the user wishes to specify their own prior then
<code>prior</code> must be an object returned from a call to
<code>set_user_prior</code>.
Otherwise, <code>prior</code> is a character scalar giving the name of the
required in-built prior.
If <code>prior</code> is not supplied then a default prior is used.
See <strong>Details</strong>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hpars</code></td>
<td>
<p>A numeric vector.  Used to set parameters (if any) in
an in-built prior.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param</code></td>
<td>
<p>A character scalar.
If <code>param = "trans"</code> (the default) then the marginal posterior
of hyperparameter vector <code class="reqn">\phi</code> is reparameterized in a way
designed to improve the efficiency of sampling from this posterior.
If <code>param = "original"</code> the original parameterization is used.
The former tends to make the optimizations involved in the
ratio-of-uniforms algorithm more stable and to increase the probability
of acceptance, but at the expense of slower function evaluations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>A numeric vector of length 2.  Optional initial estimates
for the search for the mode of the posterior density of the
hyperparameter vector <code class="reqn">\phi</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrep</code></td>
<td>
<p>A numeric scalar.  If <code>nrep</code> is not <code>NULL</code> then
<code>nrep</code> gives the number of replications of the original dataset
simulated from the posterior predictive distribution.
Each replication is based on one of the samples from the posterior
distribution.  Therefore, <code>nrep</code> must not be greater than <code>n</code>.
In that event <code>nrep</code> is set equal to <code>n</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Conditional on population-specific parameter vectors
<code class="reqn">\theta</code>1, ..., <code class="reqn">\theta</code><code class="reqn">J</code>
the observed <em>response</em> data <code class="reqn">y</code>1, ..., <code class="reqn">y</code>J within each
population are modelled as random samples from a distribution in an
exponential family. The population parameters <code class="reqn">\theta</code>1, ...,
<code class="reqn">\theta</code><code class="reqn">J</code> are modelled as random samples from a common
<em>population distribution</em>, chosen to be conditionally conjugate
to the response distribution, with <em>hyperparameter</em> vector
<code class="reqn">\phi</code>.  Conditionally on
<code class="reqn">\theta</code>1, ..., <code class="reqn">\theta</code><code class="reqn">J</code>, <code class="reqn">y</code>1, ..., <code class="reqn">y</code><code class="reqn">J</code>
are independent of each other and are independent of <code class="reqn">\phi</code>.
A <em>hyperprior</em> is placed on <code class="reqn">\phi</code>.  The user can either
choose parameter values of a default hyperprior or specify their own
hyperprior using <code>set_user_prior</code>.
</p>
<p>The <code>ru</code> function in the <code>rust</code>
package is used to draw a random sample
from the marginal posterior of the hyperparameter vector <code class="reqn">\phi</code>.
Then, conditional on these values, population parameters are sampled
directly from the conditional posterior density of
<code class="reqn">\theta</code>1, ..., <code class="reqn">\theta</code><code class="reqn">J</code> given <code class="reqn">\phi</code> and the data.
</p>
<p>We outline each <code>model</code>, specify the format of the
<code>data</code>, give the default (log-)priors (up to an additive constant)
and detail the choices of ratio-of-uniforms parameterization
<code>param</code>.
</p>
<p><strong>Beta-binomial:</strong> For <code class="reqn">j = 1, ..., J</code>,
<code class="reqn">Yj | pj</code> are i.i.d binomial<code class="reqn">(nj, pj)</code>,
where <code class="reqn">pj</code> is the probability of success in group <code class="reqn">j</code>
and <code class="reqn">nj</code> is the number of trials in group <code class="reqn">j</code>.
<code class="reqn">pj</code> are i.i.d. beta<code class="reqn">(\alpha, \beta)</code>, so
and <code class="reqn">\phi = (\alpha, \beta)</code>.
<code>data</code> is a 2-column matrix: the numbers of successes in column 1
and the corresponding numbers of trials in column 2.
</p>
<p><em>Priors:</em>
</p>
<p><code>prior = "bda"</code> (the default):
<code class="reqn">log \pi(\alpha, \beta) = - 2.5 log(\alpha + \beta),
  \alpha &gt; 0, \beta &gt; 0.</code> [See Section 5.3 of Gelman et al. (2014).]
</p>
<p><code>prior = "gamma"</code>: independent gamma priors on <code class="reqn">\alpha</code>
and <code class="reqn">\beta</code>, i.e.
<code class="reqn">log \pi(\alpha, \beta) =
  (s1 - 1)log\alpha - r1 \alpha +
  (s2 - 1)log\beta - r2 \beta,  \alpha &gt; 0, \beta &gt; 0.</code>
where the respective shape (<code class="reqn">s1</code>, <code class="reqn">s2</code>) and rate
(<code class="reqn">r1</code>, <code class="reqn">r2</code>) parameters are specified using
<code>hpars</code> = <code class="reqn">(s1, r1, s2, r2)</code>.  The default setting is
<code>hpars = c(1, 0.01, 1, 0.01).</code>
</p>
<p><em>Parameterizations for sampling:</em>
</p>
<p><code>param = "original"</code> is (<code class="reqn">\alpha, \beta</code>),
<code>param = "trans"</code> (the default) is
<code class="reqn">\phi1 = logit(\alpha/(\alpha+\beta)) = log(\alpha/\beta),
  \phi2 = log(\alpha+\beta)</code>.
See Section 5.3 of Gelman et al. (2014).
</p>
<p><strong>Gamma-Poisson:</strong> For <code class="reqn">j = 1, ..., J</code>,
<code class="reqn">Yj | \lambda</code>j are i.i.d Poisson(<code class="reqn">e</code>j<code class="reqn">\lambda</code>j),
where
<code class="reqn">ej</code> is the <em>exposure</em> in group <code class="reqn">j</code>, based on the
total length of observation time and/or size of the population at
risk of the event of interest and <code class="reqn">\lambda</code>j is the mean number
of events per unit of exposure.
<code class="reqn">\lambda</code>j are i.i.d. gamma<code class="reqn">(\alpha, \beta)</code>, so
<code class="reqn">\phi = (\alpha, \beta)</code>.
<code>data</code> is a 2-column matrix: the counts <code class="reqn">yj</code> of the numbers of
events in column 1 and the corresponding exposures <code class="reqn">ej</code> in column 2.
</p>
<p><em>Priors:</em>
</p>
<p><code>prior = "gamma"</code> (the default): independent gamma priors
on <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>, i.e.
<code class="reqn">log \pi(\alpha, \beta) =
  (s1 - 1)log\alpha - r1 \alpha +
  (s2 - 1)log\beta - r2 \beta,  \alpha &gt; 0, \beta &gt; 0.</code>
where the respective shape (<code class="reqn">s1</code>, <code class="reqn">s2</code>) and rate
(<code class="reqn">r1</code>, <code class="reqn">r2</code>) parameters are specified using
<code>hpars</code> = <code class="reqn">(s1, r1, s2, r2)</code>.  The default setting is
<code>hpars = c(1, 0.01, 1, 0.01).</code>
</p>
<p><em>Parameterizations for sampling:</em>
</p>
<p><code>param = "original"</code> is (<code class="reqn">\alpha, \beta</code>),
<code>param = "trans"</code> (the default) is
<code class="reqn">\phi1 = log(\alpha/\beta), \phi2 = log(\beta).</code>
</p>


<h3>Value</h3>

<p>An object (list) of class <code>"hef"</code>, which has the same
structure as an object of class "ru" returned from <code>ru</code>.
In particular, the columns of the <code>n</code>-row matrix <code>sim_vals</code>
contain the simulated values of <code class="reqn">\phi</code>.
In addition this list contains the arguments <code>model</code>, <code>data</code>
and <code>prior</code> detailed above, an <code>n</code> by <code class="reqn">J</code> matrix
<code>theta_sim_vals</code>: column <code class="reqn">j</code> contains the simulated values of
<code class="reqn">\theta</code><code class="reqn">j</code> and <code>call</code>: the matched call to <code>hef</code>.
</p>
<p>If <code>nrep</code> is not <code>NULL</code> then this list also contains
<code>data_rep</code>, a numerical matrix with <code>nrep</code> columns.
Each column contains a replication of the first column of the original
data <code>data[, 1]</code>, simulated from the posterior predictive
distribution.
</p>


<h3>References</h3>

<p>Gelman, A., Carlin, J. B., Stern, H. S. Dunson, D. B.,
Vehtari, A. and Rubin, D. B. (2014) <em>Bayesian Data Analysis</em>.
Chapman &amp; Hall / CRC.
<a href="http://www.stat.columbia.edu/~gelman/book/">http://www.stat.columbia.edu/~gelman/book/</a>
</p>


<h3>See Also</h3>

<p>The <code>ru</code> function in the <code>rust</code>
package for details of the arguments that can be passed to <code>ru</code> via
<code>hef</code>.
</p>
<p><code>hanova1</code> for hierarchical one-way analysis of
variance (ANOVA).
</p>
<p><code>set_user_prior</code> to set a user-defined prior.
</p>


<h3>Examples</h3>

<pre><code class="language-R">############################ Beta-binomial #################################

# ------------------------- Rat tumor data ------------------------------- #

# Default prior, sampling on (rotated) (log(mean), log(alpha + beta)) scale
rat_res &lt;- hef(model = "beta_binom", data = rat)

# Hyperparameters alpha and beta
plot(rat_res)
# Parameterization used for sampling
plot(rat_res, ru_scale = TRUE)

summary(rat_res)

# Choose rats with extreme sample probabilities
pops &lt;- c(which.min(rat[, 1] / rat[, 2]), which.max(rat[, 1] / rat[, 2]))
# Population-specific posterior samples: separate plots
plot(rat_res, params = "pop", plot_type = "both", which_pop = pops)
# Population-specific posterior samples: one plot
plot(rat_res, params = "pop", plot_type = "dens", which_pop = pops,
     one_plot = TRUE, add_legend = TRUE)

# Default prior, sampling on (rotated) (alpha, beta) scale
rat_res &lt;- hef(model = "beta_binom", data = rat, param = "original")

plot(rat_res)
plot(rat_res, ru_scale = TRUE)

summary(rat_res)

# To produce a plot akin to Figure 5.3 of Gelman et al. (2014) we
# (a) Use the same prior for (alpha, beta)
# (b) Don't use axis rotation (rotate = FALSE)
# (c) Plot on the scale used for ratio-of-uniforms sampling (ru_scale = TRUE)
# (d) Note that the mode is relocated to (0, 0) in the plot
rat_res &lt;- hef(model = "beta_binom", data = rat, rotate = FALSE)

plot(rat_res, ru_scale = TRUE)

# This is the estimated location of the posterior mode
rat_res$f_mode

# User-defined prior, passing parameters
# (equivalent to prior = "gamma" with hpars = c(1, 0.01, 1, 0.01))
user_prior &lt;- function(x, hpars) {
  return(dexp(x[1], hpars[1], log = TRUE) + dexp(x[2], hpars[2], log = TRUE))
}
user_prior_fn &lt;- set_user_prior(user_prior, hpars = c(0.01, 0.01))
rat_res &lt;- hef(model = "beta_binom", data = rat, prior = user_prior_fn)

plot(rat_res)

summary(rat_res)

############################ Gamma-Poisson #################################

# ------------------------ Pump failure data ------------------------------ #

pump_res &lt;- hef(model = "gamma_pois", data = pump)
# Hyperparameters alpha and beta

plot(pump_res)

# Parameterization used for sampling
plot(pump_res, ru_scale = TRUE)
summary(pump_res)

# Choose pumps with extreme sample rates
pops &lt;- c(which.min(pump[, 1] / pump[, 2]), which.max(pump[, 1] / pump[, 2]))
plot(pump_res, params = "pop", plot_type = "dens", which_pop = pops)
</code></pre>


</div>