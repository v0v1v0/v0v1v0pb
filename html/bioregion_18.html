<div class="container">

<table style="width: 100%;"><tr>
<td>netclu_labelprop</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Finding communities based on propagating labels</h2>

<h3>Description</h3>

<p>This function finds communities in a (un)weighted undirected network based
on propagating labels.
</p>


<h3>Usage</h3>

<pre><code class="language-R">netclu_labelprop(
  net,
  weight = TRUE,
  cut_weight = 0,
  index = names(net)[3],
  seed = NULL,
  bipartite = FALSE,
  site_col = 1,
  species_col = 2,
  return_node_type = "both",
  algorithm_in_output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>net</code></td>
<td>
<p>the output object from <code>similarity()</code> or
<code>dissimilarity_to_similarity()</code>. If a <code>data.frame</code> is used, the first two
columns represent pairs of sites (or any pair of nodes), and the next
column(s) are the similarity indices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight</code></td>
<td>
<p>a <code>boolean</code> indicating if the weights should be considered
if there are more than two columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cut_weight</code></td>
<td>
<p>a minimal weight value. If <code>weight</code> is TRUE, the links
between sites with a weight strictly lower than this value will not be
considered (O by default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p>name or number of the column to use as weight. By default,
the third column name of <code>net</code> is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>for the random number generator (NULL for random by default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bipartite</code></td>
<td>
<p>a <code>boolean</code> indicating if the network is bipartite
(see Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>site_col</code></td>
<td>
<p>name or number for the column of site nodes
(i.e. primary nodes).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>species_col</code></td>
<td>
<p>name or number for the column of species nodes
(i.e. feature nodes).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return_node_type</code></td>
<td>
<p>a <code>character</code> indicating what types of nodes
(<code>site</code>, <code>species</code> or <code>both</code>) should be returned in the output
(<code>return_node_type = "both"</code> by default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm_in_output</code></td>
<td>
<p>a <code>boolean</code> indicating if the original output
of cluster_label_prop should be returned in the
output (<code>TRUE</code> by default, see Value).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is based on propagating labels
(Raghavan et al. 2007) as implemented in the
<a href="https://cran.r-project.org/package=igraph">igraph</a>
package (cluster_label_prop).
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five slots:
</p>

<ol>
<li>
<p><strong>name</strong>: <code>character</code> containing the name of the algorithm
</p>
</li>
<li>
<p><strong>args</strong>: <code>list</code> of input arguments as provided by the user
</p>
</li>
<li>
<p><strong>inputs</strong>: <code>list</code> of characteristics of the clustering process
</p>
</li>
<li>
<p><strong>algorithm</strong>: <code>list</code> of all objects associated with the
clustering procedure, such as original cluster objects (only if
<code>algorithm_in_output = TRUE</code>)
</p>
</li>
<li>
<p><strong>clusters</strong>: <code>data.frame</code> containing the clustering results</p>
</li>
</ol>
<p>In the <code>algorithm</code> slot, if <code>algorithm_in_output = TRUE</code>, users can
find a "communities" object, output of
cluster_label_prop.
</p>


<h3>Note</h3>

<p>Although this algorithm was not primarily designed to deal with bipartite
network, it is possible to consider the bipartite network as unipartite
network (<code>bipartite = TRUE</code>).
</p>
<p>Do not forget to indicate which of the first two columns is
dedicated to the site nodes (i.e. primary nodes) and species nodes (i.e.
feature nodes) using the arguments <code>site_col</code> and <code>species_col</code>.
The type of nodes returned in the output can be chosen with the argument
<code>return_node_type</code> equal to <code>both</code> to keep both types of nodes,
<code>sites</code> to preserve only the sites nodes and <code>species</code> to
preserve only the species nodes.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>),
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) and
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>)
</p>


<h3>References</h3>

<p>Raghavan UN, Albert R, Kumara S (2007).
“Near linear time algorithm to detect community structures in large-scale networks.”
<em>Physical Review E</em>, <b>76</b>(3), 036106.
</p>


<h3>Examples</h3>

<pre><code class="language-R">comat &lt;- matrix(sample(1000, 50), 5, 10)
rownames(comat) &lt;- paste0("Site", 1:5)
colnames(comat) &lt;- paste0("Species", 1:10)

net &lt;- similarity(comat, metric = "Simpson")
com &lt;- netclu_labelprop(net)

net_bip &lt;- mat_to_net(comat, weight = TRUE)
clust2 &lt;- netclu_labelprop(net_bip, bipartite = TRUE)

</code></pre>


</div>