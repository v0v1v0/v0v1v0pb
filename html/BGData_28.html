<div class="container">

<table style="width: 100%;"><tr>
<td>multi-level-parallelism</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multi-Level Parallelism</h2>

<h3>Description</h3>

<p>Functions with the <code>nCores</code>, <code>i</code>, and <code>j</code> parameters provide
capabilities for both parallel and distributed computing.
</p>
<p>For parallel computing, <code>nCores</code> determines the number of cores the
code is run on. Memory usage can be an issue for higher values of
<code>nCores</code> as R is not particularly memory-efficient. As a rule of
thumb, at least around <code>(nCores * object_size(chunk)) +
    object_size(result)</code> MB of total memory will be needed for operations
on file-backed matrices, not including potential copies of your data that
might be created (for example <code>lsfit</code> runs <code>cbind(1, X)</code>).
<code>i</code> and <code>j</code> can be used to include or exclude certain rows or
columns. Internally, the <code>mclapply</code> function is used and therefore
parallel computing will not work on Windows machines.
</p>
<p>For distributed computing, <code>i</code> and <code>j</code> determine the subset of
the input matrix that the code runs on. In an HPC environment, this can be
used not just to include or exclude certain rows or columns, but also to
partition the task among many nodes rather than cores. Scheduler-specific
code and code to aggregate the results need to be written by the user. It
is recommended to set <code>nCores</code> to <code>1</code> as nodes are often cheaper
than cores.
</p>


<h3>See Also</h3>

<p><code>mclapply</code> to learn more about the function used to
implement parallel computing. <code>detectCores</code> to detect
the number of available cores.
</p>


</div>