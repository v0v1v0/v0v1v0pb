<div class="container">

<table style="width: 100%;"><tr>
<td>fraction</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Optimum treatment set from a candidate set of treatments</h2>

<h3>Description</h3>

<p>Finds an optimum set of treatments from a candidate set of treatments for any arbitrary 
treatments design formula.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fraction(
  treatments,
  size,
  treatments_model = NULL,
  restriction_model = NULL,
  searches = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>treatments</code></td>
<td>
<p>is a data frame or a list containing a candidate set of factorial treatments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size</code></td>
<td>
<p>is the required number of treatments in the fractional set of treatments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>treatments_model</code></td>
<td>
<p>is a model formula for the required treatments design.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>restriction_model</code></td>
<td>
<p>is a model formula which is a subset of the <code>treatments_model</code>
formula and which fixes those treatment factors contained in the restriction model formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>searches</code></td>
<td>
<p>are the maximum number of searches for selecting the best optimization.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The candidate set <code>treatments</code> will normally contain one or more complete sets of 
treatment replicates. The algorithm re-arranges the rows of the <code>treatments</code> set to ensure 
that the first <code>size</code> rows of the optimized <code>treatments</code> set contains the optimized treatment
fraction. The maximum replication of any treatment is the number of times that treatment occurs in the 
candidate treatment set and for a polynomial response surface design extra replication of the candidate
set may be necessary to allow for differential replication of the design points. The design is
optimized with respect to the <code>treatments_model</code> conditional on the treatment factors
in the <code>restriction_model</code> being held constant. The <code>restriction_model</code> must be a subset
of the full <code>treatments_model</code> otherwise the design will be fully fixed and no further optimization
will be possible. Fitting a non-null <code>restriction_model</code> allows sequential optimization
with each successively <code>treatments_model</code> optimized conditional on all previously optimized models.
The D-optimal efficiency of the design for the optimized treatment set is calculated relative to the 
D-optimal efficiency of the design for the candidate treatment set. 
</p>
<p>The default <code>treatments_model</code> parameter is an additive model for all treatment factors.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li>
<p>"TF" An optimized treatment fraction of the required <code>size</code>
</p>
</li>
<li>
<p>"fullTF" The full candidate set of treatments but with the first <code>size</code> 
rows containing the optimized treatment fraction
</p>
</li>
<li>
<p>"Efficiency" The D-efficiency of the optimized treatment fraction relative to the full candidate set of treatments
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>design</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">#' ## Plackett and Burman (P&amp;B) type design for eleven 2-level factors in 12 runs 
## NB. The algorithmic method is unlikely to succeed for larger P&amp;B type designs. 

GF = list(F1 = factor(1:2,labels=c("a","b")), F2 = factor(1:2,labels=c("a","b")), 
                 F3 = factor(1:2,labels=c("a","b")), F4 = factor(1:2,labels=c("a","b")),
                 F5 = factor(1:2,labels=c("a","b")), F6 = factor(1:2,labels=c("a","b")),
                 F7 = factor(1:2,labels=c("a","b")), F8 = factor(1:2,labels=c("a","b")), 
                 F9 = factor(1:2,labels=c("a","b")), F10= factor(1:2,labels=c("a","b")), 
                 F11= factor(1:2,labels=c("a","b")) )
model = ~ F1 + F2 + F3 + F4 + F5 + F6 + F7 + F8 + F9 + F10 + F11
Z=fraction(GF,size=12,treatments_model=model,searches=100)
print(Z$TF)
print(Z$Efficiency)
round(crossprod(scale(data.matrix(Z$TF))),6)

## Factorial treatment designs defined by sequentially fitted factorial treatment models
## 4 varieties by 3 levels of N by 3 levels of K assuming degree-2 treatment model in 24 plots.
## The single stage model gives an unequal split for the replication of the four varieties
## whereas the two stage model forces an equal split of 6 plots per variety.
## The single stage model is slightly more efficient overall (about 1.052045 versus 1.043662)
## but unequal variety replication is undesirable if all varieties are equally important.

## model terms
treatments = list(Variety = factor(1:4), N = 1:3, K = 1:3)
variety_model = ~ Variety
full_model = ~ (Variety + N + K)^2  + I(N^2) + I(K^2)

## single stage model
opt_full_treatments = fraction(treatments,24,full_model,searches=10)
opt_full_treatments$Efficiency
table(opt_full_treatments$TF[,1]) # variety replication

## two stage model
opt_var_treatments  = fraction(treatments,24,variety_model,searches=10)
opt_full_treatments = fraction(opt_var_treatments$fullTF,24,full_model,variety_model,searches=10)
opt_full_treatments$Efficiency
table(opt_full_treatments$TF[,1]) # variety replication

</code></pre>


</div>