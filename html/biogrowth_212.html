<div class="container">

<table style="width: 100%;"><tr>
<td>time_to_size</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Time for the population to reach a given size</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt="[Experimental]"></a>
</p>
<p>Calculates the elapsed time required for the population to reach a given size
(in log scale)
</p>


<h3>Usage</h3>

<pre><code class="language-R">time_to_size(model, size, type = "discrete", logbase_logN = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>An instance of GrowthPrediction, GrowthFit, GlobalGrowthFit,
GrowthUncertainty or MCMCgrowth.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size</code></td>
<td>
<p>Target population size (in log scale)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Tye of calculation, either "discrete" (default) or "distribution"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logbase_logN</code></td>
<td>
<p>Base of the logarithm for the population size. By default,
10 (i.e. log10). See vignette about units for details.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The calculation method differs depending on the value of <code>type</code>. If <code>type="discrete"</code>
(default), the function calculates by linear interpolation a discrete time to
reach the target population size. If <code>type="distribution"</code>, this calculation
is repeated several times, generating a distribution of the time. Note that this
is only possible for instances of GrowthUncertainty or MCMCgrowth.
</p>


<h3>Value</h3>

<p>If  <code>type="discrete"</code>, a number. If <code>type="distribution"</code>, an instance of
TimeDistribution.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Example 1 - Growth predictions -------------------------------------------

## The model is defined as usual with predict_growth

my_model &lt;- list(model = "modGompertz", logN0 = 0, C = 6, mu = .2, lambda = 20)

my_time &lt;- seq(0, 100, length = 1000)  # Vector of time points for the calculations

my_prediction &lt;- predict_growth(my_time, my_model, environment = "constant")

plot(my_prediction)

## We just have to pass the model and the size (in log10)

time_to_size(my_prediction, 3)

## If the size is not reached, it returns NA

time_to_size(my_prediction, 8)

## By default, it considers the population size is defined in the same log-base
## as the prediction. But that can be changed using logbase_logN

time_to_size(my_prediction, 3)
time_to_size(my_prediction, 3, logbase_logN = 10)
time_to_size(my_prediction, log(100), logbase_logN = exp(1))

## Example 2 - Model fit ----------------------------------------------------

my_data &lt;- data.frame(time = c(0, 25, 50, 75, 100), 
                      logN = c(2, 2.5, 7, 8, 8))
                      
models &lt;- list(primary = "Baranyi")

known &lt;- c(mu = .2)

start &lt;- c(logNmax = 8, lambda = 25, logN0 = 2)

primary_fit &lt;- fit_growth(my_data, models, start, known,
                          environment = "constant",
                          )
                          
plot(primary_fit)

time_to_size(primary_fit, 4)

## Example 3 - Global fitting -----------------------------------------------

## We need a model first

data("multiple_counts")
data("multiple_conditions")

sec_models &lt;- list(temperature = "CPM", pH = "CPM")

known_pars &lt;- list(Nmax = 1e8, N0 = 1e0, Q0 = 1e-3,
                   temperature_n = 2, temperature_xmin = 20, 
                   temperature_xmax = 35,
                   temperature_xopt = 30,
                   pH_n = 2, pH_xmin = 5.5, pH_xmax = 7.5, pH_xopt = 6.5)
                   
my_start &lt;- list(mu_opt = .8)

global_fit &lt;- fit_growth(multiple_counts, 
                         sec_models, 
                         my_start, 
                         known_pars,
                         environment = "dynamic",
                         algorithm = "regression",
                         approach = "global",
                         env_conditions = multiple_conditions
                         ) 
                         
plot(global_fit)

## The function calculates the time for each experiment

time_to_size(global_fit, 3)

## It returns NA for the particular experiment if the size is not reached

time_to_size(global_fit, 4.5)

</code></pre>


</div>