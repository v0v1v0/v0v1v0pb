<div class="container">

<table style="width: 100%;"><tr>
<td>BiBitWorkflow</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>BiBit Workflow</h2>

<h3>Description</h3>

<p>Workflow to discover larger (noisy) patterns in big data using BiBit
</p>


<h3>Usage</h3>

<pre><code class="language-R">BiBitWorkflow(matrix, minr = 2, minc = 2, similarity_type = "col",
  func = "agnes", link = "average", par.method = 0.625,
  cut_type = "gap", cut_pm = "Tibs2001SEmax", gap_B = 500,
  gap_maxK = 50, noise = 0.1, noise_select = 0, plots = c(3:5),
  BCresult = NULL, simmatresult = NULL, treeresult = NULL,
  plot.type = "device", filename = "BiBitWorkflow", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>matrix</code></td>
<td>
<p>The binary input matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minr</code></td>
<td>
<p>The minimum number of rows of the Biclusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minc</code></td>
<td>
<p>The minimum number of columns of the Biclusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>similarity_type</code></td>
<td>
<p>Which dimension to use for the Jaccard Index in Step 2. This is either columns (<code>"col"</code>, default) or both (<code>"both"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>func</code></td>
<td>
<p>Which clustering function to use in Step 3. Either <code>"agnes"</code> (= default) or <code>"hclust"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link</code></td>
<td>
<p>Which clustering link to use in Step 3. The available links (depending on <code>func</code>) are:
</p>

<ul>
<li>
<p><code>hclust</code>: <code>"ward.D"</code>, <code>"ward.D2"</code>, <code>"single"</code>, <code>"complete"</code>, <code>"average"</code>, <code>"mcquitty"</code>, <code>"median"</code> or <code>"centroid"</code>  
</p>
</li>
<li>
<p><code>agnes</code>: <code>"average"</code> (default), <code>"single"</code>, <code>"complete"</code>, <code>"ward"</code>, <code>"weighted"</code>, <code>"gaverage"</code> or <code>"flexible"</code>   
</p>
</li>
</ul>
<p>(More details in <code>hclust</code> and <code>agnes</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par.method</code></td>
<td>
<p>Additional parameters used for flexible link (See <code>agnes</code>). Default is <code>c(0.625)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cut_type</code></td>
<td>
<p>Which method should be used to decide the number of clusters in the tree in Step 4? 
</p>

<ul>
<li> <p><code>"gap"</code>: Use the Gap Statistic (default).
</p>
</li>
<li> <p><code>"number"</code>: Select a set number of clusters.
</p>
</li>
<li> <p><code>"height"</code>: Cut the tree at specific dissimilarity height.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cut_pm</code></td>
<td>
<p>Cut Parameter (depends on <code>cut_type</code>) for Step 4
</p>

<ul>
<li>
<p> Gap Statistic (<code>cut_type="gap"</code>): How to compute optimal number of clusters? Choose one of the following: <code>"Tibs2001SEmax"</code> (default), <code>"globalmax"</code>, <code>"firstmax"</code>, <code>"firstSEmax"</code> or <code>"globalSEmax"</code>.
</p>
</li>
<li>
<p> Number (<code>cut_type="number"</code>): Integer for number of clusters.
</p>
</li>
<li>
<p> Height (<code>cut_type="height"</code>): Numeric dissimilarity value where the tree should be cut (<code>[0,1]</code>).
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gap_B</code></td>
<td>
<p>Number of bootstrap samples (default=500) for Gap Statistic (<code>clusGap</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gap_maxK</code></td>
<td>
<p>Number of clusters to consider (default=50) for Gap Statistic (<code>clusGap</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noise</code></td>
<td>
<p>The allowed noise level when growing the rows on the merged patterns in Step 6. (default=<code>0.1</code>, namely allow 10% noise.)
</p>

<ul>
<li> <p><code>noise=0</code>: No noise allowed.
</p>
</li>
<li> <p><code>0&lt;noise&lt;1</code>: The <code>noise</code> parameter will be a noise percentage. The number of allowed 0's in a row in the bicluster will depend on the column size of the bicluster.
More specifically <code>zeros_allowed = ceiling(noise * columnsize)</code>. For example for <code>noise=0.10</code> and a bicluster column size of <code>5</code>, the number of allowed 0's would be <code>1</code>.
</p>
</li>
<li> <p><code>noise&gt;=1</code>: The <code>noise</code> parameter will be the number of allowed 0's in a row in the bicluster independent from the column size of the bicluster. In this noise option, the noise parameter should be an integer.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noise_select</code></td>
<td>
<p>Should the allowed noise level be automatically selected for each pattern? (Using ad hoc method to find the elbow/kink in the Noise Scree plots)
</p>

<ul>
<li> <p><code>noise_select=0</code>: Do <em>NOT</em> automatically select the noise levels. Use the the noise level given in the <code>noise</code> parameter (default).
</p>
</li>
<li> <p><code>noise_select=1</code>: Using the Noise Scree plot (with 'Added Rows' on the y-axis), find the noise level where the current number of added rows at this noise level is larger than the mean of 'added rows' at the lower noise levels. 
After locating this noise level, lower the noise level by 1. This is your automatically selected elbow/kink and therefore your noise level.
</p>
</li>
<li> <p><code>noise_select=2</code>: Applies the same steps as for <code>noise_select=1</code>, but instead of decreasing the noise level by only 1, keep decreasing the noise level until the number of added rows isn't decreasing anymore either.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plots</code></td>
<td>
<p>Vector for which plots to draw:
</p>

<ol>
<li>
<p> Image plot of the similarity matrix computed in Step 2.
</p>
</li>
<li>
<p> Same as <code>plots=1</code>, but the rows and columns are reordered with the hierarchical tree.
</p>
</li>
<li>
<p> Dendrogram of the tree, its clusters colored after the chosen cut has been applied.
</p>
</li>
<li>
<p> Noise Scree plots for all the Saved Patterns. Two plots will be plotted, both with Noise on the x-axis. The first one will have the number of Added Number of Rows on that noise level on the y-axis, while the second will have the Total Number of Rows (i.e. cumulative of the first).
If the title of one of the subplots is red, then this means that the Bicluster grown from this pattern, using the chosen noise level, was eventually deleted due to being a duplicate or non-maximal.
</p>
</li>
<li>
<p> Image plot of the Jaccard Index similarity matrix between the final biclusters after Step 6.
</p>
</li>
</ol>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BCresult</code></td>
<td>
<p>Import a BiBit Biclust result for Step 1 (e.g. extract from an older BiBitWorkflow object <code>$info$BiclustInitial</code>). This can be useful if you want to cut the tree differently/make different plots, but don't want to do the BiBit calculation again.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simmatresult</code></td>
<td>
<p>Import a (custom) Similarity Matrix (e.g. extract from older BiBitWorkflow object <code>$info$BiclustSimInitial</code>). Note that Step 1 (BiBit) will still be executed if <code>BCresult</code> is not provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>treeresult</code></td>
<td>
<p>Import a (custom) tree (<code>hclust</code> object) based on the BiBit/Similarity (e.g. extract from older BiBitWorkflow object <code>$info$Tree</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.type</code></td>
<td>
<p>Output Type
</p>

<ul>
<li> <p><code>"device"</code>: All plots are outputted to new R graphics devices (default).
</p>
</li>
<li> <p><code>"file"</code>: All plots are saved in external files. Plots 1 and 2 are saved in separate <code>.png</code> files while all other plots are joint together in a single <code>.pdf</code> file.
</p>
</li>
<li> <p><code>"other"</code>: All plots are outputted to the current graphics device, but will overwrite each other. Use this if you want to include one or more plots in a sweave/knitr file or if you want to export a single plot by your own chosen format.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filename</code></td>
<td>
<p>Base filename (with/without directory) for the plots if <code>plot.type="file"</code> (default=<code>"BiBitWorkflow"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical value if progress of workflow should be printed.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Looking for Noisy Biclusters in large data using BiBit (<code>bibit2</code>) often results in many (overlapping) biclusters.
In order decrease the number of biclusters and find larger meaningful patterns which make up noisy biclusters, the following workflow can be applied.
Note that this workflow is primarily used for data where there are many more rows (e.g. patients) than columns (e.g. symptoms). For example the workflow would discover larger meaningful symptom patterns which, conditioned on the allowed noise/zeros, subsets of the patients share.
</p>

<ol>
<li>
<p> Apply BiBit with <em>no noise</em> (Preferably with high enough <code>minr</code> and <code>minc</code>).
</p>
</li>
<li>
<p> Compute Similarity Matrix (Jaccard Index) of all biclusters. By default this measure is only based on column similarity.
This implies that the rows of the BC's are not of interest in this step. The goal then would be to discover highly overlapping column patterns and, in the next steps, merge them together.
</p>
</li>
<li>
<p> Apply Agglomerative Hierarchical Clustering on Similarity Matrix (default = average link)
</p>
</li>
<li>
<p> Cut the dendrogram of the clustering result and merge the biclusters based on this. (default = number of clusters is determined by the Tibs2001SEmax Gap Statistic)
</p>
</li>
<li>
<p> Extract Column Memberships of the Merged Biclusters. These are saved as the new column <em>Patterns</em>.
</p>
</li>
<li>
<p> Starting from these patterns, <em>(noisy) rows</em> are grown which match the pattern, creating a single final bicluster for each pattern. At the end duplicate/non-maximal BC's are deleted.
</p>
</li>
</ol>
<p>Using the described workflow (and column similarity in Step 2), the final result will contain biclusters which focus on larger column patterns.
</p>


<h3>Value</h3>

<p>A BiBitWorkflow S3 List Object with 3 slots:
</p>

<ul>
<li> <p><code>Biclust</code>: Biclust Class Object of Final Biclustering Result (after Step 6).
</p>
</li>
<li> <p><code>BiclustSim</code>: Jaccard Index Similarity Matrix of Final Biclustering Result (after Step 6).
</p>
</li>
<li> <p><code>info</code>: List Object containing:
</p>

<ul>
<li> <p><code>BiclustInitial</code>: Biclust Class Object of Initial Biclustering Result (after Step 1).
</p>
</li>
<li> <p><code>BiclustSimInitial</code>: Jaccard Index Similarity Matrix of Initial Biclustering Result (after Step 1).
</p>
</li>
<li> <p><code>Tree</code>: Hierarchical Tree of <code>BiclustSimInitial</code> as <code>hclust</code> object.
</p>
</li>
<li> <p><code>Number</code>: Vector containing the initial number of biclusters (<code>InitialNumber</code>), the number of saved patterns after cutting the tree (<code>PatternNumber</code>) and the final number of biclusters (<code>FinalNumber</code>).
</p>
</li>
<li> <p><code>GapStat</code>: Vector containing all different optimal cluster numbers based on the Gap Statistic.
</p>
</li>
<li> <p><code>BC.Merge</code>: A list (length of merged saved patterns) containing which biclusters were merged together after cutting the tree.
</p>
</li>
<li> <p><code>MergedColPatterns</code>: A list (length of merged saved patterns) containing the indices of which columns make up that pattern.
</p>
</li>
<li> <p><code>MergedNoiseThresholds</code>: A vector containing the selected noise levels for the merged saved patterns.
</p>
</li>
<li> <p><code>Coverage</code>: A list containing: 1. a vector of the total number (and percentage) of unique rows the final biclusters cover. 2. a table showing how many rows are used more than a single time in the final biclusters.
</p>
</li>
<li> <p><code>Call</code>: A match.call of the original function call.
</p>
</li>
</ul>
</li>
</ul>
<h3>Author(s)</h3>

<p>Ewoud De Troyer
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
## Simulate Data ##
# DATA: 10000x50
# BC1: 200x10
# BC2: 100x10
# BC1 and BC2 overlap 5 columns

# BC3: 200x10
# BC4: 100x10
# BC3 and bC4 overlap 2 columns

# Background 1 percentage: 0.15
# BC Signal Percentage: 0.9
 
set.seed(273)
mat &lt;- matrix(sample(c(0,1),10000*50,replace=TRUE,prob=c(1-0.15,0.15)),
              nrow=10000,ncol=50)
mat[1:200,1:10] &lt;- matrix(sample(c(0,1),200*10,replace=TRUE,prob=c(1-0.9,0.9)),
                          nrow=200,ncol=10)
mat[300:399,6:15] &lt;- matrix(sample(c(0,1),100*10,replace=TRUE,prob=c(1-0.9,0.9)),
                            nrow=100,ncol=10)
mat[400:599,21:30] &lt;- matrix(sample(c(0,1),200*10,replace=TRUE,prob=c(1-0.9,0.9)),
                             nrow=200,ncol=10)
mat[700:799,29:38] &lt;- matrix(sample(c(0,1),100*10,replace=TRUE,prob=c(1-0.9,0.9)),
                             nrow=100,ncol=10)
mat &lt;- mat[sample(1:10000,10000,replace=FALSE),sample(1:50,50,replace=FALSE)]


# Computing gap statistic for initial 1381 BC takes approx. 15 min.
# Gap Statistic chooses 4 clusters. 
out &lt;- BiBitWorkflow(matrix=mat,minr=50,minc=5,noise=0.2) 
summary(out$Biclust)

# Reduce computation by selecting number of clusters manually.
# Note: The "ClusterRowCoverage" function can be used to provided extra info 
#       on the number of cluster choice.
#       How?
#       - More clusters result in smaller column patterns and more matching rows.
#       - Less clusters result in larger column patterns and less matching rows.
# Step 1: Initial Workflow Run
out2 &lt;- BiBitWorkflow(matrix=mat,minr=50,minc=5,noise=0.2,cut_type="number",cut_pm=10)
# Step 2: Use ClusterRowCoverage
temp &lt;- ClusterRowCoverage(result=out2,matrix=mat,noise=0.2,plots=2)
# Step 3: Use BiBitWorkflow again (using previously computed parts) with new cut parameter
out3 &lt;- BiBitWorkflow(matrix=mat,minr=50,minc=5,noise=0.2,cut_type="number",cut_pm=4,
                      BCresult = out2$info$BiclustInitial,
                      simmatresult = out2$info$BiclustSimInitial)
summary(out3$Biclust)

## End(Not run)
</code></pre>


</div>