<div class="container">

<table style="width: 100%;"><tr>
<td>biv.norm.post</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>biv.norm.post</h2>

<h3>Description</h3>

<p>A function to calculate posterior quantities of the bivariate normal.  See page 94.
</p>


<h3>Usage</h3>

<pre><code class="language-R">biv.norm.post(data.mat,alpha,beta,m,n0=5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data.mat</code></td>
<td>
<p>A matrix with two columns of normally distributed data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Wishart first (scalar) parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>Wishart second (matrix) parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>prior mean for mu</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n0</code></td>
<td>
<p>prior confidence parameter</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns
</p>
<table>
<tr style="vertical-align: top;">
<td><code>mu2</code></td>
<td>
<p>posterior mean, dimension 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sig1</code></td>
<td>
<p>posterior mean, dimension 2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sig2</code></td>
<td>
<p>posterior variance, dimension 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>posterior variance, dimension 2</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Jeff Gill
</p>


<h3>Examples</h3>

<pre><code class="language-R">
 rwishart &lt;- function(df, p = nrow(SqrtSigma), SqrtSigma = diag(p))  { 
 if((Ident &lt;- missing(SqrtSigma)) &amp;&amp; missing(p)) stop("either p or SqrtSigma must be specified") 
 Z &lt;- matrix(0, p, p) 
 diag(Z) &lt;- sqrt(rchisq(p, df:(df-p+1))) 
 if(p &gt; 1) { 
   pseq &lt;- 1:(p-1) 
   Z[rep(p*pseq, pseq) + unlist(lapply(pseq, seq))] &lt;- rnorm(p*(p-1)/2) 
 } 
 if(Ident) crossprod(Z) 
 else crossprod(Z %*% SqrtSigma)
 }
  
  data.n10 &lt;- rmultinorm(10, c(1,3), matrix(c(1.0,0.7,0.7,3.0),2,2))
  rep.mat &lt;- NULL; reps &lt;- 1000
  for (i in 1:reps){
    rep.mat &lt;- rbind(rep.mat, biv.norm.post(data.n10,3, matrix(c(10,5,5,10),2,2),c(2,2)))
  }
  round(normal.posterior.summary(rep.mat),3)
    
</code></pre>


</div>