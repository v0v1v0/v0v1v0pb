<div class="container">

<table style="width: 100%;"><tr>
<td>wBuild</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Derive parameters for building integration grids</h2>

<h3>Description</h3>

<p>Note: <code class="reqn">w</code> is defined on the transformed scale, but for convenience 
<code>f</code> is defined on the original scale.
</p>


<h3>Usage</h3>

<pre><code class="language-R">wBuild(
  f,
  init,
  dim.theta2 = length(init),
  approx = "gaussian",
  link = rep("identity", length(init)),
  link.params = rep(list(NA), length(init)),
  optim.control = list(maxit = 5000, method = "BFGS"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>function used to derive the weight function <code class="reqn">w</code>.
<code>f</code> must be able to be called via <code>f(par, log, ...)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>initial guess for mode of <code>f</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dim.theta2</code></td>
<td>
<p><code>wBuild</code> assumes <code>par</code> is partitioned such that 
<code>par=c(theta1,theta2)</code>.  <code>dim.theta2</code> specifies the size of the 
partition.  The default is to assume that <code>f</code> is defined without a 
<code>theta1</code> component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>approx</code></td>
<td>
<p>Style of approximation (i.e., <code class="reqn">w</code>) to be created from mode 
of <code>f</code>.
</p>

<dl>
<dt><code>'gaussian'</code></dt>
<dd>
<p>Gaussian approximation for <code>theta2</code> at 
the mode of <code>f</code>. Assumes <code>f</code> is proportional to the marginal 
posterior density for <code>theta2</code>.</p>
</dd>
<dt><code>'condgauss'</code></dt>
<dd>
<p>Gaussian approximation for <code>theta2</code> at 
the mode of <code>f</code>.  The approximation is conditioned on the value of
the mode for <code>theta1</code>. Assumes <code>f</code> is proportional to the 
joint posterior density for <code>theta1,theta2.</code></p>
</dd>
<dt><code>'condgauss-laplace'</code></dt>
<dd>
<p>Gaussian approximation for 
<code>theta2</code> at the mode of <code>f</code>.  The approximation is 
conditioned on a separate laplace approximation of the marginal 
posterior mode for <code>theta1</code>.  Assumes <code>f</code> is proportional to 
the joint posterior density for <code>theta1,theta2.</code></p>
</dd>
<dt><code>'margauss'</code></dt>
<dd>
<p>Gaussian approximation for 
<code>theta2</code> at the mode of <code>f</code>.  Assumes <code>f</code> is 
proportional to the joint posterior density for <code>theta1,theta2.</code>, 
then uses the marginal mean and covariance from the posterior's 
gaussian approximation.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link</code></td>
<td>
<p>character vector that specifies transformations used during
optimization and integration of <code class="reqn">f(\theta_2 | X)</code>.  While
<code class="reqn">\theta_2</code> may be defined on arbitrary support, <code>wtdMix</code> performs
optimization and integration of <code class="reqn">\theta_2</code> on an unconstrained support.
The <code>link</code> vector describes the transformations that must be applied
to each element of <code class="reqn">\theta_2</code>.  Jacobian functions for the
transformations will automatically be added to the optimization and
integration routines. Currently supported link functions are <code>'log'</code>,
<code>'logit'</code>, and <code>'identity'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link.params</code></td>
<td>
<p>Optional list of additional parameters for link
functions.  For example, the logit function can be extended to allow
mappings to any closed interval.   There should be one list entry for each
link function.  Specify NA if no additional arguments are passed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim.control</code></td>
<td>
<p>List of arguments to pass to <code>stat::optim</code>
when used to find mode of <code>f</code>.
</p>

<dl>
<dt><code>maxit</code></dt>
<dd>
<p>Maximum number of iterations to run <code>optim</code> 
for.</p>
</dd>
<dt><code>method</code></dt>
<dd>
<p>Optimization routine to use with <code>optim</code>.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments needed for function evaluation.</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R"># Use BISQuE to approximate the marginal posterior distribution for unknown
# population f(N|c, r) for the fur seals capture-recapture data example in 
# Givens and Hoeting (2013), example 7.10.

data('furseals')

# define theta transformation and jacobian
tx.theta = function(theta) { 
  c(log(theta[1]/theta[2]), log(sum(theta[1:2]))) 
}
itx.theta = function(u) { 
  c(exp(sum(u[1:2])), exp(u[2])) / (1 + exp(u[1])) 
}
lJ.tx.theta = function(u) {
  log(exp(u[1] + 2*u[2]) + exp(2*sum(u[1:2]))) - 3 * log(1 + exp(u[1]))
}

# compute constants
r = sum(furseals$m)
nC = nrow(furseals)

# set basic initialization for parameters
init = list(U = c(-.7, 5.5))
init = c(init, list(
  alpha = rep(.5, nC),
  theta = itx.theta(init$U),
  N = r + 1
))


post.alpha_theta = function(theta2, log = TRUE, ...) {
  # Function proportional to f(alpha, U1, U2 | c, r) 
  
  alpha = theta2[1:nC]
  u = theta2[-(1:nC)]
  theta = itx.theta(u)
  p = 1 - prod(1-alpha)
  
  res = - sum(theta)/1e3 - r * log(p) + lJ.tx.theta(u) - 
    nC * lbeta(theta[1], theta[2])
  for(i in 1:nC) {
    res = res + (theta[1] + furseals$c[i] - 1)*log(alpha[i]) + 
      (theta[2] + r - furseals$c[i] - 1)*log(1-alpha[i])
  }
  
  if(log) { res } else { exp(res) }
}

post.N.mixtures = function(N, params, log = TRUE, ...) {
  # The mixture component of the weighted mixtures for f(N | c, r)
  dnbinom(x = N-r, size = r, prob = params, log = log)
}

mixparams.N = function(theta2, ...) {
  # compute parameters for post.N.mixtures
  1 - prod(1 - theta2[1:nC])
}


w.N = wBuild(f = post.alpha_theta, init = c(init$alpha, init$U), 
             approx = 'gauss', link = c(rep('logit', nC), rep('identity', 2)))

m.N = wMix(f1 = post.N.mixtures, f1.precompute = mixparams.N, 
           f2 = post.alpha_theta, w = w.N)



# compute posterior mean
m.N$expectation$Eh.precompute(h = function(p) ((1-p)*r/p + r), 
                                   quadError = TRUE)

# compute posterior density
post.N.dens = data.frame(N = r:105)
post.N.dens$d = m.N$f(post.N.dens$N)

# plot posterior density
plot(d~N, post.N.dens, ylab = expression(f(N~'|'~bold(c),r)))

</code></pre>


</div>