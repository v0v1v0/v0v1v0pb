<div class="container">

<table style="width: 100%;"><tr>
<td>Theoretical</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Theoretical error rate functions</h2>

<h3>Description</h3>

<p>Functions to calculate the theoretical performance of common modulation
formats.  Includes the functions <code>dB (x)</code> (returns <code style="white-space: pre;">⁠10log10(x)⁠</code>), <code>undB(x)</code>
(reverses <code>dB(x)</code>), <code>Q_( x)</code> (Markum's Q function), and <code>Q_Inv(x)</code>
(returns the
SNR in Decibels to get probability x).  Also includes <code>mod_Inv</code>, which returns
the SNR required for a the function <code>f</code> to reach the supplied BER (bit
error rate, or bit error probability).
</p>


<h3>Usage</h3>

<pre><code class="language-R">is.wholenumber(x, tol = sqrt(.Machine$double.eps))

dB(x)

undB(x)

Q_(x)

Q_Inv(perr)

QPSKdB(x)

DQPSKdB(x)

DQPSKDDdB(x)

PSQPSKdB(x)

MPSKdB(x, M)

MPSKdB.8(x)

QAMdB.8.star(x)

QAMdB(x, M)

QAMdB.16(x)

mod_Inv(f, perr, guess = Q_Inv(perr))

mod_InvV(f, pv, offset = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a real number</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>the tolerance to test x with.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perr</code></td>
<td>
<p>a probability of a bit error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>The integer number of symbols &gt; 4.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>a function (usually a BER function).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>guess</code></td>
<td>
<p>a guess for the <code>perr</code> (the default usually works).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pv</code></td>
<td>
<p>a vector of BERs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>an offset in Decibels for guesses in <code>mod_InvV</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The rest of the functions return the probability of a bit error given the
SNR in Decibels.
</p>

<ul>
<li> <p><code>QPSKdB</code> is Quadrature Phase shift keyed: two bits per symbol.
</p>
</li>
<li> <p><code>DQPSK</code> is differentially detected differentially coded QPSK.
</p>
</li>
<li> <p><code>DQPSKDDdB</code> is differentially detected differential QPSK (coherently
detected but differentially decoded. See <code>DQPSK</code> above.
</p>
</li>
<li> <p><code>PSQPSKdB</code> is polarization-shifted QPSK: it is dual pole, but only
one pole is active at any one time, thus supplying three bits per
symbol. (See Agrell &amp; Karlsson (2009, DOI:10.1109/JLT.2009.2029064)).
</p>
</li>
<li> <p><code>MPSKdB(x, M)</code> is generic M-ary phase shift keying of <code>M</code> points in a circle.
</p>
</li>
<li> <p><code>MPSKdB.8</code> simply returns <code>MPSKdB(x, 8)</code>
</p>
</li>
<li> <p><code>QAMdB.8.star</code> is the optimal star configuration of 8-ary Quadrature
Amplitude Modulation (QAM), such that
the legs are at <code class="reqn">\pm1</code> and <code class="reqn">\pm(1+\sqrt3)</code>.
</p>
</li>
<li> <p><code>QAMdB(x, M)</code> is generic rectangular QAM constellation of <code>M</code> points.
</p>
</li>
<li> <p><code>QAMdB.16</code> Returns the BER for the rectangular QAM constellation according to
Proakis Eq. 5-2-80.
</p>
</li>
<li> <p><code>mod_Inv</code> will take a function <code>f(x)</code> and return the x such that
<code>f(x)==perr</code>
but it does this based on the <code>log( f(x))</code> and the <code>log( perr)</code>, so
<code>f(x)&gt;0</code>.
</p>
</li>
<li> <p><code>mod_InvV</code> is a vectorized version (give it a vector of BERs and it returns a
vector of SNRs).
</p>
</li>
</ul>
<h3>Value</h3>

<p><code>is.wholenumber(x)</code> returns <code>TRUE</code> if <code>c-round(x) &lt; tol</code>.
</p>
<p><code>dB(x)</code> returns <code>10*log10(x)</code>
</p>
<p><code>undB(x)</code> returns <code>10^(x/10)</code>
</p>
<p><code>Q_Inv(x)</code> returns <code>2*dB( -qnorm(x))</code>, which is the
SNR (in Decibels) required to get a probability of error of x.
Q_Inv( Q_( undB( x/2))) = x and Q_( undB( Q_Inv( x)/2))=x
</p>
<p><code> mod_Inv( f, x)</code> returns a list with the SNR in Decibels to
reach the BER
<code>perr</code> such that <code>f( mod_Inv( f, x)$x) = x</code>.
The returned list has elements
<code>$x</code> as the SNR and
<code>$fval</code> as the function value.
</p>


<h3>See Also</h3>

<p><code>pracma::fzero()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">dB( 10) # == 10
undB( 20) # == 100
Q_Inv( Q_( undB( 10/2))) # = 10
Q_( undB( Q_Inv( 0.001)/2)) # = 0.001

mod_Inv( QPSKdB, QPSKdB( 7)) # yields 7

mod_InvV(QPSKdB, QPSKdB(c(6,7)))

</code></pre>


</div>