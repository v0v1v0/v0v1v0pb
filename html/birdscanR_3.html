<div class="container">

<table style="width: 100%;"><tr>
<td>computeDensity</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>computeDensity</h2>

<h3>Description</h3>

<p>This function will estimate the density (expressed as #objects / km3)
based on the observations in your database. Note that this function only works
properly on Birdscan MR1 database versions &gt;= 1.7.0.4 as the variable
feature37.speed is required for the density calculation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">computeDensity(
  dbName,
  echoes,
  classSelection,
  altitudeRange,
  altitudeBinSize,
  timeRange,
  timeBinDuration_sec,
  timeZone,
  sunriseSunset,
  sunOrCivil = "civil",
  crepuscule = "nauticalSolar",
  protocolData,
  visibilityData,
  manualBlindTimes = NULL,
  saveBlindTimes = FALSE,
  blindTimesOutputDir = getwd(),
  blindTimeAsMtrZero = NULL,
  propObsTimeCutoff = 0,
  computePerDayNight = FALSE,
  computePerDayCrepusculeNight = FALSE,
  computeAltitudeDistribution = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dbName</code></td>
<td>
<p>Character string, containing the name of the database you are
processing</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>echoes</code></td>
<td>
<p>dataframe with the echo data from the data list created by the
function ‘extractDBData’ or a subset of it created by the function
‘filterEchoData’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>classSelection</code></td>
<td>
<p>character string vector with all classes which should
be used to calculate the density. The density and number of Echoes will be calculated
for each class as well as for all classes together.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>altitudeRange</code></td>
<td>
<p>numeric vector of length 2 with the start and end of the
altitude range in meter a.g.l.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>altitudeBinSize</code></td>
<td>
<p>numeric, size of the altitude bins in meter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timeRange</code></td>
<td>
<p>Character vector of length 2, with start and end of time
range, formatted as "%Y-%m-%d %H:%M"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timeBinDuration_sec</code></td>
<td>
<p>duration of timeBins in seconds (numeric). for
values &lt;= 0 a duration of 1 hour will be set</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timeZone</code></td>
<td>
<p>time zone in which the time bins should be created as string,
e.g. "Etc/GMT0"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sunriseSunset</code></td>
<td>
<p>dataframe with sunrise/sunset, and civil and nautical
dawn/dusk. Computed with the function 'twilight'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sunOrCivil</code></td>
<td>
<p>sunrise/sunset or civil dawn/dusk used to split day and
night. Supported values: "sun" or "civil". Default: "civil"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crepuscule</code></td>
<td>
<p>optional character variable, Set to “nauticalSolar” to use
the time between nautical dusk/dawn and sunrise/sunset times to define the
crepuscular period, or to "nauticalCivil" to use the time between nautical
and civil dusk/dawn to define the crepuscular period, or to "civilSolar" to use
the time between civil dusk/dawn and sunrise/sunset times to define the
crepuscular period. Default is "nauticalSolar".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>protocolData</code></td>
<td>
<p>dataframe with the protocol data from the data list
created by the function <code>extractDBData</code> or a subset of it created by the
function <code>filterProtocolData</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>visibilityData</code></td>
<td>
<p>dataframe with the visibility data from the data list
created by the function ‘extractDBData’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>manualBlindTimes</code></td>
<td>
<p>dataframe with the manual blind times created by the
function <code>loadManualBlindTimes</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>saveBlindTimes</code></td>
<td>
<p>Logical, determines whether to save the blind times to
a file. Default: False.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>blindTimesOutputDir</code></td>
<td>
<p>Character string containing the path to save the
blind times to. Default: 'your-working-directory'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>blindTimeAsMtrZero</code></td>
<td>
<p>character string vector with the blind time types
which should be treated as observation time with MTR zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>propObsTimeCutoff</code></td>
<td>
<p>numeric between 0 and 1. If the density is computed per
day and night, time bins with a proportional observation time smaller than
propObsTimeCutoff are ignored when combining the time bins. If the density is
computed for each time bin, the parameter is ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>computePerDayNight</code></td>
<td>
<p>logical, TRUE: density is computed per day and night.
The time bins of each day and night will be combined and the mean density is
computed for each day and night. The spread (first and third Quartile) for
each day and night are also computed. The spread is dependent on the chosen
time bin duration/amount of time bins; When FALSE: density is computed for each
time bin. This option computes the density for each time bin defined in the time
bin dataframe. The time bins that were split due to sunrise/sunset during the
time bin will be combined to one bin.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>computePerDayCrepusculeNight</code></td>
<td>
<p>logical, TRUE: density is computed per
crepusculeMorning, day, crepusculeEvening, and night. The time bins of each
of these diel phases will be combined and the mean density is computed for each
phase. The spread (first and third Quartile) for each phase is also computed.
The spread is dependent on the chosen time bin duration/amount of time bins;
When FALSE: density is computed for each time bin. This option computes the density
for each time bin defined in the time bin dataframe. The time bins that were
split due to sunrise/sunset during the time bin will be combined to one bin.
Default = FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>computeAltitudeDistribution</code></td>
<td>
<p>logical, TRUE: compute the mean height and
altitude distribution of density for the pre-defined quantiles 0.05, 0.25, 0.5,
0.75, 0.95</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Density
</p>


<h3>Author(s)</h3>

<p>Birgen Haest, <a href="mailto:birgen.haest@vogelwarte.ch">birgen.haest@vogelwarte.ch</a>;
Fabian Hertner, <a href="mailto:fabian.hertner@swiss-birdradar.com">fabian.hertner@swiss-birdradar.com</a>;
Baptiste Schmid, <a href="mailto:baptiste.schmid@vogelwarte.ch">baptiste.schmid@vogelwarte.ch</a>;
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Set server, database, and other input settings
# ===========================================================================
  dbServer       = "MACHINE\\SERVERNAME"     # Set the name of your SQL server
  dbName         = "db_Name"                   # Set the name of your database
  dbDriverChar   = "SQL Server"                # Set either "SQL Server" or "PostgreSQL"
  mainOutputDir  = file.path(".", "results")
  radarTimeZone  = "Etc/GMT0"
  targetTimeZone = "Etc/GMT0"
  listOfRfFeaturesToExtract = c(167, 168)
  siteLocation   = c(47.494427, 8.716432)
  sunOrCivil     = "civil"
  crepuscule     = "nauticalSolar"
  timeRangeData  = c("2021-01-15 00:00", "2021-01-31 00:00")
 
# Get data
# ===========================================================================
  dbData = extractDbData(dbDriverChar                   = dbDriverChar,
                         dbServer                       = dbServer, 
                         dbName                         = dbName, 
                         saveDbToFile                   = TRUE,
                         dbDataDir                      = mainOutputDir,
                         radarTimeZone                  = radarTimeZone,
                         targetTimeZone                 = targetTimeZone,
                         listOfRfFeaturesToExtract      = listOfRfFeaturesToExtract,
                         siteLocation                   = siteLocation, 
                         sunOrCivil                     = sunOrCivil, 
                         crepuscule                     = crepuscule)
                         
# Get sunrise/sunset 
# ===========================================================================
  sunriseSunset = twilight(timeRange = timeRangeData,
                           latLon    = c(47.494427, 8.716432),
                           timeZone  = targetTimeZone)
                          
# Get manual blind times
# ===========================================================================
  data(manualBlindTimes)
  cManualBlindTimes = manualBlindTimes

# Compute migration traffic rate
# ===========================================================================
  classSelection.density = c("insect")
  densityData = computeDensity(dbName                       = dbName, 
                               echoes                       = dbData$echoData, 
                               classSelection               = classSelection.density, 
                               altitudeRange                = c(25, 1025),
                               altitudeBinSize              = 50,
                               timeRange                    = timeRangeData, 
                               timeBinDuration_sec          = 1800,
                               timeZone                     = targetTimeZone,
                               sunriseSunset                = sunriseSunset,
                               sunOrCivil                   = "civil",
                               crepuscule                   = crepuscule,
                               protocolData                 = dbData$protocolData, 
                               visibilityData               = dbData$visibilityData,
                               manualBlindTimes             = cManualBlindTimes,
                               saveBlindTimes               = FALSE,
                               blindTimesOutputDir          = getwd(),
                               blindTimeAsMtrZero           = NULL,
                               propObsTimeCutoff            = 0, 
                               computePerDayNight           = FALSE,
                               computePerDayCrepusculeNight = FALSE 
                               computeAltitudeDistribution  = TRUE)   

## End(Not run)

</code></pre>


</div>