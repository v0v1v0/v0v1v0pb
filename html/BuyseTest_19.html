<div class="container">

<table style="width: 100%;"><tr>
<td>BuyseMultComp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Adjustment for Multiple Comparisons</h2>

<h3>Description</h3>

<p>Adjust p-values and confidence intervals estimated via GPC for multiple comparisons.
</p>


<h3>Usage</h3>

<pre><code class="language-R">BuyseMultComp(
  object,
  cluster = NULL,
  linfct = NULL,
  rhs = NULL,
  endpoint = NULL,
  statistic = NULL,
  cumulative = TRUE,
  conf.level = NULL,
  band = TRUE,
  global = FALSE,
  alternative = NULL,
  transformation = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A BuyseTest object or a list of BuyseTest objects. All objects should contain the same endpoints.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>[character] name of the variable identifying the observations in the dataset used by each BuyseTest model.
Only relevant when using a list of BuyseTest objects to correctly combine the influence functions.
If NULL, then it is assumed that the BuyseTest objects correspond to different groups of individuals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linfct</code></td>
<td>
<p>[numeric matrix] a contrast matrix of size the number of endpoints times the number of BuyseTest models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rhs</code></td>
<td>
<p>[numeric vector] the values for which the test statistic should be tested against. Should have the same number of rows as <code>linfct</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>endpoint</code></td>
<td>
<p>[character or numeric vector] the endpoint(s) to be considered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>statistic</code></td>
<td>
<p>[character] the statistic summarizing the pairwise comparison:
<code>"netBenefit"</code> displays the net benefit, as described in Buyse (2010) and Peron et al. (2016)),
<code>"winRatio"</code> displays the win ratio, as described in Wang et al. (2016),
<code>"favorable"</code> displays the proportion in favor of the treatment (also called Mann-Whitney parameter), as described in Fay et al. (2018).
<code>"unfavorable"</code> displays the proportion in favor of the control.
Default value read from <code>BuyseTest.options()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cumulative</code></td>
<td>
<p>[logical] should the summary statistic be cumulated over endpoints?
Otherwise display the contribution of each endpoint.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.level</code></td>
<td>
<p>[numeric] confidence level for the confidence intervals.
Default value read from <code>BuyseTest.options()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>band</code></td>
<td>
<p>[logical] Should confidence intervals and p-values adjusted for multiple comparisons be computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>global</code></td>
<td>
<p>[logical] Should global test (intersection of all null hypotheses) be made?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alternative</code></td>
<td>
<p>[character] the type of alternative hypothesis: <code>"two.sided"</code>, <code>"greater"</code>, or <code>"less"</code>.
Default value read from <code>BuyseTest.options()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transformation</code></td>
<td>
<p>[logical]  should the CI be computed on the logit scale / log scale for the net benefit / win ratio and backtransformed.
Otherwise they are computed without any transformation.
Default value read from <code>BuyseTest.options()</code>. Not relevant when using permutations or percentile bootstrap.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>argument passsed to the function <code>transformCIBP</code> of the riskRegression package.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Simulateneous confidence intervals and adjusted p-values are computed using a single-step max-test approach via the function <code>transformCIBP</code> of the riskRegression package.
This corresponds to the single-step Dunnett described in Dmitrienko et al (2013) in table 2 and section 7.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>BuyseMultComp</code>.
</p>


<h3>References</h3>

<p>Dmitrienko, A. and D'Agostino, R., Sr (2013), Traditional multiplicity adjustment methods in clinical trials. Statist. Med., 32: 5172-5218. https://doi.org/10.1002/sim.5990
</p>


<h3>Examples</h3>

<pre><code class="language-R">#### simulate data ####
set.seed(10)
df.data &lt;- simBuyseTest(1e2, n.strata = 3)

#### adjustment for all univariate analyses ####
ff1 &lt;- treatment ~ TTE(eventtime, status = status, threshold = 0.1)
ff2 &lt;- update(ff1, .~. + cont(score, threshold = 1))
BT2 &lt;- BuyseTest(ff2, data= df.data, trace = FALSE)

## (require riskRegression &gt;= 2021.10.04 to match)
confint(BT2, cumulative = FALSE) ## not adjusted
confintAdj &lt;- BuyseMultComp(BT2, cumulative = FALSE, endpoint = 1:2) ## adjusted
confintAdj
if(require(lava)){
cor(lava::iid(confintAdj)) ## correlation between test-statistic
}

#### 2- adjustment for multi-arm trial ####
## case where we have more than two treatment groups
## here strata will represent the treatment groups
df.data$strata &lt;- as.character(df.data$strata)
df.data$id &lt;- paste0("Id",1:NROW(df.data)) ## define id variable

BT1ba &lt;- BuyseTest(strata ~ TTE(eventtime, status = status, threshold = 1),
                   data= df.data[strata %in% c("a","b"),], trace = FALSE)
BT1ca &lt;- BuyseTest(strata ~ TTE(eventtime, status = status, threshold = 0.1),
                   data= df.data[strata %in% c("a","c"),], trace = FALSE)
BT1cb &lt;- BuyseTest(strata ~ TTE(eventtime, status = status, threshold = 0.1),
                   data= df.data[strata %in% c("b","c"),], trace = FALSE)
rbind("b-a" = confint(BT1ba),
      "c-a" = confint(BT1ca),
      "c-b" = confint(BT1cb)) ## not adjusted
confintAdj &lt;- BuyseMultComp(list("b-a" = BT1ba, "c-a" = BT1ca, "c-b" = BT1cb),
                            cluster = "id", global = TRUE)
confintAdj
if(require(lava)){
cor(lava::iid(confintAdj))
}
</code></pre>


</div>