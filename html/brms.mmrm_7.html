<div class="container">

<table style="width: 100%;"><tr>
<td>brm_archetype_successive_effects</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Treatment-effect-like successive differences archetype</h2>

<h3>Description</h3>

<p>Create an informative prior archetype where the fixed effects
are successive differences between adjacent time points and terms
in non-reference groups are treatment effects.
</p>


<h3>Usage</h3>

<pre><code class="language-R">brm_archetype_successive_effects(
  data,
  intercept = FALSE,
  baseline = !is.null(attr(data, "brm_baseline")),
  baseline_subgroup = !is.null(attr(data, "brm_baseline")) &amp;&amp; !is.null(attr(data,
    "brm_subgroup")),
  baseline_subgroup_time = !is.null(attr(data, "brm_baseline")) &amp;&amp; !is.null(attr(data,
    "brm_subgroup")),
  baseline_time = !is.null(attr(data, "brm_baseline")),
  covariates = TRUE,
  clda = FALSE,
  prefix_interest = "x_",
  prefix_nuisance = "nuisance_"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A classed data frame from <code>brm_data()</code>, or an informative
prior archetype from a function like <code>brm_archetype_successive_cells()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> (default) to include an intercept, <code>FALSE</code> to omit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>baseline</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include an additive effect for baseline
response, <code>FALSE</code> to omit.
Default is <code>TRUE</code> if <code>brm_data()</code> previously declared a baseline
variable in the dataset.
Ignored for informative prior archetypes.
For informative prior archetypes, this option should be set in
functions like <code>brm_archetype_successive_cells()</code> rather than in
<code>brm_formula()</code> in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>baseline_subgroup</code></td>
<td>
<p>Logical of length 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>baseline_subgroup_time</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include baseline-by-subgroup-by-time interaction,
<code>FALSE</code> to omit.
Default is <code>TRUE</code> if <code>brm_data()</code> previously declared baseline
and subgroup variables in the dataset.
Ignored for informative prior archetypes.
For informative prior archetypes, this option should be set in
functions like <code>brm_archetype_successive_cells()</code> rather than in
<code>brm_formula()</code> in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>baseline_time</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include baseline-by-time interaction, <code>FALSE</code> to omit.
Default is <code>TRUE</code> if <code>brm_data()</code> previously declared a baseline
variable in the dataset.
Ignored for informative prior archetypes.
For informative prior archetypes, this option should be set in
functions like <code>brm_archetype_successive_cells()</code> rather than in
<code>brm_formula()</code> in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariates</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> (default) to include any additive covariates declared with
the <code>covariates</code> argument of <code>brm_data()</code>,
<code>FALSE</code> to omit.
For informative prior archetypes, this option is set in
functions like <code>brm_archetype_successive_cells()</code> rather than in
<code>brm_formula()</code> in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clda</code></td>
<td>
<p><code>TRUE</code> to opt into constrained longitudinal data analysis
(cLDA), <code>FALSE</code> otherwise. To use cLDA, <code>reference_time</code> must have been
non-<code>NULL</code> in the call to <code>brm_data()</code> used to construct the data.
</p>
<p>Some archetypes cannot support cLDA
(e.g. <code>brm_archetype_average_cells()</code> and
<code>brm_archetype_average_effects()</code>).
</p>
<p>In cLDA, the fixed effects parameterization
is restricted such that all treatment groups are pooled at baseline.
(If you supplied a <code>subgroup</code> variable in <code>brm_data()</code>, then
this constraint is applied separately within each subgroup variable.)
cLDA may result in more precise estimates when the <code>time</code> variable
has a baseline level and the baseline outcomes are recorded
before randomization in a clinical trial.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prefix_interest</code></td>
<td>
<p>Character string to prepend to the new columns
of generated fixed effects of interest (relating to group, subgroup,
and/or time).
In rare cases, you may need to set a non-default prefix to prevent
name conflicts with existing columns in the data, or rename
the columns in your data.
<code>prefix_interest</code> must not be the same value as <code>prefix_nuisance</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prefix_nuisance</code></td>
<td>
<p>Same as <code>prefix_interest</code>, but relating to
generated fixed effects NOT of interest (not relating to group,
subgroup, or time). Must not be the same value as <code>prefix_interest</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Within the reference treatment group (e.g. placebo),
each fixed effect is either an intercept
on the first time point or the difference between two adjacent time
points. In each non-reference treatment group,
each model parameter is defined as an effect relative to the
reference group.
</p>
<p>To illustrate, suppose the dataset has two treatment groups A and B,
time points 1, 2, and 3, and no other covariates.
Say group A is the reference group (e.g. placebo).
Let <code>mu_gt</code> be the marginal mean of the response at group
<code>g</code> time <code>t</code> given data and hyperparameters.
The model has fixed effect parameters <code>beta_1</code>, <code>beta_2</code>, ..., <code>beta_6</code>
which express the marginal means <code>mu_gt</code> as follows:
</p>
<div class="sourceCode"><pre>  `mu_A1 = beta_1`
  `mu_A2 = beta_1 + beta_2`
  `mu_A3 = beta_1 + beta_2 + beta_3`

  `mu_B1 = beta_1 + beta_4`
  `mu_B2 = beta_1 + beta_2 + beta_4 + beta_5`
  `mu_B3 = beta_1 + beta_2 + beta_3 + beta_4 + beta_5 + beta_6`
</pre></div>
<p>For group A, <code>beta_1</code> is the time 1 intercept, <code>beta_2</code> represents
time 2 minus time 1, and <code>beta_3</code> represents time 3 minus time 2.
<code>beta_4</code> is the treatment effect of group B relative to group A at
time 1. <code>beta_5</code> is the treatment effect of the difference between
times 2 and 1, relative to treatment group A.
Similarly, <code>beta_6</code> is the treatment effect of the difference between
times 3 and 2, relative to treatment group A.
</p>


<h3>Value</h3>

<p>A special classed <code>tibble</code> with data tailored to
the successive differences archetype. The dataset is augmented with
extra columns with the <code>"archetype_"</code> prefix, as well as special
attributes to tell downstream functions like <code>brm_formula()</code> what to
do with the object.
</p>


<h3>Prior labeling for <code>brm_archetype_successive_effects()</code>
</h3>

<p>Within each treatment group, each intercept is labeled by the earliest
time point, and each successive difference term gets the successive
time point as the label.
To illustrate, consider the example in the Details section.
In the labeling scheme for <code>brm_archetype_successive_effects()</code>,
you can label the prior on <code>beta_1</code> using
<code>brm_prior_label(code = "normal(1.2, 5)", group = "A", time = "1")</code>.
Similarly, you cal label the prior on <code>beta_5</code> with
<code>brm_prior_label(code = "normal(1.3, 7)", group = "B", time = "2")</code>.
To confirm that you set the prior correctly, compare the <code>brms</code> prior
with the output of <code>summary(your_archetype)</code>.
See the examples for details.
</p>


<h3>Nuisance variables</h3>

<p>In the presence of covariate adjustment, functions like
<code>brm_archetype_successive_cells()</code> convert nuisance factors into binary
dummy variables, then center all those dummy variables and any
continuous nuisance variables at their means in the data.
This ensures that the main model coefficients
of interest are not implicitly conditional on a subset of the data.
In other words, preprocessing nuisance variables this way preserves
the interpretations of the fixed effects of interest, and it ensures
informative priors can be specified correctly.
</p>


<h3>Prior labeling</h3>

<p>Informative prior archetypes use a labeling scheme to assign priors
to fixed effects. How it works:
</p>
<div class="sourceCode"><pre>1. First, assign the prior of each parameter a collection
  of labels from the data. This can be done manually or with
  successive calls to [brm_prior_label()].
2. Supply the labeling scheme to [brm_prior_archetype()].
  [brm_prior_archetype()] uses attributes of the archetype
  to map labeled priors to their rightful parameters in the model.
</pre></div>
<p>For informative prior archetypes, this process is much more convenient
and robust than manually calling <code>brms::set_prior()</code>.
However, it requires an understanding of how the labels of the priors
map to parameters in the model. This mapping varies from archetype
to archetype, and it is documented in the help pages of
archetype-specific functions such as <code>brm_archetype_successive_cells()</code>.
</p>


<h3>See Also</h3>

<p>Other informative prior archetypes: 
<code>brm_archetype_average_cells()</code>,
<code>brm_archetype_average_effects()</code>,
<code>brm_archetype_cells()</code>,
<code>brm_archetype_effects()</code>,
<code>brm_archetype_successive_cells()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(0L)
data &lt;- brm_simulate_outline(
  n_group = 2,
  n_patient = 100,
  n_time = 4,
  rate_dropout = 0,
  rate_lapse = 0
) |&gt;
  dplyr::mutate(response = rnorm(n = dplyr::n())) |&gt;
  brm_data_change() |&gt;
  brm_simulate_continuous(names = c("biomarker1", "biomarker2")) |&gt;
  brm_simulate_categorical(
    names = c("status1", "status2"),
    levels = c("present", "absent")
  )
dplyr::select(
  data,
  group,
  time,
  patient,
  starts_with("biomarker"),
  starts_with("status")
)
archetype &lt;- brm_archetype_successive_effects(data)
archetype
summary(archetype)
formula &lt;- brm_formula(archetype)
formula
prior &lt;- brm_prior_label(
  code = "normal(1, 2.2)",
  group = "group_1",
  time = "time_2"
) |&gt;
  brm_prior_label("normal(1, 3.3)", group = "group_1", time = "time_3") |&gt;
  brm_prior_label("normal(1, 4.4)", group = "group_1", time = "time_4") |&gt;
  brm_prior_label("normal(2, 2.2)", group = "group_2", time = "time_2") |&gt;
  brm_prior_label("normal(2, 3.3)", group = "group_2", time = "time_3") |&gt;
  brm_prior_label("normal(2, 4.4)", group = "group_2", time = "time_4") |&gt;
  brm_prior_archetype(archetype)
prior
class(prior)
if (identical(Sys.getenv("BRM_EXAMPLES", unset = ""), "true")) {
tmp &lt;- utils::capture.output(
  suppressMessages(
    suppressWarnings(
      model &lt;- brm_model(
        data = archetype,
        formula = formula,
        prior = prior,
        chains = 1,
        iter = 100,
        refresh = 0
      )
    )
  )
)
suppressWarnings(print(model))
brms::prior_summary(model)
draws &lt;- brm_marginal_draws(
  data = archetype,
  formula = formula,
  model = model
)
summaries_model &lt;- brm_marginal_summaries(draws)
summaries_data &lt;- brm_marginal_data(data)
brm_plot_compare(model = summaries_model, data = summaries_data)
}
</code></pre>


</div>